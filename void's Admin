--[[
the commands are:
fly
unfly
ws
jp
fling
car
errape
spamerrape
stoperrape
vanish (not workikng)
kill (not working)
spy
tptool
annoy [player]
unannoy
print [text]
view [player]
unview
reset
noclip
clip
lagswitch
goto [player]
blackhole
mousefling
permadeath
giant
small
bighead
chatbypass
chatlogs (not working)
chathax
autogrammar (english only)
stare [player]
unstare [player]
animations
gravitycontroller
infjump
skeletonesp
sit
mutechat
xordonhub
join [game ID]
rj [game ID] (rejoin)
telekinesis
]]

local commandBarGui = Instance.new("ScreenGui")
local ValueBox = Instance.new("Frame")
local ValueBox_2 = Instance.new("TextBox")
local commandBar2 = Instance.new("Frame")
local commandBox2 = Instance.new("TextBox")
local commandBar3 = Instance.new("Frame")
local commandBox3 = Instance.new("TextBox")
local commandBar = Instance.new("Frame")
local commandLabel = Instance.new("TextLabel")
local commandBox = Instance.new("TextBox")


commandBarGui.Name = "commandBarGui"
commandBarGui.Parent = game.CoreGui
commandBarGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling

ValueBox.Name = "ValueBox"
ValueBox.Parent = commandBarGui
ValueBox.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
ValueBox.BorderSizePixel = 0
ValueBox.Position = UDim2.new(0.796425819, 0, 0.955604911, 0)
ValueBox.Size = UDim2.new(0.202020198, 0, 0.0443951152, 0)

ValueBox_2.Name = "ValueBox"
ValueBox_2.Parent = ValueBox
ValueBox_2.BackgroundColor3 = Color3.fromRGB(150, 150, 150)
ValueBox_2.BorderSizePixel = 0
ValueBox_2.Position = UDim2.new(0.0192307699, 0, 0.117857151, 0)
ValueBox_2.Size = UDim2.new(0.961538434, 0, 0.75, 0)
ValueBox_2.Font = Enum.Font.SourceSans
ValueBox_2.PlaceholderColor3 = Color3.fromRGB(200, 200, 200)
ValueBox_2.PlaceholderText = "enter a value/player here"
ValueBox_2.Text = ""
ValueBox_2.TextColor3 = Color3.fromRGB(0, 0, 0)
ValueBox_2.TextSize = 20.000

commandBar2.Name = "commandBar2"
commandBar2.Parent = commandBarGui
commandBar2.BackgroundColor3 = Color3.fromRGB(200, 200, 200)
commandBar2.BorderColor3 = Color3.fromRGB(0, 0, 0)
commandBar2.BorderSizePixel = 0
commandBar2.Position = UDim2.new(0, 0, 0.479467273, 0)
commandBar2.Size = UDim2.new(1, 0, 0.0388457254, 0)
commandBar2.Visible = false

commandBox2.Name = "commandBox2"
commandBox2.Parent = commandBar2
commandBox2.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
commandBox2.Position = UDim2.new(0, 0, 0.142857149, 0)
commandBox2.Size = UDim2.new(1, 0, 0.714285731, 0)
commandBox2.Font = Enum.Font.SourceSans
commandBox2.Text = ""
commandBox2.TextColor3 = Color3.fromRGB(255, 255, 255)
commandBox2.TextSize = 25.000

commandBar3.Name = "commandBar3"
commandBar3.Parent = commandBarGui
commandBar3.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
commandBar3.BorderSizePixel = 0
commandBar3.Size = UDim2.new(1, 0, 0.0832408443, 0)
commandBar3.Visible = false

commandBox3.Name = "commandBox3"
commandBox3.Parent = commandBar3
commandBox3.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
commandBox3.BorderSizePixel = 0
commandBox3.Position = UDim2.new(-0.000761614647, 0, 0, 0)
commandBox3.Size = UDim2.new(0.999238372, 0, 1, 0)
commandBox3.ClearTextOnFocus = false
commandBox3.Font = Enum.Font.SourceSans
commandBox3.Text = ""
commandBox3.TextColor3 = Color3.fromRGB(255, 255, 255)
commandBox3.TextSize = 75.000
commandBox3.TextXAlignment = Enum.TextXAlignment.Left

commandBar.Name = "commandBar"
commandBar.Parent = commandBarGui
commandBar.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
commandBar.BorderSizePixel = 0
commandBar.Position = UDim2.new(0.00466200477, 0, 0.910099864, 0)
commandBar.Size = UDim2.new(0.233100235, 0, 0.0832408443, 0)
commandBar.Visible = false
commandBar.Draggable = true

commandLabel.Name = "commandLabel"
commandLabel.Parent = commandBar
commandLabel.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
commandLabel.BorderSizePixel = 0
commandLabel.Size = UDim2.new(1, 0, 0.200000003, 0)
commandLabel.Font = Enum.Font.SourceSans
commandLabel.Text = "command bar"
commandLabel.TextColor3 = Color3.fromRGB(0, 0, 0)
commandLabel.TextSize = 20.000

commandBox.Name = "commandBox"
commandBox.Parent = commandBar
commandBox.BackgroundColor3 = Color3.fromRGB(150, 150, 150)
commandBox.Position = UDim2.new(0.0500000007, 0, 0.333333343, 0)
commandBox.Size = UDim2.new(0.899999976, 0, 0.533333361, 0)
commandBox.ClearTextOnFocus = false
commandBox.Font = Enum.Font.SourceSans
commandBox.PlaceholderColor3 = Color3.fromRGB(200, 200, 200)
commandBox.PlaceholderText = "enter a command here"
commandBox.Text = ""
commandBox.TextColor3 = Color3.fromRGB(0, 0, 0)
commandBox.TextSize = 20.000


local function AUNEQXV_fake_script()
	local script = Instance.new('LocalScript', commandBar2)

	plr = game.Players.LocalPlayer
	mouse = plr:GetMouse()
	mouse.KeyDown:connect(function(key)
	
		if key == "\\" then
			script.Parent.Parent.commandBar2.Visible = true
			commandBox2:CaptureFocus()
				spawn(function()
					commandBox2.Text = ""
				end)
		end
	end)

	commandBox2.FocusLost:Connect(function(enterPressed)
	if commandBox2.Text == "reset" and enterPressed then
		game.Players.LocalPlayer.Character:BreakJoints()
		commandBar2.Visible = false
	end
	if commandBox2.Text == "view" and enterPressed then
		local target = ValueBox_2.Text
		game.Workspace.CurrentCamera.CameraSubject = target.Character.Humanoid
		commandBar2.Visible = false
	end
	if commandBox2.Text == "unview" and enterPressed then
		game.Workspace.CurrentCamera.CameraSubject = game.Players.LocalPlayer.Character.Humanoid
		commandBar2.Visible = false
	end
	if commandBox2.Text == "kill" and enterPressed then
		game.StarterGui:SetCore("SendNotification", {
			Title = "Warning";
			Text = "Make sure the player is in Value Box";
		})
				local Player = ValueBox_2.Text
				if Player[1] then
					Player = Player[1]
					LocalPlayer = game.Players.LocalPlayer
					
					if LocalPlayer.Character.PrimaryPart ~= nil then
							local Character = LocalPlayer.Character
							local previous = LocalPlayer.Character.PrimaryPart.CFrame
							
							Character.Archivable = true
							local Clone = Character:Clone()
							LocalPlayer.Character = Clone
							wait(0.5)
							LocalPlayer.Character = Character
							wait(0.2)
							
							if LocalPlayer.Character and Player.Character and Player.Character.PrimaryPart ~= nil then
								if LocalPlayer.Character:FindFirstChildOfClass("Humanoid") then
									LocalPlayer.Character:FindFirstChildOfClass("Humanoid"):Destroy()
								end
				
								local Humanoid = Instance.new("Humanoid")
								Humanoid.Parent = LocalPlayer.Character
				
								local Tool = nil
				
								if LocalPlayer.Character:FindFirstChildOfClass("Tool") then
									Tool = LocalPlayer.Character:FindFirstChildOfClass("Tool")
								elseif LocalPlayer.Backpack and LocalPlayer.Backpack:FindFirstChildOfClass("Tool") then
									Tool = LocalPlayer.Backpack:FindFirstChildOfClass("Tool")
								end
								print(Tool)

								if Tool ~= nil then
									Tool.Parent = LocalPlayer.Backpack
									
									Player.Character.HumanoidRootPart.Anchored = true
									
									local Arm = game.Players.LocalPlayer.Character['Right Arm'].CFrame * CFrame.new(0, -1, 0, 1, 0, 0, 0, 0, 1, 0, -1, 0)
									Tool.Grip = Arm:ToObjectSpace(Player.Character.PrimaryPart.CFrame):Inverse()
									
									Tool.Parent = LocalPlayer.Character
									Workspace.CurrentCamera.CameraSubject = Tool.Handle
						
									repeat
										wait()
									until not Tool or Tool and (Tool.Parent == Workspace or Tool.Parent == Player.Character)
									Player.Character.HumanoidRootPart.Anchored = false
									wait(0.1)
									Humanoid.Health = 0
									LocalPlayer.Character = nil
								end
							end
					end
				end
		commandBar2.Visible = false
	end
	if commandBox2.Text == "fly" and enterPressed then
	local Mouse = lplayer:GetMouse()

	repeat wait() until lplayer and lplayer.Character and lplayer.Character:FindFirstChild('HumanoidRootPart') and lplayer.Character:FindFirstChild('Humanoid')
	repeat wait() until Mouse
 
	local T = lplayer.Character.HumanoidRootPart
	local CONTROL = {F = 0, B = 0, L = 0, R = 0}
	local lCONTROL = {F = 0, B = 0, L = 0, R = 0}
	local SPEED = speedget
 
	local function fly()
		flying = true
		local BG = Instance.new('BodyGyro', T)
		local BV = Instance.new('BodyVelocity', T)
		BG.P = 9e4
		BG.maxTorque = Vector3.new(9e9, 9e9, 9e9)
		BG.cframe = T.CFrame
		BV.velocity = Vector3.new(0, 0.1, 0)
		BV.maxForce = Vector3.new(9e9, 9e9, 9e9)
		spawn(function()
		repeat wait()
		lplayer.Character.Humanoid.PlatformStand = true
		if CONTROL.L + CONTROL.R ~= 0 or CONTROL.F + CONTROL.B ~= 0 then
		SPEED = 50
		elseif not (CONTROL.L + CONTROL.R ~= 0 or CONTROL.F + CONTROL.B ~= 0) and SPEED ~= 0 then
		SPEED = 0
		end
		if (CONTROL.L + CONTROL.R) ~= 0 or (CONTROL.F + CONTROL.B) ~= 0 then
		BV.velocity = ((workspace.CurrentCamera.CoordinateFrame.lookVector * (CONTROL.F + CONTROL.B)) + ((workspace.CurrentCamera.CoordinateFrame * CFrame.new(CONTROL.L + CONTROL.R, (CONTROL.F + CONTROL.B) * 0.2, 0).p) - workspace.CurrentCamera.CoordinateFrame.p)) * SPEED
		lCONTROL = {F = CONTROL.F, B = CONTROL.B, L = CONTROL.L, R = CONTROL.R}
		elseif (CONTROL.L + CONTROL.R) == 0 and (CONTROL.F + CONTROL.B) == 0 and SPEED ~= 0 then
		BV.velocity = ((workspace.CurrentCamera.CoordinateFrame.lookVector * (lCONTROL.F + lCONTROL.B)) + ((workspace.CurrentCamera.CoordinateFrame * CFrame.new(lCONTROL.L + lCONTROL.R, (lCONTROL.F + lCONTROL.B) * 0.2, 0).p) - workspace.CurrentCamera.CoordinateFrame.p)) * SPEED
		else
		BV.velocity = Vector3.new(0, 0.1, 0)
		end
		BG.cframe = workspace.CurrentCamera.CoordinateFrame
				until not flying
				CONTROL = {F = 0, B = 0, L = 0, R = 0}
				lCONTROL = {F = 0, B = 0, L = 0, R = 0}
				SPEED = 0
				BG:destroy()
				BV:destroy()
				lplayer.Character.Humanoid.PlatformStand = false
			end)
		end
	Mouse.KeyDown:connect(function(KEY)
		if KEY:lower() == 'w' then
			CONTROL.F = speedfly
		elseif KEY:lower() == 's' then
			CONTROL.B = -speedfly
		elseif KEY:lower() == 'a' then
			CONTROL.L = -speedfly 
		elseif KEY:lower() == 'd' then 
			CONTROL.R = speedfly
		end
	end)
	Mouse.KeyUp:connect(function(KEY)
		if KEY:lower() == 'w' then
			CONTROL.F = 0
		elseif KEY:lower() == 's' then
			CONTROL.B = 0
		elseif KEY:lower() == 'a' then
			CONTROL.L = 0
		elseif KEY:lower() == 'd' then
			CONTROL.R = 0
		end
	end)
	fly()
	commandBar2.Visible = false
	end
	if commandBox2.Text == "unfly" and enterPressed then
		flying = false
		lplayer.Character.Humanoid.PlatformStand = false
		commandBar2.Visible = false
	end
	if commandBox2.Text == "lagswitch" and enterPressed then
		loadstring(game:HttpGet("https://paste.gg/p/anonymous/d3492bd620bd4c46b54680ac80b0fa0d/files/161ddd9c992c4ceba3c298458d45188a/raw", true))()

		game.StarterGui:SetCore("SendNotification", {
			Title = "Lag Switch Enable";
			Text = "Press X to toggle";
		})
		commandBar2.Visible = false
	end
	if commandBox2.Text == "goto" and enterPressed then
		game.StarterGui:SetCore("SendNotification", {
			Title = "Warning";
			Text = "Make sure the player is in Value Box";
		})
		local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
		local target = ValueBox_2.Text

		pl.CFrame = game.Players[target].Character.HumanoidRootPart.CFrame
		commandBar2.Visible = false
	end
	if commandBox2.Text == "mousefling" and enterPressed then
	for i,v in next, game:GetService("Players").LocalPlayer.Character:GetDescendants() do
if v:IsA("BasePart") and v.Name ~="HumanoidRootPart" then
game:GetService("RunService").Heartbeat:connect(function()
v.Velocity = Vector3.new(0,-30,0)
wait(0.5)
end)
end
end
 
function rmesh(HatName)
for _,mesh in next, workspace[game.Players.LocalPlayer.Name][HatName]:GetDescendants() do
if mesh:IsA("Mesh") or mesh:IsA("SpecialMesh") then
mesh:Remove()
end
end
end
 
function create(part, parent, position, rotation)
part.AccessoryWeld:Remove()
Instance.new("Attachment",part)
Instance.new("AlignPosition",part)
Instance.new("AlignOrientation",part)
Instance.new("Attachment",parent)
part.AlignPosition.Attachment0 = part.Attachment
part.AlignOrientation.Attachment0 = part.Attachment
part.AlignPosition.Attachment1 = parent.Attachment
part.AlignOrientation.Attachment1 = parent.Attachment
part.Attachment.Position = position
part.Attachment.Orientation = rotation
part.AlignPosition.Responsiveness = 200
part.AlignOrientation.Responsiveness = 200
part.AlignPosition.MaxForce = 9999999
part.AlignPosition.RigidityEnabled = false
part.AlignOrientation.MaxTorque = 9999999
end
 
local LocalPlayer = game.Players.LocalPlayer
 
function eswait(num)
if num == 0 or num == nil then
game:service("RunService").Stepped:wait(0)
else
for i = 0, num do
game:service("RunService").Stepped:wait(0)
end
end
end
 
function makepart(hat,part)
Instance.new('Part',workspace[LocalPlayer.Name])
workspace[LocalPlayer.Name].Part.Name = 'lerp'..hat
workspace[LocalPlayer.Name]['lerp'..hat].CanCollide = false
workspace[LocalPlayer.Name]['lerp'..hat].Size = workspace[LocalPlayer.Name][hat].Handle.Size
workspace[LocalPlayer.Name]['lerp'..hat].Transparency = 1
Instance.new('Weld',workspace[LocalPlayer.Name]['lerp'..hat])
create(workspace[LocalPlayer.Name][hat].Handle,workspace[LocalPlayer.Name]['lerp'..hat],Vector3.new(),Vector3.new())
workspace[LocalPlayer.Name]['lerp'..hat].Weld.Part0 = workspace[LocalPlayer.Name]['lerp'..hat]
workspace[LocalPlayer.Name]['lerp'..hat].Weld.Part1 = workspace[LocalPlayer.Name][part]
workspace[LocalPlayer.Name]['lerp'..hat].Weld.C0 = workspace[LocalPlayer.Name]['lerp'..hat].CFrame:inverse() * workspace[LocalPlayer.Name][part].CFrame * CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),math.rad(0),0)
end
 
local hatsine = 0
 
local hatchange = 1
 
function clerp(hat,ppx,ppy,pppz,rrrx,rrry,rrz,lppx,lppy,lpppz,lrrrx,lrrry,lrrz,speed)
coroutine.wrap(function()
while true do
hatsine = hatsine + speed
workspace[game.Players.LocalPlayer.Name]['lerp'..hat].Weld.C0 = workspace[game.Players.LocalPlayer.Name]['lerp'..hat].Weld.C0:lerp(CFrame.new(ppx + lppx * math.sin(hatsine/11), ppy + lppy * math.sin(hatsine/11), pppz + lpppz * math.sin(hatsine/11)) * CFrame.Angles(math.rad(rrrx + lrrrx * math.sin(hatsine/11)), math.rad(rrry + lrrry * math.sin(hatsine/11)), math.rad(rrz + lrrz * math.sin(hatsine/11))),0.1)
eswait()
end
end)()
end
 
local player = game.Players.LocalPlayer
local character1 = player.Character
local mouse = player:GetMouse()
 
local fakebody = Instance.new("Part", character1)
fakebody.Transparency = 1
fakebody.Anchored = true
fakebody.CanCollide = false
fakebody.Position = character1.Head.Position
fakebody.Name = "FPart"
wait()
_G.ReanimationType = "PDeath" --PDeath, Fling, Simple
_G.Velocity = Vector3.new(36,0,0)
_G.FlingBlock = true
_G.FlingBlockTransparency = 1
_G.HighlightFlingBlock = true
_G.FlingBlockPosition = "FPart"
_G.HighlightFlingBlockColor = Color3.fromRGB(255,0,0)
 
loadstring(game:HttpGet("https://raw.githubusercontent.com/GelatekWasTaken/Reanimation.lua/main/Main/Main.lua"))()
wait(1)
 
mouse.KeyDown:connect(function(key)
    if key == "e" then
    character1.Reanimate.FPart.Position = mouse.Hit.p
    end
end)
 
rmesh('Pink Hair')
rmesh('Kate Hair')
 
makepart('Kate Hair','Right Arm')
clerp('Kate Hair',0,1,0,0,0,0,0,0,0,0,0,0,1)
 
makepart('Pink Hair','Right Arm')
clerp('Pink Hair',0,0.5,-2,-90,0,0,0,0,0,0,0,0,1)
 
local Scale = game.Players.LocalPlayer.Character.Torso.Size.X/2*(game.Players.LocalPlayer.Character.Torso:FindFirstChild("ScaleInserted") ~= nil and game.Players.LocalPlayer.Character.Torso:FindFirstChild("ScaleInserted").Scale.Z or 1)*0.8
local Speed = 20*Scale
local Gravity = 0.1
 
local Player = game.Players.LocalPlayer
local Character = Player.Character.Reanimate
local Humanoid = Character.Humanoid
Humanoid:SetStateEnabled(Enum.HumanoidStateType.Ragdoll,false)
local Torso = Character.HumanoidRootPart
local Mouse = game.Players.LocalPlayer:GetMouse()
local RenderStepped = game:GetService("RunService").RenderStepped
local Camera = Workspace.CurrentCamera
Camera:ClearAllChildren()
local Model = Instance.new("Model",Character)
local IgnoreList = {Character,Workspace.Terrain}
 
local Part0Joint = CFrame.new(Vector3.new(1,0.75,0)*Scale*1.25)
local Part1Joint = CFrame.new(Vector3.new(-0.5,0.75,0)*Scale*1.25)
local RotationOffset = CFrame.Angles(math.rad(90),math.rad(0),0)
local Gangster = false
 
local Part0JointHead = CFrame.new(Vector3.new(0,1,0)*Scale*1.25)
local Part1JointHead = CFrame.new(Vector3.new(0,-0.5,0)*Scale*1.25)
local RotationOffsetHead = CFrame.Angles(0,0,0)
 
local Handle = Instance.new("Part",Model)
Handle.CanCollide = false
Handle.Name = "Handle"
Handle.Position = Vector3.new(0,100,0)
Handle:BreakJoints()
Handle.FormFactor = "Custom"
Handle.Size = Vector3.new(0.2,0.2,0.2)
Handle.TopSurface = "SmoothNoOutlines"
Handle.BottomSurface = "SmoothNoOutlines"
Handle.FrontSurface = "SmoothNoOutlines"
Handle.BackSurface = "SmoothNoOutlines"
Handle.RightSurface = "SmoothNoOutlines"
Handle.LeftSurface = "SmoothNoOutlines"
Handle.BrickColor = BrickColor.new("Black")
local Mesh = Instance.new("BlockMesh",Handle)
Mesh.Scale = Vector3.new(0.25,1,0.4) / 0.2 * Scale
local HandleWeld = Instance.new("Motor6D")
HandleWeld.Part0 = Character["Right Arm"]
HandleWeld.Part1 = Handle
HandleWeld.C0 = CFrame.new(Vector3.new(0,-1,0)*Scale) * CFrame.Angles(math.rad(-105),0,0)
HandleWeld.Parent = Handle
 
local Part = Instance.new("Part",Model)
Part.CanCollide = false
Part.Position = Vector3.new(0,100,0)
Part:BreakJoints()
Part.FormFactor = "Custom"
Part.Size = Vector3.new(0.2,0.2,0.2)
Part.TopSurface = "SmoothNoOutlines"
Part.BottomSurface = "SmoothNoOutlines"
Part.FrontSurface = "SmoothNoOutlines"
Part.BackSurface = "SmoothNoOutlines"
Part.RightSurface = "SmoothNoOutlines"
Part.LeftSurface = "SmoothNoOutlines"
Part.BrickColor = BrickColor.new("Black")
local Mesh = Instance.new("CylinderMesh",Part)
Mesh.Scale = Vector3.new(0.07,0.2,0.07) / 0.2 * Scale
local PartWeld = Instance.new("Motor6D")
PartWeld.Part0 = Handle
PartWeld.Part1 = Part
PartWeld.C0 = CFrame.new(Vector3.new(-0.115,-0.475,-0.190)*Scale) * CFrame.Angles(0,0,0)
PartWeld.Parent = Part
 
local Part = Instance.new("Part",Model)
Part.CanCollide = false
Part.Position = Vector3.new(0,100,0)
Part:BreakJoints()
Part.FormFactor = "Custom"
Part.Size = Vector3.new(0.2,0.2,0.2)
Part.TopSurface = "SmoothNoOutlines"
Part.BottomSurface = "SmoothNoOutlines"
Part.FrontSurface = "SmoothNoOutlines"
Part.BackSurface = "SmoothNoOutlines"
Part.RightSurface = "SmoothNoOutlines"
Part.LeftSurface = "SmoothNoOutlines"
Part.BrickColor = BrickColor.new("Black")
local Mesh = Instance.new("CylinderMesh",Part)
Mesh.Scale = Vector3.new(0.07,0.2,0.07) / 0.2 * Scale
local PartWeld = Instance.new("Motor6D")
PartWeld.Part0 = Handle
PartWeld.Part1 = Part
PartWeld.C0 = CFrame.new(Vector3.new(0.115,-0.475,0.190)*Scale) * CFrame.Angles(0,0,0)
PartWeld.Parent = Part
 
local Part = Instance.new("Part",Model)
Part.CanCollide = false
Part.Position = Vector3.new(0,100,0)
Part:BreakJoints()
Part.FormFactor = "Custom"
Part.Size = Vector3.new(0.2,0.2,0.2)
Part.TopSurface = "SmoothNoOutlines"
Part.BottomSurface = "SmoothNoOutlines"
Part.FrontSurface = "SmoothNoOutlines"
Part.BackSurface = "SmoothNoOutlines"
Part.RightSurface = "SmoothNoOutlines"
Part.LeftSurface = "SmoothNoOutlines"
Part.BrickColor = BrickColor.new("Black")
local Mesh = Instance.new("CylinderMesh",Part)
Mesh.Scale = Vector3.new(0.07,0.2,0.07) / 0.2 * Scale
local PartWeld = Instance.new("Motor6D")
PartWeld.Part0 = Handle
PartWeld.Part1 = Part
PartWeld.C0 = CFrame.new(Vector3.new(-0.115,-0.475,0.190)*Scale) * CFrame.Angles(0,0,0)
PartWeld.Parent = Part
 
local Part = Instance.new("Part",Model)
Part.CanCollide = false
Part.Position = Vector3.new(0,100,0)
Part:BreakJoints()
Part.FormFactor = "Custom"
Part.Size = Vector3.new(0.2,0.2,0.2)
Part.TopSurface = "SmoothNoOutlines"
Part.BottomSurface = "SmoothNoOutlines"
Part.FrontSurface = "SmoothNoOutlines"
Part.BackSurface = "SmoothNoOutlines"
Part.RightSurface = "SmoothNoOutlines"
Part.LeftSurface = "SmoothNoOutlines"
Part.BrickColor = BrickColor.new("Black")
local Mesh = Instance.new("CylinderMesh",Part)
Mesh.Scale = Vector3.new(0.07,0.2,0.07) / 0.2 * Scale
local PartWeld = Instance.new("Motor6D")
PartWeld.Part0 = Handle
PartWeld.Part1 = Part
PartWeld.C0 = CFrame.new(Vector3.new(0.115,-0.475,-0.190)*Scale) * CFrame.Angles(0,0,0)
PartWeld.Parent = Part
 
local Part = Instance.new("Part",Model)
Part.CanCollide = false
Part.Position = Vector3.new(0,100,0)
Part:BreakJoints()
Part.FormFactor = "Custom"
Part.Size = Vector3.new(0.2,0.2,0.2)
Part.TopSurface = "SmoothNoOutlines"
Part.BottomSurface = "SmoothNoOutlines"
Part.FrontSurface = "SmoothNoOutlines"
Part.BackSurface = "SmoothNoOutlines"
Part.RightSurface = "SmoothNoOutlines"
Part.LeftSurface = "SmoothNoOutlines"
Part.BrickColor = BrickColor.new("Black")
local Mesh = Instance.new("BlockMesh",Part)
Mesh.Scale = Vector3.new(0.23,0.2,0.1) / 0.2 * Scale
local PartWeld = Instance.new("Motor6D")
PartWeld.Part0 = Handle
PartWeld.Part1 = Part
PartWeld.C0 = CFrame.new(Vector3.new(0,-0.475,-0.175)*Scale) * CFrame.Angles(0,0,0)
PartWeld.Parent = Part
 
local Part = Instance.new("Part",Model)
Part.CanCollide = false
Part.Position = Vector3.new(0,100,0)
Part:BreakJoints()
Part.FormFactor = "Custom"
Part.Size = Vector3.new(0.2,0.2,0.2)
Part.TopSurface = "SmoothNoOutlines"
Part.BottomSurface = "SmoothNoOutlines"
Part.FrontSurface = "SmoothNoOutlines"
Part.BackSurface = "SmoothNoOutlines"
Part.RightSurface = "SmoothNoOutlines"
Part.LeftSurface = "SmoothNoOutlines"
Part.BrickColor = BrickColor.new("Black")
local Mesh = Instance.new("BlockMesh",Part)
Mesh.Scale = Vector3.new(0.23,0.2,0.1) / 0.2 * Scale
local PartWeld = Instance.new("Motor6D")
PartWeld.Part0 = Handle
PartWeld.Part1 = Part
PartWeld.C0 = CFrame.new(Vector3.new(0,-0.475,0.175)*Scale) * CFrame.Angles(0,0,0)
PartWeld.Parent = Part
 
local Part = Instance.new("Part",Model)
Part.CanCollide = false
Part.Position = Vector3.new(0,100,0)
Part:BreakJoints()
Part.FormFactor = "Custom"
Part.Size = Vector3.new(0.2,0.2,0.2)
Part.TopSurface = "SmoothNoOutlines"
Part.BottomSurface = "SmoothNoOutlines"
Part.FrontSurface = "SmoothNoOutlines"
Part.BackSurface = "SmoothNoOutlines"
Part.RightSurface = "SmoothNoOutlines"
Part.LeftSurface = "SmoothNoOutlines"
Part.BrickColor = BrickColor.new("Black")
local Mesh = Instance.new("BlockMesh",Part)
Mesh.Scale = Vector3.new(0.1,0.2,0.38) / 0.2 * Scale
local PartWeld = Instance.new("Motor6D")
PartWeld.Part0 = Handle
PartWeld.Part1 = Part
PartWeld.C0 = CFrame.new(Vector3.new(-0.1,-0.475,0)*Scale) * CFrame.Angles(0,0,0)
PartWeld.Parent = Part
 
local Part = Instance.new("Part",Model)
Part.CanCollide = false
Part.Position = Vector3.new(0,100,0)
Part:BreakJoints()
Part.FormFactor = "Custom"
Part.Size = Vector3.new(0.2,0.2,0.2)
Part.TopSurface = "SmoothNoOutlines"
Part.BottomSurface = "SmoothNoOutlines"
Part.FrontSurface = "SmoothNoOutlines"
Part.BackSurface = "SmoothNoOutlines"
Part.RightSurface = "SmoothNoOutlines"
Part.LeftSurface = "SmoothNoOutlines"
Part.BrickColor = BrickColor.new("Black")
local Mesh = Instance.new("BlockMesh",Part)
Mesh.Scale = Vector3.new(0.1,0.2,0.38) / 0.2 * Scale
local PartWeld = Instance.new("Motor6D")
PartWeld.Part0 = Handle
PartWeld.Part1 = Part
PartWeld.C0 = CFrame.new(Vector3.new(0.1,-0.475,0)*Scale) * CFrame.Angles(0,0,0)
PartWeld.Parent = Part
 
local Part = Instance.new("Part",Model)
Part.CanCollide = false
Part.Position = Vector3.new(0,100,0)
Part:BreakJoints()
Part.FormFactor = "Custom"
Part.Size = Vector3.new(0.2,0.2,0.2)
Part.TopSurface = "SmoothNoOutlines"
Part.BottomSurface = "SmoothNoOutlines"
Part.FrontSurface = "SmoothNoOutlines"
Part.BackSurface = "SmoothNoOutlines"
Part.RightSurface = "SmoothNoOutlines"
Part.LeftSurface = "SmoothNoOutlines"
Part.BrickColor = BrickColor.new("Black")
local Mesh = Instance.new("BlockMesh",Part)
Mesh.Scale = Vector3.new(0.1,0.3,0.05) / 0.2 * Scale
local PartWeld = Instance.new("Motor6D")
PartWeld.Part0 = Handle
PartWeld.Part1 = Part
PartWeld.C0 = CFrame.Angles(math.rad(15),0,0) * CFrame.new(Vector3.new(0,0.25,-0.75)*Scale) * CFrame.Angles(math.rad(-10),0,0)
PartWeld.Parent = Part
 
local Part = Instance.new("Part",Model)
Part.CanCollide = false
Part.Position = Vector3.new(0,100,0)
Part:BreakJoints()
Part.FormFactor = "Custom"
Part.Size = Vector3.new(0.2,0.2,0.2)
Part.TopSurface = "SmoothNoOutlines"
Part.BottomSurface = "SmoothNoOutlines"
Part.FrontSurface = "SmoothNoOutlines"
Part.BackSurface = "SmoothNoOutlines"
Part.RightSurface = "SmoothNoOutlines"
Part.LeftSurface = "SmoothNoOutlines"
Part.BrickColor = BrickColor.new("Black")
local Mesh = Instance.new("BlockMesh",Part)
Mesh.Scale = Vector3.new(0.1,0.05,0.625) / 0.2 * Scale
local PartWeld = Instance.new("Motor6D")
PartWeld.Part0 = Handle
PartWeld.Part1 = Part
PartWeld.C0 = CFrame.Angles(math.rad(15),0,0) * CFrame.new(Vector3.new(0,0.1,-0.435)*Scale)
PartWeld.Parent = Part
 
for i = 0,80,10 do
local Part = Instance.new("Part",Model)
Part.CanCollide = false
Part.Position = Vector3.new(0,100,0)
Part:BreakJoints()
Part.FormFactor = "Custom"
Part.Size = Vector3.new(0.2,0.2,0.2)
Part.TopSurface = "SmoothNoOutlines"
Part.BottomSurface = "SmoothNoOutlines"
Part.FrontSurface = "SmoothNoOutlines"
Part.BackSurface = "SmoothNoOutlines"
Part.RightSurface = "SmoothNoOutlines"
Part.LeftSurface = "SmoothNoOutlines"
Part.BrickColor = BrickColor.new("Black")
local Mesh = Instance.new("BlockMesh",Part)
Mesh.Scale = Vector3.new(0.25,0.15,0.03555*2) / 0.2 * Scale
local PartWeld = Instance.new("Motor6D")
PartWeld.Part0 = Handle
PartWeld.Part1 = Part
PartWeld.C0 = CFrame.new(Vector3.new(0,0.15,0.315)*Scale) * CFrame.Angles(math.rad(i-65),0,0) * CFrame.new(Vector3.new(0,0.2,0)*Scale)
PartWeld.Parent = Part
end
 
local Barrel = Instance.new("Part",Model)
Barrel.CanCollide = false
Barrel.Position = Vector3.new(0,100,0)
Barrel:BreakJoints()
Barrel.FormFactor = "Custom"
Barrel.Size = Vector3.new(0.2,0.2,0.2)
Barrel.TopSurface = "SmoothNoOutlines"
Barrel.BottomSurface = "SmoothNoOutlines"
Barrel.FrontSurface = "SmoothNoOutlines"
Barrel.BackSurface = "SmoothNoOutlines"
Barrel.RightSurface = "SmoothNoOutlines"
Barrel.LeftSurface = "SmoothNoOutlines"
Barrel.BrickColor = BrickColor.new("Black")
local Mesh = Instance.new("BlockMesh",Barrel)
Mesh.Scale = Vector3.new(0.25,0.2,2) / 0.2 * Scale
local BarrelWeld = Instance.new("Motor6D")
BarrelWeld.Part0 = Handle
BarrelWeld.Part1 = Barrel
BarrelWeld.C0 = CFrame.Angles(math.rad(15),0,0) * CFrame.new(Vector3.new(0,0.5,-0.7)*Scale)
BarrelWeld.Parent = Barrel
 
local Barrel1 = Barrel
 
local Barrel2 = Instance.new("Part",Model)
Barrel2.CanCollide = false
Barrel2.Position = Vector3.new(0,100,0)
Barrel2:BreakJoints()
Barrel2.FormFactor = "Custom"
Barrel2.Size = Vector3.new(0.2,0.2,0.2)
Barrel2.TopSurface = "SmoothNoOutlines"
Barrel2.BottomSurface = "SmoothNoOutlines"
Barrel2.FrontSurface = "SmoothNoOutlines"
Barrel2.BackSurface = "SmoothNoOutlines"
Barrel2.RightSurface = "SmoothNoOutlines"
Barrel2.LeftSurface = "SmoothNoOutlines"
Barrel2.BrickColor = BrickColor.new("Really black")
local Mesh = Instance.new("BlockMesh",Barrel2)
Mesh.Scale = Vector3.new(0.25,0.25,2) / 0.2 * Scale
local Barrel2Weld = Instance.new("Motor6D")
Barrel2Weld.Part0 = Barrel
Barrel2Weld.Part1 = Barrel2
Barrel2Weld.C0 = CFrame.new(Vector3.new(0,0.225,0)*Scale)
Barrel2Weld.Parent = Barrel2
 
local RealBarrel = Instance.new("Part",Model)
RealBarrel.CanCollide = false
RealBarrel.Position = Vector3.new(0,100,0)
RealBarrel:BreakJoints()
RealBarrel.FormFactor = "Custom"
RealBarrel.Size = Vector3.new(0.2,0.2,0.2)
RealBarrel.TopSurface = "SmoothNoOutlines"
RealBarrel.BottomSurface = "SmoothNoOutlines"
RealBarrel.FrontSurface = "SmoothNoOutlines"
RealBarrel.BackSurface = "SmoothNoOutlines"
RealBarrel.RightSurface = "SmoothNoOutlines"
RealBarrel.LeftSurface = "SmoothNoOutlines"
RealBarrel.BrickColor = BrickColor.new("Dark grey metallic")
local Mesh = Instance.new("CylinderMesh",RealBarrel)
Mesh.Scale = Vector3.new(0.2,2,0.2) / 0.2 * Scale
local RealBarrelWeld = Instance.new("Motor6D")
RealBarrelWeld.Part0 = Barrel
RealBarrelWeld.Part1 = RealBarrel
RealBarrelWeld.C0 = CFrame.new(Vector3.new(0,0.1,-0.01)*Scale) * CFrame.Angles(math.rad(-90),0,0)
RealBarrelWeld.Parent = RealBarrel
 
for i = 1,75,15 do
local Part = Instance.new("Part",Model)
Part.CanCollide = false
Part.Position = Vector3.new(0,100,0)
Part:BreakJoints()
Part.FormFactor = "Custom"
Part.Size = Vector3.new(0.2,0.2,0.2)
Part.TopSurface = "SmoothNoOutlines"
Part.BottomSurface = "SmoothNoOutlines"
Part.FrontSurface = "SmoothNoOutlines"
Part.BackSurface = "SmoothNoOutlines"
Part.RightSurface = "SmoothNoOutlines"
Part.LeftSurface = "SmoothNoOutlines"
Part.BrickColor = BrickColor.new("Black")
local Mesh = Instance.new("BlockMesh",Part)
Mesh.Scale = Vector3.new(0.05,0.065,0.05) / 0.2 * Scale
local PartWeld = Instance.new("Motor6D")
PartWeld.Part0 = Handle
PartWeld.Part1 = Part
PartWeld.C0 = CFrame.new(Vector3.new(0,0.525,-0.515)*Scale) * CFrame.Angles(math.rad(i),0,0) * CFrame.new(Vector3.new(0,0,0.2)*Scale)
PartWeld.Parent = Part
end
 
local Part = Instance.new("Part",Model)
Part.CanCollide = false
Part.Position = Vector3.new(0,100,0)
Part:BreakJoints()
Part.FormFactor = "Custom"
Part.Size = Vector3.new(0.2,0.2,0.2)
Part.TopSurface = "SmoothNoOutlines"
Part.BottomSurface = "SmoothNoOutlines"
Part.FrontSurface = "SmoothNoOutlines"
Part.BackSurface = "SmoothNoOutlines"
Part.RightSurface = "SmoothNoOutlines"
Part.LeftSurface = "SmoothNoOutlines"
Part.BrickColor = BrickColor.new("Really black")
local Mesh = Instance.new("BlockMesh",Part)
Mesh.Scale = Vector3.new(0.05,0.11,0.1) / 0.2 * Scale
local PartWeld = Instance.new("Motor6D")
PartWeld.Part0 = Barrel2
PartWeld.Part1 = Part
PartWeld.C0 = CFrame.new(Vector3.new(0.06,0.135,0.925)*Scale)
PartWeld.Parent = Part
 
local Part = Instance.new("Part",Model)
Part.CanCollide = false
Part.Position = Vector3.new(0,100,0)
Part:BreakJoints()
Part.FormFactor = "Custom"
Part.Size = Vector3.new(0.2,0.2,0.2)
Part.TopSurface = "SmoothNoOutlines"
Part.BottomSurface = "SmoothNoOutlines"
Part.FrontSurface = "SmoothNoOutlines"
Part.BackSurface = "SmoothNoOutlines"
Part.RightSurface = "SmoothNoOutlines"
Part.LeftSurface = "SmoothNoOutlines"
Part.BrickColor = BrickColor.new("Really black")
local Mesh = Instance.new("BlockMesh",Part)
Mesh.Scale = Vector3.new(0.05,0.11,0.1) / 0.2 * Scale
local PartWeld = Instance.new("Motor6D")
PartWeld.Part0 = Barrel2
PartWeld.Part1 = Part
PartWeld.C0 = CFrame.new(Vector3.new(-0.06,0.135,0.925)*Scale)
PartWeld.Parent = Part
 
local Part = Instance.new("Part",Model)
Part.CanCollide = false
Part.Position = Vector3.new(0,100,0)
Part:BreakJoints()
Part.FormFactor = "Custom"
Part.Size = Vector3.new(0.2,0.2,0.2)
Part.TopSurface = "SmoothNoOutlines"
Part.BottomSurface = "SmoothNoOutlines"
Part.FrontSurface = "SmoothNoOutlines"
Part.BackSurface = "SmoothNoOutlines"
Part.RightSurface = "SmoothNoOutlines"
Part.LeftSurface = "SmoothNoOutlines"
Part.BrickColor = BrickColor.new("Really black")
local Mesh = Instance.new("BlockMesh",Part)
Mesh.Scale = Vector3.new(0.025,0.1,0.1) / 0.2 * Scale
local PartWeld = Instance.new("Motor6D")
PartWeld.Part0 = Barrel2
PartWeld.Part1 = Part
PartWeld.C0 = CFrame.new(Vector3.new(0,0.135,-0.925)*Scale)
PartWeld.Parent = Part
 
local Part = Instance.new("Part",Model)
Part.CanCollide = false
Part.Position = Vector3.new(0,100,0)
Part:BreakJoints()
Part.FormFactor = "Custom"
Part.Size = Vector3.new(0.2,0.2,0.2)
Part.Transparency = 1
Part.TopSurface = "SmoothNoOutlines"
Part.BottomSurface = "SmoothNoOutlines"
Part.FrontSurface = "SmoothNoOutlines"
Part.BackSurface = "SmoothNoOutlines"
Part.RightSurface = "SmoothNoOutlines"
Part.LeftSurface = "SmoothNoOutlines"
Part.BrickColor = BrickColor.new("Really black")
local Mesh = Instance.new("BlockMesh",Part)
Mesh.Scale = Vector3.new(0.1,0.1,0.1) / 0.2 * Scale
local PartWeld = Instance.new("Motor6D")
PartWeld.Part0 = Barrel
PartWeld.Part1 = Part
PartWeld.C0 = CFrame.new(Vector3.new(0,0,-5)*Scale)
PartWeld.Parent = Part
 
local Light = Instance.new("PointLight",Part)
Light.Color = BrickColor.new("Gold").Color
Light.Enabled = true
Light.Shadows = true
Light.Brightness = 0
Light.Range = 6
 
local Part = Instance.new("Part",Model)
Part.Material = "Neon"
Part.CanCollide = false
Part.Position = Vector3.new(0,100,0)
Part:BreakJoints()
Part.FormFactor = "Custom"
Part.Size = Vector3.new(0.2,0.2,0.2)
Part.TopSurface = "SmoothNoOutlines"
Part.BottomSurface = "SmoothNoOutlines"
Part.FrontSurface = "SmoothNoOutlines"
Part.BackSurface = "SmoothNoOutlines"
Part.RightSurface = "SmoothNoOutlines"
Part.LeftSurface = "SmoothNoOutlines"
Part.BrickColor = BrickColor.new("Bright yellow")
Part.Transparency = 0.25
local RecoilMesh = Instance.new("SpecialMesh",Part)
RecoilMesh.MeshType = "FileMesh"
RecoilMesh.MeshId = "http://www.roblox.com/Asset/?id=1323306"
RecoilMesh.TextureId = "http://www.roblox.com/Asset/?id=98896228"
RecoilMesh.Scale = Vector3.new(0.175,0,0.175) * Scale
local PartWeld = Instance.new("Motor6D")
PartWeld.Part0 = RealBarrel
PartWeld.Part1 = Part
PartWeld.C0 = CFrame.new(Vector3.new(0,0.95,0)*Scale)
PartWeld.Parent = Part
 
function ShootBullet(Target,barrel)
local barrel = barrel or Barrel
local Bullet = Instance.new("Part",Workspace)
Barrel.CanCollide = false
Bullet.FormFactor = "Custom"
Bullet.Size = Vector3.new(0.2,0.2,5)*Scale
Bullet.TopSurface = "Smooth"
Bullet.BottomSurface = "Smooth"
Bullet.Anchored = true
Bullet.CanCollide = false
Bullet.CFrame = CFrame.new((barrel.CFrame*CFrame.new(0,0,-barrel.Size.Z*barrel.Mesh.Scale.Z/2)).p,Target)*CFrame.new(0,0,-Bullet.Size.Z/2)
Bullet.Transparency = 0.1
Bullet.BrickColor = BrickColor.new("Gold")
--[[local Mesh = Instance.new("SpecialMesh",Bullet)
Mesh.MeshType = "FileMesh"
Mesh.Scale = Vector3.new(0.5,0.5,0.2)
Mesh.MeshId = "http://www.roblox.com/asset/?id=2697549"
--Mesh.TextureId = "http://www.roblox.com/asset/?id=2697544"]]
local Mesh = Instance.new("BlockMesh",Bullet)
Mesh.Scale = Vector3.new(0.2,0.2,5)*Scale/Bullet.Size
IgnoreList[#IgnoreList+1] = Bullet
RenderStepped:wait()
for i = Speed,1000,Speed do -- Loop to do the bullet movement and stuff.
local ray,Hit,Pos,SurfaceNormal;
ray = Ray.new(Bullet.Position,((Bullet.CFrame*CFrame.Angles(math.rad(-Gravity),0,0)*CFrame.new(0,0,-Speed)).p-Bullet.Position).unit*Speed)
Hit,Pos,SurfaceNormal = Workspace:FindPartOnRayWithIgnoreList(ray,IgnoreList)
Bullet.CFrame = Bullet.CFrame*CFrame.Angles(math.rad(-Gravity),0,0)*CFrame.new(0,0,-Speed)
if Hit ~= nil then
local Hum = Hit.Parent:FindFirstChild("Humanoid") or Hit.Parent.Parent:FindFirstChild("Humanoid") or (Hit.Parent.Parent.Parent ~= nil and Hit.Parent.Parent.Parent:FindFirstChild("Humanoid"))
if Hum ~= nil then
Hum:TakeDamage((((Gangster and math.random(0,0) or math.random(0,0))*Scale)/100)*Hum.MaxHealth)
end
break
end
RenderStepped:wait()
end
Bullet:Destroy()
end
 
Mouse.Button1Down:connect(function()
if not Down and not DB then
Down = true
while Down do
if Humanoid.Health == 0 then break end
if not DB then
DB = true
local Sound = Instance.new("Sound",Barrel)
Sound.SoundId = "http://www.roblox.com/Asset/?id=165946426" -- 132373574
Sound.Volume = 5*Scale
Sound.Pitch = (math.random(70,110)/100)/((Scale < 0.25 and 0.25) or (Scale > 4 and 4) or Scale)
Sound:Play()
Spawn(function()
ShootBullet(Mouse.Hit.p,Barrel1)
end)
RecoilMesh.VertexColor = Vector3.new(1,math.random(160,245)/255,20/255)
PartWeld.C0 = PartWeld.C0 * CFrame.Angles(0,math.rad(math.random(-40,40)),0)
local Shell = Instance.new("Part",Workspace)
Shell.FormFactor = "Custom"
Shell.BrickColor = BrickColor.new("Bright yellow")
Shell.Size = Vector3.new(0.2,0.5,0.2)*Scale
Shell.CFrame = Barrel.CFrame*CFrame.new(0.5,0.5,0)*CFrame.Angles(math.rad(-90),0,0)
Shell.Velocity = ((Barrel.CFrame*CFrame.new(5,0,math.random(-2,2))).p-Barrel.CFrame.p)*5*Scale
local Mesh = Instance.new("CylinderMesh",Shell)
Mesh.Scale = Vector3.new(0.2,0.5,0.2)*Scale/Shell.Size
Spawn(function()
wait(5)
Shell:Destroy()
end)
for i = 1,20,7.5 do
character1.Reanimate.FPart.Position = mouse.Hit.p
RotationOffset = RotationOffset*CFrame.Angles(math.rad(7.5),0,0)
Part1Joint = Part1Joint*CFrame.new(Vector3.new(0,-0.15,0)*Scale)
Barrel2Weld.C0 = Barrel2Weld.C0*CFrame.new(Vector3.new(0,0,0.15)*Scale)
Light.Brightness = Light.Brightness+38
RecoilMesh.Scale = RecoilMesh.Scale+(Vector3.new(0,0.375,0)*Scale)
RenderStepped:wait()
end
wait(0.02)
for i = 1,20,3.75 do
character1.Reanimate.FPart.Position = mouse.Hit.p
RotationOffset = RotationOffset*CFrame.Angles(math.rad(-3.75),0,0)
Part1Joint = Part1Joint*CFrame.new(Vector3.new(0,0.075,0)*Scale)
Barrel2Weld.C0 = Barrel2Weld.C0*CFrame.new(Vector3.new(0,0,-0.075)*Scale)
Light.Brightness = Light.Brightness-19
RecoilMesh.Scale = RecoilMesh.Scale+(Vector3.new(0,-0.1875,0)*Scale)
RenderStepped:wait()
end
wait(0.02)
DB = false
end
end
end
end)
 
Mouse.Button1Up:connect(function()
Down = false
end)
 
Mouse.KeyDown:connect(function(Key)
if Key:lower() == "g" and not DB then
DB = true
if Gangster == true then
for i = 1,70,5 do
RotationOffset = RotationOffset*CFrame.Angles(0,math.rad(-5),0)
RenderStepped:wait()
end
Gangster = false
else
for i = 1,70,5 do
RotationOffset = RotationOffset*CFrame.Angles(0,math.rad(5),0)
RenderStepped:wait()
end
Gangster = true
end
DB = false
end
end)
 
local Weld = Instance.new("Weld")
Weld.Part0 = Torso
Weld.Part1 = Character["Right Arm"]
Weld.Parent = Torso
 
local Weld2 = Instance.new("Weld")
Weld2.Part0 = Torso
Weld2.Part1 = Character.Head
Weld2.Parent = Torso
 
local RA = Character["Right Arm"]
 
game:GetService("RunService"):BindToRenderStep("Pistol",Enum.RenderPriority.Character.Value,function()
local Point = Torso.CFrame:vectorToObjectSpace(Mouse.Hit.p-Torso.CFrame.p)
if Point.Z > 0 then
if Point.X > 0 then
Torso.CFrame = CFrame.new(Torso.Position,Vector3.new(Mouse.Hit.X,Torso.Position.Y,Mouse.Hit.Z))*CFrame.Angles(0,math.rad(90),0)
elseif Point.X < 0 then
Torso.CFrame = CFrame.new(Torso.Position,Vector3.new(Mouse.Hit.X,Torso.Position.Y,Mouse.Hit.Z))*CFrame.Angles(0,math.rad(-90),0)
end
end
 
local CFr = (Torso.CFrame*Part0Joint):toObjectSpace(CFrame.new((Torso.CFrame*Part0Joint).p,Mouse.Hit.p))--RayEnd))
Weld.C0 = Part0Joint * (CFr-CFr.p) * RotationOffset
Weld.C1 = Part1Joint
Weld.Part0 = Torso
Weld.Part1 = RA
local CFr = (Torso.CFrame*Part0JointHead):toObjectSpace(CFrame.new((Torso.CFrame*Part0JointHead).p,Mouse.Hit.p))--RayEnd))
Weld2.C0 = Part0JointHead * (CFr-CFr.p) * RotationOffsetHead
Weld2.C1 = Part1JointHead
Weld2.Part0 = Torso
Weld2.Part1 = Character.Head
local Last = Scale
Scale = game.Players.LocalPlayer.Character.Torso.Size.X/2*(game.Players.LocalPlayer.Character.Torso:FindFirstChild("ScaleInserted") ~= nil and game.Players.LocalPlayer.Character.Torso:FindFirstChild("ScaleInserted").Scale.Z or 1)*0.8
Speed = 20*Scale
if Scale ~= Last then
Part0Joint = CFrame.new(Vector3.new(1,0.75,0)*Scale*1.25)
Part1Joint = CFrame.new(Vector3.new(-0.5,0.75,0)*Scale*1.25)
Part0JointHead = CFrame.new(Vector3.new(0,1,0)*Scale*1.25)
Part1JointHead = CFrame.new(Vector3.new(0,-0.5,0)*Scale*1.25)
end
end)

		wait(2)

		commandBar2.Visible = false
	end
	if commandBox2.Text == "permadeath" and enterPressed then
		game.StarterGui:SetCore("SendNotification", {
			Title = "Warning";
			Text = "Must be R6";
		})
			loadstring(game:HttpGet("https://raw.githubusercontent.com/GelatekWasTaken/Reanimation.lua/main/Main/Main.lua"))()
		
		wait(2)

		commandBar2.Visible = false
	end
	if commandBox2.Text == "bighead" and enterPressed then
		game.StarterGui:SetCore("SendNotification", {
			Title = "Warning";
			Text = "Make sure you are wearing the correct avatar and the correct scales";
		})

		loadstring(game:HttpGet("https://raw.githubusercontent.com/sysGhost-aka-BiKode/Scripts2022/main/BigHeadV3_Unpatched", true))()

		wait(2)

		commandBar2.Visible = false
	end
	if commandBox2.Text == "giant" and enterPressed then
		game.StarterGui:SetCore("SendNotification", {
				Title = "Warning";
				Text = "To work you need the highest scales";
			})


			local LocalPlayer = game:GetService("Players").LocalPlayer
			local Character = LocalPlayer.Character
			local Humanoid = Character:FindFirstChildOfClass("Humanoid")

			function rm()
				for i,v in pairs(Character:GetDescendants()) do
					if v:IsA("BasePart") then
						if v.Name == "Handle" or v.Name == "Head" then
							if Character.Head:FindFirstChild("OriginalSize") then
								Character.Head.OriginalSize:Destroy()
							end
						else
							for i,cav in pairs(v:GetDescendants()) do
								if cav:IsA("Attachment") then
									if cav:FindFirstChild("OriginalPosition") then
										cav.OriginalPosition:Destroy()  
									end
								end
							end
							v:FindFirstChild("OriginalSize"):Destroy()
							if v:FindFirstChild("AvatarPartScaleType") then
								v:FindFirstChild("AvatarPartScaleType"):Destroy()
							end
						end
					end
				end
			end

			rm()
			wait(0.5)
			Humanoid:FindFirstChild("BodyProportionScale"):Destroy()
			wait(1)

			rm()
			wait(0.5)
			Humanoid:FindFirstChild("BodyHeightScale"):Destroy()
			wait(1)

			rm()
			wait(0.5)
			Humanoid:FindFirstChild("BodyWidthScale"):Destroy()
			wait(1)

			rm()
			wait(0.5)
			Humanoid:FindFirstChild("BodyDepthScale"):Destroy()
			wait(1)

			rm()
			wait(0.5)
			Humanoid:FindFirstChild("HeadScale"):Destroy()
			wait(1)

			wait(2)

			commandBar2.Visible = false
	end
	if commandBox2.Text == "small" and enterPressed then
		game.StarterGui:SetCore("SendNotification", {
				Title = "Warning";
				Text = "To work you need the smalest scales";
			})
			
			local LocalPlayer = game:GetService("Players").LocalPlayer
			local Character = LocalPlayer.Character
			local Humanoid = Character:FindFirstChildOfClass("Humanoid")

			local function rm()
				for i,v in pairs(Character:GetDescendants()) do
					if v:IsA("BasePart") then
						if v.Name ~= "Head" then
							for i,cav in pairs(v:GetDescendants()) do
								if cav:IsA("Attachment") then
									if cav:FindFirstChild("OriginalPosition") then
										cav.OriginalPosition:Destroy()
									end
								end
							end
							v:FindFirstChild("OriginalSize"):Destroy()
							if v:FindFirstChild("AvatarPartScaleType") then
								v:FindFirstChild("AvatarPartScaleType"):Destroy()
							end
						end
					end
				end
			end

			rm()
			wait(0.5)
			Humanoid:FindFirstChild("BodyTypeScale"):Destroy()
			wait(1)

			rm()
			wait(0.5)
			Humanoid:FindFirstChild("BodyWidthScale"):Destroy()
			wait(1)

			rm()
			wait(0.5)
			Humanoid:FindFirstChild("BodyDepthScale"):Destroy()
			wait(1)

			rm()
			wait(0.5)
			Humanoid:FindFirstChild("HeadScale"):Destroy()
			wait(1)

			wait(2)

			commandBar2.Visible = false
	end
	if commandBox2.Text == "errape" and enterPressed then
		game.StarterGui:SetCore("SendNotification", {
			Title = "Warning";
			Text = "Press Q to spam errape";
		})

			plr = game.Players.LocalPlayer
			mouse = plr:GetMouse()
			mouse.KeyDown:connect(function(key)
			
				if key == "q" then

					print(game:GetService("SoundService").RespectFilteringEnabled)

					for _, sound in next, workspace:GetDescendants() do
						if sound:IsA("Sound") then
							sound:Play()
						end
					end
				end
			end)

		commandBar2.Visible = false
	end
	if commandBox2.Text == "chatbypass" and enterPressed then
			loadstring(game:HttpGet("https://the-shed.xyz/roblox/scripts/ChatBypass", true))()

			commandBar2.Visible = false
	end
		if commandBar2.Text == "chatlogs" and enterPressed then
			-- get frorm infinite yield

			commandBar2.Visible = false
		end
		if commandBox2.Text == "chathax" and enterPressed then
			loadstring(game:HttpGet('https://raw.githubusercontent.com/ant-7802/--/main/straightmilk.lua'))()

			commandBar2.Visible = false
		end
		if commandBox2.Text == "autogrammar" and enterPressed then
			loadstring(game:HttpGet("https://raw.githubusercontent.com/eosuwu/boblox/main/autogremer.lua"))()
			loadstring(game:HttpGet("https://raw.githubusercontent.com/eosuwu/boblox/main/robloxgrammarly.lua"))()

			commandBar2.Visible = false
		end
end) -- final end
end
coroutine.wrap(AUNEQXV_fake_script)()
local function PXNFKP_fake_script()
	local script = Instance.new('LocalScript', commandBar3)

	plr = game.Players.LocalPlayer
	mouse = plr:GetMouse()
	mouse.KeyDown:connect(function(key)
	
		if key == "'" then
			script.Parent.Parent.commandBar3.Visible = true
			commandBox3:CaptureFocus()
				spawn(function()
					commandBox3.Text = ":"
				end)
		end
	end)
	
	commandBox3.FocusLost:Connect(function(enterPressed)
	if commandBox3.Text == ":reset" and enterPressed then
		game.Players.LocalPlayer.Character:BreakJoints()
		commandBar3.Visible = false
	end
	if commandBox3.Text == ":view" and enterPressed then
		local target = ValueBox_2.Text
		game.Workspace.CurrentCamera.CameraSubject = target.Character.Humanoid
		commandBar3.Visible = false
	end
	if commandBox3.Text == ":unview" and enterPressed then
		game.Workspace.CurrentCamera.CameraSubject = game.Players.LocalPlayer.Character.Humanoid
		commandBar3.Visible = false
	end
	if commandBox3.Text == ":kill" and enterPressed then
		game.StarterGui:SetCore("SendNotification", {
			Title = "Warning";
			Text = "Make sure the player is in Value Box";
		})
				local Player = ValueBox_2.Text
				if Player[1] then
					Player = Player[1]
					LocalPlayer = game.Players.LocalPlayer
					
					if LocalPlayer.Character.PrimaryPart ~= nil then
							local Character = LocalPlayer.Character
							local previous = LocalPlayer.Character.PrimaryPart.CFrame
							
							Character.Archivable = true
							local Clone = Character:Clone()
							LocalPlayer.Character = Clone
							wait(0.5)
							LocalPlayer.Character = Character
							wait(0.2)
							
							if LocalPlayer.Character and Player.Character and Player.Character.PrimaryPart ~= nil then
								if LocalPlayer.Character:FindFirstChildOfClass("Humanoid") then
									LocalPlayer.Character:FindFirstChildOfClass("Humanoid"):Destroy()
								end
				
								local Humanoid = Instance.new("Humanoid")
								Humanoid.Parent = LocalPlayer.Character
				
								local Tool = nil
				
								if LocalPlayer.Character:FindFirstChildOfClass("Tool") then
									Tool = LocalPlayer.Character:FindFirstChildOfClass("Tool")
								elseif LocalPlayer.Backpack and LocalPlayer.Backpack:FindFirstChildOfClass("Tool") then
									Tool = LocalPlayer.Backpack:FindFirstChildOfClass("Tool")
								end
								print(Tool)

								if Tool ~= nil then
									Tool.Parent = LocalPlayer.Backpack
									
									Player.Character.HumanoidRootPart.Anchored = true
									
									local Arm = game.Players.LocalPlayer.Character['Right Arm'].CFrame * CFrame.new(0, -1, 0, 1, 0, 0, 0, 0, 1, 0, -1, 0)
									Tool.Grip = Arm:ToObjectSpace(Player.Character.PrimaryPart.CFrame):Inverse()
									
									Tool.Parent = LocalPlayer.Character
									Workspace.CurrentCamera.CameraSubject = Tool.Handle
						
									repeat
										wait()
									until not Tool or Tool and (Tool.Parent == Workspace or Tool.Parent == Player.Character)
									Player.Character.HumanoidRootPart.Anchored = false
									wait(0.1)
									Humanoid.Health = 0
									LocalPlayer.Character = nil
								end
							end
					end
				end
		commandBar3.Visible = false
	end
	if commandBox3.Text == ":fly" and enterPressed then
	local Mouse = lplayer:GetMouse()

	repeat wait() until lplayer and lplayer.Character and lplayer.Character:FindFirstChild('HumanoidRootPart') and lplayer.Character:FindFirstChild('Humanoid')
	repeat wait() until Mouse
 
	local T = lplayer.Character.HumanoidRootPart
	local CONTROL = {F = 0, B = 0, L = 0, R = 0}
	local lCONTROL = {F = 0, B = 0, L = 0, R = 0}
	local SPEED = speedget
 
	local function fly()
		flying = true
		local BG = Instance.new('BodyGyro', T)
		local BV = Instance.new('BodyVelocity', T)
		BG.P = 9e4
		BG.maxTorque = Vector3.new(9e9, 9e9, 9e9)
		BG.cframe = T.CFrame
		BV.velocity = Vector3.new(0, 0.1, 0)
		BV.maxForce = Vector3.new(9e9, 9e9, 9e9)
		spawn(function()
		repeat wait()
		lplayer.Character.Humanoid.PlatformStand = true
		if CONTROL.L + CONTROL.R ~= 0 or CONTROL.F + CONTROL.B ~= 0 then
		SPEED = 50
		elseif not (CONTROL.L + CONTROL.R ~= 0 or CONTROL.F + CONTROL.B ~= 0) and SPEED ~= 0 then
		SPEED = 0
		end
		if (CONTROL.L + CONTROL.R) ~= 0 or (CONTROL.F + CONTROL.B) ~= 0 then
		BV.velocity = ((workspace.CurrentCamera.CoordinateFrame.lookVector * (CONTROL.F + CONTROL.B)) + ((workspace.CurrentCamera.CoordinateFrame * CFrame.new(CONTROL.L + CONTROL.R, (CONTROL.F + CONTROL.B) * 0.2, 0).p) - workspace.CurrentCamera.CoordinateFrame.p)) * SPEED
		lCONTROL = {F = CONTROL.F, B = CONTROL.B, L = CONTROL.L, R = CONTROL.R}
		elseif (CONTROL.L + CONTROL.R) == 0 and (CONTROL.F + CONTROL.B) == 0 and SPEED ~= 0 then
		BV.velocity = ((workspace.CurrentCamera.CoordinateFrame.lookVector * (lCONTROL.F + lCONTROL.B)) + ((workspace.CurrentCamera.CoordinateFrame * CFrame.new(lCONTROL.L + lCONTROL.R, (lCONTROL.F + lCONTROL.B) * 0.2, 0).p) - workspace.CurrentCamera.CoordinateFrame.p)) * SPEED
		else
		BV.velocity = Vector3.new(0, 0.1, 0)
		end
		BG.cframe = workspace.CurrentCamera.CoordinateFrame
				until not flying
				CONTROL = {F = 0, B = 0, L = 0, R = 0}
				lCONTROL = {F = 0, B = 0, L = 0, R = 0}
				SPEED = 0
				BG:destroy()
				BV:destroy()
				lplayer.Character.Humanoid.PlatformStand = false
			end)
		end
	Mouse.KeyDown:connect(function(KEY)
		if KEY:lower() == 'w' then
			CONTROL.F = speedfly
		elseif KEY:lower() == 's' then
			CONTROL.B = -speedfly
		elseif KEY:lower() == 'a' then
			CONTROL.L = -speedfly 
		elseif KEY:lower() == 'd' then 
			CONTROL.R = speedfly
		end
	end)
	Mouse.KeyUp:connect(function(KEY)
		if KEY:lower() == 'w' then
			CONTROL.F = 0
		elseif KEY:lower() == 's' then
			CONTROL.B = 0
		elseif KEY:lower() == 'a' then
			CONTROL.L = 0
		elseif KEY:lower() == 'd' then
			CONTROL.R = 0
		end
	end)
	fly()
	commandBar3.Visible = false
	end
	if commandBox3.Text == ":unfly" and enterPressed then
		flying = false
		lplayer.Character.Humanoid.PlatformStand = false
		commandBar3.Visible = false
	end
	if commandBox3.Text == ":lagswitch" and enterPressed then
		loadstring(game:HttpGet("https://paste.gg/p/anonymous/d3492bd620bd4c46b54680ac80b0fa0d/files/161ddd9c992c4ceba3c298458d45188a/raw", true))()

		game.StarterGui:SetCore("SendNotification", {
			Title = "Lag Switch Enable";
			Text = "Press X to toggle";
		})
		commandBar3.Visible = false
	end
	if commandBox3.Text == ":goto" and enterPressed then
		game.StarterGui:SetCore("SendNotification", {
			Title = "Warning";
			Text = "Make sure the player is in Value Box";
		})
		local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
		local target = ValueBox_2.Text

		pl.CFrame = game.Players[target].Character.HumanoidRootPart.CFrame
		commandBar3.Visible = false
	end
	if commandBox3.Text == ":mousefling" and enterPressed then
	for i,v in next, game:GetService("Players").LocalPlayer.Character:GetDescendants() do
if v:IsA("BasePart") and v.Name ~="HumanoidRootPart" then
game:GetService("RunService").Heartbeat:connect(function()
v.Velocity = Vector3.new(0,-30,0)
wait(0.5)
end)
end
end
 
function rmesh(HatName)
for _,mesh in next, workspace[game.Players.LocalPlayer.Name][HatName]:GetDescendants() do
if mesh:IsA("Mesh") or mesh:IsA("SpecialMesh") then
mesh:Remove()
end
end
end
 
function create(part, parent, position, rotation)
part.AccessoryWeld:Remove()
Instance.new("Attachment",part)
Instance.new("AlignPosition",part)
Instance.new("AlignOrientation",part)
Instance.new("Attachment",parent)
part.AlignPosition.Attachment0 = part.Attachment
part.AlignOrientation.Attachment0 = part.Attachment
part.AlignPosition.Attachment1 = parent.Attachment
part.AlignOrientation.Attachment1 = parent.Attachment
part.Attachment.Position = position
part.Attachment.Orientation = rotation
part.AlignPosition.Responsiveness = 200
part.AlignOrientation.Responsiveness = 200
part.AlignPosition.MaxForce = 9999999
part.AlignPosition.RigidityEnabled = false
part.AlignOrientation.MaxTorque = 9999999
end
 
local LocalPlayer = game.Players.LocalPlayer
 
function eswait(num)
if num == 0 or num == nil then
game:service("RunService").Stepped:wait(0)
else
for i = 0, num do
game:service("RunService").Stepped:wait(0)
end
end
end
 
function makepart(hat,part)
Instance.new('Part',workspace[LocalPlayer.Name])
workspace[LocalPlayer.Name].Part.Name = 'lerp'..hat
workspace[LocalPlayer.Name]['lerp'..hat].CanCollide = false
workspace[LocalPlayer.Name]['lerp'..hat].Size = workspace[LocalPlayer.Name][hat].Handle.Size
workspace[LocalPlayer.Name]['lerp'..hat].Transparency = 1
Instance.new('Weld',workspace[LocalPlayer.Name]['lerp'..hat])
create(workspace[LocalPlayer.Name][hat].Handle,workspace[LocalPlayer.Name]['lerp'..hat],Vector3.new(),Vector3.new())
workspace[LocalPlayer.Name]['lerp'..hat].Weld.Part0 = workspace[LocalPlayer.Name]['lerp'..hat]
workspace[LocalPlayer.Name]['lerp'..hat].Weld.Part1 = workspace[LocalPlayer.Name][part]
workspace[LocalPlayer.Name]['lerp'..hat].Weld.C0 = workspace[LocalPlayer.Name]['lerp'..hat].CFrame:inverse() * workspace[LocalPlayer.Name][part].CFrame * CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),math.rad(0),0)
end
 
local hatsine = 0
 
local hatchange = 1
 
function clerp(hat,ppx,ppy,pppz,rrrx,rrry,rrz,lppx,lppy,lpppz,lrrrx,lrrry,lrrz,speed)
coroutine.wrap(function()
while true do
hatsine = hatsine + speed
workspace[game.Players.LocalPlayer.Name]['lerp'..hat].Weld.C0 = workspace[game.Players.LocalPlayer.Name]['lerp'..hat].Weld.C0:lerp(CFrame.new(ppx + lppx * math.sin(hatsine/11), ppy + lppy * math.sin(hatsine/11), pppz + lpppz * math.sin(hatsine/11)) * CFrame.Angles(math.rad(rrrx + lrrrx * math.sin(hatsine/11)), math.rad(rrry + lrrry * math.sin(hatsine/11)), math.rad(rrz + lrrz * math.sin(hatsine/11))),0.1)
eswait()
end
end)()
end
 
local player = game.Players.LocalPlayer
local character1 = player.Character
local mouse = player:GetMouse()
 
local fakebody = Instance.new("Part", character1)
fakebody.Transparency = 1
fakebody.Anchored = true
fakebody.CanCollide = false
fakebody.Position = character1.Head.Position
fakebody.Name = "FPart"
wait()
_G.ReanimationType = "PDeath" --PDeath, Fling, Simple
_G.Velocity = Vector3.new(36,0,0)
_G.FlingBlock = true
_G.FlingBlockTransparency = 1
_G.HighlightFlingBlock = true
_G.FlingBlockPosition = "FPart"
_G.HighlightFlingBlockColor = Color3.fromRGB(255,0,0)
 
loadstring(game:HttpGet("https://raw.githubusercontent.com/GelatekWasTaken/Reanimation.lua/main/Main/Main.lua"))()
wait(1)
 
mouse.KeyDown:connect(function(key)
    if key == "e" then
    character1.Reanimate.FPart.Position = mouse.Hit.p
    end
end)
 
rmesh('Pink Hair')
rmesh('Kate Hair')
 
makepart('Kate Hair','Right Arm')
clerp('Kate Hair',0,1,0,0,0,0,0,0,0,0,0,0,1)
 
makepart('Pink Hair','Right Arm')
clerp('Pink Hair',0,0.5,-2,-90,0,0,0,0,0,0,0,0,1)
 
local Scale = game.Players.LocalPlayer.Character.Torso.Size.X/2*(game.Players.LocalPlayer.Character.Torso:FindFirstChild("ScaleInserted") ~= nil and game.Players.LocalPlayer.Character.Torso:FindFirstChild("ScaleInserted").Scale.Z or 1)*0.8
local Speed = 20*Scale
local Gravity = 0.1
 
local Player = game.Players.LocalPlayer
local Character = Player.Character.Reanimate
local Humanoid = Character.Humanoid
Humanoid:SetStateEnabled(Enum.HumanoidStateType.Ragdoll,false)
local Torso = Character.HumanoidRootPart
local Mouse = game.Players.LocalPlayer:GetMouse()
local RenderStepped = game:GetService("RunService").RenderStepped
local Camera = Workspace.CurrentCamera
Camera:ClearAllChildren()
local Model = Instance.new("Model",Character)
local IgnoreList = {Character,Workspace.Terrain}
 
local Part0Joint = CFrame.new(Vector3.new(1,0.75,0)*Scale*1.25)
local Part1Joint = CFrame.new(Vector3.new(-0.5,0.75,0)*Scale*1.25)
local RotationOffset = CFrame.Angles(math.rad(90),math.rad(0),0)
local Gangster = false
 
local Part0JointHead = CFrame.new(Vector3.new(0,1,0)*Scale*1.25)
local Part1JointHead = CFrame.new(Vector3.new(0,-0.5,0)*Scale*1.25)
local RotationOffsetHead = CFrame.Angles(0,0,0)
 
local Handle = Instance.new("Part",Model)
Handle.CanCollide = false
Handle.Name = "Handle"
Handle.Position = Vector3.new(0,100,0)
Handle:BreakJoints()
Handle.FormFactor = "Custom"
Handle.Size = Vector3.new(0.2,0.2,0.2)
Handle.TopSurface = "SmoothNoOutlines"
Handle.BottomSurface = "SmoothNoOutlines"
Handle.FrontSurface = "SmoothNoOutlines"
Handle.BackSurface = "SmoothNoOutlines"
Handle.RightSurface = "SmoothNoOutlines"
Handle.LeftSurface = "SmoothNoOutlines"
Handle.BrickColor = BrickColor.new("Black")
local Mesh = Instance.new("BlockMesh",Handle)
Mesh.Scale = Vector3.new(0.25,1,0.4) / 0.2 * Scale
local HandleWeld = Instance.new("Motor6D")
HandleWeld.Part0 = Character["Right Arm"]
HandleWeld.Part1 = Handle
HandleWeld.C0 = CFrame.new(Vector3.new(0,-1,0)*Scale) * CFrame.Angles(math.rad(-105),0,0)
HandleWeld.Parent = Handle
 
local Part = Instance.new("Part",Model)
Part.CanCollide = false
Part.Position = Vector3.new(0,100,0)
Part:BreakJoints()
Part.FormFactor = "Custom"
Part.Size = Vector3.new(0.2,0.2,0.2)
Part.TopSurface = "SmoothNoOutlines"
Part.BottomSurface = "SmoothNoOutlines"
Part.FrontSurface = "SmoothNoOutlines"
Part.BackSurface = "SmoothNoOutlines"
Part.RightSurface = "SmoothNoOutlines"
Part.LeftSurface = "SmoothNoOutlines"
Part.BrickColor = BrickColor.new("Black")
local Mesh = Instance.new("CylinderMesh",Part)
Mesh.Scale = Vector3.new(0.07,0.2,0.07) / 0.2 * Scale
local PartWeld = Instance.new("Motor6D")
PartWeld.Part0 = Handle
PartWeld.Part1 = Part
PartWeld.C0 = CFrame.new(Vector3.new(-0.115,-0.475,-0.190)*Scale) * CFrame.Angles(0,0,0)
PartWeld.Parent = Part
 
local Part = Instance.new("Part",Model)
Part.CanCollide = false
Part.Position = Vector3.new(0,100,0)
Part:BreakJoints()
Part.FormFactor = "Custom"
Part.Size = Vector3.new(0.2,0.2,0.2)
Part.TopSurface = "SmoothNoOutlines"
Part.BottomSurface = "SmoothNoOutlines"
Part.FrontSurface = "SmoothNoOutlines"
Part.BackSurface = "SmoothNoOutlines"
Part.RightSurface = "SmoothNoOutlines"
Part.LeftSurface = "SmoothNoOutlines"
Part.BrickColor = BrickColor.new("Black")
local Mesh = Instance.new("CylinderMesh",Part)
Mesh.Scale = Vector3.new(0.07,0.2,0.07) / 0.2 * Scale
local PartWeld = Instance.new("Motor6D")
PartWeld.Part0 = Handle
PartWeld.Part1 = Part
PartWeld.C0 = CFrame.new(Vector3.new(0.115,-0.475,0.190)*Scale) * CFrame.Angles(0,0,0)
PartWeld.Parent = Part
 
local Part = Instance.new("Part",Model)
Part.CanCollide = false
Part.Position = Vector3.new(0,100,0)
Part:BreakJoints()
Part.FormFactor = "Custom"
Part.Size = Vector3.new(0.2,0.2,0.2)
Part.TopSurface = "SmoothNoOutlines"
Part.BottomSurface = "SmoothNoOutlines"
Part.FrontSurface = "SmoothNoOutlines"
Part.BackSurface = "SmoothNoOutlines"
Part.RightSurface = "SmoothNoOutlines"
Part.LeftSurface = "SmoothNoOutlines"
Part.BrickColor = BrickColor.new("Black")
local Mesh = Instance.new("CylinderMesh",Part)
Mesh.Scale = Vector3.new(0.07,0.2,0.07) / 0.2 * Scale
local PartWeld = Instance.new("Motor6D")
PartWeld.Part0 = Handle
PartWeld.Part1 = Part
PartWeld.C0 = CFrame.new(Vector3.new(-0.115,-0.475,0.190)*Scale) * CFrame.Angles(0,0,0)
PartWeld.Parent = Part
 
local Part = Instance.new("Part",Model)
Part.CanCollide = false
Part.Position = Vector3.new(0,100,0)
Part:BreakJoints()
Part.FormFactor = "Custom"
Part.Size = Vector3.new(0.2,0.2,0.2)
Part.TopSurface = "SmoothNoOutlines"
Part.BottomSurface = "SmoothNoOutlines"
Part.FrontSurface = "SmoothNoOutlines"
Part.BackSurface = "SmoothNoOutlines"
Part.RightSurface = "SmoothNoOutlines"
Part.LeftSurface = "SmoothNoOutlines"
Part.BrickColor = BrickColor.new("Black")
local Mesh = Instance.new("CylinderMesh",Part)
Mesh.Scale = Vector3.new(0.07,0.2,0.07) / 0.2 * Scale
local PartWeld = Instance.new("Motor6D")
PartWeld.Part0 = Handle
PartWeld.Part1 = Part
PartWeld.C0 = CFrame.new(Vector3.new(0.115,-0.475,-0.190)*Scale) * CFrame.Angles(0,0,0)
PartWeld.Parent = Part
 
local Part = Instance.new("Part",Model)
Part.CanCollide = false
Part.Position = Vector3.new(0,100,0)
Part:BreakJoints()
Part.FormFactor = "Custom"
Part.Size = Vector3.new(0.2,0.2,0.2)
Part.TopSurface = "SmoothNoOutlines"
Part.BottomSurface = "SmoothNoOutlines"
Part.FrontSurface = "SmoothNoOutlines"
Part.BackSurface = "SmoothNoOutlines"
Part.RightSurface = "SmoothNoOutlines"
Part.LeftSurface = "SmoothNoOutlines"
Part.BrickColor = BrickColor.new("Black")
local Mesh = Instance.new("BlockMesh",Part)
Mesh.Scale = Vector3.new(0.23,0.2,0.1) / 0.2 * Scale
local PartWeld = Instance.new("Motor6D")
PartWeld.Part0 = Handle
PartWeld.Part1 = Part
PartWeld.C0 = CFrame.new(Vector3.new(0,-0.475,-0.175)*Scale) * CFrame.Angles(0,0,0)
PartWeld.Parent = Part
 
local Part = Instance.new("Part",Model)
Part.CanCollide = false
Part.Position = Vector3.new(0,100,0)
Part:BreakJoints()
Part.FormFactor = "Custom"
Part.Size = Vector3.new(0.2,0.2,0.2)
Part.TopSurface = "SmoothNoOutlines"
Part.BottomSurface = "SmoothNoOutlines"
Part.FrontSurface = "SmoothNoOutlines"
Part.BackSurface = "SmoothNoOutlines"
Part.RightSurface = "SmoothNoOutlines"
Part.LeftSurface = "SmoothNoOutlines"
Part.BrickColor = BrickColor.new("Black")
local Mesh = Instance.new("BlockMesh",Part)
Mesh.Scale = Vector3.new(0.23,0.2,0.1) / 0.2 * Scale
local PartWeld = Instance.new("Motor6D")
PartWeld.Part0 = Handle
PartWeld.Part1 = Part
PartWeld.C0 = CFrame.new(Vector3.new(0,-0.475,0.175)*Scale) * CFrame.Angles(0,0,0)
PartWeld.Parent = Part
 
local Part = Instance.new("Part",Model)
Part.CanCollide = false
Part.Position = Vector3.new(0,100,0)
Part:BreakJoints()
Part.FormFactor = "Custom"
Part.Size = Vector3.new(0.2,0.2,0.2)
Part.TopSurface = "SmoothNoOutlines"
Part.BottomSurface = "SmoothNoOutlines"
Part.FrontSurface = "SmoothNoOutlines"
Part.BackSurface = "SmoothNoOutlines"
Part.RightSurface = "SmoothNoOutlines"
Part.LeftSurface = "SmoothNoOutlines"
Part.BrickColor = BrickColor.new("Black")
local Mesh = Instance.new("BlockMesh",Part)
Mesh.Scale = Vector3.new(0.1,0.2,0.38) / 0.2 * Scale
local PartWeld = Instance.new("Motor6D")
PartWeld.Part0 = Handle
PartWeld.Part1 = Part
PartWeld.C0 = CFrame.new(Vector3.new(-0.1,-0.475,0)*Scale) * CFrame.Angles(0,0,0)
PartWeld.Parent = Part
 
local Part = Instance.new("Part",Model)
Part.CanCollide = false
Part.Position = Vector3.new(0,100,0)
Part:BreakJoints()
Part.FormFactor = "Custom"
Part.Size = Vector3.new(0.2,0.2,0.2)
Part.TopSurface = "SmoothNoOutlines"
Part.BottomSurface = "SmoothNoOutlines"
Part.FrontSurface = "SmoothNoOutlines"
Part.BackSurface = "SmoothNoOutlines"
Part.RightSurface = "SmoothNoOutlines"
Part.LeftSurface = "SmoothNoOutlines"
Part.BrickColor = BrickColor.new("Black")
local Mesh = Instance.new("BlockMesh",Part)
Mesh.Scale = Vector3.new(0.1,0.2,0.38) / 0.2 * Scale
local PartWeld = Instance.new("Motor6D")
PartWeld.Part0 = Handle
PartWeld.Part1 = Part
PartWeld.C0 = CFrame.new(Vector3.new(0.1,-0.475,0)*Scale) * CFrame.Angles(0,0,0)
PartWeld.Parent = Part
 
local Part = Instance.new("Part",Model)
Part.CanCollide = false
Part.Position = Vector3.new(0,100,0)
Part:BreakJoints()
Part.FormFactor = "Custom"
Part.Size = Vector3.new(0.2,0.2,0.2)
Part.TopSurface = "SmoothNoOutlines"
Part.BottomSurface = "SmoothNoOutlines"
Part.FrontSurface = "SmoothNoOutlines"
Part.BackSurface = "SmoothNoOutlines"
Part.RightSurface = "SmoothNoOutlines"
Part.LeftSurface = "SmoothNoOutlines"
Part.BrickColor = BrickColor.new("Black")
local Mesh = Instance.new("BlockMesh",Part)
Mesh.Scale = Vector3.new(0.1,0.3,0.05) / 0.2 * Scale
local PartWeld = Instance.new("Motor6D")
PartWeld.Part0 = Handle
PartWeld.Part1 = Part
PartWeld.C0 = CFrame.Angles(math.rad(15),0,0) * CFrame.new(Vector3.new(0,0.25,-0.75)*Scale) * CFrame.Angles(math.rad(-10),0,0)
PartWeld.Parent = Part
 
local Part = Instance.new("Part",Model)
Part.CanCollide = false
Part.Position = Vector3.new(0,100,0)
Part:BreakJoints()
Part.FormFactor = "Custom"
Part.Size = Vector3.new(0.2,0.2,0.2)
Part.TopSurface = "SmoothNoOutlines"
Part.BottomSurface = "SmoothNoOutlines"
Part.FrontSurface = "SmoothNoOutlines"
Part.BackSurface = "SmoothNoOutlines"
Part.RightSurface = "SmoothNoOutlines"
Part.LeftSurface = "SmoothNoOutlines"
Part.BrickColor = BrickColor.new("Black")
local Mesh = Instance.new("BlockMesh",Part)
Mesh.Scale = Vector3.new(0.1,0.05,0.625) / 0.2 * Scale
local PartWeld = Instance.new("Motor6D")
PartWeld.Part0 = Handle
PartWeld.Part1 = Part
PartWeld.C0 = CFrame.Angles(math.rad(15),0,0) * CFrame.new(Vector3.new(0,0.1,-0.435)*Scale)
PartWeld.Parent = Part
 
for i = 0,80,10 do
local Part = Instance.new("Part",Model)
Part.CanCollide = false
Part.Position = Vector3.new(0,100,0)
Part:BreakJoints()
Part.FormFactor = "Custom"
Part.Size = Vector3.new(0.2,0.2,0.2)
Part.TopSurface = "SmoothNoOutlines"
Part.BottomSurface = "SmoothNoOutlines"
Part.FrontSurface = "SmoothNoOutlines"
Part.BackSurface = "SmoothNoOutlines"
Part.RightSurface = "SmoothNoOutlines"
Part.LeftSurface = "SmoothNoOutlines"
Part.BrickColor = BrickColor.new("Black")
local Mesh = Instance.new("BlockMesh",Part)
Mesh.Scale = Vector3.new(0.25,0.15,0.03555*2) / 0.2 * Scale
local PartWeld = Instance.new("Motor6D")
PartWeld.Part0 = Handle
PartWeld.Part1 = Part
PartWeld.C0 = CFrame.new(Vector3.new(0,0.15,0.315)*Scale) * CFrame.Angles(math.rad(i-65),0,0) * CFrame.new(Vector3.new(0,0.2,0)*Scale)
PartWeld.Parent = Part
end
 
local Barrel = Instance.new("Part",Model)
Barrel.CanCollide = false
Barrel.Position = Vector3.new(0,100,0)
Barrel:BreakJoints()
Barrel.FormFactor = "Custom"
Barrel.Size = Vector3.new(0.2,0.2,0.2)
Barrel.TopSurface = "SmoothNoOutlines"
Barrel.BottomSurface = "SmoothNoOutlines"
Barrel.FrontSurface = "SmoothNoOutlines"
Barrel.BackSurface = "SmoothNoOutlines"
Barrel.RightSurface = "SmoothNoOutlines"
Barrel.LeftSurface = "SmoothNoOutlines"
Barrel.BrickColor = BrickColor.new("Black")
local Mesh = Instance.new("BlockMesh",Barrel)
Mesh.Scale = Vector3.new(0.25,0.2,2) / 0.2 * Scale
local BarrelWeld = Instance.new("Motor6D")
BarrelWeld.Part0 = Handle
BarrelWeld.Part1 = Barrel
BarrelWeld.C0 = CFrame.Angles(math.rad(15),0,0) * CFrame.new(Vector3.new(0,0.5,-0.7)*Scale)
BarrelWeld.Parent = Barrel
 
local Barrel1 = Barrel
 
local Barrel2 = Instance.new("Part",Model)
Barrel2.CanCollide = false
Barrel2.Position = Vector3.new(0,100,0)
Barrel2:BreakJoints()
Barrel2.FormFactor = "Custom"
Barrel2.Size = Vector3.new(0.2,0.2,0.2)
Barrel2.TopSurface = "SmoothNoOutlines"
Barrel2.BottomSurface = "SmoothNoOutlines"
Barrel2.FrontSurface = "SmoothNoOutlines"
Barrel2.BackSurface = "SmoothNoOutlines"
Barrel2.RightSurface = "SmoothNoOutlines"
Barrel2.LeftSurface = "SmoothNoOutlines"
Barrel2.BrickColor = BrickColor.new("Really black")
local Mesh = Instance.new("BlockMesh",Barrel2)
Mesh.Scale = Vector3.new(0.25,0.25,2) / 0.2 * Scale
local Barrel2Weld = Instance.new("Motor6D")
Barrel2Weld.Part0 = Barrel
Barrel2Weld.Part1 = Barrel2
Barrel2Weld.C0 = CFrame.new(Vector3.new(0,0.225,0)*Scale)
Barrel2Weld.Parent = Barrel2
 
local RealBarrel = Instance.new("Part",Model)
RealBarrel.CanCollide = false
RealBarrel.Position = Vector3.new(0,100,0)
RealBarrel:BreakJoints()
RealBarrel.FormFactor = "Custom"
RealBarrel.Size = Vector3.new(0.2,0.2,0.2)
RealBarrel.TopSurface = "SmoothNoOutlines"
RealBarrel.BottomSurface = "SmoothNoOutlines"
RealBarrel.FrontSurface = "SmoothNoOutlines"
RealBarrel.BackSurface = "SmoothNoOutlines"
RealBarrel.RightSurface = "SmoothNoOutlines"
RealBarrel.LeftSurface = "SmoothNoOutlines"
RealBarrel.BrickColor = BrickColor.new("Dark grey metallic")
local Mesh = Instance.new("CylinderMesh",RealBarrel)
Mesh.Scale = Vector3.new(0.2,2,0.2) / 0.2 * Scale
local RealBarrelWeld = Instance.new("Motor6D")
RealBarrelWeld.Part0 = Barrel
RealBarrelWeld.Part1 = RealBarrel
RealBarrelWeld.C0 = CFrame.new(Vector3.new(0,0.1,-0.01)*Scale) * CFrame.Angles(math.rad(-90),0,0)
RealBarrelWeld.Parent = RealBarrel
 
for i = 1,75,15 do
local Part = Instance.new("Part",Model)
Part.CanCollide = false
Part.Position = Vector3.new(0,100,0)
Part:BreakJoints()
Part.FormFactor = "Custom"
Part.Size = Vector3.new(0.2,0.2,0.2)
Part.TopSurface = "SmoothNoOutlines"
Part.BottomSurface = "SmoothNoOutlines"
Part.FrontSurface = "SmoothNoOutlines"
Part.BackSurface = "SmoothNoOutlines"
Part.RightSurface = "SmoothNoOutlines"
Part.LeftSurface = "SmoothNoOutlines"
Part.BrickColor = BrickColor.new("Black")
local Mesh = Instance.new("BlockMesh",Part)
Mesh.Scale = Vector3.new(0.05,0.065,0.05) / 0.2 * Scale
local PartWeld = Instance.new("Motor6D")
PartWeld.Part0 = Handle
PartWeld.Part1 = Part
PartWeld.C0 = CFrame.new(Vector3.new(0,0.525,-0.515)*Scale) * CFrame.Angles(math.rad(i),0,0) * CFrame.new(Vector3.new(0,0,0.2)*Scale)
PartWeld.Parent = Part
end
 
local Part = Instance.new("Part",Model)
Part.CanCollide = false
Part.Position = Vector3.new(0,100,0)
Part:BreakJoints()
Part.FormFactor = "Custom"
Part.Size = Vector3.new(0.2,0.2,0.2)
Part.TopSurface = "SmoothNoOutlines"
Part.BottomSurface = "SmoothNoOutlines"
Part.FrontSurface = "SmoothNoOutlines"
Part.BackSurface = "SmoothNoOutlines"
Part.RightSurface = "SmoothNoOutlines"
Part.LeftSurface = "SmoothNoOutlines"
Part.BrickColor = BrickColor.new("Really black")
local Mesh = Instance.new("BlockMesh",Part)
Mesh.Scale = Vector3.new(0.05,0.11,0.1) / 0.2 * Scale
local PartWeld = Instance.new("Motor6D")
PartWeld.Part0 = Barrel2
PartWeld.Part1 = Part
PartWeld.C0 = CFrame.new(Vector3.new(0.06,0.135,0.925)*Scale)
PartWeld.Parent = Part
 
local Part = Instance.new("Part",Model)
Part.CanCollide = false
Part.Position = Vector3.new(0,100,0)
Part:BreakJoints()
Part.FormFactor = "Custom"
Part.Size = Vector3.new(0.2,0.2,0.2)
Part.TopSurface = "SmoothNoOutlines"
Part.BottomSurface = "SmoothNoOutlines"
Part.FrontSurface = "SmoothNoOutlines"
Part.BackSurface = "SmoothNoOutlines"
Part.RightSurface = "SmoothNoOutlines"
Part.LeftSurface = "SmoothNoOutlines"
Part.BrickColor = BrickColor.new("Really black")
local Mesh = Instance.new("BlockMesh",Part)
Mesh.Scale = Vector3.new(0.05,0.11,0.1) / 0.2 * Scale
local PartWeld = Instance.new("Motor6D")
PartWeld.Part0 = Barrel2
PartWeld.Part1 = Part
PartWeld.C0 = CFrame.new(Vector3.new(-0.06,0.135,0.925)*Scale)
PartWeld.Parent = Part
 
local Part = Instance.new("Part",Model)
Part.CanCollide = false
Part.Position = Vector3.new(0,100,0)
Part:BreakJoints()
Part.FormFactor = "Custom"
Part.Size = Vector3.new(0.2,0.2,0.2)
Part.TopSurface = "SmoothNoOutlines"
Part.BottomSurface = "SmoothNoOutlines"
Part.FrontSurface = "SmoothNoOutlines"
Part.BackSurface = "SmoothNoOutlines"
Part.RightSurface = "SmoothNoOutlines"
Part.LeftSurface = "SmoothNoOutlines"
Part.BrickColor = BrickColor.new("Really black")
local Mesh = Instance.new("BlockMesh",Part)
Mesh.Scale = Vector3.new(0.025,0.1,0.1) / 0.2 * Scale
local PartWeld = Instance.new("Motor6D")
PartWeld.Part0 = Barrel2
PartWeld.Part1 = Part
PartWeld.C0 = CFrame.new(Vector3.new(0,0.135,-0.925)*Scale)
PartWeld.Parent = Part
 
local Part = Instance.new("Part",Model)
Part.CanCollide = false
Part.Position = Vector3.new(0,100,0)
Part:BreakJoints()
Part.FormFactor = "Custom"
Part.Size = Vector3.new(0.2,0.2,0.2)
Part.Transparency = 1
Part.TopSurface = "SmoothNoOutlines"
Part.BottomSurface = "SmoothNoOutlines"
Part.FrontSurface = "SmoothNoOutlines"
Part.BackSurface = "SmoothNoOutlines"
Part.RightSurface = "SmoothNoOutlines"
Part.LeftSurface = "SmoothNoOutlines"
Part.BrickColor = BrickColor.new("Really black")
local Mesh = Instance.new("BlockMesh",Part)
Mesh.Scale = Vector3.new(0.1,0.1,0.1) / 0.2 * Scale
local PartWeld = Instance.new("Motor6D")
PartWeld.Part0 = Barrel
PartWeld.Part1 = Part
PartWeld.C0 = CFrame.new(Vector3.new(0,0,-5)*Scale)
PartWeld.Parent = Part
 
local Light = Instance.new("PointLight",Part)
Light.Color = BrickColor.new("Gold").Color
Light.Enabled = true
Light.Shadows = true
Light.Brightness = 0
Light.Range = 6
 
local Part = Instance.new("Part",Model)
Part.Material = "Neon"
Part.CanCollide = false
Part.Position = Vector3.new(0,100,0)
Part:BreakJoints()
Part.FormFactor = "Custom"
Part.Size = Vector3.new(0.2,0.2,0.2)
Part.TopSurface = "SmoothNoOutlines"
Part.BottomSurface = "SmoothNoOutlines"
Part.FrontSurface = "SmoothNoOutlines"
Part.BackSurface = "SmoothNoOutlines"
Part.RightSurface = "SmoothNoOutlines"
Part.LeftSurface = "SmoothNoOutlines"
Part.BrickColor = BrickColor.new("Bright yellow")
Part.Transparency = 0.25
local RecoilMesh = Instance.new("SpecialMesh",Part)
RecoilMesh.MeshType = "FileMesh"
RecoilMesh.MeshId = "http://www.roblox.com/Asset/?id=1323306"
RecoilMesh.TextureId = "http://www.roblox.com/Asset/?id=98896228"
RecoilMesh.Scale = Vector3.new(0.175,0,0.175) * Scale
local PartWeld = Instance.new("Motor6D")
PartWeld.Part0 = RealBarrel
PartWeld.Part1 = Part
PartWeld.C0 = CFrame.new(Vector3.new(0,0.95,0)*Scale)
PartWeld.Parent = Part
 
function ShootBullet(Target,barrel)
local barrel = barrel or Barrel
local Bullet = Instance.new("Part",Workspace)
Barrel.CanCollide = false
Bullet.FormFactor = "Custom"
Bullet.Size = Vector3.new(0.2,0.2,5)*Scale
Bullet.TopSurface = "Smooth"
Bullet.BottomSurface = "Smooth"
Bullet.Anchored = true
Bullet.CanCollide = false
Bullet.CFrame = CFrame.new((barrel.CFrame*CFrame.new(0,0,-barrel.Size.Z*barrel.Mesh.Scale.Z/2)).p,Target)*CFrame.new(0,0,-Bullet.Size.Z/2)
Bullet.Transparency = 0.1
Bullet.BrickColor = BrickColor.new("Gold")
--[[local Mesh = Instance.new("SpecialMesh",Bullet)
Mesh.MeshType = "FileMesh"
Mesh.Scale = Vector3.new(0.5,0.5,0.2)
Mesh.MeshId = "http://www.roblox.com/asset/?id=2697549"
--Mesh.TextureId = "http://www.roblox.com/asset/?id=2697544"]]
local Mesh = Instance.new("BlockMesh",Bullet)
Mesh.Scale = Vector3.new(0.2,0.2,5)*Scale/Bullet.Size
IgnoreList[#IgnoreList+1] = Bullet
RenderStepped:wait()
for i = Speed,1000,Speed do -- Loop to do the bullet movement and stuff.
local ray,Hit,Pos,SurfaceNormal;
ray = Ray.new(Bullet.Position,((Bullet.CFrame*CFrame.Angles(math.rad(-Gravity),0,0)*CFrame.new(0,0,-Speed)).p-Bullet.Position).unit*Speed)
Hit,Pos,SurfaceNormal = Workspace:FindPartOnRayWithIgnoreList(ray,IgnoreList)
Bullet.CFrame = Bullet.CFrame*CFrame.Angles(math.rad(-Gravity),0,0)*CFrame.new(0,0,-Speed)
if Hit ~= nil then
local Hum = Hit.Parent:FindFirstChild("Humanoid") or Hit.Parent.Parent:FindFirstChild("Humanoid") or (Hit.Parent.Parent.Parent ~= nil and Hit.Parent.Parent.Parent:FindFirstChild("Humanoid"))
if Hum ~= nil then
Hum:TakeDamage((((Gangster and math.random(0,0) or math.random(0,0))*Scale)/100)*Hum.MaxHealth)
end
break
end
RenderStepped:wait()
end
Bullet:Destroy()
end
 
Mouse.Button1Down:connect(function()
if not Down and not DB then
Down = true
while Down do
if Humanoid.Health == 0 then break end
if not DB then
DB = true
local Sound = Instance.new("Sound",Barrel)
Sound.SoundId = "http://www.roblox.com/Asset/?id=165946426" -- 132373574
Sound.Volume = 5*Scale
Sound.Pitch = (math.random(70,110)/100)/((Scale < 0.25 and 0.25) or (Scale > 4 and 4) or Scale)
Sound:Play()
Spawn(function()
ShootBullet(Mouse.Hit.p,Barrel1)
end)
RecoilMesh.VertexColor = Vector3.new(1,math.random(160,245)/255,20/255)
PartWeld.C0 = PartWeld.C0 * CFrame.Angles(0,math.rad(math.random(-40,40)),0)
local Shell = Instance.new("Part",Workspace)
Shell.FormFactor = "Custom"
Shell.BrickColor = BrickColor.new("Bright yellow")
Shell.Size = Vector3.new(0.2,0.5,0.2)*Scale
Shell.CFrame = Barrel.CFrame*CFrame.new(0.5,0.5,0)*CFrame.Angles(math.rad(-90),0,0)
Shell.Velocity = ((Barrel.CFrame*CFrame.new(5,0,math.random(-2,2))).p-Barrel.CFrame.p)*5*Scale
local Mesh = Instance.new("CylinderMesh",Shell)
Mesh.Scale = Vector3.new(0.2,0.5,0.2)*Scale/Shell.Size
Spawn(function()
wait(5)
Shell:Destroy()
end)
for i = 1,20,7.5 do
character1.Reanimate.FPart.Position = mouse.Hit.p
RotationOffset = RotationOffset*CFrame.Angles(math.rad(7.5),0,0)
Part1Joint = Part1Joint*CFrame.new(Vector3.new(0,-0.15,0)*Scale)
Barrel2Weld.C0 = Barrel2Weld.C0*CFrame.new(Vector3.new(0,0,0.15)*Scale)
Light.Brightness = Light.Brightness+38
RecoilMesh.Scale = RecoilMesh.Scale+(Vector3.new(0,0.375,0)*Scale)
RenderStepped:wait()
end
wait(0.02)
for i = 1,20,3.75 do
character1.Reanimate.FPart.Position = mouse.Hit.p
RotationOffset = RotationOffset*CFrame.Angles(math.rad(-3.75),0,0)
Part1Joint = Part1Joint*CFrame.new(Vector3.new(0,0.075,0)*Scale)
Barrel2Weld.C0 = Barrel2Weld.C0*CFrame.new(Vector3.new(0,0,-0.075)*Scale)
Light.Brightness = Light.Brightness-19
RecoilMesh.Scale = RecoilMesh.Scale+(Vector3.new(0,-0.1875,0)*Scale)
RenderStepped:wait()
end
wait(0.02)
DB = false
end
end
end
end)
 
Mouse.Button1Up:connect(function()
Down = false
end)
 
Mouse.KeyDown:connect(function(Key)
if Key:lower() == "g" and not DB then
DB = true
if Gangster == true then
for i = 1,70,5 do
RotationOffset = RotationOffset*CFrame.Angles(0,math.rad(-5),0)
RenderStepped:wait()
end
Gangster = false
else
for i = 1,70,5 do
RotationOffset = RotationOffset*CFrame.Angles(0,math.rad(5),0)
RenderStepped:wait()
end
Gangster = true
end
DB = false
end
end)
 
local Weld = Instance.new("Weld")
Weld.Part0 = Torso
Weld.Part1 = Character["Right Arm"]
Weld.Parent = Torso
 
local Weld2 = Instance.new("Weld")
Weld2.Part0 = Torso
Weld2.Part1 = Character.Head
Weld2.Parent = Torso
 
local RA = Character["Right Arm"]
 
game:GetService("RunService"):BindToRenderStep("Pistol",Enum.RenderPriority.Character.Value,function()
local Point = Torso.CFrame:vectorToObjectSpace(Mouse.Hit.p-Torso.CFrame.p)
if Point.Z > 0 then
if Point.X > 0 then
Torso.CFrame = CFrame.new(Torso.Position,Vector3.new(Mouse.Hit.X,Torso.Position.Y,Mouse.Hit.Z))*CFrame.Angles(0,math.rad(90),0)
elseif Point.X < 0 then
Torso.CFrame = CFrame.new(Torso.Position,Vector3.new(Mouse.Hit.X,Torso.Position.Y,Mouse.Hit.Z))*CFrame.Angles(0,math.rad(-90),0)
end
end
 
local CFr = (Torso.CFrame*Part0Joint):toObjectSpace(CFrame.new((Torso.CFrame*Part0Joint).p,Mouse.Hit.p))--RayEnd))
Weld.C0 = Part0Joint * (CFr-CFr.p) * RotationOffset
Weld.C1 = Part1Joint
Weld.Part0 = Torso
Weld.Part1 = RA
local CFr = (Torso.CFrame*Part0JointHead):toObjectSpace(CFrame.new((Torso.CFrame*Part0JointHead).p,Mouse.Hit.p))--RayEnd))
Weld2.C0 = Part0JointHead * (CFr-CFr.p) * RotationOffsetHead
Weld2.C1 = Part1JointHead
Weld2.Part0 = Torso
Weld2.Part1 = Character.Head
local Last = Scale
Scale = game.Players.LocalPlayer.Character.Torso.Size.X/2*(game.Players.LocalPlayer.Character.Torso:FindFirstChild("ScaleInserted") ~= nil and game.Players.LocalPlayer.Character.Torso:FindFirstChild("ScaleInserted").Scale.Z or 1)*0.8
Speed = 20*Scale
if Scale ~= Last then
Part0Joint = CFrame.new(Vector3.new(1,0.75,0)*Scale*1.25)
Part1Joint = CFrame.new(Vector3.new(-0.5,0.75,0)*Scale*1.25)
Part0JointHead = CFrame.new(Vector3.new(0,1,0)*Scale*1.25)
Part1JointHead = CFrame.new(Vector3.new(0,-0.5,0)*Scale*1.25)
end
end)

		wait(2)

		commandBar3.Visible = false
	end
	if commandBox3.Text == ":permadeath" and enterPressed then
		game.StarterGui:SetCore("SendNotification", {
			Title = "Warning";
			Text = "Must be R6";
		})
			loadstring(game:HttpGet("https://raw.githubusercontent.com/GelatekWasTaken/Reanimation.lua/main/Main/Main.lua"))()
		
		wait(2)

		commandBar3.Visible = false
	end
	if commandBox3.Text == ":bighead" and enterPressed then
		game.StarterGui:SetCore("SendNotification", {
			Title = "Warning";
			Text = "Make sure you are wearing the correct avatar and the correct scales";
		})

		loadstring(game:HttpGet("https://raw.githubusercontent.com/sysGhost-aka-BiKode/Scripts2022/main/BigHeadV3_Unpatched", true))()

		commandBar3.Visible = false
	end
	if commandBox3.Text == ":giant" and enterPressed then
		game.StarterGui:SetCore("SendNotification", {
				Title = "Warning";
				Text = "To work you need the highest scales";
			})


			local LocalPlayer = game:GetService("Players").LocalPlayer
			local Character = LocalPlayer.Character
			local Humanoid = Character:FindFirstChildOfClass("Humanoid")

			function rm()
				for i,v in pairs(Character:GetDescendants()) do
					if v:IsA("BasePart") then
						if v.Name == "Handle" or v.Name == "Head" then
							if Character.Head:FindFirstChild("OriginalSize") then
								Character.Head.OriginalSize:Destroy()
							end
						else
							for i,cav in pairs(v:GetDescendants()) do
								if cav:IsA("Attachment") then
									if cav:FindFirstChild("OriginalPosition") then
										cav.OriginalPosition:Destroy()  
									end
								end
							end
							v:FindFirstChild("OriginalSize"):Destroy()
							if v:FindFirstChild("AvatarPartScaleType") then
								v:FindFirstChild("AvatarPartScaleType"):Destroy()
							end
						end
					end
				end
			end

			rm()
			wait(0.5)
			Humanoid:FindFirstChild("BodyProportionScale"):Destroy()
			wait(1)

			rm()
			wait(0.5)
			Humanoid:FindFirstChild("BodyHeightScale"):Destroy()
			wait(1)

			rm()
			wait(0.5)
			Humanoid:FindFirstChild("BodyWidthScale"):Destroy()
			wait(1)

			rm()
			wait(0.5)
			Humanoid:FindFirstChild("BodyDepthScale"):Destroy()
			wait(1)

			rm()
			wait(0.5)
			Humanoid:FindFirstChild("HeadScale"):Destroy()
			wait(1)

			commandBar3.Visible = false
	end
	if commandBox3.Text == ":small" and enterPressed then
		game.StarterGui:SetCore("SendNotification", {
				Title = "Warning";
				Text = "To work you need the smalest scales";
			})
			
			local LocalPlayer = game:GetService("Players").LocalPlayer
			local Character = LocalPlayer.Character
			local Humanoid = Character:FindFirstChildOfClass("Humanoid")

			local function rm()
				for i,v in pairs(Character:GetDescendants()) do
					if v:IsA("BasePart") then
						if v.Name ~= "Head" then
							for i,cav in pairs(v:GetDescendants()) do
								if cav:IsA("Attachment") then
									if cav:FindFirstChild("OriginalPosition") then
										cav.OriginalPosition:Destroy()
									end
								end
							end
							v:FindFirstChild("OriginalSize"):Destroy()
							if v:FindFirstChild("AvatarPartScaleType") then
								v:FindFirstChild("AvatarPartScaleType"):Destroy()
							end
						end
					end
				end
			end

			rm()
			wait(0.5)
			Humanoid:FindFirstChild("BodyTypeScale"):Destroy()
			wait(1)

			rm()
			wait(0.5)
			Humanoid:FindFirstChild("BodyWidthScale"):Destroy()
			wait(1)

			rm()
			wait(0.5)
			Humanoid:FindFirstChild("BodyDepthScale"):Destroy()
			wait(1)

			rm()
			wait(0.5)
			Humanoid:FindFirstChild("HeadScale"):Destroy()
			wait(1)

			commandBar3.Visible = false
	end
	if commandBox3.Text == ":errape" and enterPressed then
		game.StarterGui:SetCore("SendNotification", {
			Title = "Warning";
			Text = "Press Q to spam errape";
		})

			plr = game.Players.LocalPlayer
			mouse = plr:GetMouse()
			mouse.KeyDown:connect(function(key)
			
				if key == "q" then

					print(game:GetService("SoundService").RespectFilteringEnabled)

					for _, sound in next, workspace:GetDescendants() do
						if sound:IsA("Sound") then
							sound:Play()
						end
					end
				end
			end)
			
		commandBar3.Visible = false
	end
	if commandBox3.Text == ":chatbypass" and enterPressed then
			loadstring(game:HttpGet("https://the-shed.xyz/roblox/scripts/ChatBypass", true))()

			commandBar3.Visible = false
	end
		if commandBar3.Text == ":chatlogs" and enterPressed then
			-- get frorm infinite yield

			commandBar3.Visible = false
		end
		if commandBox3.Text == ":chathax" and enterPressed then
			loadstring(game:HttpGet('https://raw.githubusercontent.com/ant-7802/--/main/straightmilk.lua'))()

			commandBar3Visible = false
		end
		if commandBox3.Text == ":autogrammar" and enterPressed then
			loadstring(game:HttpGet("https://raw.githubusercontent.com/eosuwu/boblox/main/autogremer.lua"))()
			loadstring(game:HttpGet("https://raw.githubusercontent.com/eosuwu/boblox/main/robloxgrammarly.lua"))()

			commandBar3.Visible = false
		end
end) -- final end
end
coroutine.wrap(PXNFKP_fake_script)()
local function BEBF_fake_script()
	local script = Instance.new('LocalScript', commandBar)

	plr = game.Players.LocalPlayer
	mouse = plr:GetMouse()
	mouse.KeyDown:connect(function(key)
	
		if key == ";" then
			script.Parent.Parent.commandBar.Visible = not script.Parent.Parent.commandBar.Visible
		end
	end)

	commandBox.FocusLost:Connect(function(enterPressed)
	if commandBox.Text == "reset" and enterPressed then
		game.Players.LocalPlayer.Character:BreakJoints()
	end
	if commandBox.Text == "view" and enterPressed then
		local target = ValueBox_2.Text
		game.Workspace.CurrentCamera.CameraSubject = target.Character.Humanoid
	end
	if commandBox.Text == "unview" and enterPressed then
		game.Workspace.CurrentCamera.CameraSubject = game.Players.LocalPlayer.Character.Humanoid
	end
	if commandBox.Text == "kill" and enterPressed then
		game.StarterGui:SetCore("SendNotification", {
			Title = "Warning";
			Text = "Make sure the player is in Value Box";
		})
				local Player = ValueBox_2.Text
				if Player[1] then
					Player = Player[1]
					LocalPlayer = game.Players.LocalPlayer
					
					if LocalPlayer.Character.PrimaryPart ~= nil then
							local Character = LocalPlayer.Character
							local previous = LocalPlayer.Character.PrimaryPart.CFrame
							
							Character.Archivable = true
							local Clone = Character:Clone()
							LocalPlayer.Character = Clone
							wait(0.5)
							LocalPlayer.Character = Character
							wait(0.2)
							
							if LocalPlayer.Character and Player.Character and Player.Character.PrimaryPart ~= nil then
								if LocalPlayer.Character:FindFirstChildOfClass("Humanoid") then
									LocalPlayer.Character:FindFirstChildOfClass("Humanoid"):Destroy()
								end
				
								local Humanoid = Instance.new("Humanoid")
								Humanoid.Parent = LocalPlayer.Character
				
								local Tool = nil
				
								if LocalPlayer.Character:FindFirstChildOfClass("Tool") then
									Tool = LocalPlayer.Character:FindFirstChildOfClass("Tool")
								elseif LocalPlayer.Backpack and LocalPlayer.Backpack:FindFirstChildOfClass("Tool") then
									Tool = LocalPlayer.Backpack:FindFirstChildOfClass("Tool")
								end
								print(Tool)

								if Tool ~= nil then
									Tool.Parent = LocalPlayer.Backpack
									
									Player.Character.HumanoidRootPart.Anchored = true
									
									local Arm = game.Players.LocalPlayer.Character['Right Arm'].CFrame * CFrame.new(0, -1, 0, 1, 0, 0, 0, 0, 1, 0, -1, 0)
									Tool.Grip = Arm:ToObjectSpace(Player.Character.PrimaryPart.CFrame):Inverse()
									
									Tool.Parent = LocalPlayer.Character
									Workspace.CurrentCamera.CameraSubject = Tool.Handle
						
									repeat
										wait()
									until not Tool or Tool and (Tool.Parent == Workspace or Tool.Parent == Player.Character)
									Player.Character.HumanoidRootPart.Anchored = false
									wait(0.1)
									Humanoid.Health = 0
									LocalPlayer.Character = nil
								end
							end
					end
				end
	end
	if commandBox.Text == "fly" and enterPressed then
	local Mouse = lplayer:GetMouse()

	repeat wait() until lplayer and lplayer.Character and lplayer.Character:FindFirstChild('HumanoidRootPart') and lplayer.Character:FindFirstChild('Humanoid')
	repeat wait() until Mouse
 
	local T = lplayer.Character.HumanoidRootPart
	local CONTROL = {F = 0, B = 0, L = 0, R = 0}
	local lCONTROL = {F = 0, B = 0, L = 0, R = 0}
	local SPEED = speedget
 
	local function fly()
		flying = true
		local BG = Instance.new('BodyGyro', T)
		local BV = Instance.new('BodyVelocity', T)
		BG.P = 9e4
		BG.maxTorque = Vector3.new(9e9, 9e9, 9e9)
		BG.cframe = T.CFrame
		BV.velocity = Vector3.new(0, 0.1, 0)
		BV.maxForce = Vector3.new(9e9, 9e9, 9e9)
		spawn(function()
		repeat wait()
		lplayer.Character.Humanoid.PlatformStand = true
		if CONTROL.L + CONTROL.R ~= 0 or CONTROL.F + CONTROL.B ~= 0 then
		SPEED = 50
		elseif not (CONTROL.L + CONTROL.R ~= 0 or CONTROL.F + CONTROL.B ~= 0) and SPEED ~= 0 then
		SPEED = 0
		end
		if (CONTROL.L + CONTROL.R) ~= 0 or (CONTROL.F + CONTROL.B) ~= 0 then
		BV.velocity = ((workspace.CurrentCamera.CoordinateFrame.lookVector * (CONTROL.F + CONTROL.B)) + ((workspace.CurrentCamera.CoordinateFrame * CFrame.new(CONTROL.L + CONTROL.R, (CONTROL.F + CONTROL.B) * 0.2, 0).p) - workspace.CurrentCamera.CoordinateFrame.p)) * SPEED
		lCONTROL = {F = CONTROL.F, B = CONTROL.B, L = CONTROL.L, R = CONTROL.R}
		elseif (CONTROL.L + CONTROL.R) == 0 and (CONTROL.F + CONTROL.B) == 0 and SPEED ~= 0 then
		BV.velocity = ((workspace.CurrentCamera.CoordinateFrame.lookVector * (lCONTROL.F + lCONTROL.B)) + ((workspace.CurrentCamera.CoordinateFrame * CFrame.new(lCONTROL.L + lCONTROL.R, (lCONTROL.F + lCONTROL.B) * 0.2, 0).p) - workspace.CurrentCamera.CoordinateFrame.p)) * SPEED
		else
		BV.velocity = Vector3.new(0, 0.1, 0)
		end
		BG.cframe = workspace.CurrentCamera.CoordinateFrame
				until not flying
				CONTROL = {F = 0, B = 0, L = 0, R = 0}
				lCONTROL = {F = 0, B = 0, L = 0, R = 0}
				SPEED = 0
				BG:destroy()
				BV:destroy()
				lplayer.Character.Humanoid.PlatformStand = false
			end)
		end
	Mouse.KeyDown:connect(function(KEY)
		if KEY:lower() == 'w' then
			CONTROL.F = speedfly
		elseif KEY:lower() == 's' then
			CONTROL.B = -speedfly
		elseif KEY:lower() == 'a' then
			CONTROL.L = -speedfly 
		elseif KEY:lower() == 'd' then 
			CONTROL.R = speedfly
		end
	end)
	Mouse.KeyUp:connect(function(KEY)
		if KEY:lower() == 'w' then
			CONTROL.F = 0
		elseif KEY:lower() == 's' then
			CONTROL.B = 0
		elseif KEY:lower() == 'a' then
			CONTROL.L = 0
		elseif KEY:lower() == 'd' then
			CONTROL.R = 0
		end
	end)
	fly()
	end
	if commandBox.Text == "unfly" and enterPressed then
		flying = false
		lplayer.Character.Humanoid.PlatformStand = false
	end
	if commandBox.Text == "lagswitch" and enterPressed then
		loadstring(game:HttpGet("https://paste.gg/p/anonymous/d3492bd620bd4c46b54680ac80b0fa0d/files/161ddd9c992c4ceba3c298458d45188a/raw", true))()

		game.StarterGui:SetCore("SendNotification", {
			Title = "Lag Switch Enable";
			Text = "Press X to toggle";
		})
	end
	if commandBox.Text == "goto" and enterPressed then
		game.StarterGui:SetCore("SendNotification", {
			Title = "Warning";
			Text = "Make sure the player is in Value Box";
		})
		local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
		local target = ValueBox_2.Text

		pl.CFrame = game.Players[target].Character.HumanoidRootPart.CFrame
	end
	if commandBox.Text == "mousefling" and enterPressed then
	for i,v in next, game:GetService("Players").LocalPlayer.Character:GetDescendants() do
if v:IsA("BasePart") and v.Name ~="HumanoidRootPart" then
game:GetService("RunService").Heartbeat:connect(function()
v.Velocity = Vector3.new(0,-30,0)
wait(0.5)
end)
end
end
 
function rmesh(HatName)
for _,mesh in next, workspace[game.Players.LocalPlayer.Name][HatName]:GetDescendants() do
if mesh:IsA("Mesh") or mesh:IsA("SpecialMesh") then
mesh:Remove()
end
end
end
 
function create(part, parent, position, rotation)
part.AccessoryWeld:Remove()
Instance.new("Attachment",part)
Instance.new("AlignPosition",part)
Instance.new("AlignOrientation",part)
Instance.new("Attachment",parent)
part.AlignPosition.Attachment0 = part.Attachment
part.AlignOrientation.Attachment0 = part.Attachment
part.AlignPosition.Attachment1 = parent.Attachment
part.AlignOrientation.Attachment1 = parent.Attachment
part.Attachment.Position = position
part.Attachment.Orientation = rotation
part.AlignPosition.Responsiveness = 200
part.AlignOrientation.Responsiveness = 200
part.AlignPosition.MaxForce = 9999999
part.AlignPosition.RigidityEnabled = false
part.AlignOrientation.MaxTorque = 9999999
end
 
local LocalPlayer = game.Players.LocalPlayer
 
function eswait(num)
if num == 0 or num == nil then
game:service("RunService").Stepped:wait(0)
else
for i = 0, num do
game:service("RunService").Stepped:wait(0)
end
end
end
 
function makepart(hat,part)
Instance.new('Part',workspace[LocalPlayer.Name])
workspace[LocalPlayer.Name].Part.Name = 'lerp'..hat
workspace[LocalPlayer.Name]['lerp'..hat].CanCollide = false
workspace[LocalPlayer.Name]['lerp'..hat].Size = workspace[LocalPlayer.Name][hat].Handle.Size
workspace[LocalPlayer.Name]['lerp'..hat].Transparency = 1
Instance.new('Weld',workspace[LocalPlayer.Name]['lerp'..hat])
create(workspace[LocalPlayer.Name][hat].Handle,workspace[LocalPlayer.Name]['lerp'..hat],Vector3.new(),Vector3.new())
workspace[LocalPlayer.Name]['lerp'..hat].Weld.Part0 = workspace[LocalPlayer.Name]['lerp'..hat]
workspace[LocalPlayer.Name]['lerp'..hat].Weld.Part1 = workspace[LocalPlayer.Name][part]
workspace[LocalPlayer.Name]['lerp'..hat].Weld.C0 = workspace[LocalPlayer.Name]['lerp'..hat].CFrame:inverse() * workspace[LocalPlayer.Name][part].CFrame * CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),math.rad(0),0)
end
 
local hatsine = 0
 
local hatchange = 1
 
function clerp(hat,ppx,ppy,pppz,rrrx,rrry,rrz,lppx,lppy,lpppz,lrrrx,lrrry,lrrz,speed)
coroutine.wrap(function()
while true do
hatsine = hatsine + speed
workspace[game.Players.LocalPlayer.Name]['lerp'..hat].Weld.C0 = workspace[game.Players.LocalPlayer.Name]['lerp'..hat].Weld.C0:lerp(CFrame.new(ppx + lppx * math.sin(hatsine/11), ppy + lppy * math.sin(hatsine/11), pppz + lpppz * math.sin(hatsine/11)) * CFrame.Angles(math.rad(rrrx + lrrrx * math.sin(hatsine/11)), math.rad(rrry + lrrry * math.sin(hatsine/11)), math.rad(rrz + lrrz * math.sin(hatsine/11))),0.1)
eswait()
end
end)()
end
 
local player = game.Players.LocalPlayer
local character1 = player.Character
local mouse = player:GetMouse()
 
local fakebody = Instance.new("Part", character1)
fakebody.Transparency = 1
fakebody.Anchored = true
fakebody.CanCollide = false
fakebody.Position = character1.Head.Position
fakebody.Name = "FPart"
wait()
_G.ReanimationType = "PDeath" --PDeath, Fling, Simple
_G.Velocity = Vector3.new(36,0,0)
_G.FlingBlock = true
_G.FlingBlockTransparency = 1
_G.HighlightFlingBlock = true
_G.FlingBlockPosition = "FPart"
_G.HighlightFlingBlockColor = Color3.fromRGB(255,0,0)
 
loadstring(game:HttpGet("https://raw.githubusercontent.com/GelatekWasTaken/Reanimation.lua/main/Main/Main.lua"))()
wait(1)
 
mouse.KeyDown:connect(function(key)
    if key == "e" then
    character1.Reanimate.FPart.Position = mouse.Hit.p
    end
end)
 
rmesh('Pink Hair')
rmesh('Kate Hair')
 
makepart('Kate Hair','Right Arm')
clerp('Kate Hair',0,1,0,0,0,0,0,0,0,0,0,0,1)
 
makepart('Pink Hair','Right Arm')
clerp('Pink Hair',0,0.5,-2,-90,0,0,0,0,0,0,0,0,1)
 
local Scale = game.Players.LocalPlayer.Character.Torso.Size.X/2*(game.Players.LocalPlayer.Character.Torso:FindFirstChild("ScaleInserted") ~= nil and game.Players.LocalPlayer.Character.Torso:FindFirstChild("ScaleInserted").Scale.Z or 1)*0.8
local Speed = 20*Scale
local Gravity = 0.1
 
local Player = game.Players.LocalPlayer
local Character = Player.Character.Reanimate
local Humanoid = Character.Humanoid
Humanoid:SetStateEnabled(Enum.HumanoidStateType.Ragdoll,false)
local Torso = Character.HumanoidRootPart
local Mouse = game.Players.LocalPlayer:GetMouse()
local RenderStepped = game:GetService("RunService").RenderStepped
local Camera = Workspace.CurrentCamera
Camera:ClearAllChildren()
local Model = Instance.new("Model",Character)
local IgnoreList = {Character,Workspace.Terrain}
 
local Part0Joint = CFrame.new(Vector3.new(1,0.75,0)*Scale*1.25)
local Part1Joint = CFrame.new(Vector3.new(-0.5,0.75,0)*Scale*1.25)
local RotationOffset = CFrame.Angles(math.rad(90),math.rad(0),0)
local Gangster = false
 
local Part0JointHead = CFrame.new(Vector3.new(0,1,0)*Scale*1.25)
local Part1JointHead = CFrame.new(Vector3.new(0,-0.5,0)*Scale*1.25)
local RotationOffsetHead = CFrame.Angles(0,0,0)
 
local Handle = Instance.new("Part",Model)
Handle.CanCollide = false
Handle.Name = "Handle"
Handle.Position = Vector3.new(0,100,0)
Handle:BreakJoints()
Handle.FormFactor = "Custom"
Handle.Size = Vector3.new(0.2,0.2,0.2)
Handle.TopSurface = "SmoothNoOutlines"
Handle.BottomSurface = "SmoothNoOutlines"
Handle.FrontSurface = "SmoothNoOutlines"
Handle.BackSurface = "SmoothNoOutlines"
Handle.RightSurface = "SmoothNoOutlines"
Handle.LeftSurface = "SmoothNoOutlines"
Handle.BrickColor = BrickColor.new("Black")
local Mesh = Instance.new("BlockMesh",Handle)
Mesh.Scale = Vector3.new(0.25,1,0.4) / 0.2 * Scale
local HandleWeld = Instance.new("Motor6D")
HandleWeld.Part0 = Character["Right Arm"]
HandleWeld.Part1 = Handle
HandleWeld.C0 = CFrame.new(Vector3.new(0,-1,0)*Scale) * CFrame.Angles(math.rad(-105),0,0)
HandleWeld.Parent = Handle
 
local Part = Instance.new("Part",Model)
Part.CanCollide = false
Part.Position = Vector3.new(0,100,0)
Part:BreakJoints()
Part.FormFactor = "Custom"
Part.Size = Vector3.new(0.2,0.2,0.2)
Part.TopSurface = "SmoothNoOutlines"
Part.BottomSurface = "SmoothNoOutlines"
Part.FrontSurface = "SmoothNoOutlines"
Part.BackSurface = "SmoothNoOutlines"
Part.RightSurface = "SmoothNoOutlines"
Part.LeftSurface = "SmoothNoOutlines"
Part.BrickColor = BrickColor.new("Black")
local Mesh = Instance.new("CylinderMesh",Part)
Mesh.Scale = Vector3.new(0.07,0.2,0.07) / 0.2 * Scale
local PartWeld = Instance.new("Motor6D")
PartWeld.Part0 = Handle
PartWeld.Part1 = Part
PartWeld.C0 = CFrame.new(Vector3.new(-0.115,-0.475,-0.190)*Scale) * CFrame.Angles(0,0,0)
PartWeld.Parent = Part
 
local Part = Instance.new("Part",Model)
Part.CanCollide = false
Part.Position = Vector3.new(0,100,0)
Part:BreakJoints()
Part.FormFactor = "Custom"
Part.Size = Vector3.new(0.2,0.2,0.2)
Part.TopSurface = "SmoothNoOutlines"
Part.BottomSurface = "SmoothNoOutlines"
Part.FrontSurface = "SmoothNoOutlines"
Part.BackSurface = "SmoothNoOutlines"
Part.RightSurface = "SmoothNoOutlines"
Part.LeftSurface = "SmoothNoOutlines"
Part.BrickColor = BrickColor.new("Black")
local Mesh = Instance.new("CylinderMesh",Part)
Mesh.Scale = Vector3.new(0.07,0.2,0.07) / 0.2 * Scale
local PartWeld = Instance.new("Motor6D")
PartWeld.Part0 = Handle
PartWeld.Part1 = Part
PartWeld.C0 = CFrame.new(Vector3.new(0.115,-0.475,0.190)*Scale) * CFrame.Angles(0,0,0)
PartWeld.Parent = Part
 
local Part = Instance.new("Part",Model)
Part.CanCollide = false
Part.Position = Vector3.new(0,100,0)
Part:BreakJoints()
Part.FormFactor = "Custom"
Part.Size = Vector3.new(0.2,0.2,0.2)
Part.TopSurface = "SmoothNoOutlines"
Part.BottomSurface = "SmoothNoOutlines"
Part.FrontSurface = "SmoothNoOutlines"
Part.BackSurface = "SmoothNoOutlines"
Part.RightSurface = "SmoothNoOutlines"
Part.LeftSurface = "SmoothNoOutlines"
Part.BrickColor = BrickColor.new("Black")
local Mesh = Instance.new("CylinderMesh",Part)
Mesh.Scale = Vector3.new(0.07,0.2,0.07) / 0.2 * Scale
local PartWeld = Instance.new("Motor6D")
PartWeld.Part0 = Handle
PartWeld.Part1 = Part
PartWeld.C0 = CFrame.new(Vector3.new(-0.115,-0.475,0.190)*Scale) * CFrame.Angles(0,0,0)
PartWeld.Parent = Part
 
local Part = Instance.new("Part",Model)
Part.CanCollide = false
Part.Position = Vector3.new(0,100,0)
Part:BreakJoints()
Part.FormFactor = "Custom"
Part.Size = Vector3.new(0.2,0.2,0.2)
Part.TopSurface = "SmoothNoOutlines"
Part.BottomSurface = "SmoothNoOutlines"
Part.FrontSurface = "SmoothNoOutlines"
Part.BackSurface = "SmoothNoOutlines"
Part.RightSurface = "SmoothNoOutlines"
Part.LeftSurface = "SmoothNoOutlines"
Part.BrickColor = BrickColor.new("Black")
local Mesh = Instance.new("CylinderMesh",Part)
Mesh.Scale = Vector3.new(0.07,0.2,0.07) / 0.2 * Scale
local PartWeld = Instance.new("Motor6D")
PartWeld.Part0 = Handle
PartWeld.Part1 = Part
PartWeld.C0 = CFrame.new(Vector3.new(0.115,-0.475,-0.190)*Scale) * CFrame.Angles(0,0,0)
PartWeld.Parent = Part
 
local Part = Instance.new("Part",Model)
Part.CanCollide = false
Part.Position = Vector3.new(0,100,0)
Part:BreakJoints()
Part.FormFactor = "Custom"
Part.Size = Vector3.new(0.2,0.2,0.2)
Part.TopSurface = "SmoothNoOutlines"
Part.BottomSurface = "SmoothNoOutlines"
Part.FrontSurface = "SmoothNoOutlines"
Part.BackSurface = "SmoothNoOutlines"
Part.RightSurface = "SmoothNoOutlines"
Part.LeftSurface = "SmoothNoOutlines"
Part.BrickColor = BrickColor.new("Black")
local Mesh = Instance.new("BlockMesh",Part)
Mesh.Scale = Vector3.new(0.23,0.2,0.1) / 0.2 * Scale
local PartWeld = Instance.new("Motor6D")
PartWeld.Part0 = Handle
PartWeld.Part1 = Part
PartWeld.C0 = CFrame.new(Vector3.new(0,-0.475,-0.175)*Scale) * CFrame.Angles(0,0,0)
PartWeld.Parent = Part
 
local Part = Instance.new("Part",Model)
Part.CanCollide = false
Part.Position = Vector3.new(0,100,0)
Part:BreakJoints()
Part.FormFactor = "Custom"
Part.Size = Vector3.new(0.2,0.2,0.2)
Part.TopSurface = "SmoothNoOutlines"
Part.BottomSurface = "SmoothNoOutlines"
Part.FrontSurface = "SmoothNoOutlines"
Part.BackSurface = "SmoothNoOutlines"
Part.RightSurface = "SmoothNoOutlines"
Part.LeftSurface = "SmoothNoOutlines"
Part.BrickColor = BrickColor.new("Black")
local Mesh = Instance.new("BlockMesh",Part)
Mesh.Scale = Vector3.new(0.23,0.2,0.1) / 0.2 * Scale
local PartWeld = Instance.new("Motor6D")
PartWeld.Part0 = Handle
PartWeld.Part1 = Part
PartWeld.C0 = CFrame.new(Vector3.new(0,-0.475,0.175)*Scale) * CFrame.Angles(0,0,0)
PartWeld.Parent = Part
 
local Part = Instance.new("Part",Model)
Part.CanCollide = false
Part.Position = Vector3.new(0,100,0)
Part:BreakJoints()
Part.FormFactor = "Custom"
Part.Size = Vector3.new(0.2,0.2,0.2)
Part.TopSurface = "SmoothNoOutlines"
Part.BottomSurface = "SmoothNoOutlines"
Part.FrontSurface = "SmoothNoOutlines"
Part.BackSurface = "SmoothNoOutlines"
Part.RightSurface = "SmoothNoOutlines"
Part.LeftSurface = "SmoothNoOutlines"
Part.BrickColor = BrickColor.new("Black")
local Mesh = Instance.new("BlockMesh",Part)
Mesh.Scale = Vector3.new(0.1,0.2,0.38) / 0.2 * Scale
local PartWeld = Instance.new("Motor6D")
PartWeld.Part0 = Handle
PartWeld.Part1 = Part
PartWeld.C0 = CFrame.new(Vector3.new(-0.1,-0.475,0)*Scale) * CFrame.Angles(0,0,0)
PartWeld.Parent = Part
 
local Part = Instance.new("Part",Model)
Part.CanCollide = false
Part.Position = Vector3.new(0,100,0)
Part:BreakJoints()
Part.FormFactor = "Custom"
Part.Size = Vector3.new(0.2,0.2,0.2)
Part.TopSurface = "SmoothNoOutlines"
Part.BottomSurface = "SmoothNoOutlines"
Part.FrontSurface = "SmoothNoOutlines"
Part.BackSurface = "SmoothNoOutlines"
Part.RightSurface = "SmoothNoOutlines"
Part.LeftSurface = "SmoothNoOutlines"
Part.BrickColor = BrickColor.new("Black")
local Mesh = Instance.new("BlockMesh",Part)
Mesh.Scale = Vector3.new(0.1,0.2,0.38) / 0.2 * Scale
local PartWeld = Instance.new("Motor6D")
PartWeld.Part0 = Handle
PartWeld.Part1 = Part
PartWeld.C0 = CFrame.new(Vector3.new(0.1,-0.475,0)*Scale) * CFrame.Angles(0,0,0)
PartWeld.Parent = Part
 
local Part = Instance.new("Part",Model)
Part.CanCollide = false
Part.Position = Vector3.new(0,100,0)
Part:BreakJoints()
Part.FormFactor = "Custom"
Part.Size = Vector3.new(0.2,0.2,0.2)
Part.TopSurface = "SmoothNoOutlines"
Part.BottomSurface = "SmoothNoOutlines"
Part.FrontSurface = "SmoothNoOutlines"
Part.BackSurface = "SmoothNoOutlines"
Part.RightSurface = "SmoothNoOutlines"
Part.LeftSurface = "SmoothNoOutlines"
Part.BrickColor = BrickColor.new("Black")
local Mesh = Instance.new("BlockMesh",Part)
Mesh.Scale = Vector3.new(0.1,0.3,0.05) / 0.2 * Scale
local PartWeld = Instance.new("Motor6D")
PartWeld.Part0 = Handle
PartWeld.Part1 = Part
PartWeld.C0 = CFrame.Angles(math.rad(15),0,0) * CFrame.new(Vector3.new(0,0.25,-0.75)*Scale) * CFrame.Angles(math.rad(-10),0,0)
PartWeld.Parent = Part
 
local Part = Instance.new("Part",Model)
Part.CanCollide = false
Part.Position = Vector3.new(0,100,0)
Part:BreakJoints()
Part.FormFactor = "Custom"
Part.Size = Vector3.new(0.2,0.2,0.2)
Part.TopSurface = "SmoothNoOutlines"
Part.BottomSurface = "SmoothNoOutlines"
Part.FrontSurface = "SmoothNoOutlines"
Part.BackSurface = "SmoothNoOutlines"
Part.RightSurface = "SmoothNoOutlines"
Part.LeftSurface = "SmoothNoOutlines"
Part.BrickColor = BrickColor.new("Black")
local Mesh = Instance.new("BlockMesh",Part)
Mesh.Scale = Vector3.new(0.1,0.05,0.625) / 0.2 * Scale
local PartWeld = Instance.new("Motor6D")
PartWeld.Part0 = Handle
PartWeld.Part1 = Part
PartWeld.C0 = CFrame.Angles(math.rad(15),0,0) * CFrame.new(Vector3.new(0,0.1,-0.435)*Scale)
PartWeld.Parent = Part
 
for i = 0,80,10 do
local Part = Instance.new("Part",Model)
Part.CanCollide = false
Part.Position = Vector3.new(0,100,0)
Part:BreakJoints()
Part.FormFactor = "Custom"
Part.Size = Vector3.new(0.2,0.2,0.2)
Part.TopSurface = "SmoothNoOutlines"
Part.BottomSurface = "SmoothNoOutlines"
Part.FrontSurface = "SmoothNoOutlines"
Part.BackSurface = "SmoothNoOutlines"
Part.RightSurface = "SmoothNoOutlines"
Part.LeftSurface = "SmoothNoOutlines"
Part.BrickColor = BrickColor.new("Black")
local Mesh = Instance.new("BlockMesh",Part)
Mesh.Scale = Vector3.new(0.25,0.15,0.03555*2) / 0.2 * Scale
local PartWeld = Instance.new("Motor6D")
PartWeld.Part0 = Handle
PartWeld.Part1 = Part
PartWeld.C0 = CFrame.new(Vector3.new(0,0.15,0.315)*Scale) * CFrame.Angles(math.rad(i-65),0,0) * CFrame.new(Vector3.new(0,0.2,0)*Scale)
PartWeld.Parent = Part
end
 
local Barrel = Instance.new("Part",Model)
Barrel.CanCollide = false
Barrel.Position = Vector3.new(0,100,0)
Barrel:BreakJoints()
Barrel.FormFactor = "Custom"
Barrel.Size = Vector3.new(0.2,0.2,0.2)
Barrel.TopSurface = "SmoothNoOutlines"
Barrel.BottomSurface = "SmoothNoOutlines"
Barrel.FrontSurface = "SmoothNoOutlines"
Barrel.BackSurface = "SmoothNoOutlines"
Barrel.RightSurface = "SmoothNoOutlines"
Barrel.LeftSurface = "SmoothNoOutlines"
Barrel.BrickColor = BrickColor.new("Black")
local Mesh = Instance.new("BlockMesh",Barrel)
Mesh.Scale = Vector3.new(0.25,0.2,2) / 0.2 * Scale
local BarrelWeld = Instance.new("Motor6D")
BarrelWeld.Part0 = Handle
BarrelWeld.Part1 = Barrel
BarrelWeld.C0 = CFrame.Angles(math.rad(15),0,0) * CFrame.new(Vector3.new(0,0.5,-0.7)*Scale)
BarrelWeld.Parent = Barrel
 
local Barrel1 = Barrel
 
local Barrel2 = Instance.new("Part",Model)
Barrel2.CanCollide = false
Barrel2.Position = Vector3.new(0,100,0)
Barrel2:BreakJoints()
Barrel2.FormFactor = "Custom"
Barrel2.Size = Vector3.new(0.2,0.2,0.2)
Barrel2.TopSurface = "SmoothNoOutlines"
Barrel2.BottomSurface = "SmoothNoOutlines"
Barrel2.FrontSurface = "SmoothNoOutlines"
Barrel2.BackSurface = "SmoothNoOutlines"
Barrel2.RightSurface = "SmoothNoOutlines"
Barrel2.LeftSurface = "SmoothNoOutlines"
Barrel2.BrickColor = BrickColor.new("Really black")
local Mesh = Instance.new("BlockMesh",Barrel2)
Mesh.Scale = Vector3.new(0.25,0.25,2) / 0.2 * Scale
local Barrel2Weld = Instance.new("Motor6D")
Barrel2Weld.Part0 = Barrel
Barrel2Weld.Part1 = Barrel2
Barrel2Weld.C0 = CFrame.new(Vector3.new(0,0.225,0)*Scale)
Barrel2Weld.Parent = Barrel2
 
local RealBarrel = Instance.new("Part",Model)
RealBarrel.CanCollide = false
RealBarrel.Position = Vector3.new(0,100,0)
RealBarrel:BreakJoints()
RealBarrel.FormFactor = "Custom"
RealBarrel.Size = Vector3.new(0.2,0.2,0.2)
RealBarrel.TopSurface = "SmoothNoOutlines"
RealBarrel.BottomSurface = "SmoothNoOutlines"
RealBarrel.FrontSurface = "SmoothNoOutlines"
RealBarrel.BackSurface = "SmoothNoOutlines"
RealBarrel.RightSurface = "SmoothNoOutlines"
RealBarrel.LeftSurface = "SmoothNoOutlines"
RealBarrel.BrickColor = BrickColor.new("Dark grey metallic")
local Mesh = Instance.new("CylinderMesh",RealBarrel)
Mesh.Scale = Vector3.new(0.2,2,0.2) / 0.2 * Scale
local RealBarrelWeld = Instance.new("Motor6D")
RealBarrelWeld.Part0 = Barrel
RealBarrelWeld.Part1 = RealBarrel
RealBarrelWeld.C0 = CFrame.new(Vector3.new(0,0.1,-0.01)*Scale) * CFrame.Angles(math.rad(-90),0,0)
RealBarrelWeld.Parent = RealBarrel
 
for i = 1,75,15 do
local Part = Instance.new("Part",Model)
Part.CanCollide = false
Part.Position = Vector3.new(0,100,0)
Part:BreakJoints()
Part.FormFactor = "Custom"
Part.Size = Vector3.new(0.2,0.2,0.2)
Part.TopSurface = "SmoothNoOutlines"
Part.BottomSurface = "SmoothNoOutlines"
Part.FrontSurface = "SmoothNoOutlines"
Part.BackSurface = "SmoothNoOutlines"
Part.RightSurface = "SmoothNoOutlines"
Part.LeftSurface = "SmoothNoOutlines"
Part.BrickColor = BrickColor.new("Black")
local Mesh = Instance.new("BlockMesh",Part)
Mesh.Scale = Vector3.new(0.05,0.065,0.05) / 0.2 * Scale
local PartWeld = Instance.new("Motor6D")
PartWeld.Part0 = Handle
PartWeld.Part1 = Part
PartWeld.C0 = CFrame.new(Vector3.new(0,0.525,-0.515)*Scale) * CFrame.Angles(math.rad(i),0,0) * CFrame.new(Vector3.new(0,0,0.2)*Scale)
PartWeld.Parent = Part
end
 
local Part = Instance.new("Part",Model)
Part.CanCollide = false
Part.Position = Vector3.new(0,100,0)
Part:BreakJoints()
Part.FormFactor = "Custom"
Part.Size = Vector3.new(0.2,0.2,0.2)
Part.TopSurface = "SmoothNoOutlines"
Part.BottomSurface = "SmoothNoOutlines"
Part.FrontSurface = "SmoothNoOutlines"
Part.BackSurface = "SmoothNoOutlines"
Part.RightSurface = "SmoothNoOutlines"
Part.LeftSurface = "SmoothNoOutlines"
Part.BrickColor = BrickColor.new("Really black")
local Mesh = Instance.new("BlockMesh",Part)
Mesh.Scale = Vector3.new(0.05,0.11,0.1) / 0.2 * Scale
local PartWeld = Instance.new("Motor6D")
PartWeld.Part0 = Barrel2
PartWeld.Part1 = Part
PartWeld.C0 = CFrame.new(Vector3.new(0.06,0.135,0.925)*Scale)
PartWeld.Parent = Part
 
local Part = Instance.new("Part",Model)
Part.CanCollide = false
Part.Position = Vector3.new(0,100,0)
Part:BreakJoints()
Part.FormFactor = "Custom"
Part.Size = Vector3.new(0.2,0.2,0.2)
Part.TopSurface = "SmoothNoOutlines"
Part.BottomSurface = "SmoothNoOutlines"
Part.FrontSurface = "SmoothNoOutlines"
Part.BackSurface = "SmoothNoOutlines"
Part.RightSurface = "SmoothNoOutlines"
Part.LeftSurface = "SmoothNoOutlines"
Part.BrickColor = BrickColor.new("Really black")
local Mesh = Instance.new("BlockMesh",Part)
Mesh.Scale = Vector3.new(0.05,0.11,0.1) / 0.2 * Scale
local PartWeld = Instance.new("Motor6D")
PartWeld.Part0 = Barrel2
PartWeld.Part1 = Part
PartWeld.C0 = CFrame.new(Vector3.new(-0.06,0.135,0.925)*Scale)
PartWeld.Parent = Part
 
local Part = Instance.new("Part",Model)
Part.CanCollide = false
Part.Position = Vector3.new(0,100,0)
Part:BreakJoints()
Part.FormFactor = "Custom"
Part.Size = Vector3.new(0.2,0.2,0.2)
Part.TopSurface = "SmoothNoOutlines"
Part.BottomSurface = "SmoothNoOutlines"
Part.FrontSurface = "SmoothNoOutlines"
Part.BackSurface = "SmoothNoOutlines"
Part.RightSurface = "SmoothNoOutlines"
Part.LeftSurface = "SmoothNoOutlines"
Part.BrickColor = BrickColor.new("Really black")
local Mesh = Instance.new("BlockMesh",Part)
Mesh.Scale = Vector3.new(0.025,0.1,0.1) / 0.2 * Scale
local PartWeld = Instance.new("Motor6D")
PartWeld.Part0 = Barrel2
PartWeld.Part1 = Part
PartWeld.C0 = CFrame.new(Vector3.new(0,0.135,-0.925)*Scale)
PartWeld.Parent = Part
 
local Part = Instance.new("Part",Model)
Part.CanCollide = false
Part.Position = Vector3.new(0,100,0)
Part:BreakJoints()
Part.FormFactor = "Custom"
Part.Size = Vector3.new(0.2,0.2,0.2)
Part.Transparency = 1
Part.TopSurface = "SmoothNoOutlines"
Part.BottomSurface = "SmoothNoOutlines"
Part.FrontSurface = "SmoothNoOutlines"
Part.BackSurface = "SmoothNoOutlines"
Part.RightSurface = "SmoothNoOutlines"
Part.LeftSurface = "SmoothNoOutlines"
Part.BrickColor = BrickColor.new("Really black")
local Mesh = Instance.new("BlockMesh",Part)
Mesh.Scale = Vector3.new(0.1,0.1,0.1) / 0.2 * Scale
local PartWeld = Instance.new("Motor6D")
PartWeld.Part0 = Barrel
PartWeld.Part1 = Part
PartWeld.C0 = CFrame.new(Vector3.new(0,0,-5)*Scale)
PartWeld.Parent = Part
 
local Light = Instance.new("PointLight",Part)
Light.Color = BrickColor.new("Gold").Color
Light.Enabled = true
Light.Shadows = true
Light.Brightness = 0
Light.Range = 6
 
local Part = Instance.new("Part",Model)
Part.Material = "Neon"
Part.CanCollide = false
Part.Position = Vector3.new(0,100,0)
Part:BreakJoints()
Part.FormFactor = "Custom"
Part.Size = Vector3.new(0.2,0.2,0.2)
Part.TopSurface = "SmoothNoOutlines"
Part.BottomSurface = "SmoothNoOutlines"
Part.FrontSurface = "SmoothNoOutlines"
Part.BackSurface = "SmoothNoOutlines"
Part.RightSurface = "SmoothNoOutlines"
Part.LeftSurface = "SmoothNoOutlines"
Part.BrickColor = BrickColor.new("Bright yellow")
Part.Transparency = 0.25
local RecoilMesh = Instance.new("SpecialMesh",Part)
RecoilMesh.MeshType = "FileMesh"
RecoilMesh.MeshId = "http://www.roblox.com/Asset/?id=1323306"
RecoilMesh.TextureId = "http://www.roblox.com/Asset/?id=98896228"
RecoilMesh.Scale = Vector3.new(0.175,0,0.175) * Scale
local PartWeld = Instance.new("Motor6D")
PartWeld.Part0 = RealBarrel
PartWeld.Part1 = Part
PartWeld.C0 = CFrame.new(Vector3.new(0,0.95,0)*Scale)
PartWeld.Parent = Part
 
function ShootBullet(Target,barrel)
local barrel = barrel or Barrel
local Bullet = Instance.new("Part",Workspace)
Barrel.CanCollide = false
Bullet.FormFactor = "Custom"
Bullet.Size = Vector3.new(0.2,0.2,5)*Scale
Bullet.TopSurface = "Smooth"
Bullet.BottomSurface = "Smooth"
Bullet.Anchored = true
Bullet.CanCollide = false
Bullet.CFrame = CFrame.new((barrel.CFrame*CFrame.new(0,0,-barrel.Size.Z*barrel.Mesh.Scale.Z/2)).p,Target)*CFrame.new(0,0,-Bullet.Size.Z/2)
Bullet.Transparency = 0.1
Bullet.BrickColor = BrickColor.new("Gold")
--[[local Mesh = Instance.new("SpecialMesh",Bullet)
Mesh.MeshType = "FileMesh"
Mesh.Scale = Vector3.new(0.5,0.5,0.2)
Mesh.MeshId = "http://www.roblox.com/asset/?id=2697549"
--Mesh.TextureId = "http://www.roblox.com/asset/?id=2697544"]]
local Mesh = Instance.new("BlockMesh",Bullet)
Mesh.Scale = Vector3.new(0.2,0.2,5)*Scale/Bullet.Size
IgnoreList[#IgnoreList+1] = Bullet
RenderStepped:wait()
for i = Speed,1000,Speed do -- Loop to do the bullet movement and stuff.
local ray,Hit,Pos,SurfaceNormal;
ray = Ray.new(Bullet.Position,((Bullet.CFrame*CFrame.Angles(math.rad(-Gravity),0,0)*CFrame.new(0,0,-Speed)).p-Bullet.Position).unit*Speed)
Hit,Pos,SurfaceNormal = Workspace:FindPartOnRayWithIgnoreList(ray,IgnoreList)
Bullet.CFrame = Bullet.CFrame*CFrame.Angles(math.rad(-Gravity),0,0)*CFrame.new(0,0,-Speed)
if Hit ~= nil then
local Hum = Hit.Parent:FindFirstChild("Humanoid") or Hit.Parent.Parent:FindFirstChild("Humanoid") or (Hit.Parent.Parent.Parent ~= nil and Hit.Parent.Parent.Parent:FindFirstChild("Humanoid"))
if Hum ~= nil then
Hum:TakeDamage((((Gangster and math.random(0,0) or math.random(0,0))*Scale)/100)*Hum.MaxHealth)
end
break
end
RenderStepped:wait()
end
Bullet:Destroy()
end
 
Mouse.Button1Down:connect(function()
if not Down and not DB then
Down = true
while Down do
if Humanoid.Health == 0 then break end
if not DB then
DB = true
local Sound = Instance.new("Sound",Barrel)
Sound.SoundId = "http://www.roblox.com/Asset/?id=165946426" -- 132373574
Sound.Volume = 5*Scale
Sound.Pitch = (math.random(70,110)/100)/((Scale < 0.25 and 0.25) or (Scale > 4 and 4) or Scale)
Sound:Play()
Spawn(function()
ShootBullet(Mouse.Hit.p,Barrel1)
end)
RecoilMesh.VertexColor = Vector3.new(1,math.random(160,245)/255,20/255)
PartWeld.C0 = PartWeld.C0 * CFrame.Angles(0,math.rad(math.random(-40,40)),0)
local Shell = Instance.new("Part",Workspace)
Shell.FormFactor = "Custom"
Shell.BrickColor = BrickColor.new("Bright yellow")
Shell.Size = Vector3.new(0.2,0.5,0.2)*Scale
Shell.CFrame = Barrel.CFrame*CFrame.new(0.5,0.5,0)*CFrame.Angles(math.rad(-90),0,0)
Shell.Velocity = ((Barrel.CFrame*CFrame.new(5,0,math.random(-2,2))).p-Barrel.CFrame.p)*5*Scale
local Mesh = Instance.new("CylinderMesh",Shell)
Mesh.Scale = Vector3.new(0.2,0.5,0.2)*Scale/Shell.Size
Spawn(function()
wait(5)
Shell:Destroy()
end)
for i = 1,20,7.5 do
character1.Reanimate.FPart.Position = mouse.Hit.p
RotationOffset = RotationOffset*CFrame.Angles(math.rad(7.5),0,0)
Part1Joint = Part1Joint*CFrame.new(Vector3.new(0,-0.15,0)*Scale)
Barrel2Weld.C0 = Barrel2Weld.C0*CFrame.new(Vector3.new(0,0,0.15)*Scale)
Light.Brightness = Light.Brightness+38
RecoilMesh.Scale = RecoilMesh.Scale+(Vector3.new(0,0.375,0)*Scale)
RenderStepped:wait()
end
wait(0.02)
for i = 1,20,3.75 do
character1.Reanimate.FPart.Position = mouse.Hit.p
RotationOffset = RotationOffset*CFrame.Angles(math.rad(-3.75),0,0)
Part1Joint = Part1Joint*CFrame.new(Vector3.new(0,0.075,0)*Scale)
Barrel2Weld.C0 = Barrel2Weld.C0*CFrame.new(Vector3.new(0,0,-0.075)*Scale)
Light.Brightness = Light.Brightness-19
RecoilMesh.Scale = RecoilMesh.Scale+(Vector3.new(0,-0.1875,0)*Scale)
RenderStepped:wait()
end
wait(0.02)
DB = false
end
end
end
end)
 
Mouse.Button1Up:connect(function()
Down = false
end)
 
Mouse.KeyDown:connect(function(Key)
if Key:lower() == "g" and not DB then
DB = true
if Gangster == true then
for i = 1,70,5 do
RotationOffset = RotationOffset*CFrame.Angles(0,math.rad(-5),0)
RenderStepped:wait()
end
Gangster = false
else
for i = 1,70,5 do
RotationOffset = RotationOffset*CFrame.Angles(0,math.rad(5),0)
RenderStepped:wait()
end
Gangster = true
end
DB = false
end
end)
 
local Weld = Instance.new("Weld")
Weld.Part0 = Torso
Weld.Part1 = Character["Right Arm"]
Weld.Parent = Torso
 
local Weld2 = Instance.new("Weld")
Weld2.Part0 = Torso
Weld2.Part1 = Character.Head
Weld2.Parent = Torso
 
local RA = Character["Right Arm"]
 
game:GetService("RunService"):BindToRenderStep("Pistol",Enum.RenderPriority.Character.Value,function()
local Point = Torso.CFrame:vectorToObjectSpace(Mouse.Hit.p-Torso.CFrame.p)
if Point.Z > 0 then
if Point.X > 0 then
Torso.CFrame = CFrame.new(Torso.Position,Vector3.new(Mouse.Hit.X,Torso.Position.Y,Mouse.Hit.Z))*CFrame.Angles(0,math.rad(90),0)
elseif Point.X < 0 then
Torso.CFrame = CFrame.new(Torso.Position,Vector3.new(Mouse.Hit.X,Torso.Position.Y,Mouse.Hit.Z))*CFrame.Angles(0,math.rad(-90),0)
end
end
 
local CFr = (Torso.CFrame*Part0Joint):toObjectSpace(CFrame.new((Torso.CFrame*Part0Joint).p,Mouse.Hit.p))--RayEnd))
Weld.C0 = Part0Joint * (CFr-CFr.p) * RotationOffset
Weld.C1 = Part1Joint
Weld.Part0 = Torso
Weld.Part1 = RA
local CFr = (Torso.CFrame*Part0JointHead):toObjectSpace(CFrame.new((Torso.CFrame*Part0JointHead).p,Mouse.Hit.p))--RayEnd))
Weld2.C0 = Part0JointHead * (CFr-CFr.p) * RotationOffsetHead
Weld2.C1 = Part1JointHead
Weld2.Part0 = Torso
Weld2.Part1 = Character.Head
local Last = Scale
Scale = game.Players.LocalPlayer.Character.Torso.Size.X/2*(game.Players.LocalPlayer.Character.Torso:FindFirstChild("ScaleInserted") ~= nil and game.Players.LocalPlayer.Character.Torso:FindFirstChild("ScaleInserted").Scale.Z or 1)*0.8
Speed = 20*Scale
if Scale ~= Last then
Part0Joint = CFrame.new(Vector3.new(1,0.75,0)*Scale*1.25)
Part1Joint = CFrame.new(Vector3.new(-0.5,0.75,0)*Scale*1.25)
Part0JointHead = CFrame.new(Vector3.new(0,1,0)*Scale*1.25)
Part1JointHead = CFrame.new(Vector3.new(0,-0.5,0)*Scale*1.25)
end
end)
	end
	if commandBox.Text == "permadeath" and enterPressed then
		game.StarterGui:SetCore("SendNotification", {
			Title = "Warning";
			Text = "Must be R6";
		})
			loadstring(game:HttpGet("https://raw.githubusercontent.com/GelatekWasTaken/Reanimation.lua/main/Main/Main.lua"))()
	end
	if commandBox.Text == "bighead" and enterPressed then
		game.StarterGui:SetCore("SendNotification", {
			Title = "Warning";
			Text = "Make sure you are wearing the correct avatar and the correct scales";
		})

		loadstring(game:HttpGet("https://raw.githubusercontent.com/sysGhost-aka-BiKode/Scripts2022/main/BigHeadV3_Unpatched", true))()
	end
	if commandBox.Text == "giant" and enterPressed then
		game.StarterGui:SetCore("SendNotification", {
				Title = "Warning";
				Text = "To work you need the highest scales";
			})


			local LocalPlayer = game:GetService("Players").LocalPlayer
			local Character = LocalPlayer.Character
			local Humanoid = Character:FindFirstChildOfClass("Humanoid")

			function rm()
				for i,v in pairs(Character:GetDescendants()) do
					if v:IsA("BasePart") then
						if v.Name == "Handle" or v.Name == "Head" then
							if Character.Head:FindFirstChild("OriginalSize") then
								Character.Head.OriginalSize:Destroy()
							end
						else
							for i,cav in pairs(v:GetDescendants()) do
								if cav:IsA("Attachment") then
									if cav:FindFirstChild("OriginalPosition") then
										cav.OriginalPosition:Destroy()  
									end
								end
							end
							v:FindFirstChild("OriginalSize"):Destroy()
							if v:FindFirstChild("AvatarPartScaleType") then
								v:FindFirstChild("AvatarPartScaleType"):Destroy()
							end
						end
					end
				end
			end

			rm()
			wait(0.5)
			Humanoid:FindFirstChild("BodyProportionScale"):Destroy()
			wait(1)

			rm()
			wait(0.5)
			Humanoid:FindFirstChild("BodyHeightScale"):Destroy()
			wait(1)

			rm()
			wait(0.5)
			Humanoid:FindFirstChild("BodyWidthScale"):Destroy()
			wait(1)

			rm()
			wait(0.5)
			Humanoid:FindFirstChild("BodyDepthScale"):Destroy()
			wait(1)

			rm()
			wait(0.5)
			Humanoid:FindFirstChild("HeadScale"):Destroy()
			wait(1)
	end
	if commandBox.Text == "small" and enterPressed then
		game.StarterGui:SetCore("SendNotification", {
				Title = "Warning";
				Text = "To work you need the smalest scales";
			})
			
			local LocalPlayer = game:GetService("Players").LocalPlayer
			local Character = LocalPlayer.Character
			local Humanoid = Character:FindFirstChildOfClass("Humanoid")

			local function rm()
				for i,v in pairs(Character:GetDescendants()) do
					if v:IsA("BasePart") then
						if v.Name ~= "Head" then
							for i,cav in pairs(v:GetDescendants()) do
								if cav:IsA("Attachment") then
									if cav:FindFirstChild("OriginalPosition") then
										cav.OriginalPosition:Destroy()
									end
								end
							end
							v:FindFirstChild("OriginalSize"):Destroy()
							if v:FindFirstChild("AvatarPartScaleType") then
								v:FindFirstChild("AvatarPartScaleType"):Destroy()
							end
						end
					end
				end
			end

			rm()
			wait(0.5)
			Humanoid:FindFirstChild("BodyTypeScale"):Destroy()
			wait(1)

			rm()
			wait(0.5)
			Humanoid:FindFirstChild("BodyWidthScale"):Destroy()
			wait(1)

			rm()
			wait(0.5)
			Humanoid:FindFirstChild("BodyDepthScale"):Destroy()
			wait(1)

			rm()
			wait(0.5)
			Humanoid:FindFirstChild("HeadScale"):Destroy()
			wait(1)
	end
	if commandBox.Text == "errape" and enterPressed then
		game.StarterGui:SetCore("SendNotification", {
			Title = "Warning";
			Text = "Press Q to spam errape";
		})

			plr = game.Players.LocalPlayer
			mouse = plr:GetMouse()
			mouse.KeyDown:connect(function(key)
			
				if key == "q" then

					print(game:GetService("SoundService").RespectFilteringEnabled)

					for _, sound in next, workspace:GetDescendants() do
						if sound:IsA("Sound") then
							sound:Play()
						end
					end
				end
			end)
	end
	if commandBox.Text == "chatbypass" and enterPressed then
			loadstring(game:HttpGet("https://the-shed.xyz/roblox/scripts/ChatBypass", true))()
	end
		if commandBar.Text == "chatlogs" and enterPressed then
			-- get frorm infinite yield
		end
		if commandBox.Text == "chathax" and enterPressed then
			loadstring(game:HttpGet('https://raw.githubusercontent.com/ant-7802/--/main/straightmilk.lua'))()
		end
		if commandBox.Text == "autogrammar" and enterPressed then
			loadstring(game:HttpGet("https://raw.githubusercontent.com/eosuwu/boblox/main/autogremer.lua"))()
			loadstring(game:HttpGet("https://raw.githubusercontent.com/eosuwu/boblox/main/robloxgrammarly.lua"))()
		end
end) -- final end
end
coroutine.wrap(BEBF_fake_script)()


game.StarterGui:SetCore("SendNotification", {
	Title = "Prefix is ':'";
	Text = "Type :cmds or :help to see a command list";
})

print("finish cmds gui XD")
print("stoped at autogrammar")
print("kill need to be fixed")
print("vanish need to be fixed")
print("stole chatlogs :sunglasses:")

lplayer = game:GetService("Players").LocalPlayer
 
lplayer.CharacterAdded:Connect(function(character)
	spin = false
	flying = false
	staring = false
	banpl = false
end)

flying = false
speedfly = 1


local prefix = ":"
local LPlayer = game.Players.LocalPlayer
LPlayer.Chatted:Connect(function(msg)
	msg = msg:lower()
	if string.sub(msg,1,3) == "/e " then
		msg = string.sub(msg,4)
	end
	if string.sub(msg,1,1) == prefix then
		local cmd
		local space = string.find(msg," ")
		if space then
			cmd = string.sub(msg,2,space-1)
		else
			cmd = string.sub(msg,2)
		end

		if cmd == "print" then
			local var = string.sub(msg,space+1)
			print(var)
		end
		if cmd == "reset" then
			game.Players.LocalPlayer.Character:BreakJoints()
		end
		if cmd == "view" then
			local var = string.sub(msg,space+1)
			local target = GetPlayer(var)
			game.Workspace.CurrentCamera.CameraSubject = target.Character.Humanoid
		end
		if cmd == "unview" then
			game.Workspace.CurrentCamera.CameraSubject = game.Players.LocalPlayer.Character.Humanoid
		end
		if cmd == "kill" then
		game.StarterGui:SetCore("SendNotification", {
			Title = "Warning";
			Text = "Make sure the player is in Value Box";
		})
				local Player = ValueBox_2.Text
				if Player[1] then
					Player = Player[1]
					LocalPlayer = game.Players.LocalPlayer
					
					if LocalPlayer.Character.PrimaryPart ~= nil then
							local Character = LocalPlayer.Character
							local previous = LocalPlayer.Character.PrimaryPart.CFrame
							
							Character.Archivable = true
							local Clone = Character:Clone()
							LocalPlayer.Character = Clone
							wait(0.5)
							LocalPlayer.Character = Character
							wait(0.2)
							
							if LocalPlayer.Character and Player.Character and Player.Character.PrimaryPart ~= nil then
								if LocalPlayer.Character:FindFirstChildOfClass("Humanoid") then
									LocalPlayer.Character:FindFirstChildOfClass("Humanoid"):Destroy()
								end
				
								local Humanoid = Instance.new("Humanoid")
								Humanoid.Parent = LocalPlayer.Character
				
								local Tool = nil
				
								if LocalPlayer.Character:FindFirstChildOfClass("Tool") then
									Tool = LocalPlayer.Character:FindFirstChildOfClass("Tool")
								elseif LocalPlayer.Backpack and LocalPlayer.Backpack:FindFirstChildOfClass("Tool") then
									Tool = LocalPlayer.Backpack:FindFirstChildOfClass("Tool")
								end
								print(Tool)

								if Tool ~= nil then
									Tool.Parent = LocalPlayer.Backpack
									
									Player.Character.HumanoidRootPart.Anchored = true
									
									local Arm = game.Players.LocalPlayer.Character['Right Arm'].CFrame * CFrame.new(0, -1, 0, 1, 0, 0, 0, 0, 1, 0, -1, 0)
									Tool.Grip = Arm:ToObjectSpace(Player.Character.PrimaryPart.CFrame):Inverse()
									
									Tool.Parent = LocalPlayer.Character
									Workspace.CurrentCamera.CameraSubject = Tool.Handle
						
									repeat
										wait()
									until not Tool or Tool and (Tool.Parent == Workspace or Tool.Parent == Player.Character)
									Player.Character.HumanoidRootPart.Anchored = false
									wait(0.1)
									Humanoid.Health = 0
									LocalPlayer.Character = nil
								end
							end
					end
				end
		end
		if cmd == "fly" then
	local Mouse = lplayer:GetMouse()

	repeat wait() until lplayer and lplayer.Character and lplayer.Character:FindFirstChild('HumanoidRootPart') and lplayer.Character:FindFirstChild('Humanoid')
	repeat wait() until Mouse
 
	local T = lplayer.Character.HumanoidRootPart
	local CONTROL = {F = 0, B = 0, L = 0, R = 0}
	local lCONTROL = {F = 0, B = 0, L = 0, R = 0}
	local SPEED = speedget
 
	local function fly()
		flying = true
		local BG = Instance.new('BodyGyro', T)
		local BV = Instance.new('BodyVelocity', T)
		BG.P = 9e4
		BG.maxTorque = Vector3.new(9e9, 9e9, 9e9)
		BG.cframe = T.CFrame
		BV.velocity = Vector3.new(0, 0.1, 0)
		BV.maxForce = Vector3.new(9e9, 9e9, 9e9)
		spawn(function()
		repeat wait()
		lplayer.Character.Humanoid.PlatformStand = true
		if CONTROL.L + CONTROL.R ~= 0 or CONTROL.F + CONTROL.B ~= 0 then
		SPEED = 50
		elseif not (CONTROL.L + CONTROL.R ~= 0 or CONTROL.F + CONTROL.B ~= 0) and SPEED ~= 0 then
		SPEED = 0
		end
		if (CONTROL.L + CONTROL.R) ~= 0 or (CONTROL.F + CONTROL.B) ~= 0 then
		BV.velocity = ((workspace.CurrentCamera.CoordinateFrame.lookVector * (CONTROL.F + CONTROL.B)) + ((workspace.CurrentCamera.CoordinateFrame * CFrame.new(CONTROL.L + CONTROL.R, (CONTROL.F + CONTROL.B) * 0.2, 0).p) - workspace.CurrentCamera.CoordinateFrame.p)) * SPEED
		lCONTROL = {F = CONTROL.F, B = CONTROL.B, L = CONTROL.L, R = CONTROL.R}
		elseif (CONTROL.L + CONTROL.R) == 0 and (CONTROL.F + CONTROL.B) == 0 and SPEED ~= 0 then
		BV.velocity = ((workspace.CurrentCamera.CoordinateFrame.lookVector * (lCONTROL.F + lCONTROL.B)) + ((workspace.CurrentCamera.CoordinateFrame * CFrame.new(lCONTROL.L + lCONTROL.R, (lCONTROL.F + lCONTROL.B) * 0.2, 0).p) - workspace.CurrentCamera.CoordinateFrame.p)) * SPEED
		else
		BV.velocity = Vector3.new(0, 0.1, 0)
		end
		BG.cframe = workspace.CurrentCamera.CoordinateFrame
				until not flying
				CONTROL = {F = 0, B = 0, L = 0, R = 0}
				lCONTROL = {F = 0, B = 0, L = 0, R = 0}
				SPEED = 0
				BG:destroy()
				BV:destroy()
				lplayer.Character.Humanoid.PlatformStand = false
			end)
		end
	Mouse.KeyDown:connect(function(KEY)
		if KEY:lower() == 'w' then
			CONTROL.F = speedfly
		elseif KEY:lower() == 's' then
			CONTROL.B = -speedfly
		elseif KEY:lower() == 'a' then
			CONTROL.L = -speedfly 
		elseif KEY:lower() == 'd' then 
			CONTROL.R = speedfly
		end
	end)
	Mouse.KeyUp:connect(function(KEY)
		if KEY:lower() == 'w' then
			CONTROL.F = 0
		elseif KEY:lower() == 's' then
			CONTROL.B = 0
		elseif KEY:lower() == 'a' then
			CONTROL.L = 0
		elseif KEY:lower() == 'd' then
			CONTROL.R = 0
		end
	end)
	fly()
		end
		if cmd == "unfly" then
			flying = false
			lplayer.Character.Humanoid.PlatformStand = false
		end
		if cmd == "lagswitch" then
			loadstring(game:HttpGet("https://paste.gg/p/anonymous/d3492bd620bd4c46b54680ac80b0fa0d/files/161ddd9c992c4ceba3c298458d45188a/raw", true))()

			game.StarterGui:SetCore("SendNotification", {
				Title = "Lag Switch Enable";
				Text = "Press X to toggle";
			})
		end
		if cmd == "goto" then
			game.StarterGui:SetCore("SendNotification", {
				Title = "Warning";
				Text = "Make sure the player is in Value Box";
			})
			local pl = game.Players.LocalPlayer.Character.HumanoidRootPart
			local target = ValueBox_2.Text

			pl.CFrame = game.Players[target].Character.HumanoidRootPart.CFrame
		end
		if cmd == "mousefling" then 
			for i,v in next, game:GetService("Players").LocalPlayer.Character:GetDescendants() do
				if v:IsA("BasePart") and v.Name ~="HumanoidRootPart" then
					game:GetService("RunService").Heartbeat:connect(function()
						v.Velocity = Vector3.new(0,-30,0)
						wait(0.5)
					end)
				end
			end

			function rmesh(HatName)
				for _,mesh in next, workspace[game.Players.LocalPlayer.Name][HatName]:GetDescendants() do
					if mesh:IsA("Mesh") or mesh:IsA("SpecialMesh") then
						mesh:Remove()
					end
				end
			end

			function create(part, parent, position, rotation)
				part.AccessoryWeld:Remove()
				Instance.new("Attachment",part)
				Instance.new("AlignPosition",part)
				Instance.new("AlignOrientation",part)
				Instance.new("Attachment",parent)
				part.AlignPosition.Attachment0 = part.Attachment
				part.AlignOrientation.Attachment0 = part.Attachment
				part.AlignPosition.Attachment1 = parent.Attachment
				part.AlignOrientation.Attachment1 = parent.Attachment
				part.Attachment.Position = position
				part.Attachment.Orientation = rotation
				part.AlignPosition.Responsiveness = 200
				part.AlignOrientation.Responsiveness = 200
				part.AlignPosition.MaxForce = 9999999
				part.AlignPosition.RigidityEnabled = false
				part.AlignOrientation.MaxTorque = 9999999
			end

			local LocalPlayer = game.Players.LocalPlayer

			function eswait(num)
				if num == 0 or num == nil then
					game:service("RunService").Stepped:wait(0)
				else
					for i = 0, num do
						game:service("RunService").Stepped:wait(0)
					end
				end
			end

			function makepart(hat,part)
				Instance.new('Part',workspace[LocalPlayer.Name])
				workspace[LocalPlayer.Name].Part.Name = 'lerp'..hat
				workspace[LocalPlayer.Name]['lerp'..hat].CanCollide = false
				workspace[LocalPlayer.Name]['lerp'..hat].Size = workspace[LocalPlayer.Name][hat].Handle.Size
				workspace[LocalPlayer.Name]['lerp'..hat].Transparency = 1
				Instance.new('Weld',workspace[LocalPlayer.Name]['lerp'..hat])
				create(workspace[LocalPlayer.Name][hat].Handle,workspace[LocalPlayer.Name]['lerp'..hat],Vector3.new(),Vector3.new())
				workspace[LocalPlayer.Name]['lerp'..hat].Weld.Part0 = workspace[LocalPlayer.Name]['lerp'..hat]
				workspace[LocalPlayer.Name]['lerp'..hat].Weld.Part1 = workspace[LocalPlayer.Name][part]
				workspace[LocalPlayer.Name]['lerp'..hat].Weld.C0 = workspace[LocalPlayer.Name]['lerp'..hat].CFrame:inverse() * workspace[LocalPlayer.Name][part].CFrame * CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),math.rad(0),0)
			end

			local hatsine = 0

			local hatchange = 1

			function clerp(hat,ppx,ppy,pppz,rrrx,rrry,rrz,lppx,lppy,lpppz,lrrrx,lrrry,lrrz,speed)
				coroutine.wrap(function()
					while true do
						hatsine = hatsine + speed
						workspace[game.Players.LocalPlayer.Name]['lerp'..hat].Weld.C0 = workspace[game.Players.LocalPlayer.Name]['lerp'..hat].Weld.C0:lerp(CFrame.new(ppx + lppx * math.sin(hatsine/11), ppy + lppy * math.sin(hatsine/11), pppz + lpppz * math.sin(hatsine/11)) * CFrame.Angles(math.rad(rrrx + lrrrx * math.sin(hatsine/11)), math.rad(rrry + lrrry * math.sin(hatsine/11)), math.rad(rrz + lrrz * math.sin(hatsine/11))),0.1)
						eswait()
					end
				end)()
			end

			local player = game.Players.LocalPlayer
			local character1 = player.Character
			local mouse = player:GetMouse()

			local fakebody = Instance.new("Part", character1)
			fakebody.Transparency = 1
			fakebody.Anchored = true
			fakebody.CanCollide = false
			fakebody.Position = character1.Head.Position
			fakebody.Name = "FPart"
			wait()
			_G.ReanimationType = "PDeath" --PDeath, Fling, Simple
			_G.Velocity = Vector3.new(36,0,0)
			_G.FlingBlock = true
			_G.FlingBlockTransparency = 1
			_G.HighlightFlingBlock = true
			_G.FlingBlockPosition = "FPart"
			_G.HighlightFlingBlockColor = Color3.fromRGB(255,0,0)

			loadstring(game:HttpGet("https://raw.githubusercontent.com/GelatekWasTaken/Reanimation.lua/main/Main/Main.lua"))()
			wait(1)

			mouse.KeyDown:connect(function(key)
				if key == "e" then
					character1.Reanimate.FPart.Position = mouse.Hit.p
				end
			end)

			rmesh('Pink Hair')
			rmesh('Kate Hair')

			makepart('Kate Hair','Right Arm')
			clerp('Kate Hair',0,1,0,0,0,0,0,0,0,0,0,0,1)

			makepart('Pink Hair','Right Arm')
			clerp('Pink Hair',0,0.5,-2,-90,0,0,0,0,0,0,0,0,1)

			local Scale = game.Players.LocalPlayer.Character.Torso.Size.X/2*(game.Players.LocalPlayer.Character.Torso:FindFirstChild("ScaleInserted") ~= nil and game.Players.LocalPlayer.Character.Torso:FindFirstChild("ScaleInserted").Scale.Z or 1)*0.8
			local Speed = 20*Scale
			local Gravity = 0.1

			local Player = game.Players.LocalPlayer
			local Character = Player.Character.Reanimate
			local Humanoid = Character.Humanoid
			Humanoid:SetStateEnabled(Enum.HumanoidStateType.Ragdoll,false)
			local Torso = Character.HumanoidRootPart
			local Mouse = game.Players.LocalPlayer:GetMouse()
			local RenderStepped = game:GetService("RunService").RenderStepped
			local Camera = Workspace.CurrentCamera
			Camera:ClearAllChildren()
			local Model = Instance.new("Model",Character)
			local IgnoreList = {Character,Workspace.Terrain}

			local Part0Joint = CFrame.new(Vector3.new(1,0.75,0)*Scale*1.25)
			local Part1Joint = CFrame.new(Vector3.new(-0.5,0.75,0)*Scale*1.25)
			local RotationOffset = CFrame.Angles(math.rad(90),math.rad(0),0)
			local Gangster = false

			local Part0JointHead = CFrame.new(Vector3.new(0,1,0)*Scale*1.25)
			local Part1JointHead = CFrame.new(Vector3.new(0,-0.5,0)*Scale*1.25)
			local RotationOffsetHead = CFrame.Angles(0,0,0)

			local Handle = Instance.new("Part",Model)
			Handle.CanCollide = false
			Handle.Name = "Handle"
			Handle.Position = Vector3.new(0,100,0)
			Handle:BreakJoints()
			Handle.FormFactor = "Custom"
			Handle.Size = Vector3.new(0.2,0.2,0.2)
			Handle.TopSurface = "SmoothNoOutlines"
			Handle.BottomSurface = "SmoothNoOutlines"
			Handle.FrontSurface = "SmoothNoOutlines"
			Handle.BackSurface = "SmoothNoOutlines"
			Handle.RightSurface = "SmoothNoOutlines"
			Handle.LeftSurface = "SmoothNoOutlines"
			Handle.BrickColor = BrickColor.new("Black")
			local Mesh = Instance.new("BlockMesh",Handle)
			Mesh.Scale = Vector3.new(0.25,1,0.4) / 0.2 * Scale
			local HandleWeld = Instance.new("Motor6D")
			HandleWeld.Part0 = Character["Right Arm"]
			HandleWeld.Part1 = Handle
			HandleWeld.C0 = CFrame.new(Vector3.new(0,-1,0)*Scale) * CFrame.Angles(math.rad(-105),0,0)
			HandleWeld.Parent = Handle

			local Part = Instance.new("Part",Model)
			Part.CanCollide = false
			Part.Position = Vector3.new(0,100,0)
			Part:BreakJoints()
			Part.FormFactor = "Custom"
			Part.Size = Vector3.new(0.2,0.2,0.2)
			Part.TopSurface = "SmoothNoOutlines"
			Part.BottomSurface = "SmoothNoOutlines"
			Part.FrontSurface = "SmoothNoOutlines"
			Part.BackSurface = "SmoothNoOutlines"
			Part.RightSurface = "SmoothNoOutlines"
			Part.LeftSurface = "SmoothNoOutlines"
			Part.BrickColor = BrickColor.new("Black")
			local Mesh = Instance.new("CylinderMesh",Part)
			Mesh.Scale = Vector3.new(0.07,0.2,0.07) / 0.2 * Scale
			local PartWeld = Instance.new("Motor6D")
			PartWeld.Part0 = Handle
			PartWeld.Part1 = Part
			PartWeld.C0 = CFrame.new(Vector3.new(-0.115,-0.475,-0.190)*Scale) * CFrame.Angles(0,0,0)
			PartWeld.Parent = Part

			local Part = Instance.new("Part",Model)
			Part.CanCollide = false
			Part.Position = Vector3.new(0,100,0)
			Part:BreakJoints()
			Part.FormFactor = "Custom"
			Part.Size = Vector3.new(0.2,0.2,0.2)
			Part.TopSurface = "SmoothNoOutlines"
			Part.BottomSurface = "SmoothNoOutlines"
			Part.FrontSurface = "SmoothNoOutlines"
			Part.BackSurface = "SmoothNoOutlines"
			Part.RightSurface = "SmoothNoOutlines"
			Part.LeftSurface = "SmoothNoOutlines"
			Part.BrickColor = BrickColor.new("Black")
			local Mesh = Instance.new("CylinderMesh",Part)
			Mesh.Scale = Vector3.new(0.07,0.2,0.07) / 0.2 * Scale
			local PartWeld = Instance.new("Motor6D")
			PartWeld.Part0 = Handle
			PartWeld.Part1 = Part
			PartWeld.C0 = CFrame.new(Vector3.new(0.115,-0.475,0.190)*Scale) * CFrame.Angles(0,0,0)
			PartWeld.Parent = Part

			local Part = Instance.new("Part",Model)
			Part.CanCollide = false
			Part.Position = Vector3.new(0,100,0)
			Part:BreakJoints()
			Part.FormFactor = "Custom"
			Part.Size = Vector3.new(0.2,0.2,0.2)
			Part.TopSurface = "SmoothNoOutlines"
			Part.BottomSurface = "SmoothNoOutlines"
			Part.FrontSurface = "SmoothNoOutlines"
			Part.BackSurface = "SmoothNoOutlines"
			Part.RightSurface = "SmoothNoOutlines"
			Part.LeftSurface = "SmoothNoOutlines"
			Part.BrickColor = BrickColor.new("Black")
			local Mesh = Instance.new("CylinderMesh",Part)
			Mesh.Scale = Vector3.new(0.07,0.2,0.07) / 0.2 * Scale
			local PartWeld = Instance.new("Motor6D")
			PartWeld.Part0 = Handle
			PartWeld.Part1 = Part
			PartWeld.C0 = CFrame.new(Vector3.new(-0.115,-0.475,0.190)*Scale) * CFrame.Angles(0,0,0)
			PartWeld.Parent = Part

			local Part = Instance.new("Part",Model)
			Part.CanCollide = false
			Part.Position = Vector3.new(0,100,0)
			Part:BreakJoints()
			Part.FormFactor = "Custom"
			Part.Size = Vector3.new(0.2,0.2,0.2)
			Part.TopSurface = "SmoothNoOutlines"
			Part.BottomSurface = "SmoothNoOutlines"
			Part.FrontSurface = "SmoothNoOutlines"
			Part.BackSurface = "SmoothNoOutlines"
			Part.RightSurface = "SmoothNoOutlines"
			Part.LeftSurface = "SmoothNoOutlines"
			Part.BrickColor = BrickColor.new("Black")
			local Mesh = Instance.new("CylinderMesh",Part)
			Mesh.Scale = Vector3.new(0.07,0.2,0.07) / 0.2 * Scale
			local PartWeld = Instance.new("Motor6D")
			PartWeld.Part0 = Handle
			PartWeld.Part1 = Part
			PartWeld.C0 = CFrame.new(Vector3.new(0.115,-0.475,-0.190)*Scale) * CFrame.Angles(0,0,0)
			PartWeld.Parent = Part

			local Part = Instance.new("Part",Model)
			Part.CanCollide = false
			Part.Position = Vector3.new(0,100,0)
			Part:BreakJoints()
			Part.FormFactor = "Custom"
			Part.Size = Vector3.new(0.2,0.2,0.2)
			Part.TopSurface = "SmoothNoOutlines"
			Part.BottomSurface = "SmoothNoOutlines"
			Part.FrontSurface = "SmoothNoOutlines"
			Part.BackSurface = "SmoothNoOutlines"
			Part.RightSurface = "SmoothNoOutlines"
			Part.LeftSurface = "SmoothNoOutlines"
			Part.BrickColor = BrickColor.new("Black")
			local Mesh = Instance.new("BlockMesh",Part)
			Mesh.Scale = Vector3.new(0.23,0.2,0.1) / 0.2 * Scale
			local PartWeld = Instance.new("Motor6D")
			PartWeld.Part0 = Handle
			PartWeld.Part1 = Part
			PartWeld.C0 = CFrame.new(Vector3.new(0,-0.475,-0.175)*Scale) * CFrame.Angles(0,0,0)
			PartWeld.Parent = Part

			local Part = Instance.new("Part",Model)
			Part.CanCollide = false
			Part.Position = Vector3.new(0,100,0)
			Part:BreakJoints()
			Part.FormFactor = "Custom"
			Part.Size = Vector3.new(0.2,0.2,0.2)
			Part.TopSurface = "SmoothNoOutlines"
			Part.BottomSurface = "SmoothNoOutlines"
			Part.FrontSurface = "SmoothNoOutlines"
			Part.BackSurface = "SmoothNoOutlines"
			Part.RightSurface = "SmoothNoOutlines"
			Part.LeftSurface = "SmoothNoOutlines"
			Part.BrickColor = BrickColor.new("Black")
			local Mesh = Instance.new("BlockMesh",Part)
			Mesh.Scale = Vector3.new(0.23,0.2,0.1) / 0.2 * Scale
			local PartWeld = Instance.new("Motor6D")
			PartWeld.Part0 = Handle
			PartWeld.Part1 = Part
			PartWeld.C0 = CFrame.new(Vector3.new(0,-0.475,0.175)*Scale) * CFrame.Angles(0,0,0)
			PartWeld.Parent = Part

			local Part = Instance.new("Part",Model)
			Part.CanCollide = false
			Part.Position = Vector3.new(0,100,0)
			Part:BreakJoints()
			Part.FormFactor = "Custom"
			Part.Size = Vector3.new(0.2,0.2,0.2)
			Part.TopSurface = "SmoothNoOutlines"
			Part.BottomSurface = "SmoothNoOutlines"
			Part.FrontSurface = "SmoothNoOutlines"
			Part.BackSurface = "SmoothNoOutlines"
			Part.RightSurface = "SmoothNoOutlines"
			Part.LeftSurface = "SmoothNoOutlines"
			Part.BrickColor = BrickColor.new("Black")
			local Mesh = Instance.new("BlockMesh",Part)
			Mesh.Scale = Vector3.new(0.1,0.2,0.38) / 0.2 * Scale
			local PartWeld = Instance.new("Motor6D")
			PartWeld.Part0 = Handle
			PartWeld.Part1 = Part
			PartWeld.C0 = CFrame.new(Vector3.new(-0.1,-0.475,0)*Scale) * CFrame.Angles(0,0,0)
			PartWeld.Parent = Part

			local Part = Instance.new("Part",Model)
			Part.CanCollide = false
			Part.Position = Vector3.new(0,100,0)
			Part:BreakJoints()
			Part.FormFactor = "Custom"
			Part.Size = Vector3.new(0.2,0.2,0.2)
			Part.TopSurface = "SmoothNoOutlines"
			Part.BottomSurface = "SmoothNoOutlines"
			Part.FrontSurface = "SmoothNoOutlines"
			Part.BackSurface = "SmoothNoOutlines"
			Part.RightSurface = "SmoothNoOutlines"
			Part.LeftSurface = "SmoothNoOutlines"
			Part.BrickColor = BrickColor.new("Black")
			local Mesh = Instance.new("BlockMesh",Part)
			Mesh.Scale = Vector3.new(0.1,0.2,0.38) / 0.2 * Scale
			local PartWeld = Instance.new("Motor6D")
			PartWeld.Part0 = Handle
			PartWeld.Part1 = Part
			PartWeld.C0 = CFrame.new(Vector3.new(0.1,-0.475,0)*Scale) * CFrame.Angles(0,0,0)
			PartWeld.Parent = Part

			local Part = Instance.new("Part",Model)
			Part.CanCollide = false
			Part.Position = Vector3.new(0,100,0)
			Part:BreakJoints()
			Part.FormFactor = "Custom"
			Part.Size = Vector3.new(0.2,0.2,0.2)
			Part.TopSurface = "SmoothNoOutlines"
			Part.BottomSurface = "SmoothNoOutlines"
			Part.FrontSurface = "SmoothNoOutlines"
			Part.BackSurface = "SmoothNoOutlines"
			Part.RightSurface = "SmoothNoOutlines"
			Part.LeftSurface = "SmoothNoOutlines"
			Part.BrickColor = BrickColor.new("Black")
			local Mesh = Instance.new("BlockMesh",Part)
			Mesh.Scale = Vector3.new(0.1,0.3,0.05) / 0.2 * Scale
			local PartWeld = Instance.new("Motor6D")
			PartWeld.Part0 = Handle
			PartWeld.Part1 = Part
			PartWeld.C0 = CFrame.Angles(math.rad(15),0,0) * CFrame.new(Vector3.new(0,0.25,-0.75)*Scale) * CFrame.Angles(math.rad(-10),0,0)
			PartWeld.Parent = Part

			local Part = Instance.new("Part",Model)
			Part.CanCollide = false
			Part.Position = Vector3.new(0,100,0)
			Part:BreakJoints()
			Part.FormFactor = "Custom"
			Part.Size = Vector3.new(0.2,0.2,0.2)
			Part.TopSurface = "SmoothNoOutlines"
			Part.BottomSurface = "SmoothNoOutlines"
			Part.FrontSurface = "SmoothNoOutlines"
			Part.BackSurface = "SmoothNoOutlines"
			Part.RightSurface = "SmoothNoOutlines"
			Part.LeftSurface = "SmoothNoOutlines"
			Part.BrickColor = BrickColor.new("Black")
			local Mesh = Instance.new("BlockMesh",Part)
			Mesh.Scale = Vector3.new(0.1,0.05,0.625) / 0.2 * Scale
			local PartWeld = Instance.new("Motor6D")
			PartWeld.Part0 = Handle
			PartWeld.Part1 = Part
			PartWeld.C0 = CFrame.Angles(math.rad(15),0,0) * CFrame.new(Vector3.new(0,0.1,-0.435)*Scale)
			PartWeld.Parent = Part

			for i = 0,80,10 do
				local Part = Instance.new("Part",Model)
				Part.CanCollide = false
				Part.Position = Vector3.new(0,100,0)
				Part:BreakJoints()
				Part.FormFactor = "Custom"
				Part.Size = Vector3.new(0.2,0.2,0.2)
				Part.TopSurface = "SmoothNoOutlines"
				Part.BottomSurface = "SmoothNoOutlines"
				Part.FrontSurface = "SmoothNoOutlines"
				Part.BackSurface = "SmoothNoOutlines"
				Part.RightSurface = "SmoothNoOutlines"
				Part.LeftSurface = "SmoothNoOutlines"
				Part.BrickColor = BrickColor.new("Black")
				local Mesh = Instance.new("BlockMesh",Part)
				Mesh.Scale = Vector3.new(0.25,0.15,0.03555*2) / 0.2 * Scale
				local PartWeld = Instance.new("Motor6D")
				PartWeld.Part0 = Handle
				PartWeld.Part1 = Part
				PartWeld.C0 = CFrame.new(Vector3.new(0,0.15,0.315)*Scale) * CFrame.Angles(math.rad(i-65),0,0) * CFrame.new(Vector3.new(0,0.2,0)*Scale)
				PartWeld.Parent = Part
			end

			local Barrel = Instance.new("Part",Model)
			Barrel.CanCollide = false
			Barrel.Position = Vector3.new(0,100,0)
			Barrel:BreakJoints()
			Barrel.FormFactor = "Custom"
			Barrel.Size = Vector3.new(0.2,0.2,0.2)
			Barrel.TopSurface = "SmoothNoOutlines"
			Barrel.BottomSurface = "SmoothNoOutlines"
			Barrel.FrontSurface = "SmoothNoOutlines"
			Barrel.BackSurface = "SmoothNoOutlines"
			Barrel.RightSurface = "SmoothNoOutlines"
			Barrel.LeftSurface = "SmoothNoOutlines"
			Barrel.BrickColor = BrickColor.new("Black")
			local Mesh = Instance.new("BlockMesh",Barrel)
			Mesh.Scale = Vector3.new(0.25,0.2,2) / 0.2 * Scale
			local BarrelWeld = Instance.new("Motor6D")
			BarrelWeld.Part0 = Handle
			BarrelWeld.Part1 = Barrel
			BarrelWeld.C0 = CFrame.Angles(math.rad(15),0,0) * CFrame.new(Vector3.new(0,0.5,-0.7)*Scale)
			BarrelWeld.Parent = Barrel

			local Barrel1 = Barrel

			local Barrel2 = Instance.new("Part",Model)
			Barrel2.CanCollide = false
			Barrel2.Position = Vector3.new(0,100,0)
			Barrel2:BreakJoints()
			Barrel2.FormFactor = "Custom"
			Barrel2.Size = Vector3.new(0.2,0.2,0.2)
			Barrel2.TopSurface = "SmoothNoOutlines"
			Barrel2.BottomSurface = "SmoothNoOutlines"
			Barrel2.FrontSurface = "SmoothNoOutlines"
			Barrel2.BackSurface = "SmoothNoOutlines"
			Barrel2.RightSurface = "SmoothNoOutlines"
			Barrel2.LeftSurface = "SmoothNoOutlines"
			Barrel2.BrickColor = BrickColor.new("Really black")
			local Mesh = Instance.new("BlockMesh",Barrel2)
			Mesh.Scale = Vector3.new(0.25,0.25,2) / 0.2 * Scale
			local Barrel2Weld = Instance.new("Motor6D")
			Barrel2Weld.Part0 = Barrel
			Barrel2Weld.Part1 = Barrel2
			Barrel2Weld.C0 = CFrame.new(Vector3.new(0,0.225,0)*Scale)
			Barrel2Weld.Parent = Barrel2

			local RealBarrel = Instance.new("Part",Model)
			RealBarrel.CanCollide = false
			RealBarrel.Position = Vector3.new(0,100,0)
			RealBarrel:BreakJoints()
			RealBarrel.FormFactor = "Custom"
			RealBarrel.Size = Vector3.new(0.2,0.2,0.2)
			RealBarrel.TopSurface = "SmoothNoOutlines"
			RealBarrel.BottomSurface = "SmoothNoOutlines"
			RealBarrel.FrontSurface = "SmoothNoOutlines"
			RealBarrel.BackSurface = "SmoothNoOutlines"
			RealBarrel.RightSurface = "SmoothNoOutlines"
			RealBarrel.LeftSurface = "SmoothNoOutlines"
			RealBarrel.BrickColor = BrickColor.new("Dark grey metallic")
			local Mesh = Instance.new("CylinderMesh",RealBarrel)
			Mesh.Scale = Vector3.new(0.2,2,0.2) / 0.2 * Scale
			local RealBarrelWeld = Instance.new("Motor6D")
			RealBarrelWeld.Part0 = Barrel
			RealBarrelWeld.Part1 = RealBarrel
			RealBarrelWeld.C0 = CFrame.new(Vector3.new(0,0.1,-0.01)*Scale) * CFrame.Angles(math.rad(-90),0,0)
			RealBarrelWeld.Parent = RealBarrel

			for i = 1,75,15 do
				local Part = Instance.new("Part",Model)
				Part.CanCollide = false
				Part.Position = Vector3.new(0,100,0)
				Part:BreakJoints()
				Part.FormFactor = "Custom"
				Part.Size = Vector3.new(0.2,0.2,0.2)
				Part.TopSurface = "SmoothNoOutlines"
				Part.BottomSurface = "SmoothNoOutlines"
				Part.FrontSurface = "SmoothNoOutlines"
				Part.BackSurface = "SmoothNoOutlines"
				Part.RightSurface = "SmoothNoOutlines"
				Part.LeftSurface = "SmoothNoOutlines"
				Part.BrickColor = BrickColor.new("Black")
				local Mesh = Instance.new("BlockMesh",Part)
				Mesh.Scale = Vector3.new(0.05,0.065,0.05) / 0.2 * Scale
				local PartWeld = Instance.new("Motor6D")
				PartWeld.Part0 = Handle
				PartWeld.Part1 = Part
				PartWeld.C0 = CFrame.new(Vector3.new(0,0.525,-0.515)*Scale) * CFrame.Angles(math.rad(i),0,0) * CFrame.new(Vector3.new(0,0,0.2)*Scale)
				PartWeld.Parent = Part
			end

			local Part = Instance.new("Part",Model)
			Part.CanCollide = false
			Part.Position = Vector3.new(0,100,0)
			Part:BreakJoints()
			Part.FormFactor = "Custom"
			Part.Size = Vector3.new(0.2,0.2,0.2)
			Part.TopSurface = "SmoothNoOutlines"
			Part.BottomSurface = "SmoothNoOutlines"
			Part.FrontSurface = "SmoothNoOutlines"
			Part.BackSurface = "SmoothNoOutlines"
			Part.RightSurface = "SmoothNoOutlines"
			Part.LeftSurface = "SmoothNoOutlines"
			Part.BrickColor = BrickColor.new("Really black")
			local Mesh = Instance.new("BlockMesh",Part)
			Mesh.Scale = Vector3.new(0.05,0.11,0.1) / 0.2 * Scale
			local PartWeld = Instance.new("Motor6D")
			PartWeld.Part0 = Barrel2
			PartWeld.Part1 = Part
			PartWeld.C0 = CFrame.new(Vector3.new(0.06,0.135,0.925)*Scale)
			PartWeld.Parent = Part

			local Part = Instance.new("Part",Model)
			Part.CanCollide = false
			Part.Position = Vector3.new(0,100,0)
			Part:BreakJoints()
			Part.FormFactor = "Custom"
			Part.Size = Vector3.new(0.2,0.2,0.2)
			Part.TopSurface = "SmoothNoOutlines"
			Part.BottomSurface = "SmoothNoOutlines"
			Part.FrontSurface = "SmoothNoOutlines"
			Part.BackSurface = "SmoothNoOutlines"
			Part.RightSurface = "SmoothNoOutlines"
			Part.LeftSurface = "SmoothNoOutlines"
			Part.BrickColor = BrickColor.new("Really black")
			local Mesh = Instance.new("BlockMesh",Part)
			Mesh.Scale = Vector3.new(0.05,0.11,0.1) / 0.2 * Scale
			local PartWeld = Instance.new("Motor6D")
			PartWeld.Part0 = Barrel2
			PartWeld.Part1 = Part
			PartWeld.C0 = CFrame.new(Vector3.new(-0.06,0.135,0.925)*Scale)
			PartWeld.Parent = Part

			local Part = Instance.new("Part",Model)
			Part.CanCollide = false
			Part.Position = Vector3.new(0,100,0)
			Part:BreakJoints()
			Part.FormFactor = "Custom"
			Part.Size = Vector3.new(0.2,0.2,0.2)
			Part.TopSurface = "SmoothNoOutlines"
			Part.BottomSurface = "SmoothNoOutlines"
			Part.FrontSurface = "SmoothNoOutlines"
			Part.BackSurface = "SmoothNoOutlines"
			Part.RightSurface = "SmoothNoOutlines"
			Part.LeftSurface = "SmoothNoOutlines"
			Part.BrickColor = BrickColor.new("Really black")
			local Mesh = Instance.new("BlockMesh",Part)
			Mesh.Scale = Vector3.new(0.025,0.1,0.1) / 0.2 * Scale
			local PartWeld = Instance.new("Motor6D")
			PartWeld.Part0 = Barrel2
			PartWeld.Part1 = Part
			PartWeld.C0 = CFrame.new(Vector3.new(0,0.135,-0.925)*Scale)
			PartWeld.Parent = Part

			local Part = Instance.new("Part",Model)
			Part.CanCollide = false
			Part.Position = Vector3.new(0,100,0)
			Part:BreakJoints()
			Part.FormFactor = "Custom"
			Part.Size = Vector3.new(0.2,0.2,0.2)
			Part.Transparency = 1
			Part.TopSurface = "SmoothNoOutlines"
			Part.BottomSurface = "SmoothNoOutlines"
			Part.FrontSurface = "SmoothNoOutlines"
			Part.BackSurface = "SmoothNoOutlines"
			Part.RightSurface = "SmoothNoOutlines"
			Part.LeftSurface = "SmoothNoOutlines"
			Part.BrickColor = BrickColor.new("Really black")
			local Mesh = Instance.new("BlockMesh",Part)
			Mesh.Scale = Vector3.new(0.1,0.1,0.1) / 0.2 * Scale
			local PartWeld = Instance.new("Motor6D")
			PartWeld.Part0 = Barrel
			PartWeld.Part1 = Part
			PartWeld.C0 = CFrame.new(Vector3.new(0,0,-5)*Scale)
			PartWeld.Parent = Part

			local Light = Instance.new("PointLight",Part)
			Light.Color = BrickColor.new("Gold").Color
			Light.Enabled = true
			Light.Shadows = true
			Light.Brightness = 0
			Light.Range = 6

			local Part = Instance.new("Part",Model)
			Part.Material = "Neon"
			Part.CanCollide = false
			Part.Position = Vector3.new(0,100,0)
			Part:BreakJoints()
			Part.FormFactor = "Custom"
			Part.Size = Vector3.new(0.2,0.2,0.2)
			Part.TopSurface = "SmoothNoOutlines"
			Part.BottomSurface = "SmoothNoOutlines"
			Part.FrontSurface = "SmoothNoOutlines"
			Part.BackSurface = "SmoothNoOutlines"
			Part.RightSurface = "SmoothNoOutlines"
			Part.LeftSurface = "SmoothNoOutlines"
			Part.BrickColor = BrickColor.new("Bright yellow")
			Part.Transparency = 0.25
			local RecoilMesh = Instance.new("SpecialMesh",Part)
			RecoilMesh.MeshType = "FileMesh"
			RecoilMesh.MeshId = "http://www.roblox.com/Asset/?id=1323306"
			RecoilMesh.TextureId = "http://www.roblox.com/Asset/?id=98896228"
			RecoilMesh.Scale = Vector3.new(0.175,0,0.175) * Scale
			local PartWeld = Instance.new("Motor6D")
			PartWeld.Part0 = RealBarrel
			PartWeld.Part1 = Part
			PartWeld.C0 = CFrame.new(Vector3.new(0,0.95,0)*Scale)
			PartWeld.Parent = Part

			function ShootBullet(Target,barrel)
				local barrel = barrel or Barrel
				local Bullet = Instance.new("Part",Workspace)
				Barrel.CanCollide = false
				Bullet.FormFactor = "Custom"
				Bullet.Size = Vector3.new(0.2,0.2,5)*Scale
				Bullet.TopSurface = "Smooth"
				Bullet.BottomSurface = "Smooth"
				Bullet.Anchored = true
				Bullet.CanCollide = false
				Bullet.CFrame = CFrame.new((barrel.CFrame*CFrame.new(0,0,-barrel.Size.Z*barrel.Mesh.Scale.Z/2)).p,Target)*CFrame.new(0,0,-Bullet.Size.Z/2)
				Bullet.Transparency = 0.1
				Bullet.BrickColor = BrickColor.new("Gold")
--[[local Mesh = Instance.new("SpecialMesh",Bullet)
Mesh.MeshType = "FileMesh"
Mesh.Scale = Vector3.new(0.5,0.5,0.2)
Mesh.MeshId = "http://www.roblox.com/asset/?id=2697549"
--Mesh.TextureId = "http://www.roblox.com/asset/?id=2697544"]]
				local Mesh = Instance.new("BlockMesh",Bullet)
				Mesh.Scale = Vector3.new(0.2,0.2,5)*Scale/Bullet.Size
				IgnoreList[#IgnoreList+1] = Bullet
				RenderStepped:wait()
				for i = Speed,1000,Speed do -- Loop to do the bullet movement and stuff.
					local ray,Hit,Pos,SurfaceNormal;
					ray = Ray.new(Bullet.Position,((Bullet.CFrame*CFrame.Angles(math.rad(-Gravity),0,0)*CFrame.new(0,0,-Speed)).p-Bullet.Position).unit*Speed)
					Hit,Pos,SurfaceNormal = Workspace:FindPartOnRayWithIgnoreList(ray,IgnoreList)
					Bullet.CFrame = Bullet.CFrame*CFrame.Angles(math.rad(-Gravity),0,0)*CFrame.new(0,0,-Speed)
					if Hit ~= nil then
						local Hum = Hit.Parent:FindFirstChild("Humanoid") or Hit.Parent.Parent:FindFirstChild("Humanoid") or (Hit.Parent.Parent.Parent ~= nil and Hit.Parent.Parent.Parent:FindFirstChild("Humanoid"))
						if Hum ~= nil then
							Hum:TakeDamage((((Gangster and math.random(0,0) or math.random(0,0))*Scale)/100)*Hum.MaxHealth)
						end
						break
					end
					RenderStepped:wait()
				end
				Bullet:Destroy()
			end

			Mouse.Button1Down:connect(function()
				if not Down and not DB then
					Down = true
					while Down do
						if Humanoid.Health == 0 then break end
						if not DB then
							DB = true
							local Sound = Instance.new("Sound",Barrel)
							Sound.SoundId = "http://www.roblox.com/Asset/?id=165946426" -- 132373574
							Sound.Volume = 5*Scale
							Sound.Pitch = (math.random(70,110)/100)/((Scale < 0.25 and 0.25) or (Scale > 4 and 4) or Scale)
							Sound:Play()
							Spawn(function()
								ShootBullet(Mouse.Hit.p,Barrel1)
							end)
							RecoilMesh.VertexColor = Vector3.new(1,math.random(160,245)/255,20/255)
							PartWeld.C0 = PartWeld.C0 * CFrame.Angles(0,math.rad(math.random(-40,40)),0)
							local Shell = Instance.new("Part",Workspace)
							Shell.FormFactor = "Custom"
							Shell.BrickColor = BrickColor.new("Bright yellow")
							Shell.Size = Vector3.new(0.2,0.5,0.2)*Scale
							Shell.CFrame = Barrel.CFrame*CFrame.new(0.5,0.5,0)*CFrame.Angles(math.rad(-90),0,0)
							Shell.Velocity = ((Barrel.CFrame*CFrame.new(5,0,math.random(-2,2))).p-Barrel.CFrame.p)*5*Scale
							local Mesh = Instance.new("CylinderMesh",Shell)
							Mesh.Scale = Vector3.new(0.2,0.5,0.2)*Scale/Shell.Size
							Spawn(function()
								wait(5)
								Shell:Destroy()
							end)
							for i = 1,20,7.5 do
								character1.Reanimate.FPart.Position = mouse.Hit.p
								RotationOffset = RotationOffset*CFrame.Angles(math.rad(7.5),0,0)
								Part1Joint = Part1Joint*CFrame.new(Vector3.new(0,-0.15,0)*Scale)
								Barrel2Weld.C0 = Barrel2Weld.C0*CFrame.new(Vector3.new(0,0,0.15)*Scale)
								Light.Brightness = Light.Brightness+38
								RecoilMesh.Scale = RecoilMesh.Scale+(Vector3.new(0,0.375,0)*Scale)
								RenderStepped:wait()
							end
							wait(0.02)
							for i = 1,20,3.75 do
								character1.Reanimate.FPart.Position = mouse.Hit.p
								RotationOffset = RotationOffset*CFrame.Angles(math.rad(-3.75),0,0)
								Part1Joint = Part1Joint*CFrame.new(Vector3.new(0,0.075,0)*Scale)
								Barrel2Weld.C0 = Barrel2Weld.C0*CFrame.new(Vector3.new(0,0,-0.075)*Scale)
								Light.Brightness = Light.Brightness-19
								RecoilMesh.Scale = RecoilMesh.Scale+(Vector3.new(0,-0.1875,0)*Scale)
								RenderStepped:wait()
							end
							wait(0.02)
							DB = false
						end
					end
				end
			end)

			Mouse.Button1Up:connect(function()
				Down = false
			end)

			Mouse.KeyDown:connect(function(Key)
				if Key:lower() == "g" and not DB then
					DB = true
					if Gangster == true then
						for i = 1,70,5 do
							RotationOffset = RotationOffset*CFrame.Angles(0,math.rad(-5),0)
							RenderStepped:wait()
						end
						Gangster = false
					else
						for i = 1,70,5 do
							RotationOffset = RotationOffset*CFrame.Angles(0,math.rad(5),0)
							RenderStepped:wait()
						end
						Gangster = true
					end
					DB = false
				end
			end)

			local Weld = Instance.new("Weld")
			Weld.Part0 = Torso
			Weld.Part1 = Character["Right Arm"]
			Weld.Parent = Torso

			local Weld2 = Instance.new("Weld")
			Weld2.Part0 = Torso
			Weld2.Part1 = Character.Head
			Weld2.Parent = Torso

			local RA = Character["Right Arm"]

			game:GetService("RunService"):BindToRenderStep("Pistol",Enum.RenderPriority.Character.Value,function()
				local Point = Torso.CFrame:vectorToObjectSpace(Mouse.Hit.p-Torso.CFrame.p)
				if Point.Z > 0 then
					if Point.X > 0 then
						Torso.CFrame = CFrame.new(Torso.Position,Vector3.new(Mouse.Hit.X,Torso.Position.Y,Mouse.Hit.Z))*CFrame.Angles(0,math.rad(90),0)
					elseif Point.X < 0 then
						Torso.CFrame = CFrame.new(Torso.Position,Vector3.new(Mouse.Hit.X,Torso.Position.Y,Mouse.Hit.Z))*CFrame.Angles(0,math.rad(-90),0)
					end
				end

				local CFr = (Torso.CFrame*Part0Joint):toObjectSpace(CFrame.new((Torso.CFrame*Part0Joint).p,Mouse.Hit.p))--RayEnd))
				Weld.C0 = Part0Joint * (CFr-CFr.p) * RotationOffset
				Weld.C1 = Part1Joint
				Weld.Part0 = Torso
				Weld.Part1 = RA
				local CFr = (Torso.CFrame*Part0JointHead):toObjectSpace(CFrame.new((Torso.CFrame*Part0JointHead).p,Mouse.Hit.p))--RayEnd))
				Weld2.C0 = Part0JointHead * (CFr-CFr.p) * RotationOffsetHead
				Weld2.C1 = Part1JointHead
				Weld2.Part0 = Torso
				Weld2.Part1 = Character.Head
				local Last = Scale
				Scale = game.Players.LocalPlayer.Character.Torso.Size.X/2*(game.Players.LocalPlayer.Character.Torso:FindFirstChild("ScaleInserted") ~= nil and game.Players.LocalPlayer.Character.Torso:FindFirstChild("ScaleInserted").Scale.Z or 1)*0.8
				Speed = 20*Scale
				if Scale ~= Last then
					Part0Joint = CFrame.new(Vector3.new(1,0.75,0)*Scale*1.25)
					Part1Joint = CFrame.new(Vector3.new(-0.5,0.75,0)*Scale*1.25)
					Part0JointHead = CFrame.new(Vector3.new(0,1,0)*Scale*1.25)
					Part1JointHead = CFrame.new(Vector3.new(0,-0.5,0)*Scale*1.25)
				end
			end)

			game.StarterGui:SetCore("SendNotification", {
				Title = "Mouse fling Enable";
				Text = "Press E to move and make sure you are wearing any hats";
			})
			game.StarterGui:SetCore("SendNotification", {
			Title = "Warning";
			Text = "Must be R6";
		})
		end
		if cmd == "permadeath" then
		game.StarterGui:SetCore("SendNotification", {
			Title = "Warning";
			Text = "Must be R6";
		})
			loadstring(game:HttpGet("https://raw.githubusercontent.com/GelatekWasTaken/Reanimation.lua/main/Main/Main.lua"))()
		end
		if cmd == "bighead" then
			game.StarterGui:SetCore("SendNotification", {
				Title = "Warning";
				Text = "Make sure you are wearing the correct avatar and the correct scales";
			})

			loadstring(game:HttpGet("https://raw.githubusercontent.com/sysGhost-aka-BiKode/Scripts2022/main/BigHeadV3_Unpatched", true))()
		end
		if cmd == "giant" then
			game.StarterGui:SetCore("SendNotification", {
				Title = "Warning";
				Text = "To work you need the highest scales";
			})


			local LocalPlayer = game:GetService("Players").LocalPlayer
			local Character = LocalPlayer.Character
			local Humanoid = Character:FindFirstChildOfClass("Humanoid")

			function rm()
				for i,v in pairs(Character:GetDescendants()) do
					if v:IsA("BasePart") then
						if v.Name == "Handle" or v.Name == "Head" then
							if Character.Head:FindFirstChild("OriginalSize") then
								Character.Head.OriginalSize:Destroy()
							end
						else
							for i,cav in pairs(v:GetDescendants()) do
								if cav:IsA("Attachment") then
									if cav:FindFirstChild("OriginalPosition") then
										cav.OriginalPosition:Destroy()  
									end
								end
							end
							v:FindFirstChild("OriginalSize"):Destroy()
							if v:FindFirstChild("AvatarPartScaleType") then
								v:FindFirstChild("AvatarPartScaleType"):Destroy()
							end
						end
					end
				end
			end

			rm()
			wait(0.5)
			Humanoid:FindFirstChild("BodyProportionScale"):Destroy()
			wait(1)

			rm()
			wait(0.5)
			Humanoid:FindFirstChild("BodyHeightScale"):Destroy()
			wait(1)

			rm()
			wait(0.5)
			Humanoid:FindFirstChild("BodyWidthScale"):Destroy()
			wait(1)

			rm()
			wait(0.5)
			Humanoid:FindFirstChild("BodyDepthScale"):Destroy()
			wait(1)

			rm()
			wait(0.5)
			Humanoid:FindFirstChild("HeadScale"):Destroy()
			wait(1)
		end
		if cmd == "small" then
			game.StarterGui:SetCore("SendNotification", {
				Title = "Warning";
				Text = "To work you need the smalest scales";
			})
			
			local LocalPlayer = game:GetService("Players").LocalPlayer
			local Character = LocalPlayer.Character
			local Humanoid = Character:FindFirstChildOfClass("Humanoid")

			local function rm()
				for i,v in pairs(Character:GetDescendants()) do
					if v:IsA("BasePart") then
						if v.Name ~= "Head" then
							for i,cav in pairs(v:GetDescendants()) do
								if cav:IsA("Attachment") then
									if cav:FindFirstChild("OriginalPosition") then
										cav.OriginalPosition:Destroy()
									end
								end
							end
							v:FindFirstChild("OriginalSize"):Destroy()
							if v:FindFirstChild("AvatarPartScaleType") then
								v:FindFirstChild("AvatarPartScaleType"):Destroy()
							end
						end
					end
				end
			end

			rm()
			wait(0.5)
			Humanoid:FindFirstChild("BodyTypeScale"):Destroy()
			wait(1)

			rm()
			wait(0.5)
			Humanoid:FindFirstChild("BodyWidthScale"):Destroy()
			wait(1)

			rm()
			wait(0.5)
			Humanoid:FindFirstChild("BodyDepthScale"):Destroy()
			wait(1)

			rm()
			wait(0.5)
			Humanoid:FindFirstChild("HeadScale"):Destroy()
			wait(1)
		end
		if cmd == "errape" then
		game.StarterGui:SetCore("SendNotification", {
			Title = "Warning";
			Text = "Press Q to spam errape";
		})

			plr = game.Players.LocalPlayer
			mouse = plr:GetMouse()
			mouse.KeyDown:connect(function(key)
			
				if key == "q" then

					print(game:GetService("SoundService").RespectFilteringEnabled)

					for _, sound in next, workspace:GetDescendants() do
						if sound:IsA("Sound") then
							sound:Play()
						end
					end
				end
			end)
		end
		if cmd == "chatbypass" then
			loadstring(game:HttpGet("https://the-shed.xyz/roblox/scripts/ChatBypass", true))()
		end
		if cmd == "chatlogs" then
			-- get frorm infinite yield
		end
		if cmd == "chathax" then
			loadstring(game:HttpGet('https://raw.githubusercontent.com/ant-7802/--/main/straightmilk.lua'))()
		end
		if cmd == "autogrammar" then
			loadstring(game:HttpGet("https://raw.githubusercontent.com/eosuwu/boblox/main/autogremer.lua"))()

			loadstring(game:HttpGet("https://raw.githubusercontent.com/eosuwu/boblox/main/robloxgrammarly.lua"))()
		end
		if cmd == "blackhole" then
		game.StarterGui:SetCore("SendNotification", {
			Title = "Warning";
			Text = "TMust be R6";
		})

			local UserInputService = game:GetService("UserInputService")
			local Mouse = game:GetService("Players").LocalPlayer:GetMouse()
			local Folder = Instance.new("Folder", game:GetService("Workspace"))
			local Part = Instance.new("Part", Folder)
			local Attachment1 = Instance.new("Attachment", Part)
			Part.Anchored = true
			Part.CanCollide = false
			Part.Transparency = 1
			local Updated = Mouse.Hit + Vector3.new(0, 5, 0)
			local NetworkAccess = coroutine.create(function()
				settings().Physics.AllowSleep = false
				while game:GetService("RunService").RenderStepped:Wait() do
					for _, Players in next, game:GetService("Players"):GetPlayers() do
						if Players ~= game:GetService("Players").LocalPlayer then
							Players.MaximumSimulationRadius = 0 
							sethiddenproperty(Players, "SimulationRadius", 0) 
						end 
					end
					game:GetService("Players").LocalPlayer.MaximumSimulationRadius = math.pow(math.huge,math.huge)
					setsimulationradius(math.huge) 
				end 
			end) 
			coroutine.resume(NetworkAccess)
			local function ForcePart(v)
				if v:IsA("Part") and v.Anchored == false and v.Parent:FindFirstChild("Humanoid") == nil and v.Parent:FindFirstChild("Head") == nil and v.Name ~= "Handle" then
					Mouse.TargetFilter = v
					for _, x in next, v:GetChildren() do
						if x:IsA("BodyAngularVelocity") or x:IsA("BodyForce") or x:IsA("BodyGyro") or x:IsA("BodyPosition") or x:IsA("BodyThrust") or x:IsA("BodyVelocity") or x:IsA("RocketPropulsion") then
							x:Destroy()
						end
					end
					if v:FindFirstChild("Attachment") then
						v:FindFirstChild("Attachment"):Destroy()
					end
					if v:FindFirstChild("AlignPosition") then
						v:FindFirstChild("AlignPosition"):Destroy()
					end
					if v:FindFirstChild("Torque") then
						v:FindFirstChild("Torque"):Destroy()
					end
					v.CanCollide = false
					local Torque = Instance.new("Torque", v)
					Torque.Torque = Vector3.new(100000, 100000, 100000)
					local AlignPosition = Instance.new("AlignPosition", v)
					local Attachment2 = Instance.new("Attachment", v)
					Torque.Attachment0 = Attachment2
					AlignPosition.MaxForce = 9999999999999999
					AlignPosition.MaxVelocity = math.huge
					AlignPosition.Responsiveness = 200
					AlignPosition.Attachment0 = Attachment2 
					AlignPosition.Attachment1 = Attachment1
				end
			end
			for _, v in next, game:GetService("Workspace"):GetDescendants() do
				ForcePart(v)
			end
			game:GetService("Workspace").DescendantAdded:Connect(function(v)
				ForcePart(v)
			end)
			UserInputService.InputBegan:Connect(function(Key, Chat)
				if Key.KeyCode == Enum.KeyCode.E and not Chat then
					Updated = Mouse.Hit + Vector3.new(0, 5, 0)
				end
			end)
			spawn(function()
				while game:GetService("RunService").RenderStepped:Wait() do
					Attachment1.WorldCFrame = Updated
				end
			end)

			game.StarterGui:SetCore("SendNotification", {
				Title = "Black Hole Enable";
				Text = "Press E to move";
			})
		end
		if cmd == "noclip" then
			game.StarterGui:SetCore("SendNotification", {
				Title = "Warning";
				Text = "Must be R6";
			})

			lplayer.Character.Head.CanCollide = false
			lplayer.Character.Torso.CanCollide = false
			lplayer.Character["Left Leg"].CanCollide = false
			lplayer.Character["Right Leg"].CanCollide = false

			lplayer.Character.Humanoid:ChangeState(11)
			game.Players.LocalPlayer.Character.Humanoid.JumpPower = 0
		end
		if cmd == "clip" then
			game.Players.LocalPlayer.Character.Humanoid.JumpPower = 50

			wait(0.1)
			
			lplayer.Character.Humanoid:ChangeState(0)
		end
		if cmd == "stare" then
			game.StarterGui:SetCore("SendNotification", {
				Title = "Warning";
				Text = "Make sure the player is in Value Box and the player must be R6";
			})
			
			local target = ValueBox_2.Text

			mouse = game.Players.LocalPlayer:GetMouse()

			tool = Instance.new("Tool")
			tool.RequiresHandle = false
			tool.Name = "Teleport Tool"
			tool.Activated:Connect(function()
			local pos = mouse.Hit+Vector3.new(0,2.5,0)

			pos = CFrame.new(pos.X,pos.Y,pos.Z)
			game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = pos
			end)

			tool.Parent = game.Players.LocalPlayer.Backpack

			game.Players.LocalPlayer.Character.Humanoid.WalkSpeed = 0

			repeat
				wait(0)
				if lplayer.Character.Humanoid.RigType == Enum.HumanoidRigType.R6 then
					lplayer.Character.HumanoidRootPart.CFrame = CFrame.new(lplayer.Character.Torso.Position, game:GetService("Players")[target].Character.Torso.Position)
					lplayer.Character.Humanoid:ChangeState(11)
				end
			until ValueBox_2.Text == ""
		end
		if cmd == "unstare" then
			lplayer.Character.Humanoid:ChangeState(0)
			game.Players.LocalPlayer.Character.Humanoid.WalkSpeed = 16
			game.Players.LocalPlayer.Character.Humanoid.JumpPower = 50

			wait(0.1)

			game.Players.LocalPlayer.Character.Humanoid.Jump = true

			ValueBox_2.Text = ""
		end
		if cmd == "animations" then
		game.StarterGui:SetCore("SendNotification", {
			Title = "Warning";
			Text = "The animations are R6";
		})
			save = nil
			c3 = function(r,g,b) return Color3.new(r/255,g/255,b/255) end


			if not save then
				save = {
					ui = {
						highlightcolor = c3(33, 122, 255);
						errorcolor = c3(255, 0, 0);
						--AnimationPriority colors
						core = c3(65, 65, 65);
						idle = c3(134, 200, 230);
						movement = c3(114, 230, 121);
						action = c3(235, 235, 235);
					};
					preferences = {

					};
					custom_animations = {
						template = {
							Title = "";
							AnimationId = "rbxassetid://";
							Image = "rbxassetid://2151539455"; --not required
							Speed = 1;
							Time = 0;
							Weight = 1;
							Loop = false;
							R6 = true;
							Priority = 2; --0, 1, 2, and 1000 are acceptable priorities
						};
					};
				}
			end

			lp = game:GetService("Players").LocalPlayer
			m = lp:GetMouse()

			function getHumanoid()
				if not lp.Character then return nil end
				return lp.Character:FindFirstChildWhichIsA("Humanoid")
			end

			screengui = game:GetObjects("rbxassetid://02159099015")[1]
			screengui.Parent = game:GetService("CoreGui")
			main = screengui.Topbar.Main

			mainframe = main.MainFrame
			scrollframe = mainframe.ScrollingFrame
			items = scrollframe.Items
			search = scrollframe.SearchFrame.Search
			searchbutton = scrollframe.SearchFrame.ImageLabel.TextButton
			searchframe = scrollframe.SearchFrame

			preview = main.Preview
			previewimage = preview.Image
			previewtitle = preview.Title
			previewdesc = preview.Desc

			function draggable(gObj)
				local UserInputService = game:GetService("UserInputService")

				local gui = gObj

				local dragging
				local dragInput
				local dragStart
				local startPos

				local function update(input)
					local delta = input.Position - dragStart
					gui.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
				end

				gui.InputBegan:Connect(function(input)
					if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
						dragging = true
						dragStart = input.Position
						startPos = gui.Position

						input.Changed:Connect(function()
							if input.UserInputState == Enum.UserInputState.End then
								dragging = false
							end
						end)
					end
				end)

				gui.InputChanged:Connect(function(input)
					if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
						dragInput = input
					end
				end)

				UserInputService.InputChanged:Connect(function(input)
					if input == dragInput and dragging then
						update(input)
					end
				end)
			end
			function tween(object,style,direction,t,goal)
				local tweenservice = game:GetService("TweenService")
				local tweenInfo = TweenInfo.new(t,Enum.EasingStyle[style],Enum.EasingDirection[direction])
				local tween = tweenservice:Create(object,tweenInfo,goal)
				tween:Play()
				return tween
			end

			draggable(screengui.Topbar)

			function checkIfStudio()
				return game.Name ~= "Game"
			end

			if not checkIfStudio() then
				print'Client is not in Roblox studio'
				--main.Size = UDim2.new(0.398, 0, 0.477, 0)
			end

			search.Changed:connect(function(p)
				local n = 0
				for i,v in pairs (items:GetChildren()) do
					if v:IsA("TextButton") and not string.find(v.Title.Text:lower(), search.Text:lower()) then
						v.Visible = false
					elseif v:IsA("TextButton") and string.find(v.Title.Text:lower(), search.Text:lower()) then
						v.Visible = true
						n = n + 1
					end
				end
				if p == "Text" then
					if n > 0 then
						tween(searchframe, "Sine", "Out", 0.25, {
							BorderColor3 = save.ui.highlightcolor;
						})
						wait(0.25)
						tween(searchframe, "Sine", "In", 0.5, {
							BorderColor3 = c3(58, 58, 58);
						})
					else
						tween(searchframe, "Sine", "Out", 0.25, {
							BorderColor3 = save.ui.errorcolor;
						})
						wait(0.25)
						tween(searchframe, "Sine", "In", 0.5, {
							BorderColor3 = c3(58, 58, 58);
						})
					end
				end
			end)

			spawn(function()
				while wait(10) do
					--auto-save every 10 seconds
				end
			end)

			cam = workspace.CurrentCamera

			running = {}
			popAnims = {
				armturbine = {
					Title = "Arm Turbine";
					AnimationId = "rbxassetid://259438880";
					Speed = 1.5;
					Time = 0;
					Weight = 1;
					Loop = true;
					R6 = true;
					Priority = 2; --0, 1, 2, and 1000 are acceptable priorities
				};
				weirdsway = {
					Title = "Weird Sway";
					AnimationId = "rbxassetid://248336677";
					Speed = 1;
					Time = 0;
					Weight = 1;
					Loop = true;
					R6 = true;
					Priority = 2; --0, 1, 2, and 1000 are acceptable priorities
				};
				weirdfloat = {
					Title = "Weird Float";
					AnimationId = "rbxassetid://248336459";
					Speed = 1;
					Time = 0;
					Weight = 1;
					Loop = true;
					R6 = true;
					Priority = 2; --0, 1, 2, and 1000 are acceptable priorities
				};
				weirdpose = {
					Title = "Weird Pose";
					AnimationId = "rbxassetid://248336163";
					Speed = 1;
					Time = 0;
					Weight = 1;
					Loop = true;
					R6 = true;
					Priority = 2; --0, 1, 2, and 1000 are acceptable priorities
				};
				penguinslide = {
					Title = "Penguin Slide";
					AnimationId = "rbxassetid://282574440";
					Speed = 1;
					Time = 0;
					Weight = 1;
					Loop = true;
					R6 = true;
					Priority = 2; --0, 1, 2, and 1000 are acceptable priorities
				};
				scream = {
					Title = "Scream";
					AnimationId = "rbxassetid://180611870";
					Speed = 1.5;
					Time = 0;
					Weight = 1;
					Loop = true;
					R6 = true;
					Priority = 2; --0, 1, 2, and 1000 are acceptable priorities
				};
				crouch = {
					Title = "Crouch";
					AnimationId = "rbxassetid://182724289";
					Speed = 1;
					Time = 0;
					Weight = 1;
					Loop = true;
					R6 = true;
					Priority = 2; --0, 1, 2, and 1000 are acceptable priorities
				};
				happydance = {
					Title = "Happy Dance";
					AnimationId = "rbxassetid://248335946";
					Speed = 1;
					Time = 0;
					Weight = 1;
					Loop = true;
					R6 = true;
					Priority = 2; --0, 1, 2, and 1000 are acceptable priorities
				};
				floatinghead = {
					Title = "Floating Head";
					AnimationId = "rbxassetid://121572214";
					Speed = 1;
					Time = 0;
					Weight = 1;
					Loop = true;
					R6 = true;
					Priority = 2; --0, 1, 2, and 1000 are acceptable priorities
				};
				balloonfloat = {
					Title = "Balloon Float";
					AnimationId = "rbxassetid://148840371";
					Speed = 1;
					Time = 0;
					Weight = 1;
					Loop = true;
					R6 = true;
					Priority = 2; --0, 1, 2, and 1000 are acceptable priorities
				};
				pinchnose = {
					Title = "Pinch Nose";
					AnimationId = "rbxassetid://30235165";
					Speed = 1;
					Time = 0;
					Weight = 1;
					Loop = true;
					R6 = true;
					Priority = 2; --0, 1, 2, and 1000 are acceptable priorities
				};
				goal = {
					Title = "Goal!";
					AnimationId = "rbxassetid://28488254";
					Speed = 1;
					Time = 0;
					Weight = 1;
					Loop = true;
					R6 = true;
					Priority = 2; --0, 1, 2, and 1000 are acceptable priorities
				};
				cry = {
					Title = "Cry";
					AnimationId = "rbxassetid://180612465";
					Speed = 0;
					Time = 1.5;
					Weight = 1;
					Loop = true;
					R6 = true;
					Priority = 2; --0, 1, 2, and 1000 are acceptable priorities
				};
				partytime = {
					Title = "Party Time";
					AnimationId = "rbxassetid://33796059";
					Speed = 1;
					Time = 0;
					Weight = 1;
					Loop = true;
					R6 = true;
					Priority = 2; --0, 1, 2, and 1000 are acceptable priorities
				};
				moondance = {
					Title = "Moon Dance";
					AnimationId = "rbxassetid://27789359";
					Speed = 1;
					Time = 0;
					Weight = 1;
					Loop = true;
					R6 = true;
					Priority = 2; --0, 1, 2, and 1000 are acceptable priorities
				};
				insanelegs = {
					Title = "Insane Legs";
					AnimationId = "rbxassetid://87986341";
					Speed = 99;
					Time = 0;
					Weight = 1;
					Loop = true;
					R6 = true;
					Priority = 2; --0, 1, 2, and 1000 are acceptable priorities
				};
				rotation = {
					Title = "Rotation";
					AnimationId = "rbxassetid://136801964";
					Speed = 1;
					Time = 0;
					Weight = 1;
					Loop = true;
					R6 = true;
					Priority = 2; --0, 1, 2, and 1000 are acceptable priorities
				};
				insanerotation = {
					Title = "Insane Rotation";
					AnimationId = "rbxassetid://136801964";
					Speed = 99;
					Time = 0;
					Weight = 1;
					Loop = true;
					R6 = true;
					Priority = 2; --0, 1, 2, and 1000 are acceptable priorities
				};
				roar = {
					Title = "Roar";
					AnimationId = "rbxassetid://163209885";
					Speed = 1;
					Time = 0;
					Weight = 1;
					Loop = true;
					R6 = true;
					Priority = 2; --0, 1, 2, and 1000 are acceptable priorities
				};
				spin = {
					Title = "Spin";
					AnimationId = "rbxassetid://188632011";
					Speed = 1;
					Time = 0;
					Weight = 1;
					Loop = true;
					R6 = true;
					Priority = 2; --0, 1, 2, and 1000 are acceptable priorities
				};
				zombiearms = {
					Title = "Zombie Arms";
					AnimationId = "rbxassetid://183294396";
					Speed = 0;
					Time = 0;
					Weight = 1;
					Loop = true;
					R6 = true;
					Priority = 2; --0, 1, 2, and 1000 are acceptable priorities
				};
				insane = {
					Title = "Insane";
					AnimationId = "rbxassetid://33796059";
					Speed = 99;
					Time = 0;
					Weight = 1;
					Loop = true;
					R6 = true;
					Priority = 2; --0, 1, 2, and 1000 are acceptable priorities
				};
				neckbreak = {
					Title = "Neck Break";
					AnimationId = "rbxassetid://35154961";
					Speed = 0;
					Time = 2;
					Weight = 1;
					Loop = true;
					R6 = true;
					Priority = 2; --0, 1, 2, and 1000 are acceptable priorities
				};
				headdetach = {
					Title = "Head Detach";
					AnimationId = "rbxassetid://35154961";
					Speed = 0;
					Time = 3;
					Weight = 1;
					Loop = true;
					R6 = true;
					Priority = 2; --0, 1, 2, and 1000 are acceptable priorities
				};
				idle = {
					Title = "Idle";
					AnimationId = "rbxassetid://180435571";
					Speed = 1;
					Time = 0;
					Weight = 1;
					Loop = true;
					R6 = true;
					Priority = 2; --0, 1, 2, and 1000 are acceptable priorities
				};
				charleston = {
					Title = "Charleston";
					AnimationId = "rbxassetid://429703734";
					Speed = 1;
					Time = 0;
					Weight = 1;
					Loop = true;
					R6 = true;
					Priority = 2; --0, 1, 2, and 1000 are acceptable priorities
				};
			}
			robloxOwns = {}

			ownerOwns = {}

			customAnims = {}

			function getOwnedAnimations(userid)
				local httpserv = game:GetService("HttpService")
				local owned = httpserv:GetAsync("https://inventory.roblox.com/v1/users/"..userid.."/inventory/Animation?pageNumber=1&itemsPerPage=10", true)
				return owned
			end


			function getAnim(name)
				return popAnims[name] or customAnims[name]
			end
			function runAnim(info, humanoid)
				local animation = Instance.new("Animation")
				animation.AnimationId = info.AnimationId

				local animtrack = humanoid:LoadAnimation(animation)
				table.insert(running,animtrack)
				animtrack.Priority = info.Priority
				animtrack.Looped = info.Loop

				animtrack:Play()
				animtrack:AdjustSpeed(info.Speed)
				animtrack:AdjustWeight(info.Weight)
				animtrack.TimePosition = info.Time

				animtrack.Stopped:connect(function()
					for i = 1,#running do
						if running[i] == animtrack then
							table.remove(running,i)
						end
					end
				end)

				return animtrack
			end

			template = items.Template
			template.Parent = nil

			function clear()
				for i,v in pairs (items:GetChildren()) do
					if v:IsA("TextButton") then
						v:Destroy()
					end
				end
			end

--[[
    idle = {
        Title = "Idle";
        AnimationId = "rbxassetid://180435571";
        Speed = 1;
        Time = 0;
        Weight = 1;
        Loop = true;
        R6 = true;
        Priority = 2; --0, 1, 2, and 1000 are acceptable priorities
    };
--]]

			function createbutton(v)
				local temp = template:Clone()
				temp.Parent = items
				temp.Name = v.Title
				temp.Title.Text = v.Title
				temp.Image.Image = v.Image or "rbxassetid://2151539455"
				if temp.Image.Image == "rbxassetid://2151539455" then
					temp.Image.ImageColor3 = (v.Priority == 0 and save.ui.idle) or (v.Priority == 1 and save.ui.movement) or (v.Priority == 2 and save.ui.action) or (v.Priority == 1000 and save.ui.core)
				else
					temp.Image.ImageColor3 = Color3.new(1,1,1)
				end
				temp.LayoutOrder = math.random(1,10000)

				temp.Settings.AnimationId.Value = v.AnimationId
				temp.Settings.Loop.Value = v.Loop
				temp.Settings.Priority.Value = v.Priority
				temp.Settings.R6.Value = v.R6
				temp.Settings.Speed.Value = v.Speed
				temp.Settings.Weight.Value = v.Weight
				temp.Settings.Time.Value = v.Time

				temp.MouseEnter:connect(function()
					preview.Title.Text = v.Title
					preview.Desc.Text = "Speed: "..tostring(v.Speed).."\nPriority: "..tostring(v.Priority).."\nR6 Rig: "..tostring(v.R6).."\nAnimID: "..tostring(v.AnimationId).."\n\n"..(v.Description or "No description provided")

					preview.Image.Image = v.Image or "rbxassetid://2151539455"
					if preview.Image.Image == "rbxassetid://2151539455" then
						preview.Image.ImageColor3 = (v.Priority == 0 and save.ui.idle) or (v.Priority == 1 and save.ui.movement) or (v.Priority == 2 and save.ui.action) or (v.Priority == 1000 and save.ui.core)
					else
						preview.Image.ImageColor3 = Color3.new(1,1,1)
					end
				end)
				temp.MouseButton1Click:connect(function()
					temp.Border.ImageColor3 = save.ui.highlightcolor
					for i,anim in pairs (running) do
						if anim.Animation.AnimationId == v.AnimationId then
							anim:Stop()
							return
						end
					end
					temp.Border.Visible = true
					local rAnim = runAnim(v, getHumanoid())
					rAnim.Stopped:connect(function()
						temp.Border.Visible = false
					end)
				end)

				return temp
			end

			dropdown = mainframe.ScrollingFrame.DropdownFrame
			elements = dropdown.HoldContentsFrame.Frame.Elements
			dropdownenabled = true

			tween(dropdown.HoldContentsFrame.Frame, "Linear", "In", 0, {
				Position = UDim2.new(0,0,-1,0)
			})
			dropdown.HoldContentsFrame.Frame.Visible = false

			dropdowndeactivate = screengui.DropdownDeactivate
			dropdowndeactivate.Visible = false

			function hideddown()
				tween(dropdown.HoldContentsFrame.Frame, "Linear", "In", 0, {
					Position = UDim2.new(0,0,-1,0)
				})
				dropdown.HoldContentsFrame.Frame.Visible = false
				dropdowndeactivate.Visible = false
				dropdownenabled = true

				for i,e in pairs (elements:GetChildren()) do
					if e:IsA("TextButton") then
						e.BackgroundColor3 = c3(46,46,46)
					end
				end
			end

			dropdown.MouseButton1Click:connect(function()
				print'ddownclick'
				dropdownenabled = not dropdownenabled
				if dropdownenabled then
					hideddown()
				else
					tween(dropdown.HoldContentsFrame.Frame, "Linear", "In", 0.3, {
						Position = UDim2.new(0,0,0,0)
					})
					dropdown.HoldContentsFrame.Frame.Visible = true
					dropdowndeactivate.Visible = true
				end
			end)

			dropdowndeactivate.MouseButton1Down:connect(function()
				hideddown()
			end)

			for i,v in pairs (elements:GetChildren()) do
				if v:IsA("TextButton") then
					v.MouseEnter:connect(function()
						for i,e in pairs (elements:GetChildren()) do
							if e:IsA("TextButton") then
								e.BackgroundColor3 = c3(46,46,46)
							end
						end
						v.BackgroundColor3 = save.ui.highlightcolor
					end)
					v.MouseButton1Click:connect(function()
						hideddown()
						dropdown.TextLabel.Text = v.Name
						sort(v.Name)
					end)
				end
			end

			function sort(category)
				clear()
				if category == "Popular" then
					for i,v in pairs (popAnims) do
						local temp = createbutton(v)
					end
				elseif category == "By Roblox" then

				end
			end

			game:GetService('RunService').RenderStepped:connect(function()
				items.Parent.CanvasSize = UDim2.new(0,0,0,items.GridLayout.AbsoluteContentSize.Y + 50)
			end)

			sort("Popular")
		end
		if cmd == "infjump" then
			loadstring(game:HttpGet("https://pastebin.com/raw/HQsQysa8", true))()

			game.StarterGui:SetCore("SendNotification", {
				Title = "InfiniteJump Enable";
				Text = "Press R to toggle";
			})
		end
		if cmd == "gravitycontroller" then
			--[[
local _p = game:WaitForChild("Players")
local _plr = _p.ChildAdded:Wait()
if _plr == _p.LocalPlayer then
	_plr.ChildAdded:Connect(function(cccc)
		if c.Name == "PlayerScriptsLoader" then
			c.Disabled = true
		end
	end)
end
]]
	repeat wait()
	a = pcall(function()
	game:WaitForChild("Players").LocalPlayer:WaitForChild("PlayerScripts").ChildAdded:Connect(function(c)
		if c.Name == "PlayerScriptsLoader"then
			c.Disabled = true
		end
	end)
	end)
	if a == true then break end
	until true == false
	game:WaitForChild("Players").LocalPlayer:WaitForChild("PlayerScripts").ChildAdded:Connect(function(c)
	if c.Name == "PlayerScriptsLoader"then
		c.Disabled = true
	end
	end)


	function _CameraUI()
	local Players = game:GetService("Players")
	local TweenService = game:GetService("TweenService")
	
	local LocalPlayer = Players.LocalPlayer
	if not LocalPlayer then
		Players:GetPropertyChangedSignal("LocalPlayer"):Wait()
		LocalPlayer = Players.LocalPlayer
	end
	
	local function waitForChildOfClass(parent, class)
		local child = parent:FindFirstChildOfClass(class)
		while not child or child.ClassName ~= class do
			child = parent.ChildAdded:Wait()
		end
		return child
	end
	
	local PlayerGui = waitForChildOfClass(LocalPlayer, "PlayerGui")
	
	local TOAST_OPEN_SIZE = UDim2.new(0, 326, 0, 58)
	local TOAST_CLOSED_SIZE = UDim2.new(0, 80, 0, 58)
	local TOAST_BACKGROUND_COLOR = Color3.fromRGB(32, 32, 32)
	local TOAST_BACKGROUND_TRANS = 0.4
	local TOAST_FOREGROUND_COLOR = Color3.fromRGB(200, 200, 200)
	local TOAST_FOREGROUND_TRANS = 0
	
	-- Convenient syntax for creating a tree of instanes
	local function create(className)
		return function(props)
			local inst = Instance.new(className)
			local parent = props.Parent
			props.Parent = nil
			for name, val in pairs(props) do
				if type(name) == "string" then
					inst[name] = val
				else
					val.Parent = inst
				end
			end
			-- Only set parent after all other properties are initialized
			inst.Parent = parent
			return inst
		end
	end
	
	local initialized = false
	
	local uiRoot
	local toast
	local toastIcon
	local toastUpperText
	local toastLowerText
	
	local function initializeUI()
		assert(not initialized)
	
		uiRoot = create("ScreenGui"){
			Name = "RbxCameraUI",
			AutoLocalize = false,
			Enabled = true,
			DisplayOrder = -1, -- Appears behind default developer UI
			IgnoreGuiInset = false,
			ResetOnSpawn = false,
			ZIndexBehavior = Enum.ZIndexBehavior.Sibling,
	
			create("ImageLabel"){
				Name = "Toast",
				Visible = false,
				AnchorPoint = Vector2.new(0.5, 0),
				BackgroundTransparency = 1,
				BorderSizePixel = 0,
				Position = UDim2.new(0.5, 0, 0, 8),
				Size = TOAST_CLOSED_SIZE,
				Image = "rbxasset://textures/ui/Camera/CameraToast9Slice.png",
				ImageColor3 = TOAST_BACKGROUND_COLOR,
				ImageRectSize = Vector2.new(6, 6),
				ImageTransparency = 1,
				ScaleType = Enum.ScaleType.Slice,
				SliceCenter = Rect.new(3, 3, 3, 3),
				ClipsDescendants = true,
	
				create("Frame"){
					Name = "IconBuffer",
					BackgroundTransparency = 1,
					BorderSizePixel = 0,
					Position = UDim2.new(0, 0, 0, 0),
					Size = UDim2.new(0, 80, 1, 0),
	
					create("ImageLabel"){
						Name = "Icon",
						AnchorPoint = Vector2.new(0.5, 0.5),
						BackgroundTransparency = 1,
						Position = UDim2.new(0.5, 0, 0.5, 0),
						Size = UDim2.new(0, 48, 0, 48),
						ZIndex = 2,
						Image = "rbxasset://textures/ui/Camera/CameraToastIcon.png",
						ImageColor3 = TOAST_FOREGROUND_COLOR,
						ImageTransparency = 1,
					}
				},
	
				create("Frame"){
					Name = "TextBuffer",
					BackgroundTransparency = 1,
					BorderSizePixel = 0,
					Position = UDim2.new(0, 80, 0, 0),
					Size = UDim2.new(1, -80, 1, 0),
					ClipsDescendants = true,
	
					create("TextLabel"){
						Name = "Upper",
						AnchorPoint = Vector2.new(0, 1),
						BackgroundTransparency = 1,
						Position = UDim2.new(0, 0, 0.5, 0),
						Size = UDim2.new(1, 0, 0, 19),
						Font = Enum.Font.GothamSemibold,
						Text = "Camera control enabled",
						TextColor3 = TOAST_FOREGROUND_COLOR,
						TextTransparency = 1,
						TextSize = 19,
						TextXAlignment = Enum.TextXAlignment.Left,
						TextYAlignment = Enum.TextYAlignment.Center,
					},
	
					create("TextLabel"){
						Name = "Lower",
						AnchorPoint = Vector2.new(0, 0),
						BackgroundTransparency = 1,
						Position = UDim2.new(0, 0, 0.5, 3),
						Size = UDim2.new(1, 0, 0, 15),
						Font = Enum.Font.Gotham,
						Text = "Right mouse button to toggle",
						TextColor3 = TOAST_FOREGROUND_COLOR,
						TextTransparency = 1,
						TextSize = 15,
						TextXAlignment = Enum.TextXAlignment.Left,
						TextYAlignment = Enum.TextYAlignment.Center,
					},
				},
			},
	
			Parent = PlayerGui,
		}
	
		toast = uiRoot.Toast
		toastIcon = toast.IconBuffer.Icon
		toastUpperText = toast.TextBuffer.Upper
		toastLowerText = toast.TextBuffer.Lower
	
		initialized = true
	end
	
	local CameraUI = {}
	
	do
		-- Instantaneously disable the toast or enable for opening later on. Used when switching camera modes.
		function CameraUI.setCameraModeToastEnabled(enabled)
			if not enabled and not initialized then
				return
			end
	
			if not initialized then
				initializeUI()
			end
	
			toast.Visible = enabled
			if not enabled then
				CameraUI.setCameraModeToastOpen(false)
			end
		end
	
		local tweenInfo = TweenInfo.new(0.25, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
	
		-- Tween the toast in or out. Toast must be enabled with setCameraModeToastEnabled.
		function CameraUI.setCameraModeToastOpen(open)
			assert(initialized)
	
			TweenService:Create(toast, tweenInfo, {
				Size = open and TOAST_OPEN_SIZE or TOAST_CLOSED_SIZE,
				ImageTransparency = open and TOAST_BACKGROUND_TRANS or 1,
			}):Play()
	
			TweenService:Create(toastIcon, tweenInfo, {
				ImageTransparency = open and TOAST_FOREGROUND_TRANS or 1,
			}):Play()
	
			TweenService:Create(toastUpperText, tweenInfo, {
				TextTransparency = open and TOAST_FOREGROUND_TRANS or 1,
			}):Play()
	
			TweenService:Create(toastLowerText, tweenInfo, {
				TextTransparency = open and TOAST_FOREGROUND_TRANS or 1,
			}):Play()
		end
	end
	
	return CameraUI
end

function _CameraToggleStateController()
	local Players = game:GetService("Players")
	local UserInputService = game:GetService("UserInputService")
	local GameSettings = UserSettings():GetService("UserGameSettings")
	
	local LocalPlayer = Players.LocalPlayer
	if not LocalPlayer then
		Players:GetPropertyChangedSignal("LocalPlayer"):Wait()
		LocalPlayer = Players.LocalPlayer
	end
	
	local Mouse = LocalPlayer:GetMouse()
	
	local Input = _CameraInput()
	local CameraUI = _CameraUI()
	
	local lastTogglePan = false
	local lastTogglePanChange = tick()
	
	local CROSS_MOUSE_ICON = "rbxasset://textures/Cursors/CrossMouseIcon.png"
	
	local lockStateDirty = false
	local wasTogglePanOnTheLastTimeYouWentIntoFirstPerson = false
	local lastFirstPerson = false
	
	CameraUI.setCameraModeToastEnabled(false)
	
	return function(isFirstPerson)
		local togglePan = Input.getTogglePan()
		local toastTimeout = 3
	
		if isFirstPerson and togglePan ~= lastTogglePan then
			lockStateDirty = true
		end
	
		if lastTogglePan ~= togglePan or tick() - lastTogglePanChange > toastTimeout then
			local doShow = togglePan and tick() - lastTogglePanChange < toastTimeout
	
			CameraUI.setCameraModeToastOpen(doShow)
	
			if togglePan then
				lockStateDirty = false
			end
			lastTogglePanChange = tick()
			lastTogglePan = togglePan
		end
	
		if isFirstPerson ~= lastFirstPerson then
			if isFirstPerson then
				wasTogglePanOnTheLastTimeYouWentIntoFirstPerson = Input.getTogglePan()
				Input.setTogglePan(true)
			elseif not lockStateDirty then
				Input.setTogglePan(wasTogglePanOnTheLastTimeYouWentIntoFirstPerson)
			end
		end
	
		if isFirstPerson then
			if Input.getTogglePan() then
				Mouse.Icon = CROSS_MOUSE_ICON
				UserInputService.MouseBehavior = Enum.MouseBehavior.LockCenter
				--GameSettings.RotationType = Enum.RotationType.CameraRelative
			else
				Mouse.Icon = ""
				UserInputService.MouseBehavior = Enum.MouseBehavior.Default
				--GameSettings.RotationType = Enum.RotationType.CameraRelative
			end
	
		elseif Input.getTogglePan() then
			Mouse.Icon = CROSS_MOUSE_ICON
			UserInputService.MouseBehavior = Enum.MouseBehavior.LockCenter
			GameSettings.RotationType = Enum.RotationType.MovementRelative
	
		elseif Input.getHoldPan() then
			Mouse.Icon = ""
			UserInputService.MouseBehavior = Enum.MouseBehavior.LockCurrentPosition
			GameSettings.RotationType = Enum.RotationType.MovementRelative
	
		else
			Mouse.Icon = ""
			UserInputService.MouseBehavior = Enum.MouseBehavior.Default
			GameSettings.RotationType = Enum.RotationType.MovementRelative
		end
	
		lastFirstPerson = isFirstPerson
	end
end

function _CameraInput()
	local UserInputService = game:GetService("UserInputService")
	
	local MB_TAP_LENGTH = 0.3 -- length of time for a short mouse button tap to be registered
	
	local rmbDown, rmbUp
	do
		local rmbDownBindable = Instance.new("BindableEvent")
		local rmbUpBindable = Instance.new("BindableEvent")
	
		rmbDown = rmbDownBindable.Event
		rmbUp = rmbUpBindable.Event
	
		UserInputService.InputBegan:Connect(function(input, gpe)
			if not gpe and input.UserInputType == Enum.UserInputType.MouseButton2 then
				rmbDownBindable:Fire()
			end
		end)
	
		UserInputService.InputEnded:Connect(function(input, gpe)
			if input.UserInputType == Enum.UserInputType.MouseButton2 then
				rmbUpBindable:Fire()
			end
		end)
	end
	
	local holdPan = false
	local togglePan = false
	local lastRmbDown = 0 -- tick() timestamp of the last right mouse button down event
	
	local CameraInput = {}
	
	function CameraInput.getHoldPan()
		return holdPan
	end
	
	function CameraInput.getTogglePan()
		return togglePan
	end
	
	function CameraInput.getPanning()
		return togglePan or holdPan
	end
	
	function CameraInput.setTogglePan(value)
		togglePan = value
	end
	
	local cameraToggleInputEnabled = false
	local rmbDownConnection
	local rmbUpConnection
	
	function CameraInput.enableCameraToggleInput()
		if cameraToggleInputEnabled then
			return
		end
		cameraToggleInputEnabled = true
	
		holdPan = false
		togglePan = false
	
		if rmbDownConnection then
			rmbDownConnection:Disconnect()
		end
	
		if rmbUpConnection then
			rmbUpConnection:Disconnect()
		end
	
		rmbDownConnection = rmbDown:Connect(function()
			holdPan = true
			lastRmbDown = tick()
		end)
	
		rmbUpConnection = rmbUp:Connect(function()
			holdPan = false
			if tick() - lastRmbDown < MB_TAP_LENGTH and (togglePan or UserInputService:GetMouseDelta().Magnitude < 2) then
				togglePan = not togglePan
			end
		end)
	end
	
	function CameraInput.disableCameraToggleInput()
		if not cameraToggleInputEnabled then
			return
		end
		cameraToggleInputEnabled = false
	
		if rmbDownConnection then
			rmbDownConnection:Disconnect()
			rmbDownConnection = nil
		end
		if rmbUpConnection then
			rmbUpConnection:Disconnect()
			rmbUpConnection = nil
		end
	end
	
	return CameraInput
	end

	function _BaseCamera()
	--[[
		BaseCamera - Abstract base class for camera control modules
		2018 Camera Update - AllYourBlox
	--]]
	
	--[[ Local Constants ]]--
	local UNIT_Z = Vector3.new(0,0,1)
	local X1_Y0_Z1 = Vector3.new(1,0,1)	--Note: not a unit vector, used for projecting onto XZ plane
	
	local THUMBSTICK_DEADZONE = 0.2
	local DEFAULT_DISTANCE = 12.5	-- Studs
	local PORTRAIT_DEFAULT_DISTANCE = 25		-- Studs
	local FIRST_PERSON_DISTANCE_THRESHOLD = 1.0 -- Below this value, snap into first person
	
	local CAMERA_ACTION_PRIORITY = Enum.ContextActionPriority.Default.Value
	
	-- Note: DotProduct check in CoordinateFrame::lookAt() prevents using values within about
	-- 8.11 degrees of the +/- Y axis, that's why these limits are currently 80 degrees
	local MIN_Y = math.rad(-80)
	local MAX_Y = math.rad(80)
	
	local TOUCH_ADJUST_AREA_UP = math.rad(30)
	local TOUCH_ADJUST_AREA_DOWN = math.rad(-15)
	
	local TOUCH_SENSITIVTY_ADJUST_MAX_Y = 2.1
	local TOUCH_SENSITIVTY_ADJUST_MIN_Y = 0.5
	
	local VR_ANGLE = math.rad(15)
	local VR_LOW_INTENSITY_ROTATION = Vector2.new(math.rad(15), 0)
	local VR_HIGH_INTENSITY_ROTATION = Vector2.new(math.rad(45), 0)
	local VR_LOW_INTENSITY_REPEAT = 0.1
	local VR_HIGH_INTENSITY_REPEAT = 0.4
	
	local ZERO_VECTOR2 = Vector2.new(0,0)
	local ZERO_VECTOR3 = Vector3.new(0,0,0)
	
	local TOUCH_SENSITIVTY = Vector2.new(0.00945 * math.pi, 0.003375 * math.pi)
	local MOUSE_SENSITIVITY = Vector2.new( 0.002 * math.pi, 0.0015 * math.pi )
	
	local SEAT_OFFSET = Vector3.new(0,5,0)
	local VR_SEAT_OFFSET = Vector3.new(0,4,0)
	local HEAD_OFFSET = Vector3.new(0,1.5,0)
	local R15_HEAD_OFFSET = Vector3.new(0, 1.5, 0)
	local R15_HEAD_OFFSET_NO_SCALING = Vector3.new(0, 2, 0)
	local HUMANOID_ROOT_PART_SIZE = Vector3.new(2, 2, 1)
	
	local GAMEPAD_ZOOM_STEP_1 = 0
	local GAMEPAD_ZOOM_STEP_2 = 10
	local GAMEPAD_ZOOM_STEP_3 = 20
	
	local PAN_SENSITIVITY = 20
	local ZOOM_SENSITIVITY_CURVATURE = 0.5
	
	local abs = math.abs
	local sign = math.sign
	
	local FFlagUserCameraToggle do
		local success, result = pcall(function()
			return UserSettings():IsUserFeatureEnabled("UserCameraToggle")
		end)
		FFlagUserCameraToggle = success and result
	end
	
	local FFlagUserDontAdjustSensitvityForPortrait do
		local success, result = pcall(function()
			return UserSettings():IsUserFeatureEnabled("UserDontAdjustSensitvityForPortrait")
		end)
		FFlagUserDontAdjustSensitvityForPortrait = success and result
	end
	
	local FFlagUserFixZoomInZoomOutDiscrepancy do
		local success, result = pcall(function()
			return UserSettings():IsUserFeatureEnabled("UserFixZoomInZoomOutDiscrepancy")
		end)
		FFlagUserFixZoomInZoomOutDiscrepancy = success and result
	end
	
	local Util = _CameraUtils()
	local ZoomController = _ZoomController()
	local CameraToggleStateController = _CameraToggleStateController()
	local CameraInput = _CameraInput()
	local CameraUI = _CameraUI()
	
	--[[ Roblox Services ]]--
	local Players = game:GetService("Players")
	local UserInputService = game:GetService("UserInputService")
	local StarterGui = game:GetService("StarterGui")
	local GuiService = game:GetService("GuiService")
	local ContextActionService = game:GetService("ContextActionService")
	local VRService = game:GetService("VRService")
	local UserGameSettings = UserSettings():GetService("UserGameSettings")
	
	local player = Players.LocalPlayer 
	
	--[[ The Module ]]--
	local BaseCamera = {}
	BaseCamera.__index = BaseCamera
	
	function BaseCamera.new()
		local self = setmetatable({}, BaseCamera)
	
		-- So that derived classes have access to this
		self.FIRST_PERSON_DISTANCE_THRESHOLD = FIRST_PERSON_DISTANCE_THRESHOLD
	
		self.cameraType = nil
		self.cameraMovementMode = nil
	
		self.lastCameraTransform = nil
		self.rotateInput = ZERO_VECTOR2
		self.userPanningCamera = false
		self.lastUserPanCamera = tick()
	
		self.humanoidRootPart = nil
		self.humanoidCache = {}
	
		-- Subject and position on last update call
		self.lastSubject = nil
		self.lastSubjectPosition = Vector3.new(0,5,0)
	
		-- These subject distance members refer to the nominal camera-to-subject follow distance that the camera
		-- is trying to maintain, not the actual measured value.
		-- The default is updated when screen orientation or the min/max distances change,
		-- to be sure the default is always in range and appropriate for the orientation.
		self.defaultSubjectDistance = math.clamp(DEFAULT_DISTANCE, player.CameraMinZoomDistance, player.CameraMaxZoomDistance)
		self.currentSubjectDistance = math.clamp(DEFAULT_DISTANCE, player.CameraMinZoomDistance, player.CameraMaxZoomDistance)
	
		self.inFirstPerson = false
		self.inMouseLockedMode = false
		self.portraitMode = false
		self.isSmallTouchScreen = false
	
		-- Used by modules which want to reset the camera angle on respawn.
		self.resetCameraAngle = true
	
		self.enabled = false
	
		-- Input Event Connections
		self.inputBeganConn = nil
		self.inputChangedConn = nil
		self.inputEndedConn = nil
	
		self.startPos = nil
		self.lastPos = nil
		self.panBeginLook = nil
	
		self.panEnabled = true
		self.keyPanEnabled = true
		self.distanceChangeEnabled = true
	
		self.PlayerGui = nil
	
		self.cameraChangedConn = nil
		self.viewportSizeChangedConn = nil
	
		self.boundContextActions = {}
	
		-- VR Support
		self.shouldUseVRRotation = false
		self.VRRotationIntensityAvailable = false
		self.lastVRRotationIntensityCheckTime = 0
		self.lastVRRotationTime = 0
		self.vrRotateKeyCooldown = {}
		self.cameraTranslationConstraints = Vector3.new(1, 1, 1)
		self.humanoidJumpOrigin = nil
		self.trackingHumanoid = nil
		self.cameraFrozen = false
		self.subjectStateChangedConn = nil
	
		-- Gamepad support
		self.activeGamepad = nil
		self.gamepadPanningCamera = false
		self.lastThumbstickRotate = nil
		self.numOfSeconds = 0.7
		self.currentSpeed = 0
		self.maxSpeed = 6
		self.vrMaxSpeed = 4
		self.lastThumbstickPos = Vector2.new(0,0)
		self.ySensitivity = 0.65
		self.lastVelocity = nil
		self.gamepadConnectedConn = nil
		self.gamepadDisconnectedConn = nil
		self.currentZoomSpeed = 1.0
		self.L3ButtonDown = false
		self.dpadLeftDown = false
		self.dpadRightDown = false
	
		-- Touch input support
		self.isDynamicThumbstickEnabled = false
		self.fingerTouches = {}
		self.dynamicTouchInput = nil
		self.numUnsunkTouches = 0
		self.inputStartPositions = {}
		self.inputStartTimes = {}
		self.startingDiff = nil
		self.pinchBeginZoom = nil
		self.userPanningTheCamera = false
		self.touchActivateConn = nil
	
		-- Mouse locked formerly known as shift lock mode
		self.mouseLockOffset = ZERO_VECTOR3
	
		-- [[ NOTICE ]] --
		-- Initialization things used to always execute at game load time, but now these camera modules are instantiated
		-- when needed, so the code here may run well after the start of the game
	
		if player.Character then
			self:OnCharacterAdded(player.Character)
		end
	
		player.CharacterAdded:Connect(function(char)
			self:OnCharacterAdded(char)
		end)
	
		if self.cameraChangedConn then self.cameraChangedConn:Disconnect() end
		self.cameraChangedConn = workspace:GetPropertyChangedSignal("CurrentCamera"):Connect(function()
			self:OnCurrentCameraChanged()
		end)
		self:OnCurrentCameraChanged()
	
		if self.playerCameraModeChangeConn then self.playerCameraModeChangeConn:Disconnect() end
		self.playerCameraModeChangeConn = player:GetPropertyChangedSignal("CameraMode"):Connect(function()
			self:OnPlayerCameraPropertyChange()
		end)
	
		if self.minDistanceChangeConn then self.minDistanceChangeConn:Disconnect() end
		self.minDistanceChangeConn = player:GetPropertyChangedSignal("CameraMinZoomDistance"):Connect(function()
			self:OnPlayerCameraPropertyChange()
		end)
	
		if self.maxDistanceChangeConn then self.maxDistanceChangeConn:Disconnect() end
		self.maxDistanceChangeConn = player:GetPropertyChangedSignal("CameraMaxZoomDistance"):Connect(function()
			self:OnPlayerCameraPropertyChange()
		end)
	
		if self.playerDevTouchMoveModeChangeConn then self.playerDevTouchMoveModeChangeConn:Disconnect() end
		self.playerDevTouchMoveModeChangeConn = player:GetPropertyChangedSignal("DevTouchMovementMode"):Connect(function()
			self:OnDevTouchMovementModeChanged()
		end)
		self:OnDevTouchMovementModeChanged() -- Init
	
		if self.gameSettingsTouchMoveMoveChangeConn then self.gameSettingsTouchMoveMoveChangeConn:Disconnect() end
		self.gameSettingsTouchMoveMoveChangeConn = UserGameSettings:GetPropertyChangedSignal("TouchMovementMode"):Connect(function()
			self:OnGameSettingsTouchMovementModeChanged()
		end)
		self:OnGameSettingsTouchMovementModeChanged() -- Init
	
		UserGameSettings:SetCameraYInvertVisible()
		UserGameSettings:SetGamepadCameraSensitivityVisible()
	
		self.hasGameLoaded = game:IsLoaded()
		if not self.hasGameLoaded then
			self.gameLoadedConn = game.Loaded:Connect(function()
				self.hasGameLoaded = true
				self.gameLoadedConn:Disconnect()
				self.gameLoadedConn = nil
			end)
		end
	
		self:OnPlayerCameraPropertyChange()
	
		return self
	end
	
	function BaseCamera:GetModuleName()
		return "BaseCamera"
	end
	
	function BaseCamera:OnCharacterAdded(char)
		self.resetCameraAngle = self.resetCameraAngle or self:GetEnabled()
		self.humanoidRootPart = nil
		if UserInputService.TouchEnabled then
			self.PlayerGui = player:WaitForChild("PlayerGui")
			for _, child in ipairs(char:GetChildren()) do
				if child:IsA("Tool") then
					self.isAToolEquipped = true
				end
			end
			char.ChildAdded:Connect(function(child)
				if child:IsA("Tool") then
					self.isAToolEquipped = true
				end
			end)
			char.ChildRemoved:Connect(function(child)
				if child:IsA("Tool") then
					self.isAToolEquipped = false
				end
			end)
		end
	end
	
	function BaseCamera:GetHumanoidRootPart()
		if not self.humanoidRootPart then
			if player.Character then
				local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
				if humanoid then
					self.humanoidRootPart = humanoid.RootPart
				end
			end
		end
		return self.humanoidRootPart
	end
	
	function BaseCamera:GetBodyPartToFollow(humanoid, isDead)
		-- If the humanoid is dead, prefer the head part if one still exists as a sibling of the humanoid
		if humanoid:GetState() == Enum.HumanoidStateType.Dead then
			local character = humanoid.Parent
			if character and character:IsA("Model") then
				return character:FindFirstChild("Head") or humanoid.RootPart
			end
		end
	
		return humanoid.RootPart
	end
	
	function BaseCamera:GetSubjectPosition()
		local result = self.lastSubjectPosition
		local camera = game.Workspace.CurrentCamera
		local cameraSubject = camera and camera.CameraSubject
	
		if cameraSubject then
			if cameraSubject:IsA("Humanoid") then
				local humanoid = cameraSubject
				local humanoidIsDead = humanoid:GetState() == Enum.HumanoidStateType.Dead
	
				if VRService.VREnabled and humanoidIsDead and humanoid == self.lastSubject then
					result = self.lastSubjectPosition
				else
					local bodyPartToFollow = humanoid.RootPart
	
					-- If the humanoid is dead, prefer their head part as a follow target, if it exists
					if humanoidIsDead then
						if humanoid.Parent and humanoid.Parent:IsA("Model") then
							bodyPartToFollow = humanoid.Parent:FindFirstChild("Head") or bodyPartToFollow
						end
					end
	
					if bodyPartToFollow and bodyPartToFollow:IsA("BasePart") then
						local heightOffset
						if humanoid.RigType == Enum.HumanoidRigType.R15 then
							if humanoid.AutomaticScalingEnabled then
								heightOffset = R15_HEAD_OFFSET
								if bodyPartToFollow == humanoid.RootPart then
									local rootPartSizeOffset = (humanoid.RootPart.Size.Y/2) - (HUMANOID_ROOT_PART_SIZE.Y/2)
									heightOffset = heightOffset + Vector3.new(0, rootPartSizeOffset, 0)
								end
							else
								heightOffset = R15_HEAD_OFFSET_NO_SCALING
							end
						else
							heightOffset = HEAD_OFFSET
						end
	
						if humanoidIsDead then
							heightOffset = ZERO_VECTOR3
						end
	
						result = bodyPartToFollow.CFrame.p + bodyPartToFollow.CFrame:vectorToWorldSpace(heightOffset + humanoid.CameraOffset)
					end
				end
	
			elseif cameraSubject:IsA("VehicleSeat") then
				local offset = SEAT_OFFSET
				if VRService.VREnabled then
					offset = VR_SEAT_OFFSET
				end
				result = cameraSubject.CFrame.p + cameraSubject.CFrame:vectorToWorldSpace(offset)
			elseif cameraSubject:IsA("SkateboardPlatform") then
				result = cameraSubject.CFrame.p + SEAT_OFFSET
			elseif cameraSubject:IsA("BasePart") then
				result = cameraSubject.CFrame.p
			elseif cameraSubject:IsA("Model") then
				if cameraSubject.PrimaryPart then
					result = cameraSubject:GetPrimaryPartCFrame().p
				else
					result = cameraSubject:GetModelCFrame().p
				end
			end
		else
			-- cameraSubject is nil
			-- Note: Previous RootCamera did not have this else case and let self.lastSubject and self.lastSubjectPosition
			-- both get set to nil in the case of cameraSubject being nil. This function now exits here to preserve the
			-- last set valid values for these, as nil values are not handled cases
			return
		end
	
		self.lastSubject = cameraSubject
		self.lastSubjectPosition = result
	
		return result
	end
	
	function BaseCamera:UpdateDefaultSubjectDistance()
		if self.portraitMode then
			self.defaultSubjectDistance = math.clamp(PORTRAIT_DEFAULT_DISTANCE, player.CameraMinZoomDistance, player.CameraMaxZoomDistance)
		else
			self.defaultSubjectDistance = math.clamp(DEFAULT_DISTANCE, player.CameraMinZoomDistance, player.CameraMaxZoomDistance)
		end
	end
	
	function BaseCamera:OnViewportSizeChanged()
		local camera = game.Workspace.CurrentCamera
		local size = camera.ViewportSize
		self.portraitMode = size.X < size.Y
		self.isSmallTouchScreen = UserInputService.TouchEnabled and (size.Y < 500 or size.X < 700)
	
		self:UpdateDefaultSubjectDistance()
	end
	
	-- Listener for changes to workspace.CurrentCamera
	function BaseCamera:OnCurrentCameraChanged()
		if UserInputService.TouchEnabled then
			if self.viewportSizeChangedConn then
				self.viewportSizeChangedConn:Disconnect()
				self.viewportSizeChangedConn = nil
			end
	
			local newCamera = game.Workspace.CurrentCamera
	
			if newCamera then
				self:OnViewportSizeChanged()
				self.viewportSizeChangedConn = newCamera:GetPropertyChangedSignal("ViewportSize"):Connect(function()
					self:OnViewportSizeChanged()
				end)
			end
		end
	
		-- VR support additions
		if self.cameraSubjectChangedConn then
			self.cameraSubjectChangedConn:Disconnect()
			self.cameraSubjectChangedConn = nil
		end
	
		local camera = game.Workspace.CurrentCamera
		if camera then
			self.cameraSubjectChangedConn = camera:GetPropertyChangedSignal("CameraSubject"):Connect(function()
				self:OnNewCameraSubject()
			end)
			self:OnNewCameraSubject()
		end
	end
	
	function BaseCamera:OnDynamicThumbstickEnabled()
		if UserInputService.TouchEnabled then
			self.isDynamicThumbstickEnabled = true
		end
	end
	
	function BaseCamera:OnDynamicThumbstickDisabled()
		self.isDynamicThumbstickEnabled = false
	end
	
	function BaseCamera:OnGameSettingsTouchMovementModeChanged()
		if player.DevTouchMovementMode == Enum.DevTouchMovementMode.UserChoice then
			if (UserGameSettings.TouchMovementMode == Enum.TouchMovementMode.DynamicThumbstick
				or UserGameSettings.TouchMovementMode == Enum.TouchMovementMode.Default) then
				self:OnDynamicThumbstickEnabled()
			else
				self:OnDynamicThumbstickDisabled()
			end
		end
	end
	
	function BaseCamera:OnDevTouchMovementModeChanged()
		if player.DevTouchMovementMode.Name == "DynamicThumbstick" then
			self:OnDynamicThumbstickEnabled()
		else
			self:OnGameSettingsTouchMovementModeChanged()
		end
	end
	
	function BaseCamera:OnPlayerCameraPropertyChange()
		-- This call forces re-evaluation of player.CameraMode and clamping to min/max distance which may have changed
		self:SetCameraToSubjectDistance(self.currentSubjectDistance)
	end
	
	function BaseCamera:GetCameraHeight()
		if VRService.VREnabled and not self.inFirstPerson then
			return math.sin(VR_ANGLE) * self.currentSubjectDistance
		end
		return 0
	end
	
	function BaseCamera:InputTranslationToCameraAngleChange(translationVector, sensitivity)
		if not FFlagUserDontAdjustSensitvityForPortrait then
			local camera = game.Workspace.CurrentCamera
			if camera and camera.ViewportSize.X > 0 and camera.ViewportSize.Y > 0 and (camera.ViewportSize.Y > camera.ViewportSize.X) then
				-- Screen has portrait orientation, swap X and Y sensitivity
				return translationVector * Vector2.new( sensitivity.Y, sensitivity.X)
			end
		end
		return translationVector * sensitivity
	end
	
	function BaseCamera:Enable(enable)
		if self.enabled ~= enable then
			self.enabled = enable
			if self.enabled then
				self:ConnectInputEvents()
				self:BindContextActions()
	
				if player.CameraMode == Enum.CameraMode.LockFirstPerson then
					self.currentSubjectDistance = 0.5
					if not self.inFirstPerson then
						self:EnterFirstPerson()
					end
				end
			else
				self:DisconnectInputEvents()
				self:UnbindContextActions()
				-- Clean up additional event listeners and reset a bunch of properties
				self:Cleanup()
			end
		end
	end
	
	function BaseCamera:GetEnabled()
		return self.enabled
	end
	
	function BaseCamera:OnInputBegan(input, processed)
		if input.UserInputType == Enum.UserInputType.Touch then
			self:OnTouchBegan(input, processed)
		elseif input.UserInputType == Enum.UserInputType.MouseButton2 then
			self:OnMouse2Down(input, processed)
		elseif input.UserInputType == Enum.UserInputType.MouseButton3 then
			self:OnMouse3Down(input, processed)
		end
	end
	
	function BaseCamera:OnInputChanged(input, processed)
		if input.UserInputType == Enum.UserInputType.Touch then
			self:OnTouchChanged(input, processed)
		elseif input.UserInputType == Enum.UserInputType.MouseMovement then
			self:OnMouseMoved(input, processed)
		end
	end
	
	function BaseCamera:OnInputEnded(input, processed)
		if input.UserInputType == Enum.UserInputType.Touch then
			self:OnTouchEnded(input, processed)
		elseif input.UserInputType == Enum.UserInputType.MouseButton2 then
			self:OnMouse2Up(input, processed)
		elseif input.UserInputType == Enum.UserInputType.MouseButton3 then
			self:OnMouse3Up(input, processed)
		end
	end
	
	function BaseCamera:OnPointerAction(wheel, pan, pinch, processed)
		if processed then
			return
		end
	
		if pan.Magnitude > 0 then
			local inversionVector = Vector2.new(1, UserGameSettings:GetCameraYInvertValue())
			local rotateDelta = self:InputTranslationToCameraAngleChange(PAN_SENSITIVITY*pan, MOUSE_SENSITIVITY)*inversionVector
			self.rotateInput = self.rotateInput + rotateDelta
		end
	
		local zoom = self.currentSubjectDistance
		local zoomDelta = -(wheel + pinch)
	
		if abs(zoomDelta) > 0 then
			local newZoom
			if self.inFirstPerson and zoomDelta > 0 then
				newZoom = FIRST_PERSON_DISTANCE_THRESHOLD
			else
				if FFlagUserFixZoomInZoomOutDiscrepancy then
					if (zoomDelta > 0) then
						newZoom = zoom + zoomDelta*(1 + zoom*ZOOM_SENSITIVITY_CURVATURE)
					else
						newZoom = (zoom + zoomDelta) / (1 - zoomDelta*ZOOM_SENSITIVITY_CURVATURE)
					end
				else
					newZoom = zoom + zoomDelta*(1 + zoom*ZOOM_SENSITIVITY_CURVATURE)
				end
			end
	
			self:SetCameraToSubjectDistance(newZoom)
		end
	end
	
	function BaseCamera:ConnectInputEvents()
		self.pointerActionConn = UserInputService.PointerAction:Connect(function(wheel, pan, pinch, processed)
			self:OnPointerAction(wheel, pan, pinch, processed)
		end)
	
		self.inputBeganConn = UserInputService.InputBegan:Connect(function(input, processed)
			self:OnInputBegan(input, processed)
		end)
	
		self.inputChangedConn = UserInputService.InputChanged:Connect(function(input, processed)
			self:OnInputChanged(input, processed)
		end)
	
		self.inputEndedConn = UserInputService.InputEnded:Connect(function(input, processed)
			self:OnInputEnded(input, processed)
		end)
	
		self.menuOpenedConn = GuiService.MenuOpened:connect(function()
			self:ResetInputStates()
		end)
	
		self.gamepadConnectedConn = UserInputService.GamepadDisconnected:connect(function(gamepadEnum)
			if self.activeGamepad ~= gamepadEnum then return end
			self.activeGamepad = nil
			self:AssignActivateGamepad()
		end)
	
		self.gamepadDisconnectedConn = UserInputService.GamepadConnected:connect(function(gamepadEnum)
			if self.activeGamepad == nil then
				self:AssignActivateGamepad()
			end
		end)
	
		self:AssignActivateGamepad()
		if not FFlagUserCameraToggle then
			self:UpdateMouseBehavior()
		end
	end
	
	function BaseCamera:BindContextActions()
		self:BindGamepadInputActions()
		self:BindKeyboardInputActions()
	end
	
	function BaseCamera:AssignActivateGamepad()
		local connectedGamepads = UserInputService:GetConnectedGamepads()
		if #connectedGamepads > 0 then
			for i = 1, #connectedGamepads do
				if self.activeGamepad == nil then
					self.activeGamepad = connectedGamepads[i]
				elseif connectedGamepads[i].Value < self.activeGamepad.Value then
					self.activeGamepad = connectedGamepads[i]
				end
			end
		end
	
		if self.activeGamepad == nil then -- nothing is connected, at least set up for gamepad1
			self.activeGamepad = Enum.UserInputType.Gamepad1
		end
	end
	
	function BaseCamera:DisconnectInputEvents()
		if self.inputBeganConn then
			self.inputBeganConn:Disconnect()
			self.inputBeganConn = nil
		end
		if self.inputChangedConn then
			self.inputChangedConn:Disconnect()
			self.inputChangedConn = nil
		end
		if self.inputEndedConn then
			self.inputEndedConn:Disconnect()
			self.inputEndedConn = nil
		end
	end
	
	function BaseCamera:UnbindContextActions()
		for i = 1, #self.boundContextActions do
			ContextActionService:UnbindAction(self.boundContextActions[i])
		end
		self.boundContextActions = {}
	end
	
	function BaseCamera:Cleanup()
		if self.pointerActionConn then
			self.pointerActionConn:Disconnect()
			self.pointerActionConn = nil
		end
		if self.menuOpenedConn then
			self.menuOpenedConn:Disconnect()
			self.menuOpenedConn = nil
		end
		if self.mouseLockToggleConn then
			self.mouseLockToggleConn:Disconnect()
			self.mouseLockToggleConn = nil
		end
		if self.gamepadConnectedConn then
			self.gamepadConnectedConn:Disconnect()
			self.gamepadConnectedConn = nil
		end
		if self.gamepadDisconnectedConn then
			self.gamepadDisconnectedConn:Disconnect()
			self.gamepadDisconnectedConn = nil
		end
		if self.subjectStateChangedConn then
			self.subjectStateChangedConn:Disconnect()
			self.subjectStateChangedConn = nil
		end
		if self.viewportSizeChangedConn then
			self.viewportSizeChangedConn:Disconnect()
			self.viewportSizeChangedConn = nil
		end
		if self.touchActivateConn then
			self.touchActivateConn:Disconnect()
			self.touchActivateConn = nil
		end
	
		self.turningLeft = false
		self.turningRight = false
		self.lastCameraTransform = nil
		self.lastSubjectCFrame = nil
		self.userPanningTheCamera = false
		self.rotateInput = Vector2.new()
		self.gamepadPanningCamera = Vector2.new(0,0)
	
		-- Reset input states
		self.startPos = nil
		self.lastPos = nil
		self.panBeginLook = nil
		self.isRightMouseDown = false
		self.isMiddleMouseDown = false
	
		self.fingerTouches = {}
		self.dynamicTouchInput = nil
		self.numUnsunkTouches = 0
	
		self.startingDiff = nil
		self.pinchBeginZoom = nil
	
		-- Unlock mouse for example if right mouse button was being held down
		if UserInputService.MouseBehavior ~= Enum.MouseBehavior.LockCenter then
			UserInputService.MouseBehavior = Enum.MouseBehavior.Default
		end
	end
	
	-- This is called when settings menu is opened
	function BaseCamera:ResetInputStates()
		self.isRightMouseDown = false
		self.isMiddleMouseDown = false
		self:OnMousePanButtonReleased() -- this function doesn't seem to actually need parameters
	
		if UserInputService.TouchEnabled then
			--[[menu opening was causing serious touch issues
			this should disable all active touch events if
			they're active when menu opens.]]
			for inputObject in pairs(self.fingerTouches) do
				self.fingerTouches[inputObject] = nil
			end
			self.dynamicTouchInput = nil
			self.panBeginLook = nil
			self.startPos = nil
			self.lastPos = nil
			self.userPanningTheCamera = false
			self.startingDiff = nil
			self.pinchBeginZoom = nil
			self.numUnsunkTouches = 0
		end
	end
	
	function BaseCamera:GetGamepadPan(name, state, input)
		if input.UserInputType == self.activeGamepad and input.KeyCode == Enum.KeyCode.Thumbstick2 then
	--		if self.L3ButtonDown then
	--			-- L3 Thumbstick is depressed, right stick controls dolly in/out
	--			if (input.Position.Y > THUMBSTICK_DEADZONE) then
	--				self.currentZoomSpeed = 0.96
	--			elseif (input.Position.Y < -THUMBSTICK_DEADZONE) then
	--				self.currentZoomSpeed = 1.04
	--			else
	--				self.currentZoomSpeed = 1.00
	--			end
	--		else
				if state == Enum.UserInputState.Cancel then
					self.gamepadPanningCamera = ZERO_VECTOR2
					return
				end
	
				local inputVector = Vector2.new(input.Position.X, -input.Position.Y)
				if inputVector.magnitude > THUMBSTICK_DEADZONE then
					self.gamepadPanningCamera = Vector2.new(input.Position.X, -input.Position.Y)
				else
					self.gamepadPanningCamera = ZERO_VECTOR2
				end
			--end
			return Enum.ContextActionResult.Sink
		end
		return Enum.ContextActionResult.Pass
	end
	
	function BaseCamera:DoKeyboardPanTurn(name, state, input)
		if not self.hasGameLoaded and VRService.VREnabled then
			return Enum.ContextActionResult.Pass
		end
	
		if state == Enum.UserInputState.Cancel then
			self.turningLeft = false
			self.turningRight = false
			return Enum.ContextActionResult.Sink
		end
	
		if self.panBeginLook == nil and self.keyPanEnabled then
			if input.KeyCode == Enum.KeyCode.Left then
				self.turningLeft = state == Enum.UserInputState.Begin
			elseif input.KeyCode == Enum.KeyCode.Right then
				self.turningRight = state == Enum.UserInputState.Begin
			end
			return Enum.ContextActionResult.Sink
		end
		return Enum.ContextActionResult.Pass
	end
	
	function BaseCamera:DoPanRotateCamera(rotateAngle)
		local angle = Util.RotateVectorByAngleAndRound(self:GetCameraLookVector() * Vector3.new(1,0,1), rotateAngle, math.pi*0.25)
		if angle ~= 0 then
			self.rotateInput = self.rotateInput + Vector2.new(angle, 0)
			self.lastUserPanCamera = tick()
			self.lastCameraTransform = nil
		end
	end
	
	function BaseCamera:DoGamepadZoom(name, state, input)
		if input.UserInputType == self.activeGamepad then
			if input.KeyCode == Enum.KeyCode.ButtonR3 then
				if state == Enum.UserInputState.Begin then
					if self.distanceChangeEnabled then
						local dist = self:GetCameraToSubjectDistance()
	
						if dist > (GAMEPAD_ZOOM_STEP_2 + GAMEPAD_ZOOM_STEP_3)/2 then
							self:SetCameraToSubjectDistance(GAMEPAD_ZOOM_STEP_2)
						elseif dist > (GAMEPAD_ZOOM_STEP_1 + GAMEPAD_ZOOM_STEP_2)/2 then
							self:SetCameraToSubjectDistance(GAMEPAD_ZOOM_STEP_1)
						else
							self:SetCameraToSubjectDistance(GAMEPAD_ZOOM_STEP_3)
						end
					end
				end
			elseif input.KeyCode == Enum.KeyCode.DPadLeft then
				self.dpadLeftDown = (state == Enum.UserInputState.Begin)
			elseif input.KeyCode == Enum.KeyCode.DPadRight then
				self.dpadRightDown = (state == Enum.UserInputState.Begin)
			end
	
			if self.dpadLeftDown then
				self.currentZoomSpeed = 1.04
			elseif self.dpadRightDown then
				self.currentZoomSpeed = 0.96
			else
				self.currentZoomSpeed = 1.00
			end
			return Enum.ContextActionResult.Sink
		end
		return Enum.ContextActionResult.Pass
	--	elseif input.UserInputType == self.activeGamepad and input.KeyCode == Enum.KeyCode.ButtonL3 then
	--		if (state == Enum.UserInputState.Begin) then
	--			self.L3ButtonDown = true
	--		elseif (state == Enum.UserInputState.End) then
	--			self.L3ButtonDown = false
	--			self.currentZoomSpeed = 1.00
	--		end
	--	end
	end
	
	function BaseCamera:DoKeyboardZoom(name, state, input)
		if not self.hasGameLoaded and VRService.VREnabled then
			return Enum.ContextActionResult.Pass
		end
	
		if state ~= Enum.UserInputState.Begin then
			return Enum.ContextActionResult.Pass
		end
	
		if self.distanceChangeEnabled and player.CameraMode ~= Enum.CameraMode.LockFirstPerson then
			if input.KeyCode == Enum.KeyCode.I then
				self:SetCameraToSubjectDistance( self.currentSubjectDistance - 5 )
			elseif input.KeyCode == Enum.KeyCode.O then
				self:SetCameraToSubjectDistance( self.currentSubjectDistance + 5 )
			end
			return Enum.ContextActionResult.Sink
		end
		return Enum.ContextActionResult.Pass
	end
	
	function BaseCamera:BindAction(actionName, actionFunc, createTouchButton, ...)
		table.insert(self.boundContextActions, actionName)
		ContextActionService:BindActionAtPriority(actionName, actionFunc, createTouchButton,
			CAMERA_ACTION_PRIORITY, ...)
	end
	
	function BaseCamera:BindGamepadInputActions()
		self:BindAction("BaseCameraGamepadPan", function(name, state, input) return self:GetGamepadPan(name, state, input) end,
			false, Enum.KeyCode.Thumbstick2)
		self:BindAction("BaseCameraGamepadZoom", function(name, state, input) return self:DoGamepadZoom(name, state, input) end,
			false, Enum.KeyCode.DPadLeft, Enum.KeyCode.DPadRight, Enum.KeyCode.ButtonR3)
	end
	
	function BaseCamera:BindKeyboardInputActions()
		self:BindAction("BaseCameraKeyboardPanArrowKeys", function(name, state, input) return self:DoKeyboardPanTurn(name, state, input) end,
			false, Enum.KeyCode.Left, Enum.KeyCode.Right)
		self:BindAction("BaseCameraKeyboardZoom", function(name, state, input) return self:DoKeyboardZoom(name, state, input) end,
			false, Enum.KeyCode.I, Enum.KeyCode.O)
	end
	
	local function isInDynamicThumbstickArea(input)
		local playerGui = player:FindFirstChildOfClass("PlayerGui")
		local touchGui = playerGui and playerGui:FindFirstChild("TouchGui")
		local touchFrame = touchGui and touchGui:FindFirstChild("TouchControlFrame")
		local thumbstickFrame = touchFrame and touchFrame:FindFirstChild("DynamicThumbstickFrame")
	
		if not thumbstickFrame then
			return false
		end
	
		local frameCornerTopLeft = thumbstickFrame.AbsolutePosition
		local frameCornerBottomRight = frameCornerTopLeft + thumbstickFrame.AbsoluteSize
		if input.Position.X >= frameCornerTopLeft.X and input.Position.Y >= frameCornerTopLeft.Y then
			if input.Position.X <= frameCornerBottomRight.X and input.Position.Y <= frameCornerBottomRight.Y then
				return true
			end
		end
	
		return false
	end
	
	---Adjusts the camera Y touch Sensitivity when moving away from the center and in the TOUCH_SENSITIVTY_ADJUST_AREA
	function BaseCamera:AdjustTouchSensitivity(delta, sensitivity)
		local cameraCFrame = game.Workspace.CurrentCamera and game.Workspace.CurrentCamera.CFrame
		if not cameraCFrame then
			return sensitivity
		end
		local currPitchAngle = cameraCFrame:ToEulerAnglesYXZ()
	
		local multiplierY = TOUCH_SENSITIVTY_ADJUST_MAX_Y
		if currPitchAngle > TOUCH_ADJUST_AREA_UP and delta.Y < 0 then
			local fractionAdjust = (currPitchAngle - TOUCH_ADJUST_AREA_UP)/(MAX_Y - TOUCH_ADJUST_AREA_UP)
			fractionAdjust = 1 - (1 - fractionAdjust)^3
			multiplierY = TOUCH_SENSITIVTY_ADJUST_MAX_Y - fractionAdjust * (
				TOUCH_SENSITIVTY_ADJUST_MAX_Y - TOUCH_SENSITIVTY_ADJUST_MIN_Y)
		elseif currPitchAngle < TOUCH_ADJUST_AREA_DOWN and delta.Y > 0 then
			local fractionAdjust = (currPitchAngle - TOUCH_ADJUST_AREA_DOWN)/(MIN_Y - TOUCH_ADJUST_AREA_DOWN)
			fractionAdjust = 1 - (1 - fractionAdjust)^3
			multiplierY = TOUCH_SENSITIVTY_ADJUST_MAX_Y - fractionAdjust * (
				TOUCH_SENSITIVTY_ADJUST_MAX_Y - TOUCH_SENSITIVTY_ADJUST_MIN_Y)
		end
	
		return Vector2.new(
			sensitivity.X,
			sensitivity.Y * multiplierY
		)
	end
	
	function BaseCamera:OnTouchBegan(input, processed)
		local canUseDynamicTouch = self.isDynamicThumbstickEnabled and not processed
		if canUseDynamicTouch then
			if self.dynamicTouchInput == nil and isInDynamicThumbstickArea(input) then
				-- First input in the dynamic thumbstick area should always be ignored for camera purposes
				-- Even if the dynamic thumbstick does not process it immediately
				self.dynamicTouchInput = input
				return
			end
			self.fingerTouches[input] = processed
			self.inputStartPositions[input] = input.Position
			self.inputStartTimes[input] = tick()
			self.numUnsunkTouches = self.numUnsunkTouches + 1
		end
	end
	
	function BaseCamera:OnTouchChanged(input, processed)
		if self.fingerTouches[input] == nil then
			if self.isDynamicThumbstickEnabled then
				return
			end
			self.fingerTouches[input] = processed
			if not processed then
				self.numUnsunkTouches = self.numUnsunkTouches + 1
			end
		end
	
		if self.numUnsunkTouches == 1 then
			if self.fingerTouches[input] == false then
				self.panBeginLook = self.panBeginLook or self:GetCameraLookVector()
				self.startPos = self.startPos or input.Position
				self.lastPos = self.lastPos or self.startPos
				self.userPanningTheCamera = true
	
				local delta = input.Position - self.lastPos
				delta = Vector2.new(delta.X, delta.Y * UserGameSettings:GetCameraYInvertValue())
				if self.panEnabled then
					local adjustedTouchSensitivity = TOUCH_SENSITIVTY
					self:AdjustTouchSensitivity(delta, TOUCH_SENSITIVTY)
	
					local desiredXYVector = self:InputTranslationToCameraAngleChange(delta, adjustedTouchSensitivity)
					self.rotateInput = self.rotateInput + desiredXYVector
				end
				self.lastPos = input.Position
			end
		else
			self.panBeginLook = nil
			self.startPos = nil
			self.lastPos = nil
			self.userPanningTheCamera = false
		end
		if self.numUnsunkTouches == 2 then
			local unsunkTouches = {}
			for touch, wasSunk in pairs(self.fingerTouches) do
				if not wasSunk then
					table.insert(unsunkTouches, touch)
				end
			end
			if #unsunkTouches == 2 then
				local difference = (unsunkTouches[1].Position - unsunkTouches[2].Position).magnitude
				if self.startingDiff and self.pinchBeginZoom then
					local scale = difference / math.max(0.01, self.startingDiff)
					local clampedScale = math.clamp(scale, 0.1, 10)
					if self.distanceChangeEnabled then
						self:SetCameraToSubjectDistance(self.pinchBeginZoom / clampedScale)
					end
				else
					self.startingDiff = difference
					self.pinchBeginZoom = self:GetCameraToSubjectDistance()
				end
			end
		else
			self.startingDiff = nil
			self.pinchBeginZoom = nil
		end
	end
	
	function BaseCamera:OnTouchEnded(input, processed)
		if input == self.dynamicTouchInput then
			self.dynamicTouchInput = nil
			return
		end
	
		if self.fingerTouches[input] == false then
			if self.numUnsunkTouches == 1 then
				self.panBeginLook = nil
				self.startPos = nil
				self.lastPos = nil
				self.userPanningTheCamera = false
			elseif self.numUnsunkTouches == 2 then
				self.startingDiff = nil
				self.pinchBeginZoom = nil
			end
		end
	
		if self.fingerTouches[input] ~= nil and self.fingerTouches[input] == false then
			self.numUnsunkTouches = self.numUnsunkTouches - 1
		end
		self.fingerTouches[input] = nil
		self.inputStartPositions[input] = nil
		self.inputStartTimes[input] = nil
	end
	
	function BaseCamera:OnMouse2Down(input, processed)
		if processed then return end
	
		self.isRightMouseDown = true
		self:OnMousePanButtonPressed(input, processed)
	end
	
	function BaseCamera:OnMouse2Up(input, processed)
		self.isRightMouseDown = false
		self:OnMousePanButtonReleased(input, processed)
	end
	
	function BaseCamera:OnMouse3Down(input, processed)
		if processed then return end
	
		self.isMiddleMouseDown = true
		self:OnMousePanButtonPressed(input, processed)
	end
	
	function BaseCamera:OnMouse3Up(input, processed)
		self.isMiddleMouseDown = false
		self:OnMousePanButtonReleased(input, processed)
	end
	
	function BaseCamera:OnMouseMoved(input, processed)
		if not self.hasGameLoaded and VRService.VREnabled then
			return
		end
	
		local inputDelta = input.Delta
		inputDelta = Vector2.new(inputDelta.X, inputDelta.Y * UserGameSettings:GetCameraYInvertValue())
	
		local isInputPanning = FFlagUserCameraToggle and CameraInput.getPanning()
		local isBeginLook = self.startPos and self.lastPos and self.panBeginLook
		local isPanning = isBeginLook or self.inFirstPerson or self.inMouseLockedMode or isInputPanning
	
		if self.panEnabled and isPanning then
			local desiredXYVector = self:InputTranslationToCameraAngleChange(inputDelta, MOUSE_SENSITIVITY)
			self.rotateInput = self.rotateInput + desiredXYVector
		end
	
		if self.startPos and self.lastPos and self.panBeginLook then
			self.lastPos = self.lastPos + input.Delta
		end
	end
	
	function BaseCamera:OnMousePanButtonPressed(input, processed)
		if processed then return end
		if not FFlagUserCameraToggle then
			self:UpdateMouseBehavior()
		end
		self.panBeginLook = self.panBeginLook or self:GetCameraLookVector()
		self.startPos = self.startPos or input.Position
		self.lastPos = self.lastPos or self.startPos
		self.userPanningTheCamera = true
	end
	
	function BaseCamera:OnMousePanButtonReleased(input, processed)
		if not FFlagUserCameraToggle then
			self:UpdateMouseBehavior()
		end
		if not (self.isRightMouseDown or self.isMiddleMouseDown) then
			self.panBeginLook = nil
			self.startPos = nil
			self.lastPos = nil
			self.userPanningTheCamera = false
		end
	end
	
	function BaseCamera:UpdateMouseBehavior()
		if FFlagUserCameraToggle and self.isCameraToggle then
			CameraUI.setCameraModeToastEnabled(true)
			CameraInput.enableCameraToggleInput()
			CameraToggleStateController(self.inFirstPerson)
		else
			if FFlagUserCameraToggle then
				CameraUI.setCameraModeToastEnabled(false)
				CameraInput.disableCameraToggleInput()
			end
			-- first time transition to first person mode or mouse-locked third person
			if self.inFirstPerson or self.inMouseLockedMode then
				--UserGameSettings.RotationType = Enum.RotationType.CameraRelative
				UserInputService.MouseBehavior = Enum.MouseBehavior.LockCenter
			else
				UserGameSettings.RotationType = Enum.RotationType.MovementRelative
				if self.isRightMouseDown or self.isMiddleMouseDown then
					UserInputService.MouseBehavior = Enum.MouseBehavior.LockCurrentPosition
				else
					UserInputService.MouseBehavior = Enum.MouseBehavior.Default
				end
			end
		end
	end
	
	function BaseCamera:UpdateForDistancePropertyChange()
		-- Calling this setter with the current value will force checking that it is still
		-- in range after a change to the min/max distance limits
		self:SetCameraToSubjectDistance(self.currentSubjectDistance)
	end
	
	function BaseCamera:SetCameraToSubjectDistance(desiredSubjectDistance)
		local lastSubjectDistance = self.currentSubjectDistance
	
		-- By default, camera modules will respect LockFirstPerson and override the currentSubjectDistance with 0
		-- regardless of what Player.CameraMinZoomDistance is set to, so that first person can be made
		-- available by the developer without needing to allow players to mousewheel dolly into first person.
		-- Some modules will override this function to remove or change first-person capability.
		if player.CameraMode == Enum.CameraMode.LockFirstPerson then
			self.currentSubjectDistance = 0.5
			if not self.inFirstPerson then
				self:EnterFirstPerson()
			end
		else
			local newSubjectDistance = math.clamp(desiredSubjectDistance, player.CameraMinZoomDistance, player.CameraMaxZoomDistance)
			if newSubjectDistance < FIRST_PERSON_DISTANCE_THRESHOLD then
				self.currentSubjectDistance = 0.5
				if not self.inFirstPerson then
					self:EnterFirstPerson()
				end
			else
				self.currentSubjectDistance = newSubjectDistance
				if self.inFirstPerson then
					self:LeaveFirstPerson()
				end
			end
		end
	
		-- Pass target distance and zoom direction to the zoom controller
		ZoomController.SetZoomParameters(self.currentSubjectDistance, math.sign(desiredSubjectDistance - lastSubjectDistance))
	
		-- Returned only for convenience to the caller to know the outcome
		return self.currentSubjectDistance
	end
	
	function BaseCamera:SetCameraType( cameraType )
		--Used by derived classes
		self.cameraType = cameraType
	end
	
	function BaseCamera:GetCameraType()
		return self.cameraType
	end
	
	-- Movement mode standardized to Enum.ComputerCameraMovementMode values
	function BaseCamera:SetCameraMovementMode( cameraMovementMode )
		self.cameraMovementMode = cameraMovementMode
	end
	
	function BaseCamera:GetCameraMovementMode()
		return self.cameraMovementMode
	end
	
	function BaseCamera:SetIsMouseLocked(mouseLocked)
		self.inMouseLockedMode = mouseLocked
		if not FFlagUserCameraToggle then
			self:UpdateMouseBehavior()
		end
	end
	
	function BaseCamera:GetIsMouseLocked()
		return self.inMouseLockedMode
	end
	
	function BaseCamera:SetMouseLockOffset(offsetVector)
		self.mouseLockOffset = offsetVector
	end
	
	function BaseCamera:GetMouseLockOffset()
		return self.mouseLockOffset
	end
	
	function BaseCamera:InFirstPerson()
		return self.inFirstPerson
	end
	
	function BaseCamera:EnterFirstPerson()
		-- Overridden in ClassicCamera, the only module which supports FirstPerson
	end
	
	function BaseCamera:LeaveFirstPerson()
		-- Overridden in ClassicCamera, the only module which supports FirstPerson
	end
	
	-- Nominal distance, set by dollying in and out with the mouse wheel or equivalent, not measured distance
	function BaseCamera:GetCameraToSubjectDistance()
		return self.currentSubjectDistance
	end
	
	-- Actual measured distance to the camera Focus point, which may be needed in special circumstances, but should
	-- never be used as the starting point for updating the nominal camera-to-subject distance (self.currentSubjectDistance)
	-- since that is a desired target value set only by mouse wheel (or equivalent) input, PopperCam, and clamped to min max camera distance
	function BaseCamera:GetMeasuredDistanceToFocus()
		local camera = game.Workspace.CurrentCamera
		if camera then
			return (camera.CoordinateFrame.p - camera.Focus.p).magnitude
		end
		return nil
	end
	
	function BaseCamera:GetCameraLookVector()
		return game.Workspace.CurrentCamera and game.Workspace.CurrentCamera.CFrame.lookVector or UNIT_Z
	end
	
	-- Replacements for RootCamera:RotateCamera() which did not actually rotate the camera
	-- suppliedLookVector is not normally passed in, it's used only by Watch camera
	function BaseCamera:CalculateNewLookCFrame(suppliedLookVector)
		local currLookVector = suppliedLookVector or self:GetCameraLookVector()
		local currPitchAngle = math.asin(currLookVector.y)
		local yTheta = math.clamp(self.rotateInput.y, -MAX_Y + currPitchAngle, -MIN_Y + currPitchAngle)
		local constrainedRotateInput = Vector2.new(self.rotateInput.x, yTheta)
		local startCFrame = CFrame.new(ZERO_VECTOR3, currLookVector)
		local newLookCFrame = CFrame.Angles(0, -constrainedRotateInput.x, 0) * startCFrame * CFrame.Angles(-constrainedRotateInput.y,0,0)
		return newLookCFrame
	end
	function BaseCamera:CalculateNewLookVector(suppliedLookVector)
		local newLookCFrame = self:CalculateNewLookCFrame(suppliedLookVector)
		return newLookCFrame.lookVector
	end
	
	function BaseCamera:CalculateNewLookVectorVR()
		local subjectPosition = self:GetSubjectPosition()
		local vecToSubject = (subjectPosition - game.Workspace.CurrentCamera.CFrame.p)
		local currLookVector = (vecToSubject * X1_Y0_Z1).unit
		local vrRotateInput = Vector2.new(self.rotateInput.x, 0)
		local startCFrame = CFrame.new(ZERO_VECTOR3, currLookVector)
		local yawRotatedVector = (CFrame.Angles(0, -vrRotateInput.x, 0) * startCFrame * CFrame.Angles(-vrRotateInput.y,0,0)).lookVector
		return (yawRotatedVector * X1_Y0_Z1).unit
	end
	
	function BaseCamera:GetHumanoid()
		local character = player and player.Character
		if character then
			local resultHumanoid = self.humanoidCache[player]
			if resultHumanoid and resultHumanoid.Parent == character then
				return resultHumanoid
			else
				self.humanoidCache[player] = nil -- Bust Old Cache
				local humanoid = character:FindFirstChildOfClass("Humanoid")
				if humanoid then
					self.humanoidCache[player] = humanoid
				end
				return humanoid
			end
		end
		return nil
	end
	
	function BaseCamera:GetHumanoidPartToFollow(humanoid, humanoidStateType)
		if humanoidStateType == Enum.HumanoidStateType.Dead then
			local character = humanoid.Parent
			if character then
				return character:FindFirstChild("Head") or humanoid.Torso
			else
				return humanoid.Torso
			end
		else
			return humanoid.Torso
		end
	end
	
	function BaseCamera:UpdateGamepad()
		local gamepadPan = self.gamepadPanningCamera
		if gamepadPan and (self.hasGameLoaded or not VRService.VREnabled) then
			gamepadPan = Util.GamepadLinearToCurve(gamepadPan)
			local currentTime = tick()
			if gamepadPan.X ~= 0 or gamepadPan.Y ~= 0 then
				self.userPanningTheCamera = true
			elseif gamepadPan == ZERO_VECTOR2 then
				self.lastThumbstickRotate = nil
				if self.lastThumbstickPos == ZERO_VECTOR2 then
					self.currentSpeed = 0
				end
			end
	
			local finalConstant = 0
	
			if self.lastThumbstickRotate then
				if VRService.VREnabled then
					self.currentSpeed = self.vrMaxSpeed
				else
					local elapsedTime = (currentTime - self.lastThumbstickRotate) * 10
					self.currentSpeed = self.currentSpeed + (self.maxSpeed * ((elapsedTime*elapsedTime)/self.numOfSeconds))
	
					if self.currentSpeed > self.maxSpeed then self.currentSpeed = self.maxSpeed end
	
					if self.lastVelocity then
						local velocity = (gamepadPan - self.lastThumbstickPos)/(currentTime - self.lastThumbstickRotate)
						local velocityDeltaMag = (velocity - self.lastVelocity).magnitude
	
						if velocityDeltaMag > 12 then
							self.currentSpeed = self.currentSpeed * (20/velocityDeltaMag)
							if self.currentSpeed > self.maxSpeed then self.currentSpeed = self.maxSpeed end
						end
					end
				end
	
				finalConstant = UserGameSettings.GamepadCameraSensitivity * self.currentSpeed
				self.lastVelocity = (gamepadPan - self.lastThumbstickPos)/(currentTime - self.lastThumbstickRotate)
			end
	
			self.lastThumbstickPos = gamepadPan
			self.lastThumbstickRotate = currentTime
	
			return Vector2.new( gamepadPan.X * finalConstant, gamepadPan.Y * finalConstant * self.ySensitivity * UserGameSettings:GetCameraYInvertValue())
		end
	
		return ZERO_VECTOR2
	end
	
	-- [[ VR Support Section ]] --
	
	function BaseCamera:ApplyVRTransform()
		if not VRService.VREnabled then
			return
		end
	
		--we only want this to happen in first person VR
		local rootJoint = self.humanoidRootPart and self.humanoidRootPart:FindFirstChild("RootJoint")
		if not rootJoint then
			return
		end
	
		local cameraSubject = game.Workspace.CurrentCamera.CameraSubject
		local isInVehicle = cameraSubject and cameraSubject:IsA("VehicleSeat")
	
		if self.inFirstPerson and not isInVehicle then
			local vrFrame = VRService:GetUserCFrame(Enum.UserCFrame.Head)
			local vrRotation = vrFrame - vrFrame.p
			rootJoint.C0 = CFrame.new(vrRotation:vectorToObjectSpace(vrFrame.p)) * CFrame.new(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, 0)
		else
			rootJoint.C0 = CFrame.new(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, 0)
		end
	end
	
	function BaseCamera:IsInFirstPerson()
		return self.inFirstPerson
	end
	
	function BaseCamera:ShouldUseVRRotation()
		if not VRService.VREnabled then
			return false
		end
	
		if not self.VRRotationIntensityAvailable and tick() - self.lastVRRotationIntensityCheckTime < 1 then
			return false
		end
	
		local success, vrRotationIntensity = pcall(function() return StarterGui:GetCore("VRRotationIntensity") end)
		self.VRRotationIntensityAvailable = success and vrRotationIntensity ~= nil
		self.lastVRRotationIntensityCheckTime = tick()
	
		self.shouldUseVRRotation = success and vrRotationIntensity ~= nil and vrRotationIntensity ~= "Smooth"
	
		return self.shouldUseVRRotation
	end
	
	function BaseCamera:GetVRRotationInput()
		local vrRotateSum = ZERO_VECTOR2
		local success, vrRotationIntensity = pcall(function() return StarterGui:GetCore("VRRotationIntensity") end)
	
		if not success then
			return
		end
	
		local vrGamepadRotation = self.GamepadPanningCamera or ZERO_VECTOR2
		local delayExpired = (tick() - self.lastVRRotationTime) >= self:GetRepeatDelayValue(vrRotationIntensity)
	
		if math.abs(vrGamepadRotation.x) >= self:GetActivateValue() then
			if (delayExpired or not self.vrRotateKeyCooldown[Enum.KeyCode.Thumbstick2]) then
				local sign = 1
				if vrGamepadRotation.x < 0 then
					sign = -1
				end
				vrRotateSum = vrRotateSum + self:GetRotateAmountValue(vrRotationIntensity) * sign
				self.vrRotateKeyCooldown[Enum.KeyCode.Thumbstick2] = true
			end
		elseif math.abs(vrGamepadRotation.x) < self:GetActivateValue() - 0.1 then
			self.vrRotateKeyCooldown[Enum.KeyCode.Thumbstick2] = nil
		end
		if self.turningLeft then
			if delayExpired or not self.vrRotateKeyCooldown[Enum.KeyCode.Left] then
				vrRotateSum = vrRotateSum - self:GetRotateAmountValue(vrRotationIntensity)
				self.vrRotateKeyCooldown[Enum.KeyCode.Left] = true
			end
		else
			self.vrRotateKeyCooldown[Enum.KeyCode.Left] = nil
		end
		if self.turningRight then
			if (delayExpired or not self.vrRotateKeyCooldown[Enum.KeyCode.Right]) then
				vrRotateSum = vrRotateSum + self:GetRotateAmountValue(vrRotationIntensity)
				self.vrRotateKeyCooldown[Enum.KeyCode.Right] = true
			end
		else
			self.vrRotateKeyCooldown[Enum.KeyCode.Right] = nil
		end
	
		if vrRotateSum ~= ZERO_VECTOR2 then
			self.lastVRRotationTime = tick()
		end
	
		return vrRotateSum
	end
	
	function BaseCamera:CancelCameraFreeze(keepConstraints)
		if not keepConstraints then
			self.cameraTranslationConstraints = Vector3.new(self.cameraTranslationConstraints.x, 1, self.cameraTranslationConstraints.z)
		end
		if self.cameraFrozen then
			self.trackingHumanoid = nil
			self.cameraFrozen = false
		end
	end
	
	function BaseCamera:StartCameraFreeze(subjectPosition, humanoidToTrack)
		if not self.cameraFrozen then
			self.humanoidJumpOrigin = subjectPosition
			self.trackingHumanoid = humanoidToTrack
			self.cameraTranslationConstraints = Vector3.new(self.cameraTranslationConstraints.x, 0, self.cameraTranslationConstraints.z)
			self.cameraFrozen = true
		end
	end
	
	function BaseCamera:OnNewCameraSubject()
		if self.subjectStateChangedConn then
			self.subjectStateChangedConn:Disconnect()
			self.subjectStateChangedConn = nil
		end
	
		local humanoid = workspace.CurrentCamera and workspace.CurrentCamera.CameraSubject
		if self.trackingHumanoid ~= humanoid then
			self:CancelCameraFreeze()
		end
		if humanoid and humanoid:IsA("Humanoid") then
			self.subjectStateChangedConn = humanoid.StateChanged:Connect(function(oldState, newState)
				if VRService.VREnabled and newState == Enum.HumanoidStateType.Jumping and not self.inFirstPerson then
					self:StartCameraFreeze(self:GetSubjectPosition(), humanoid)
				elseif newState ~= Enum.HumanoidStateType.Jumping and newState ~= Enum.HumanoidStateType.Freefall then
					self:CancelCameraFreeze(true)
				end
			end)
		end
	end
	
	function BaseCamera:GetVRFocus(subjectPosition, timeDelta)
		local lastFocus = self.LastCameraFocus or subjectPosition
		if not self.cameraFrozen then
			self.cameraTranslationConstraints = Vector3.new(self.cameraTranslationConstraints.x, math.min(1, self.cameraTranslationConstraints.y + 0.42 * timeDelta), self.cameraTranslationConstraints.z)
		end
	
		local newFocus
		if self.cameraFrozen and self.humanoidJumpOrigin and self.humanoidJumpOrigin.y > lastFocus.y then
			newFocus = CFrame.new(Vector3.new(subjectPosition.x, math.min(self.humanoidJumpOrigin.y, lastFocus.y + 5 * timeDelta), subjectPosition.z))
		else
			newFocus = CFrame.new(Vector3.new(subjectPosition.x, lastFocus.y, subjectPosition.z):lerp(subjectPosition, self.cameraTranslationConstraints.y))
		end
	
		if self.cameraFrozen then
			-- No longer in 3rd person
			if self.inFirstPerson then -- not VRService.VREnabled
				self:CancelCameraFreeze()
			end
			-- This case you jumped off a cliff and want to keep your character in view
			-- 0.5 is to fix floating point error when not jumping off cliffs
			if self.humanoidJumpOrigin and subjectPosition.y < (self.humanoidJumpOrigin.y - 0.5) then
				self:CancelCameraFreeze()
			end
		end
	
		return newFocus
	end
	
	function BaseCamera:GetRotateAmountValue(vrRotationIntensity)
		vrRotationIntensity = vrRotationIntensity or StarterGui:GetCore("VRRotationIntensity")
		if vrRotationIntensity then
			if vrRotationIntensity == "Low" then
				return VR_LOW_INTENSITY_ROTATION
			elseif vrRotationIntensity == "High" then
				return VR_HIGH_INTENSITY_ROTATION
			end
		end
		return ZERO_VECTOR2
	end
	
	function BaseCamera:GetRepeatDelayValue(vrRotationIntensity)
		vrRotationIntensity = vrRotationIntensity or StarterGui:GetCore("VRRotationIntensity")
		if vrRotationIntensity then
			if vrRotationIntensity == "Low" then
				return VR_LOW_INTENSITY_REPEAT
			elseif vrRotationIntensity == "High" then
				return VR_HIGH_INTENSITY_REPEAT
			end
		end
		return 0
	end
	
	function BaseCamera:Update(dt)
		error("BaseCamera:Update() This is a virtual function that should never be getting called.", 2)
	end
	
	BaseCamera.UpCFrame = CFrame.new()
	
	function BaseCamera:UpdateUpCFrame(cf)
		self.UpCFrame = cf
	end
	local ZERO = Vector3.new(0, 0, 0)
	function BaseCamera:CalculateNewLookCFrame(suppliedLookVector)
		local currLookVector = suppliedLookVector or self:GetCameraLookVector()
		currLookVector = self.UpCFrame:VectorToObjectSpace(currLookVector)
		
		local currPitchAngle = math.asin(currLookVector.y)
		local yTheta = math.clamp(self.rotateInput.y, -MAX_Y + currPitchAngle, -MIN_Y + currPitchAngle)
		local constrainedRotateInput = Vector2.new(self.rotateInput.x, yTheta)
		local startCFrame = CFrame.new(ZERO, currLookVector)
		local newLookCFrame = CFrame.Angles(0, -constrainedRotateInput.x, 0) * startCFrame * CFrame.Angles(-constrainedRotateInput.y,0,0)
		
		return newLookCFrame
	end
	
	return BaseCamera
	end

function _BaseOcclusion()
	--[[ The Module ]]--
	local BaseOcclusion = {}
	BaseOcclusion.__index = BaseOcclusion
	setmetatable(BaseOcclusion, {
		__call = function(_, ...)
			return BaseOcclusion.new(...)
		end
	})
	
	function BaseOcclusion.new()
		local self = setmetatable({}, BaseOcclusion)
		return self
	end
	
	-- Called when character is added
	function BaseOcclusion:CharacterAdded(char, player)
	end
	
	-- Called when character is about to be removed
	function BaseOcclusion:CharacterRemoving(char, player)
	end
	
	function BaseOcclusion:OnCameraSubjectChanged(newSubject)
	end
	
	--[[ Derived classes are required to override and implement all of the following functions ]]--
	function BaseOcclusion:GetOcclusionMode()
		-- Must be overridden in derived classes to return an Enum.DevCameraOcclusionMode value
		warn("BaseOcclusion GetOcclusionMode must be overridden by derived classes")
		return nil
	end
	
	function BaseOcclusion:Enable(enabled)
		warn("BaseOcclusion Enable must be overridden by derived classes")
	end
	
	function BaseOcclusion:Update(dt, desiredCameraCFrame, desiredCameraFocus)
		warn("BaseOcclusion Update must be overridden by derived classes")
		return desiredCameraCFrame, desiredCameraFocus
	end
	
	return BaseOcclusion
end

function _Popper()
	
	local Players = game:GetService("Players")
	
	local camera = game.Workspace.CurrentCamera
	
	local min = math.min
	local tan = math.tan
	local rad = math.rad
	local inf = math.huge
	local ray = Ray.new
	
	local function getTotalTransparency(part)
		return 1 - (1 - part.Transparency)*(1 - part.LocalTransparencyModifier)
	end
	
	local function eraseFromEnd(t, toSize)
		for i = #t, toSize + 1, -1 do
			t[i] = nil
		end
	end
	
	local nearPlaneZ, projX, projY do
		local function updateProjection()
			local fov = rad(camera.FieldOfView)
			local view = camera.ViewportSize
			local ar = view.X/view.Y
	
			projY = 2*tan(fov/2)
			projX = ar*projY
		end
	
		camera:GetPropertyChangedSignal("FieldOfView"):Connect(updateProjection)
		camera:GetPropertyChangedSignal("ViewportSize"):Connect(updateProjection)
	
		updateProjection()
	
		nearPlaneZ = camera.NearPlaneZ
		camera:GetPropertyChangedSignal("NearPlaneZ"):Connect(function()
			nearPlaneZ = camera.NearPlaneZ
		end)
	end
	
	local blacklist = {} do
		local charMap = {}
	
		local function refreshIgnoreList()
			local n = 1
			blacklist = {}
			for _, character in pairs(charMap) do
				blacklist[n] = character
				n = n + 1
			end
		end
	
		local function playerAdded(player)
			local function characterAdded(character)
				charMap[player] = character
				refreshIgnoreList()
			end
			local function characterRemoving()
				charMap[player] = nil
				refreshIgnoreList()
			end
	
			player.CharacterAdded:Connect(characterAdded)
			player.CharacterRemoving:Connect(characterRemoving)
			if player.Character then
				characterAdded(player.Character)
			end
		end
	
		local function playerRemoving(player)
			charMap[player] = nil
			refreshIgnoreList()
		end
	
		Players.PlayerAdded:Connect(playerAdded)
		Players.PlayerRemoving:Connect(playerRemoving)
	
		for _, player in ipairs(Players:GetPlayers()) do
			playerAdded(player)
		end
		refreshIgnoreList()
	end
	
	--------------------------------------------------------------------------------------------
	-- Popper uses the level geometry find an upper bound on subject-to-camera distance.
	--
	-- Hard limits are applied immediately and unconditionally. They are generally caused
	-- when level geometry intersects with the near plane (with exceptions, see below).
	--
	-- Soft limits are only applied under certain conditions.
	-- They are caused when level geometry occludes the subject without actually intersecting
	-- with the near plane at the target distance.
	--
	-- Soft limits can be promoted to hard limits and hard limits can be demoted to soft limits.
	-- We usually don"t want the latter to happen.
	--
	-- A soft limit will be promoted to a hard limit if an obstruction
	-- lies between the current and target camera positions.
	--------------------------------------------------------------------------------------------
	
	local subjectRoot
	local subjectPart
	
	camera:GetPropertyChangedSignal("CameraSubject"):Connect(function()
		local subject = camera.CameraSubject
		if subject:IsA("Humanoid") then
			subjectPart = subject.RootPart
		elseif subject:IsA("BasePart") then
			subjectPart = subject
		else
			subjectPart = nil
		end
	end)
	
	local function canOcclude(part)
		-- Occluders must be:
		-- 1. Opaque
		-- 2. Interactable
		-- 3. Not in the same assembly as the subject
	
		return
			getTotalTransparency(part) < 0.25 and
			part.CanCollide and
			subjectRoot ~= (part:GetRootPart() or part) and
			not part:IsA("TrussPart")
	end
	
	-- Offsets for the volume visibility test
	local SCAN_SAMPLE_OFFSETS = {
		Vector2.new( 0.4, 0.0),
		Vector2.new(-0.4, 0.0),
		Vector2.new( 0.0,-0.4),
		Vector2.new( 0.0, 0.4),
		Vector2.new( 0.0, 0.2),
	}
	
	--------------------------------------------------------------------------------
	-- Piercing raycasts
	
	local function getCollisionPoint(origin, dir)
		local originalSize = #blacklist
		repeat
			local hitPart, hitPoint = workspace:FindPartOnRayWithIgnoreList(
				ray(origin, dir), blacklist, false, true
			)
	
			if hitPart then
				if hitPart.CanCollide then
					eraseFromEnd(blacklist, originalSize)
					return hitPoint, true
				end
				blacklist[#blacklist + 1] = hitPart
			end
		until not hitPart
	
		eraseFromEnd(blacklist, originalSize)
		return origin + dir, false
	end
	
	--------------------------------------------------------------------------------
	
	local function queryPoint(origin, unitDir, dist, lastPos)
		debug.profilebegin("queryPoint")
	
		local originalSize = #blacklist
	
		dist = dist + nearPlaneZ
		local target = origin + unitDir*dist
	
		local softLimit = inf
		local hardLimit = inf
		local movingOrigin = origin
	
		repeat
			local entryPart, entryPos = workspace:FindPartOnRayWithIgnoreList(ray(movingOrigin, target - movingOrigin), blacklist, false, true)
	
			if entryPart then
				if canOcclude(entryPart) then
					local wl = {entryPart}
					local exitPart = workspace:FindPartOnRayWithWhitelist(ray(target, entryPos - target), wl, true)
	
					local lim = (entryPos - origin).Magnitude
	
					if exitPart then
						local promote = false
						if lastPos then
							promote =
								workspace:FindPartOnRayWithWhitelist(ray(lastPos, target - lastPos), wl, true) or
								workspace:FindPartOnRayWithWhitelist(ray(target, lastPos - target), wl, true)
						end
	
						if promote then
							-- Ostensibly a soft limit, but the camera has passed through it in the last frame, so promote to a hard limit.
							hardLimit = lim
						elseif dist < softLimit then
							-- Trivial soft limit
							softLimit = lim
						end
					else
						-- Trivial hard limit
						hardLimit = lim
					end
				end
	
				blacklist[#blacklist + 1] = entryPart
				movingOrigin = entryPos - unitDir*1e-3
			end
		until hardLimit < inf or not entryPart
	
		eraseFromEnd(blacklist, originalSize)
	
		debug.profileend()
		return softLimit - nearPlaneZ, hardLimit - nearPlaneZ
	end
	
	local function queryViewport(focus, dist)
		debug.profilebegin("queryViewport")
	
		local fP =  focus.p
		local fX =  focus.rightVector
		local fY =  focus.upVector
		local fZ = -focus.lookVector
	
		local viewport = camera.ViewportSize
	
		local hardBoxLimit = inf
		local softBoxLimit = inf
	
		-- Center the viewport on the PoI, sweep points on the edge towards the target, and take the minimum limits
		for viewX = 0, 1 do
			local worldX = fX*((viewX - 0.5)*projX)
	
			for viewY = 0, 1 do
				local worldY = fY*((viewY - 0.5)*projY)
	
				local origin = fP + nearPlaneZ*(worldX + worldY)
				local lastPos = camera:ViewportPointToRay(
					viewport.x*viewX,
					viewport.y*viewY
				).Origin
	
				local softPointLimit, hardPointLimit = queryPoint(origin, fZ, dist, lastPos)
	
				if hardPointLimit < hardBoxLimit then
					hardBoxLimit = hardPointLimit
				end
				if softPointLimit < softBoxLimit then
					softBoxLimit = softPointLimit
				end
			end
		end
		debug.profileend()
	
		return softBoxLimit, hardBoxLimit
	end
	
	local function testPromotion(focus, dist, focusExtrapolation)
		debug.profilebegin("testPromotion")
	
		local fP = focus.p
		local fX = focus.rightVector
		local fY = focus.upVector
		local fZ = -focus.lookVector
	
		do
			-- Dead reckoning the camera rotation and focus
			debug.profilebegin("extrapolate")
	
			local SAMPLE_DT = 0.0625
			local SAMPLE_MAX_T = 1.25
	
			local maxDist = (getCollisionPoint(fP, focusExtrapolation.posVelocity*SAMPLE_MAX_T) - fP).Magnitude
			-- Metric that decides how many samples to take
			local combinedSpeed = focusExtrapolation.posVelocity.magnitude
	
			for dt = 0, min(SAMPLE_MAX_T, focusExtrapolation.rotVelocity.magnitude + maxDist/combinedSpeed), SAMPLE_DT do
				local cfDt = focusExtrapolation.extrapolate(dt) -- Extrapolated CFrame at time dt
	
				if queryPoint(cfDt.p, -cfDt.lookVector, dist) >= dist then
					return false
				end
			end
	
			debug.profileend()
		end
	
		do
			-- Test screen-space offsets from the focus for the presence of soft limits
			debug.profilebegin("testOffsets")
	
			for _, offset in ipairs(SCAN_SAMPLE_OFFSETS) do
				local scaledOffset = offset
				local pos = getCollisionPoint(fP, fX*scaledOffset.x + fY*scaledOffset.y)
				if queryPoint(pos, (fP + fZ*dist - pos).Unit, dist) == inf then
					return false
				end
			end
	
			debug.profileend()
		end
	
		debug.profileend()
		return true
	end
	
	local function Popper(focus, targetDist, focusExtrapolation)
		debug.profilebegin("popper")
	
		subjectRoot = subjectPart and subjectPart:GetRootPart() or subjectPart
	
		local dist = targetDist
		local soft, hard = queryViewport(focus, targetDist)
		if hard < dist then
			dist = hard
		end
		if soft < dist and testPromotion(focus, targetDist, focusExtrapolation) then
			dist = soft
		end
	
		subjectRoot = nil
	
		debug.profileend()
		return dist
	end
	
	return Popper
end

function _ZoomController()
	local ZOOM_STIFFNESS = 4.5
	local ZOOM_DEFAULT = 12.5
	local ZOOM_ACCELERATION = 0.0375
	
	local MIN_FOCUS_DIST = 0.5
	local DIST_OPAQUE = 1
	
	local Popper = _Popper()
	
	local clamp = math.clamp
	local exp = math.exp
	local min = math.min
	local max = math.max
	local pi = math.pi
	
	local cameraMinZoomDistance, cameraMaxZoomDistance do
		local Player = game:GetService("Players").LocalPlayer
	
		local function updateBounds()
			cameraMinZoomDistance = Player.CameraMinZoomDistance
			cameraMaxZoomDistance = Player.CameraMaxZoomDistance
		end
	
		updateBounds()
	
		Player:GetPropertyChangedSignal("CameraMinZoomDistance"):Connect(updateBounds)
		Player:GetPropertyChangedSignal("CameraMaxZoomDistance"):Connect(updateBounds)
	end
	
	local ConstrainedSpring = {} do
		ConstrainedSpring.__index = ConstrainedSpring
	
		function ConstrainedSpring.new(freq, x, minValue, maxValue)
			x = clamp(x, minValue, maxValue)
			return setmetatable({
				freq = freq, -- Undamped frequency (Hz)
				x = x, -- Current position
				v = 0, -- Current velocity
				minValue = minValue, -- Minimum bound
				maxValue = maxValue, -- Maximum bound
				goal = x, -- Goal position
			}, ConstrainedSpring)
		end
	
		function ConstrainedSpring:Step(dt)
			local freq = self.freq*2*pi -- Convert from Hz to rad/s
			local x = self.x
			local v = self.v
			local minValue = self.minValue
			local maxValue = self.maxValue
			local goal = self.goal
	
			-- Solve the spring ODE for position and velocity after time t, assuming critical damping:
			--   2*f*x'[t] + x''[t] = f^2*(g - x[t])
			-- Knowns are x[0] and x'[0].
			-- Solve for x[t] and x'[t].
	
			local offset = goal - x
			local step = freq*dt
			local decay = exp(-step)
	
			local x1 = goal + (v*dt - offset*(step + 1))*decay
			local v1 = ((offset*freq - v)*step + v)*decay
	
			-- Constrain
			if x1 < minValue then
				x1 = minValue
				v1 = 0
			elseif x1 > maxValue then
				x1 = maxValue
				v1 = 0
			end
	
			self.x = x1
			self.v = v1
	
			return x1
		end
	end
	
	local zoomSpring = ConstrainedSpring.new(ZOOM_STIFFNESS, ZOOM_DEFAULT, MIN_FOCUS_DIST, cameraMaxZoomDistance)
	
	local function stepTargetZoom(z, dz, zoomMin, zoomMax)
		z = clamp(z + dz*(1 + z*ZOOM_ACCELERATION), zoomMin, zoomMax)
		if z < DIST_OPAQUE then
			z = dz <= 0 and zoomMin or DIST_OPAQUE
		end
		return z
	end
	
	local zoomDelta = 0
	
	local Zoom = {} do
		function Zoom.Update(renderDt, focus, extrapolation)
			local poppedZoom = math.huge
	
			if zoomSpring.goal > DIST_OPAQUE then
				-- Make a pessimistic estimate of zoom distance for this step without accounting for poppercam
				local maxPossibleZoom = max(
					zoomSpring.x,
					stepTargetZoom(zoomSpring.goal, zoomDelta, cameraMinZoomDistance, cameraMaxZoomDistance)
				)
	
				-- Run the Popper algorithm on the feasible zoom range, [MIN_FOCUS_DIST, maxPossibleZoom]
				poppedZoom = Popper(
					focus*CFrame.new(0, 0, MIN_FOCUS_DIST),
					maxPossibleZoom - MIN_FOCUS_DIST,
					extrapolation
				) + MIN_FOCUS_DIST
			end
	
			zoomSpring.minValue = MIN_FOCUS_DIST
			zoomSpring.maxValue = min(cameraMaxZoomDistance, poppedZoom)
	
			return zoomSpring:Step(renderDt)
		end
	
		function Zoom.SetZoomParameters(targetZoom, newZoomDelta)
			zoomSpring.goal = targetZoom
			zoomDelta = newZoomDelta
		end
	end
	
	return Zoom
end

function _MouseLockController()
	--[[ Constants ]]--
	local DEFAULT_MOUSE_LOCK_CURSOR = "rbxasset://textures/MouseLockedCursor.png"
	
	local CONTEXT_ACTION_NAME = "MouseLockSwitchAction"
	local MOUSELOCK_ACTION_PRIORITY = Enum.ContextActionPriority.Default.Value
	
	--[[ Services ]]--
	local PlayersService = game:GetService("Players")
	local ContextActionService = game:GetService("ContextActionService")
	local Settings = UserSettings()	-- ignore warning
	local GameSettings = Settings.GameSettings
	local Mouse = PlayersService.LocalPlayer:GetMouse()
	
	--[[ The Module ]]--
	local MouseLockController = {}
	MouseLockController.__index = MouseLockController
	
	function MouseLockController.new()
		local self = setmetatable({}, MouseLockController)
	
		self.isMouseLocked = false
		self.savedMouseCursor = nil
		self.boundKeys = {Enum.KeyCode.LeftShift, Enum.KeyCode.RightShift} -- defaults
	
		self.mouseLockToggledEvent = Instance.new("BindableEvent")
	
		local boundKeysObj = script:FindFirstChild("BoundKeys")
		if (not boundKeysObj) or (not boundKeysObj:IsA("StringValue")) then
			-- If object with correct name was found, but it's not a StringValue, destroy and replace
			if boundKeysObj then
				boundKeysObj:Destroy()
			end
	
			boundKeysObj = Instance.new("StringValue")
			boundKeysObj.Name = "BoundKeys"
			boundKeysObj.Value = "LeftShift,RightShift"
			boundKeysObj.Parent = script
		end
	
		if boundKeysObj then
			boundKeysObj.Changed:Connect(function(value)
				self:OnBoundKeysObjectChanged(value)
			end)
			self:OnBoundKeysObjectChanged(boundKeysObj.Value) -- Initial setup call
		end
	
		-- Watch for changes to user's ControlMode and ComputerMovementMode settings and update the feature availability accordingly
		GameSettings.Changed:Connect(function(property)
			if property == "ControlMode" or property == "ComputerMovementMode" then
				self:UpdateMouseLockAvailability()
			end
		end)
	
		-- Watch for changes to DevEnableMouseLock and update the feature availability accordingly
		PlayersService.LocalPlayer:GetPropertyChangedSignal("DevEnableMouseLock"):Connect(function()
			self:UpdateMouseLockAvailability()
		end)
	
		-- Watch for changes to DevEnableMouseLock and update the feature availability accordingly
		PlayersService.LocalPlayer:GetPropertyChangedSignal("DevComputerMovementMode"):Connect(function()
			self:UpdateMouseLockAvailability()
		end)
	
		self:UpdateMouseLockAvailability()
	
		return self
	end
	
	function MouseLockController:GetIsMouseLocked()
		return self.isMouseLocked
	end
	
	function MouseLockController:GetBindableToggleEvent()
		return self.mouseLockToggledEvent.Event
	end
	
	function MouseLockController:GetMouseLockOffset()
		local offsetValueObj = script:FindFirstChild("CameraOffset")
		if offsetValueObj and offsetValueObj:IsA("Vector3Value") then
			return offsetValueObj.Value
		else
			-- If CameraOffset object was found but not correct type, destroy
			if offsetValueObj then
				offsetValueObj:Destroy()
			end
			offsetValueObj = Instance.new("Vector3Value")
			offsetValueObj.Name = "CameraOffset"
			offsetValueObj.Value = Vector3.new(1.75,0,0) -- Legacy Default Value
			offsetValueObj.Parent = script
		end
	
		if offsetValueObj and offsetValueObj.Value then
			return offsetValueObj.Value
		end
	
		return Vector3.new(1.75,0,0)
	end
	
	function MouseLockController:UpdateMouseLockAvailability()
		local devAllowsMouseLock = PlayersService.LocalPlayer.DevEnableMouseLock
		local devMovementModeIsScriptable = PlayersService.LocalPlayer.DevComputerMovementMode == Enum.DevComputerMovementMode.Scriptable
		local userHasMouseLockModeEnabled = GameSettings.ControlMode == Enum.ControlMode.MouseLockSwitch
		local userHasClickToMoveEnabled =  GameSettings.ComputerMovementMode == Enum.ComputerMovementMode.ClickToMove
		local MouseLockAvailable = devAllowsMouseLock and userHasMouseLockModeEnabled and not userHasClickToMoveEnabled and not devMovementModeIsScriptable
	
		if MouseLockAvailable~=self.enabled then
			self:EnableMouseLock(MouseLockAvailable)
		end
	end
	
	function MouseLockController:OnBoundKeysObjectChanged(newValue)
		self.boundKeys = {} -- Overriding defaults, note: possibly with nothing at all if boundKeysObj.Value is "" or contains invalid values
		for token in string.gmatch(newValue,"[^%s,]+") do
			for _, keyEnum in pairs(Enum.KeyCode:GetEnumItems()) do
				if token == keyEnum.Name then
					self.boundKeys[#self.boundKeys+1] = keyEnum
					break
				end
			end
		end
		self:UnbindContextActions()
		self:BindContextActions()
	end
	
	--[[ Local Functions ]]--
	function MouseLockController:OnMouseLockToggled()
		self.isMouseLocked = not self.isMouseLocked
	
		if self.isMouseLocked then
			local cursorImageValueObj = script:FindFirstChild("CursorImage")
			if cursorImageValueObj and cursorImageValueObj:IsA("StringValue") and cursorImageValueObj.Value then
				self.savedMouseCursor = Mouse.Icon
				Mouse.Icon = cursorImageValueObj.Value
			else
				if cursorImageValueObj then
					cursorImageValueObj:Destroy()
				end
				cursorImageValueObj = Instance.new("StringValue")
				cursorImageValueObj.Name = "CursorImage"
				cursorImageValueObj.Value = DEFAULT_MOUSE_LOCK_CURSOR
				cursorImageValueObj.Parent = script
				self.savedMouseCursor = Mouse.Icon
				Mouse.Icon = DEFAULT_MOUSE_LOCK_CURSOR
			end
		else
			if self.savedMouseCursor then
				Mouse.Icon = self.savedMouseCursor
				self.savedMouseCursor = nil
			end
		end
	
		self.mouseLockToggledEvent:Fire()
	end
	
	function MouseLockController:DoMouseLockSwitch(name, state, input)
		if state == Enum.UserInputState.Begin then
			self:OnMouseLockToggled()
			return Enum.ContextActionResult.Sink
		end
		return Enum.ContextActionResult.Pass
	end
	
	function MouseLockController:BindContextActions()
		ContextActionService:BindActionAtPriority(CONTEXT_ACTION_NAME, function(name, state, input)
			return self:DoMouseLockSwitch(name, state, input)
		end, false, MOUSELOCK_ACTION_PRIORITY, unpack(self.boundKeys))
	end
	
	function MouseLockController:UnbindContextActions()
		ContextActionService:UnbindAction(CONTEXT_ACTION_NAME)
	end
	
	function MouseLockController:IsMouseLocked()
		return self.enabled and self.isMouseLocked
	end
	
	function MouseLockController:EnableMouseLock(enable)
		if enable ~= self.enabled then
	
			self.enabled = enable
	
			if self.enabled then
				-- Enabling the mode
				self:BindContextActions()
			else
				-- Disabling
				-- Restore mouse cursor
				if Mouse.Icon~="" then
					Mouse.Icon = ""
				end
	
				self:UnbindContextActions()
	
				-- If the mode is disabled while being used, fire the event to toggle it off
				if self.isMouseLocked then
					self.mouseLockToggledEvent:Fire()
				end
	
				self.isMouseLocked = false
			end
	
		end
	end
	
	return MouseLockController
end

function _TransparencyController()
	
	local MAX_TWEEN_RATE = 2.8 -- per second
	
	local Util = _CameraUtils()
	
	--[[ The Module ]]--
	local TransparencyController = {}
	TransparencyController.__index = TransparencyController
	
	function TransparencyController.new()
		local self = setmetatable({}, TransparencyController)
	
		self.lastUpdate = tick()
		self.transparencyDirty = false
		self.enabled = false
		self.lastTransparency = nil
	
		self.descendantAddedConn, self.descendantRemovingConn = nil, nil
		self.toolDescendantAddedConns = {}
		self.toolDescendantRemovingConns = {}
		self.cachedParts = {}
	
		return self
	end
	
	
	function TransparencyController:HasToolAncestor(object)
		if object.Parent == nil then return false end
		return object.Parent:IsA('Tool') or self:HasToolAncestor(object.Parent)
	end
	
	function TransparencyController:IsValidPartToModify(part)
		if part:IsA('BasePart') or part:IsA('Decal') then
			return not self:HasToolAncestor(part)
		end
		return false
	end
	
	function TransparencyController:CachePartsRecursive(object)
		if object then
			if self:IsValidPartToModify(object) then
				self.cachedParts[object] = true
				self.transparencyDirty = true
			end
			for _, child in pairs(object:GetChildren()) do
				self:CachePartsRecursive(child)
			end
		end
	end
	
	function TransparencyController:TeardownTransparency()
		for child, _ in pairs(self.cachedParts) do
			child.LocalTransparencyModifier = 0
		end
		self.cachedParts = {}
		self.transparencyDirty = true
		self.lastTransparency = nil
	
		if self.descendantAddedConn then
			self.descendantAddedConn:disconnect()
			self.descendantAddedConn = nil
		end
		if self.descendantRemovingConn then
			self.descendantRemovingConn:disconnect()
			self.descendantRemovingConn = nil
		end
		for object, conn in pairs(self.toolDescendantAddedConns) do
			conn:Disconnect()
			self.toolDescendantAddedConns[object] = nil
		end
		for object, conn in pairs(self.toolDescendantRemovingConns) do
			conn:Disconnect()
			self.toolDescendantRemovingConns[object] = nil
		end
	end
	
	function TransparencyController:SetupTransparency(character)
		self:TeardownTransparency()
	
		if self.descendantAddedConn then self.descendantAddedConn:disconnect() end
		self.descendantAddedConn = character.DescendantAdded:Connect(function(object)
			-- This is a part we want to invisify
			if self:IsValidPartToModify(object) then
				self.cachedParts[object] = true
				self.transparencyDirty = true
			-- There is now a tool under the character
			elseif object:IsA('Tool') then
				if self.toolDescendantAddedConns[object] then self.toolDescendantAddedConns[object]:Disconnect() end
				self.toolDescendantAddedConns[object] = object.DescendantAdded:Connect(function(toolChild)
					self.cachedParts[toolChild] = nil
					if toolChild:IsA('BasePart') or toolChild:IsA('Decal') then
						-- Reset the transparency
						toolChild.LocalTransparencyModifier = 0
					end
				end)
				if self.toolDescendantRemovingConns[object] then self.toolDescendantRemovingConns[object]:disconnect() end
				self.toolDescendantRemovingConns[object] = object.DescendantRemoving:Connect(function(formerToolChild)
					wait() -- wait for new parent
					if character and formerToolChild and formerToolChild:IsDescendantOf(character) then
						if self:IsValidPartToModify(formerToolChild) then
							self.cachedParts[formerToolChild] = true
							self.transparencyDirty = true
						end
					end
				end)
			end
		end)
		if self.descendantRemovingConn then self.descendantRemovingConn:disconnect() end
		self.descendantRemovingConn = character.DescendantRemoving:connect(function(object)
			if self.cachedParts[object] then
				self.cachedParts[object] = nil
				-- Reset the transparency
				object.LocalTransparencyModifier = 0
			end
		end)
		self:CachePartsRecursive(character)
	end
	
	
	function TransparencyController:Enable(enable)
		if self.enabled ~= enable then
			self.enabled = enable
			self:Update()
		end
	end
	
	function TransparencyController:SetSubject(subject)
		local character = nil
		if subject and subject:IsA("Humanoid") then
			character = subject.Parent
		end
		if subject and subject:IsA("VehicleSeat") and subject.Occupant then
			character = subject.Occupant.Parent
		end
		if character then
			self:SetupTransparency(character)
		else
			self:TeardownTransparency()
		end
	end
	
	function TransparencyController:Update()
		local instant = false
		local now = tick()
		local currentCamera = workspace.CurrentCamera
	
		if currentCamera then
			local transparency = 0
			if not self.enabled then
				instant = true
			else
				local distance = (currentCamera.Focus.p - currentCamera.CoordinateFrame.p).magnitude
				transparency = (distance<2) and (1.0-(distance-0.5)/1.5) or 0 --(7 - distance) / 5
				if transparency < 0.5 then
					transparency = 0
				end
	
				if self.lastTransparency then
					local deltaTransparency = transparency - self.lastTransparency
	
					-- Don't tween transparency if it is instant or your character was fully invisible last frame
					if not instant and transparency < 1 and self.lastTransparency < 0.95 then
						local maxDelta = MAX_TWEEN_RATE * (now - self.lastUpdate)
						deltaTransparency = math.clamp(deltaTransparency, -maxDelta, maxDelta)
					end
					transparency = self.lastTransparency + deltaTransparency
				else
					self.transparencyDirty = true
				end
	
				transparency = math.clamp(Util.Round(transparency, 2), 0, 1)
			end
	
			if self.transparencyDirty or self.lastTransparency ~= transparency then
				for child, _ in pairs(self.cachedParts) do
					child.LocalTransparencyModifier = transparency
				end
				self.transparencyDirty = false
				self.lastTransparency = transparency
			end
		end
		self.lastUpdate = now
	end
	
	return TransparencyController
end

function _Poppercam()
	local ZoomController =  _ZoomController()
	
	local TransformExtrapolator = {} do
		TransformExtrapolator.__index = TransformExtrapolator
	
		local CF_IDENTITY = CFrame.new()
	
		local function cframeToAxis(cframe)
			local axis, angle = cframe:toAxisAngle()
			return axis*angle
		end
	
		local function axisToCFrame(axis)
			local angle = axis.magnitude
			if angle > 1e-5 then
				return CFrame.fromAxisAngle(axis, angle)
			end
			return CF_IDENTITY
		end
	
		local function extractRotation(cf)
			local _, _, _, xx, yx, zx, xy, yy, zy, xz, yz, zz = cf:components()
			return CFrame.new(0, 0, 0, xx, yx, zx, xy, yy, zy, xz, yz, zz)
		end
	
		function TransformExtrapolator.new()
			return setmetatable({
				lastCFrame = nil,
			}, TransformExtrapolator)
		end
	
		function TransformExtrapolator:Step(dt, currentCFrame)
			local lastCFrame = self.lastCFrame or currentCFrame
			self.lastCFrame = currentCFrame
	
			local currentPos = currentCFrame.p
			local currentRot = extractRotation(currentCFrame)
	
			local lastPos = lastCFrame.p
			local lastRot = extractRotation(lastCFrame)
	
			-- Estimate velocities from the delta between now and the last frame
			-- This estimation can be a little noisy.
			local dp = (currentPos - lastPos)/dt
			local dr = cframeToAxis(currentRot*lastRot:inverse())/dt
	
			local function extrapolate(t)
				local p = dp*t + currentPos
				local r = axisToCFrame(dr*t)*currentRot
				return r + p
			end
	
			return {
				extrapolate = extrapolate,
				posVelocity = dp,
				rotVelocity = dr,
			}
		end
	
		function TransformExtrapolator:Reset()
			self.lastCFrame = nil
		end
	end
	
	--[[ The Module ]]--
	local BaseOcclusion = _BaseOcclusion()
	local Poppercam = setmetatable({}, BaseOcclusion)
	Poppercam.__index = Poppercam
	
	function Poppercam.new()
		local self = setmetatable(BaseOcclusion.new(), Poppercam)
		self.focusExtrapolator = TransformExtrapolator.new()
		return self
	end
	
	function Poppercam:GetOcclusionMode()
		return Enum.DevCameraOcclusionMode.Zoom
	end
	
	function Poppercam:Enable(enable)
		self.focusExtrapolator:Reset()
	end
	
	function Poppercam:Update(renderDt, desiredCameraCFrame, desiredCameraFocus, cameraController)
		local rotatedFocus = CFrame.new(desiredCameraFocus.p, desiredCameraCFrame.p)*CFrame.new(
			0, 0, 0,
			-1, 0, 0,
			0, 1, 0,
			0, 0, -1
		)
		local extrapolation = self.focusExtrapolator:Step(renderDt, rotatedFocus)
		local zoom = ZoomController.Update(renderDt, rotatedFocus, extrapolation)
		return rotatedFocus*CFrame.new(0, 0, zoom), desiredCameraFocus
	end
	
	-- Called when character is added
	function Poppercam:CharacterAdded(character, player)
	end
	
	-- Called when character is about to be removed
	function Poppercam:CharacterRemoving(character, player)
	end
	
	function Poppercam:OnCameraSubjectChanged(newSubject)
	end
	
	local ZoomController = _ZoomController()
	
	function Poppercam:Update(renderDt, desiredCameraCFrame, desiredCameraFocus, cameraController)
		local rotatedFocus = desiredCameraFocus * (desiredCameraCFrame - desiredCameraCFrame.p)
		local extrapolation = self.focusExtrapolator:Step(renderDt, rotatedFocus)
		local zoom = ZoomController.Update(renderDt, rotatedFocus, extrapolation)
		return rotatedFocus*CFrame.new(0, 0, zoom), desiredCameraFocus
	end
	
	return Poppercam
end

function _Invisicam()
	
	--[[ Top Level Roblox Services ]]--
	local PlayersService = game:GetService("Players")
	
	--[[ Constants ]]--
	local ZERO_VECTOR3 = Vector3.new(0,0,0)
	local USE_STACKING_TRANSPARENCY = true	-- Multiple items between the subject and camera get transparency values that add up to TARGET_TRANSPARENCY
	local TARGET_TRANSPARENCY = 0.75 -- Classic Invisicam's Value, also used by new invisicam for parts hit by head and torso rays
	local TARGET_TRANSPARENCY_PERIPHERAL = 0.5 -- Used by new SMART_CIRCLE mode for items not hit by head and torso rays
	
	local MODE = {
		--CUSTOM = 1, 		-- Retired, unused
		LIMBS = 2, 			-- Track limbs
		MOVEMENT = 3, 		-- Track movement
		CORNERS = 4, 		-- Char model corners
		CIRCLE1 = 5, 		-- Circle of casts around character
		CIRCLE2 = 6, 		-- Circle of casts around character, camera relative
		LIMBMOVE = 7, 		-- LIMBS mode + MOVEMENT mode
		SMART_CIRCLE = 8, 	-- More sample points on and around character
		CHAR_OUTLINE = 9,	-- Dynamic outline around the character
	}
	
	local LIMB_TRACKING_SET = {
		-- Body parts common to R15 and R6
		['Head'] = true,
	
		-- Body parts unique to R6
		['Left Arm'] = true,
		['Right Arm'] = true,
		['Left Leg'] = true,
		['Right Leg'] = true,
	
		-- Body parts unique to R15
		['LeftLowerArm'] = true,
		['RightLowerArm'] = true,
		['LeftUpperLeg'] = true,
		['RightUpperLeg'] = true
	}
	
	local CORNER_FACTORS = {
		Vector3.new(1,1,-1),
		Vector3.new(1,-1,-1),
		Vector3.new(-1,-1,-1),
		Vector3.new(-1,1,-1)
	}
	
	local CIRCLE_CASTS = 10
	local MOVE_CASTS = 3
	local SMART_CIRCLE_CASTS = 24
	local SMART_CIRCLE_INCREMENT = 2.0 * math.pi / SMART_CIRCLE_CASTS
	local CHAR_OUTLINE_CASTS = 24
	
	-- Used to sanitize user-supplied functions
	local function AssertTypes(param, ...)
		local allowedTypes = {}
		local typeString = ''
		for _, typeName in pairs({...}) do
			allowedTypes[typeName] = true
			typeString = typeString .. (typeString == '' and '' or ' or ') .. typeName
		end
		local theType = type(param)
		assert(allowedTypes[theType], typeString .. " type expected, got: " .. theType)
	end
	
	-- Helper function for Determinant of 3x3, not in CameraUtils for performance reasons
	local function Det3x3(a,b,c,d,e,f,g,h,i)
		return (a*(e*i-f*h)-b*(d*i-f*g)+c*(d*h-e*g))
	end
	
	-- Smart Circle mode needs the intersection of 2 rays that are known to be in the same plane
	-- because they are generated from cross products with a common vector. This function is computing
	-- that intersection, but it's actually the general solution for the point halfway between where
	-- two skew lines come nearest to each other, which is more forgiving.
	local function RayIntersection(p0, v0, p1, v1)
		local v2 = v0:Cross(v1)
		local d1 = p1.x - p0.x
		local d2 = p1.y - p0.y
		local d3 = p1.z - p0.z
		local denom = Det3x3(v0.x,-v1.x,v2.x,v0.y,-v1.y,v2.y,v0.z,-v1.z,v2.z)
	
		if (denom == 0) then
			return ZERO_VECTOR3 -- No solution (rays are parallel)
		end
	
		local t0 = Det3x3(d1,-v1.x,v2.x,d2,-v1.y,v2.y,d3,-v1.z,v2.z) / denom
		local t1 = Det3x3(v0.x,d1,v2.x,v0.y,d2,v2.y,v0.z,d3,v2.z) / denom
		local s0 = p0 + t0 * v0
		local s1 = p1 + t1 * v1
		local s = s0 + 0.5 * ( s1 - s0 )
	
		-- 0.25 studs is a threshold for deciding if the rays are
		-- close enough to be considered intersecting, found through testing 
		if (s1-s0).Magnitude < 0.25 then
			return s
		else
			return ZERO_VECTOR3
		end
	end
	
	
	
	--[[ The Module ]]--
	local BaseOcclusion = _BaseOcclusion()
	local Invisicam = setmetatable({}, BaseOcclusion)
	Invisicam.__index = Invisicam
	
	function Invisicam.new()
		local self = setmetatable(BaseOcclusion.new(), Invisicam)
	
		self.char = nil
		self.humanoidRootPart = nil
		self.torsoPart = nil
		self.headPart = nil
	
		self.childAddedConn = nil
		self.childRemovedConn = nil
	
		self.behaviors = {} 	-- Map of modes to behavior fns
		self.behaviors[MODE.LIMBS] = self.LimbBehavior
		self.behaviors[MODE.MOVEMENT] = self.MoveBehavior
		self.behaviors[MODE.CORNERS] = self.CornerBehavior
		self.behaviors[MODE.CIRCLE1] = self.CircleBehavior
		self.behaviors[MODE.CIRCLE2] = self.CircleBehavior
		self.behaviors[MODE.LIMBMOVE] = self.LimbMoveBehavior
		self.behaviors[MODE.SMART_CIRCLE] = self.SmartCircleBehavior
		self.behaviors[MODE.CHAR_OUTLINE] = self.CharacterOutlineBehavior
	
		self.mode = MODE.SMART_CIRCLE
		self.behaviorFunction = self.SmartCircleBehavior
	
		self.savedHits = {} 	-- Objects currently being faded in/out
		self.trackedLimbs = {}	-- Used in limb-tracking casting modes
	
		self.camera = game.Workspace.CurrentCamera
	
		self.enabled = false
		return self
	end
	
	function Invisicam:Enable(enable)
		self.enabled = enable
	
		if not enable then
			self:Cleanup()
		end
	end
	
	function Invisicam:GetOcclusionMode()
		return Enum.DevCameraOcclusionMode.Invisicam
	end
	
	--[[ Module functions ]]--
	function Invisicam:LimbBehavior(castPoints)
		for limb, _ in pairs(self.trackedLimbs) do
			castPoints[#castPoints + 1] = limb.Position
		end
	end
	
	function Invisicam:MoveBehavior(castPoints)
		for i = 1, MOVE_CASTS do
			local position, velocity = self.humanoidRootPart.Position, self.humanoidRootPart.Velocity
			local horizontalSpeed = Vector3.new(velocity.X, 0, velocity.Z).Magnitude / 2
			local offsetVector = (i - 1) * self.humanoidRootPart.CFrame.lookVector * horizontalSpeed
			castPoints[#castPoints + 1] = position + offsetVector
		end
	end
	
	function Invisicam:CornerBehavior(castPoints)
		local cframe = self.humanoidRootPart.CFrame
		local centerPoint = cframe.p
		local rotation = cframe - centerPoint
		local halfSize = self.char:GetExtentsSize() / 2 --NOTE: Doesn't update w/ limb animations
		castPoints[#castPoints + 1] = centerPoint
		for i = 1, #CORNER_FACTORS do
			castPoints[#castPoints + 1] = centerPoint + (rotation * (halfSize * CORNER_FACTORS[i]))
		end
	end
	
	function Invisicam:CircleBehavior(castPoints)
		local cframe
		if self.mode == MODE.CIRCLE1 then
			cframe = self.humanoidRootPart.CFrame
		else
			local camCFrame = self.camera.CoordinateFrame
			cframe = camCFrame - camCFrame.p + self.humanoidRootPart.Position
		end
		castPoints[#castPoints + 1] = cframe.p
		for i = 0, CIRCLE_CASTS - 1 do
			local angle = (2 * math.pi / CIRCLE_CASTS) * i
			local offset = 3 * Vector3.new(math.cos(angle), math.sin(angle), 0)
			castPoints[#castPoints + 1] = cframe * offset
		end
	end
	
	function Invisicam:LimbMoveBehavior(castPoints)
		self:LimbBehavior(castPoints)
		self:MoveBehavior(castPoints)
	end
	
	function Invisicam:CharacterOutlineBehavior(castPoints)
		local torsoUp = self.torsoPart.CFrame.upVector.unit
		local torsoRight = self.torsoPart.CFrame.rightVector.unit
	
		-- Torso cross of points for interior coverage
		castPoints[#castPoints + 1] = self.torsoPart.CFrame.p
		castPoints[#castPoints + 1] = self.torsoPart.CFrame.p + torsoUp
		castPoints[#castPoints + 1] = self.torsoPart.CFrame.p - torsoUp
		castPoints[#castPoints + 1] = self.torsoPart.CFrame.p + torsoRight
		castPoints[#castPoints + 1] = self.torsoPart.CFrame.p - torsoRight
		if self.headPart then
			castPoints[#castPoints + 1] = self.headPart.CFrame.p
		end
	
		local cframe = CFrame.new(ZERO_VECTOR3,Vector3.new(self.camera.CoordinateFrame.lookVector.X,0,self.camera.CoordinateFrame.lookVector.Z))
		local centerPoint = (self.torsoPart and self.torsoPart.Position or self.humanoidRootPart.Position)
	
		local partsWhitelist = {self.torsoPart}
		if self.headPart then
			partsWhitelist[#partsWhitelist + 1] = self.headPart
		end
	
		for i = 1, CHAR_OUTLINE_CASTS do
			local angle = (2 * math.pi * i / CHAR_OUTLINE_CASTS)
			local offset = cframe * (3 * Vector3.new(math.cos(angle), math.sin(angle), 0))
	
			offset = Vector3.new(offset.X, math.max(offset.Y, -2.25), offset.Z)	
	
			local ray = Ray.new(centerPoint + offset, -3 * offset)
			local hit, hitPoint = game.Workspace:FindPartOnRayWithWhitelist(ray, partsWhitelist, false, false)
	
			if hit then
				-- Use hit point as the cast point, but nudge it slightly inside the character so that bumping up against
				-- walls is less likely to cause a transparency glitch
				castPoints[#castPoints + 1] = hitPoint + 0.2 * (centerPoint - hitPoint).unit
			end
		end
	end
	
	function Invisicam:SmartCircleBehavior(castPoints)
		local torsoUp = self.torsoPart.CFrame.upVector.unit
		local torsoRight = self.torsoPart.CFrame.rightVector.unit
	
		-- SMART_CIRCLE mode includes rays to head and 5 to the torso.
		-- Hands, arms, legs and feet are not included since they
		-- are not canCollide and can therefore go inside of parts
		castPoints[#castPoints + 1] = self.torsoPart.CFrame.p
		castPoints[#castPoints + 1] = self.torsoPart.CFrame.p + torsoUp
		castPoints[#castPoints + 1] = self.torsoPart.CFrame.p - torsoUp
		castPoints[#castPoints + 1] = self.torsoPart.CFrame.p + torsoRight
		castPoints[#castPoints + 1] = self.torsoPart.CFrame.p - torsoRight
		if self.headPart then
			castPoints[#castPoints + 1] = self.headPart.CFrame.p
		end
	
		local cameraOrientation = self.camera.CFrame - self.camera.CFrame.p
		local torsoPoint = Vector3.new(0,0.5,0) + (self.torsoPart and self.torsoPart.Position or self.humanoidRootPart.Position)
		local radius = 2.5
	
		-- This loop first calculates points in a circle of radius 2.5 around the torso of the character, in the
		-- plane orthogonal to the camera's lookVector. Each point is then raycast to, to determine if it is within
		-- the free space surrounding the player (not inside anything). Two iterations are done to adjust points that
		-- are inside parts, to try to move them to valid locations that are still on their camera ray, so that the
		-- circle remains circular from the camera's perspective, but does not cast rays into walls or parts that are
		-- behind, below or beside the character and not really obstructing view of the character. This minimizes
		-- the undesirable situation where the character walks up to an exterior wall and it is made invisible even
		-- though it is behind the character.
		for i = 1, SMART_CIRCLE_CASTS do
			local angle = SMART_CIRCLE_INCREMENT * i - 0.5 * math.pi
			local offset = radius * Vector3.new(math.cos(angle), math.sin(angle), 0)
			local circlePoint = torsoPoint + cameraOrientation * offset
	
			-- Vector from camera to point on the circle being tested
			local vp = circlePoint - self.camera.CFrame.p
	
			local ray = Ray.new(torsoPoint, circlePoint - torsoPoint)
			local hit, hp, hitNormal = game.Workspace:FindPartOnRayWithIgnoreList(ray, {self.char}, false, false )
			local castPoint = circlePoint
	
			if hit then
				local hprime = hp + 0.1 * hitNormal.unit -- Slightly offset hit point from the hit surface
				local v0 = hprime - torsoPoint -- Vector from torso to offset hit point
	
				local perp = (v0:Cross(vp)).unit
	
				-- Vector from the offset hit point, along the hit surface
				local v1 = (perp:Cross(hitNormal)).unit
	
				-- Vector from camera to offset hit
				local vprime = (hprime - self.camera.CFrame.p).unit
	
				-- This dot product checks to see if the vector along the hit surface would hit the correct
				-- side of the invisicam cone, or if it would cross the camera look vector and hit the wrong side
				if ( v0.unit:Dot(-v1) < v0.unit:Dot(vprime)) then
					castPoint = RayIntersection(hprime, v1, circlePoint, vp)
	
					if castPoint.Magnitude > 0 then
						local ray = Ray.new(hprime, castPoint - hprime)
						local hit, hitPoint, hitNormal = game.Workspace:FindPartOnRayWithIgnoreList(ray, {self.char}, false, false )
	
						if hit then
							local hprime2 = hitPoint + 0.1 * hitNormal.unit
							castPoint = hprime2
						end
					else
						castPoint = hprime
					end
				else
					castPoint = hprime
				end
	
				local ray = Ray.new(torsoPoint, (castPoint - torsoPoint))
				local hit, hitPoint, hitNormal = game.Workspace:FindPartOnRayWithIgnoreList(ray, {self.char}, false, false )
	
				if hit then
					local castPoint2 = hitPoint - 0.1 * (castPoint - torsoPoint).unit
					castPoint = castPoint2
				end
			end
	
			castPoints[#castPoints + 1] = castPoint
		end
	end
	
	function Invisicam:CheckTorsoReference()
		if self.char then
			self.torsoPart = self.char:FindFirstChild("Torso")
			if not self.torsoPart then
				self.torsoPart = self.char:FindFirstChild("UpperTorso")
				if not self.torsoPart then
					self.torsoPart = self.char:FindFirstChild("HumanoidRootPart")
				end
			end
	
			self.headPart = self.char:FindFirstChild("Head")
		end
	end
	
	function Invisicam:CharacterAdded(char, player)
		-- We only want the LocalPlayer's character
		if player~=PlayersService.LocalPlayer then return end
	
		if self.childAddedConn then
			self.childAddedConn:Disconnect()
			self.childAddedConn = nil
		end
		if self.childRemovedConn then
			self.childRemovedConn:Disconnect()
			self.childRemovedConn = nil
		end
	
		self.char = char
	
		self.trackedLimbs = {}
		local function childAdded(child)
			if child:IsA("BasePart") then
				if LIMB_TRACKING_SET[child.Name] then
					self.trackedLimbs[child] = true
				end
	
				if child.Name == "Torso" or child.Name == "UpperTorso" then
					self.torsoPart = child
				end
	
				if child.Name == "Head" then
					self.headPart = child
				end
			end
		end
	
		local function childRemoved(child)
			self.trackedLimbs[child] = nil
	
			-- If removed/replaced part is 'Torso' or 'UpperTorso' double check that we still have a TorsoPart to use
			self:CheckTorsoReference()
		end
	
		self.childAddedConn = char.ChildAdded:Connect(childAdded)
		self.childRemovedConn = char.ChildRemoved:Connect(childRemoved)
		for _, child in pairs(self.char:GetChildren()) do
			childAdded(child)
		end
	end
	
	function Invisicam:SetMode(newMode)
		AssertTypes(newMode, 'number')
		for _, modeNum in pairs(MODE) do
			if modeNum == newMode then
				self.mode = newMode
				self.behaviorFunction = self.behaviors[self.mode]
				return
			end
		end
		error("Invalid mode number")
	end
	
	function Invisicam:GetObscuredParts()
		return self.savedHits
	end
	
	-- Want to turn off Invisicam? Be sure to call this after.
	function Invisicam:Cleanup()
		for hit, originalFade in pairs(self.savedHits) do
			hit.LocalTransparencyModifier = originalFade
		end
	end
	
	function Invisicam:Update(dt, desiredCameraCFrame, desiredCameraFocus)
		-- Bail if there is no Character
		if not self.enabled or not self.char then
			return desiredCameraCFrame, desiredCameraFocus
		end
	
		self.camera = game.Workspace.CurrentCamera
	
		-- TODO: Move this to a GetHumanoidRootPart helper, probably combine with CheckTorsoReference
		-- Make sure we still have a HumanoidRootPart
		if not self.humanoidRootPart then
			local humanoid = self.char:FindFirstChildOfClass("Humanoid")
			if humanoid and humanoid.RootPart then
				self.humanoidRootPart = humanoid.RootPart
			else
				-- Not set up with Humanoid? Try and see if there's one in the Character at all:
				self.humanoidRootPart = self.char:FindFirstChild("HumanoidRootPart")
				if not self.humanoidRootPart then
					-- Bail out, since we're relying on HumanoidRootPart existing
					return desiredCameraCFrame, desiredCameraFocus
				end
			end
	
			-- TODO: Replace this with something more sensible
			local ancestryChangedConn
			ancestryChangedConn = self.humanoidRootPart.AncestryChanged:Connect(function(child, parent)
				if child == self.humanoidRootPart and not parent then 
					self.humanoidRootPart = nil
					if ancestryChangedConn and ancestryChangedConn.Connected then
						ancestryChangedConn:Disconnect()
						ancestryChangedConn = nil
					end
				end
			end)
		end
	
		if not self.torsoPart then
			self:CheckTorsoReference()
			if not self.torsoPart then
				-- Bail out, since we're relying on Torso existing, should never happen since we fall back to using HumanoidRootPart as torso
				return desiredCameraCFrame, desiredCameraFocus
			end
		end
	
		-- Make a list of world points to raycast to
		local castPoints = {}
		self.behaviorFunction(self, castPoints)
	
		-- Cast to get a list of objects between the camera and the cast points
		local currentHits = {}
		local ignoreList = {self.char}
		local function add(hit)
			currentHits[hit] = true
			if not self.savedHits[hit] then
				self.savedHits[hit] = hit.LocalTransparencyModifier
			end
		end
	
		local hitParts
		local hitPartCount = 0
	
		-- Hash table to treat head-ray-hit parts differently than the rest of the hit parts hit by other rays
		-- head/torso ray hit parts will be more transparent than peripheral parts when USE_STACKING_TRANSPARENCY is enabled
		local headTorsoRayHitParts = {}
	
		local perPartTransparencyHeadTorsoHits = TARGET_TRANSPARENCY
		local perPartTransparencyOtherHits = TARGET_TRANSPARENCY
	
		if USE_STACKING_TRANSPARENCY then
	
			-- This first call uses head and torso rays to find out how many parts are stacked up
			-- for the purpose of calculating required per-part transparency
			local headPoint = self.headPart and self.headPart.CFrame.p or castPoints[1]
			local torsoPoint = self.torsoPart and self.torsoPart.CFrame.p or castPoints[2]
			hitParts = self.camera:GetPartsObscuringTarget({headPoint, torsoPoint}, ignoreList)
	
			-- Count how many things the sample rays passed through, including decals. This should only
			-- count decals facing the camera, but GetPartsObscuringTarget does not return surface normals,
			-- so my compromise for now is to just let any decal increase the part count by 1. Only one
			-- decal per part will be considered.
			for i = 1, #hitParts do
				local hitPart = hitParts[i]
				hitPartCount = hitPartCount + 1 -- count the part itself
				headTorsoRayHitParts[hitPart] = true
				for _, child in pairs(hitPart:GetChildren()) do
					if child:IsA('Decal') or child:IsA('Texture') then
						hitPartCount = hitPartCount + 1 -- count first decal hit, then break
						break
					end
				end
			end
	
			if (hitPartCount > 0) then
				perPartTransparencyHeadTorsoHits = math.pow( ((0.5 * TARGET_TRANSPARENCY) + (0.5 * TARGET_TRANSPARENCY / hitPartCount)), 1 / hitPartCount )
				perPartTransparencyOtherHits = math.pow( ((0.5 * TARGET_TRANSPARENCY_PERIPHERAL) + (0.5 * TARGET_TRANSPARENCY_PERIPHERAL / hitPartCount)), 1 / hitPartCount )
			end
		end
	
		-- Now get all the parts hit by all the rays
		hitParts = self.camera:GetPartsObscuringTarget(castPoints, ignoreList)
	
		local partTargetTransparency = {}
	
		-- Include decals and textures
		for i = 1, #hitParts do
			local hitPart = hitParts[i]
	
			partTargetTransparency[hitPart] =headTorsoRayHitParts[hitPart] and perPartTransparencyHeadTorsoHits or perPartTransparencyOtherHits
	
			-- If the part is not already as transparent or more transparent than what invisicam requires, add it to the list of
			-- parts to be modified by invisicam
			if hitPart.Transparency < partTargetTransparency[hitPart] then
				add(hitPart)
			end
	
			-- Check all decals and textures on the part
			for _, child in pairs(hitPart:GetChildren()) do
				if child:IsA('Decal') or child:IsA('Texture') then
					if (child.Transparency < partTargetTransparency[hitPart]) then
						partTargetTransparency[child] = partTargetTransparency[hitPart]
						add(child)
					end
				end
			end
		end
	
		-- Invisibilize objects that are in the way, restore those that aren't anymore
		for hitPart, originalLTM in pairs(self.savedHits) do
			if currentHits[hitPart] then
				-- LocalTransparencyModifier gets whatever value is required to print the part's total transparency to equal perPartTransparency
				hitPart.LocalTransparencyModifier = (hitPart.Transparency < 1) and ((partTargetTransparency[hitPart] - hitPart.Transparency) / (1.0 - hitPart.Transparency)) or 0
			else -- Restore original pre-invisicam value of LTM
				hitPart.LocalTransparencyModifier = originalLTM
				self.savedHits[hitPart] = nil
			end
		end
	
		-- Invisicam does not change the camera values
		return desiredCameraCFrame, desiredCameraFocus
	end
	
	return Invisicam
end

function _LegacyCamera()
	
	local ZERO_VECTOR2 = Vector2.new(0,0)
	
	local Util = _CameraUtils()
	
	--[[ Services ]]--
	local PlayersService = game:GetService('Players')
	
	--[[ The Module ]]--
	local BaseCamera = _BaseCamera()
	local LegacyCamera = setmetatable({}, BaseCamera)
	LegacyCamera.__index = LegacyCamera
	
	function LegacyCamera.new()
		local self = setmetatable(BaseCamera.new(), LegacyCamera)
	
		self.cameraType = Enum.CameraType.Fixed
		self.lastUpdate = tick()
		self.lastDistanceToSubject = nil
	
		return self
	end
	
	function LegacyCamera:GetModuleName()
		return "LegacyCamera"
	end
	
	--[[ Functions overridden from BaseCamera ]]--
	function LegacyCamera:SetCameraToSubjectDistance(desiredSubjectDistance)
		return BaseCamera.SetCameraToSubjectDistance(self,desiredSubjectDistance)
	end
	
	function LegacyCamera:Update(dt)
	
		-- Cannot update until cameraType has been set
		if not self.cameraType then return end
	
		local now = tick()
		local timeDelta = (now - self.lastUpdate)
		local camera = 	workspace.CurrentCamera
		local newCameraCFrame = camera.CFrame
		local newCameraFocus = camera.Focus
		local player = PlayersService.LocalPlayer
	
		if self.lastUpdate == nil or timeDelta > 1 then
			self.lastDistanceToSubject = nil
		end
		local subjectPosition = self:GetSubjectPosition()
	
		if self.cameraType == Enum.CameraType.Fixed then
			if self.lastUpdate then
				-- Cap out the delta to 0.1 so we don't get some crazy things when we re-resume from
				local delta = math.min(0.1, now - self.lastUpdate)
				local gamepadRotation = self:UpdateGamepad()
				self.rotateInput = self.rotateInput + (gamepadRotation * delta)
			end
	
			if subjectPosition and player and camera then
				local distanceToSubject = self:GetCameraToSubjectDistance()
				local newLookVector = self:CalculateNewLookVector()
				self.rotateInput = ZERO_VECTOR2
	
				newCameraFocus = camera.Focus -- Fixed camera does not change focus
				newCameraCFrame = CFrame.new(camera.CFrame.p, camera.CFrame.p + (distanceToSubject * newLookVector))
			end
		elseif self.cameraType == Enum.CameraType.Attach then
			if subjectPosition and camera then
				local distanceToSubject = self:GetCameraToSubjectDistance()
				local humanoid = self:GetHumanoid()
				if self.lastUpdate and humanoid and humanoid.RootPart then
	
					-- Cap out the delta to 0.1 so we don't get some crazy things when we re-resume from
					local delta = math.min(0.1, now - self.lastUpdate)
					local gamepadRotation = self:UpdateGamepad()
					self.rotateInput = self.rotateInput + (gamepadRotation * delta)
	
					local forwardVector = humanoid.RootPart.CFrame.lookVector
	
					local y = Util.GetAngleBetweenXZVectors(forwardVector, self:GetCameraLookVector())
					if Util.IsFinite(y) then
						-- Preserve vertical rotation from user input
						self.rotateInput = Vector2.new(y, self.rotateInput.Y)
					end
				end
	
				local newLookVector = self:CalculateNewLookVector()
				self.rotateInput = ZERO_VECTOR2
	
				newCameraFocus = CFrame.new(subjectPosition)
				newCameraCFrame = CFrame.new(subjectPosition - (distanceToSubject * newLookVector), subjectPosition)
			end
		elseif self.cameraType == Enum.CameraType.Watch then
			if subjectPosition and player and camera then
				local cameraLook = nil
	
				local humanoid = self:GetHumanoid()
				if humanoid and humanoid.RootPart then
					local diffVector = subjectPosition - camera.CFrame.p
					cameraLook = diffVector.unit
	
					if self.lastDistanceToSubject and self.lastDistanceToSubject == self:GetCameraToSubjectDistance() then
						-- Don't clobber the zoom if they zoomed the camera
						local newDistanceToSubject = diffVector.magnitude
						self:SetCameraToSubjectDistance(newDistanceToSubject)
					end
				end
	
				local distanceToSubject = self:GetCameraToSubjectDistance()
				local newLookVector = self:CalculateNewLookVector(cameraLook)
				self.rotateInput = ZERO_VECTOR2
	
				newCameraFocus = CFrame.new(subjectPosition)
				newCameraCFrame = CFrame.new(subjectPosition - (distanceToSubject * newLookVector), subjectPosition)
	
				self.lastDistanceToSubject = distanceToSubject
			end
		else
			-- Unsupported type, return current values unchanged
			return camera.CFrame, camera.Focus
		end
	
		self.lastUpdate = now
		return newCameraCFrame, newCameraFocus
	end
	
	return LegacyCamera
end

function _OrbitalCamera()
	
	-- Local private variables and constants
	local UNIT_Z = Vector3.new(0,0,1)
	local X1_Y0_Z1 = Vector3.new(1,0,1)	--Note: not a unit vector, used for projecting onto XZ plane
	local ZERO_VECTOR3 = Vector3.new(0,0,0)
	local ZERO_VECTOR2 = Vector2.new(0,0)
	local TAU = 2 * math.pi
	
	--[[ Gamepad Support ]]--
	local THUMBSTICK_DEADZONE = 0.2
	
	-- Do not edit these values, they are not the developer-set limits, they are limits
	-- to the values the camera system equations can correctly handle
	local MIN_ALLOWED_ELEVATION_DEG = -80
	local MAX_ALLOWED_ELEVATION_DEG = 80
	
	local externalProperties = {}
	externalProperties["InitialDistance"]  = 25
	externalProperties["MinDistance"]      = 10
	externalProperties["MaxDistance"]      = 100
	externalProperties["InitialElevation"] = 35
	externalProperties["MinElevation"]     = 35
	externalProperties["MaxElevation"]     = 35
	externalProperties["ReferenceAzimuth"] = -45	-- Angle around the Y axis where the camera starts. -45 offsets the camera in the -X and +Z directions equally
	externalProperties["CWAzimuthTravel"]  = 90	-- How many degrees the camera is allowed to rotate from the reference position, CW as seen from above
	externalProperties["CCWAzimuthTravel"] = 90	-- How many degrees the camera is allowed to rotate from the reference position, CCW as seen from above
	externalProperties["UseAzimuthLimits"] = false -- Full rotation around Y axis available by default
	
	local Util = _CameraUtils()
	
	--[[ Services ]]--
	local PlayersService = game:GetService('Players')
	local VRService = game:GetService("VRService")
	
	--[[ The Module ]]--
	local BaseCamera = _BaseCamera()
	local OrbitalCamera = setmetatable({}, BaseCamera)
	OrbitalCamera.__index = OrbitalCamera
	
	
	function OrbitalCamera.new()
		local self = setmetatable(BaseCamera.new(), OrbitalCamera)
	
		self.lastUpdate = tick()
	
		-- OrbitalCamera-specific members
		self.changedSignalConnections = {}
		self.refAzimuthRad = nil
		self.curAzimuthRad = nil
		self.minAzimuthAbsoluteRad = nil
		self.maxAzimuthAbsoluteRad = nil
		self.useAzimuthLimits = nil
		self.curElevationRad = nil
		self.minElevationRad = nil
		self.maxElevationRad = nil
		self.curDistance = nil
		self.minDistance = nil
		self.maxDistance = nil
	
		-- Gamepad
		self.r3ButtonDown = false
		self.l3ButtonDown = false
		self.gamepadDollySpeedMultiplier = 1
	
		self.lastUserPanCamera = tick()
	
		self.externalProperties = {}
		self.externalProperties["InitialDistance"] 	= 25
		self.externalProperties["MinDistance"] 		= 10
		self.externalProperties["MaxDistance"] 		= 100
		self.externalProperties["InitialElevation"] 	= 35
		self.externalProperties["MinElevation"] 		= 35
		self.externalProperties["MaxElevation"] 		= 35
		self.externalProperties["ReferenceAzimuth"] 	= -45	-- Angle around the Y axis where the camera starts. -45 offsets the camera in the -X and +Z directions equally
		self.externalProperties["CWAzimuthTravel"] 	= 90	-- How many degrees the camera is allowed to rotate from the reference position, CW as seen from above
		self.externalProperties["CCWAzimuthTravel"] 	= 90	-- How many degrees the camera is allowed to rotate from the reference position, CCW as seen from above
		self.externalProperties["UseAzimuthLimits"] 	= false -- Full rotation around Y axis available by default
		self:LoadNumberValueParameters()
	
		return self
	end
	
	function OrbitalCamera:LoadOrCreateNumberValueParameter(name, valueType, updateFunction)
		local valueObj = script:FindFirstChild(name)
	
		if valueObj and valueObj:isA(valueType) then
			-- Value object exists and is the correct type, use its value
			self.externalProperties[name] = valueObj.Value
		elseif self.externalProperties[name] ~= nil then
			-- Create missing (or replace incorrectly-typed) valueObject with default value
			valueObj = Instance.new(valueType)
			valueObj.Name = name
			valueObj.Parent = script
			valueObj.Value = self.externalProperties[name]
		else
			print("externalProperties table has no entry for ",name)
			return
		end
	
		if updateFunction then
			if self.changedSignalConnections[name] then
				self.changedSignalConnections[name]:Disconnect()
			end
			self.changedSignalConnections[name] = valueObj.Changed:Connect(function(newValue)
				self.externalProperties[name] = newValue
				updateFunction(self)
			end)
		end
	end
	
	function OrbitalCamera:SetAndBoundsCheckAzimuthValues()
		self.minAzimuthAbsoluteRad = math.rad(self.externalProperties["ReferenceAzimuth"]) - math.abs(math.rad(self.externalProperties["CWAzimuthTravel"]))
		self.maxAzimuthAbsoluteRad = math.rad(self.externalProperties["ReferenceAzimuth"]) + math.abs(math.rad(self.externalProperties["CCWAzimuthTravel"]))
		self.useAzimuthLimits = self.externalProperties["UseAzimuthLimits"]
		if self.useAzimuthLimits then
			self.curAzimuthRad = math.max(self.curAzimuthRad, self.minAzimuthAbsoluteRad)
			self.curAzimuthRad = math.min(self.curAzimuthRad, self.maxAzimuthAbsoluteRad)
		end
	end
	
	function OrbitalCamera:SetAndBoundsCheckElevationValues()
		-- These degree values are the direct user input values. It is deliberate that they are
		-- ranged checked only against the extremes, and not against each other. Any time one
		-- is changed, both of the internal values in radians are recalculated. This allows for
		-- A developer to change the values in any order and for the end results to be that the
		-- internal values adjust to match intent as best as possible.
		local minElevationDeg = math.max(self.externalProperties["MinElevation"], MIN_ALLOWED_ELEVATION_DEG)
		local maxElevationDeg = math.min(self.externalProperties["MaxElevation"], MAX_ALLOWED_ELEVATION_DEG)
	
		-- Set internal values in radians
		self.minElevationRad = math.rad(math.min(minElevationDeg, maxElevationDeg))
		self.maxElevationRad = math.rad(math.max(minElevationDeg, maxElevationDeg))
		self.curElevationRad = math.max(self.curElevationRad, self.minElevationRad)
		self.curElevationRad = math.min(self.curElevationRad, self.maxElevationRad)
	end
	
	function OrbitalCamera:SetAndBoundsCheckDistanceValues()
		self.minDistance = self.externalProperties["MinDistance"]
		self.maxDistance = self.externalProperties["MaxDistance"]
		self.curDistance = math.max(self.curDistance, self.minDistance)
		self.curDistance = math.min(self.curDistance, self.maxDistance)
	end
	
	-- This loads from, or lazily creates, NumberValue objects for exposed parameters
	function OrbitalCamera:LoadNumberValueParameters()
		-- These initial values do not require change listeners since they are read only once
		self:LoadOrCreateNumberValueParameter("InitialElevation", "NumberValue", nil)
		self:LoadOrCreateNumberValueParameter("InitialDistance", "NumberValue", nil)
	
		-- Note: ReferenceAzimuth is also used as an initial value, but needs a change listener because it is used in the calculation of the limits
		self:LoadOrCreateNumberValueParameter("ReferenceAzimuth", "NumberValue", self.SetAndBoundsCheckAzimuthValue)
		self:LoadOrCreateNumberValueParameter("CWAzimuthTravel", "NumberValue", self.SetAndBoundsCheckAzimuthValues)
		self:LoadOrCreateNumberValueParameter("CCWAzimuthTravel", "NumberValue", self.SetAndBoundsCheckAzimuthValues)
		self:LoadOrCreateNumberValueParameter("MinElevation", "NumberValue", self.SetAndBoundsCheckElevationValues)
		self:LoadOrCreateNumberValueParameter("MaxElevation", "NumberValue", self.SetAndBoundsCheckElevationValues)
		self:LoadOrCreateNumberValueParameter("MinDistance", "NumberValue", self.SetAndBoundsCheckDistanceValues)
		self:LoadOrCreateNumberValueParameter("MaxDistance", "NumberValue", self.SetAndBoundsCheckDistanceValues)
		self:LoadOrCreateNumberValueParameter("UseAzimuthLimits", "BoolValue", self.SetAndBoundsCheckAzimuthValues)
	
		-- Internal values set (in radians, from degrees), plus sanitization
		self.curAzimuthRad = math.rad(self.externalProperties["ReferenceAzimuth"])
		self.curElevationRad = math.rad(self.externalProperties["InitialElevation"])
		self.curDistance = self.externalProperties["InitialDistance"]
	
		self:SetAndBoundsCheckAzimuthValues()
		self:SetAndBoundsCheckElevationValues()
		self:SetAndBoundsCheckDistanceValues()
	end
	
	function OrbitalCamera:GetModuleName()
		return "OrbitalCamera"
	end
	
	function OrbitalCamera:SetInitialOrientation(humanoid)
		if not humanoid or not humanoid.RootPart then
			warn("OrbitalCamera could not set initial orientation due to missing humanoid")
			return
		end
		local newDesiredLook = (humanoid.RootPart.CFrame.lookVector - Vector3.new(0,0.23,0)).unit
		local horizontalShift = Util.GetAngleBetweenXZVectors(newDesiredLook, self:GetCameraLookVector())
		local vertShift = math.asin(self:GetCameraLookVector().y) - math.asin(newDesiredLook.y)
		if not Util.IsFinite(horizontalShift) then
			horizontalShift = 0
		end
		if not Util.IsFinite(vertShift) then
			vertShift = 0
		end
		self.rotateInput = Vector2.new(horizontalShift, vertShift)
	end
	
	--[[ Functions of BaseCamera that are overridden by OrbitalCamera ]]--
	function OrbitalCamera:GetCameraToSubjectDistance()
		return self.curDistance
	end
	
	function OrbitalCamera:SetCameraToSubjectDistance(desiredSubjectDistance)
		print("OrbitalCamera SetCameraToSubjectDistance ",desiredSubjectDistance)
		local player = PlayersService.LocalPlayer
		if player then
			self.currentSubjectDistance = math.clamp(desiredSubjectDistance, self.minDistance, self.maxDistance)
	
			-- OrbitalCamera is not allowed to go into the first-person range
			self.currentSubjectDistance = math.max(self.currentSubjectDistance, self.FIRST_PERSON_DISTANCE_THRESHOLD)
		end
		self.inFirstPerson = false
		self:UpdateMouseBehavior()
		return self.currentSubjectDistance
	end
	
	function OrbitalCamera:CalculateNewLookVector(suppliedLookVector, xyRotateVector)
		local currLookVector = suppliedLookVector or self:GetCameraLookVector()
		local currPitchAngle = math.asin(currLookVector.y)
		local yTheta = math.clamp(xyRotateVector.y, currPitchAngle - math.rad(MAX_ALLOWED_ELEVATION_DEG), currPitchAngle - math.rad(MIN_ALLOWED_ELEVATION_DEG))
		local constrainedRotateInput = Vector2.new(xyRotateVector.x, yTheta)
		local startCFrame = CFrame.new(ZERO_VECTOR3, currLookVector)
		local newLookVector = (CFrame.Angles(0, -constrainedRotateInput.x, 0) * startCFrame * CFrame.Angles(-constrainedRotateInput.y,0,0)).lookVector
		return newLookVector
	end
	
	function OrbitalCamera:GetGamepadPan(name, state, input)
		if input.UserInputType == self.activeGamepad and input.KeyCode == Enum.KeyCode.Thumbstick2 then
			if self.r3ButtonDown or self.l3ButtonDown then
			-- R3 or L3 Thumbstick is depressed, right stick controls dolly in/out
				if (input.Position.Y > THUMBSTICK_DEADZONE) then
					self.gamepadDollySpeedMultiplier = 0.96
				elseif (input.Position.Y < -THUMBSTICK_DEADZONE) then
					self.gamepadDollySpeedMultiplier = 1.04
				else
					self.gamepadDollySpeedMultiplier = 1.00
				end
			else
				if state == Enum.UserInputState.Cancel then
					self.gamepadPanningCamera = ZERO_VECTOR2
					return
				end
	
				local inputVector = Vector2.new(input.Position.X, -input.Position.Y)
				if inputVector.magnitude > THUMBSTICK_DEADZONE then
					self.gamepadPanningCamera = Vector2.new(input.Position.X, -input.Position.Y)
				else
					self.gamepadPanningCamera = ZERO_VECTOR2
				end
			end
			return Enum.ContextActionResult.Sink
		end
		return Enum.ContextActionResult.Pass
	end
	
	function OrbitalCamera:DoGamepadZoom(name, state, input)
		if input.UserInputType == self.activeGamepad and (input.KeyCode == Enum.KeyCode.ButtonR3 or input.KeyCode == Enum.KeyCode.ButtonL3) then
			if (state == Enum.UserInputState.Begin) then
				self.r3ButtonDown = input.KeyCode == Enum.KeyCode.ButtonR3
				self.l3ButtonDown = input.KeyCode == Enum.KeyCode.ButtonL3
			elseif (state == Enum.UserInputState.End) then
				if (input.KeyCode == Enum.KeyCode.ButtonR3) then
					self.r3ButtonDown = false
				elseif (input.KeyCode == Enum.KeyCode.ButtonL3) then
					self.l3ButtonDown = false
				end
				if (not self.r3ButtonDown) and (not self.l3ButtonDown) then
					self.gamepadDollySpeedMultiplier = 1.00
				end
			end
			return Enum.ContextActionResult.Sink
		end
		return Enum.ContextActionResult.Pass
	end
	
	function OrbitalCamera:BindGamepadInputActions()
		self:BindAction("OrbitalCamGamepadPan", function(name, state, input) return self:GetGamepadPan(name, state, input) end,
			false, Enum.KeyCode.Thumbstick2)
		self:BindAction("OrbitalCamGamepadZoom", function(name, state, input) return self:DoGamepadZoom(name, state, input) end,
			false, Enum.KeyCode.ButtonR3, Enum.KeyCode.ButtonL3)
	end
	
	
	-- [[ Update ]]--
	function OrbitalCamera:Update(dt)
		local now = tick()
		local timeDelta = (now - self.lastUpdate)
		local userPanningTheCamera = (self.UserPanningTheCamera == true)
		local camera = 	workspace.CurrentCamera
		local newCameraCFrame = camera.CFrame
		local newCameraFocus = camera.Focus
		local player = PlayersService.LocalPlayer
		local cameraSubject = camera and camera.CameraSubject
		local isInVehicle = cameraSubject and cameraSubject:IsA('VehicleSeat')
		local isOnASkateboard = cameraSubject and cameraSubject:IsA('SkateboardPlatform')
	
		if self.lastUpdate == nil or timeDelta > 1 then
			self.lastCameraTransform = nil
		end
	
		if self.lastUpdate then
			local gamepadRotation = self:UpdateGamepad()
	
			if self:ShouldUseVRRotation() then
				self.RotateInput = self.RotateInput + self:GetVRRotationInput()
			else
				-- Cap out the delta to 0.1 so we don't get some crazy things when we re-resume from
				local delta = math.min(0.1, timeDelta)
	
				if gamepadRotation ~= ZERO_VECTOR2 then
					userPanningTheCamera = true
					self.rotateInput = self.rotateInput + (gamepadRotation * delta)
				end
	
				local angle = 0
				if not (isInVehicle or isOnASkateboard) then
					angle = angle + (self.TurningLeft and -120 or 0)
					angle = angle + (self.TurningRight and 120 or 0)
				end
	
				if angle ~= 0 then
					self.rotateInput = self.rotateInput +  Vector2.new(math.rad(angle * delta), 0)
					userPanningTheCamera = true
				end
			end
		end
	
		-- Reset tween speed if user is panning
		if userPanningTheCamera then
			self.lastUserPanCamera = tick()
		end
	
		local subjectPosition = self:GetSubjectPosition()
	
		if subjectPosition and player and camera then
	
			-- Process any dollying being done by gamepad
			-- TODO: Move this
			if self.gamepadDollySpeedMultiplier ~= 1 then
				self:SetCameraToSubjectDistance(self.currentSubjectDistance * self.gamepadDollySpeedMultiplier)
			end
	
			local VREnabled = VRService.VREnabled
			newCameraFocus = VREnabled and self:GetVRFocus(subjectPosition, timeDelta) or CFrame.new(subjectPosition)
	
			local cameraFocusP = newCameraFocus.p
			if VREnabled and not self:IsInFirstPerson() then
				local cameraHeight = self:GetCameraHeight()
				local vecToSubject = (subjectPosition - camera.CFrame.p)
				local distToSubject = vecToSubject.magnitude
	
				-- Only move the camera if it exceeded a maximum distance to the subject in VR
				if distToSubject > self.currentSubjectDistance or self.rotateInput.x ~= 0 then
					local desiredDist = math.min(distToSubject, self.currentSubjectDistance)
	
					-- Note that CalculateNewLookVector is overridden from BaseCamera
					vecToSubject = self:CalculateNewLookVector(vecToSubject.unit * X1_Y0_Z1, Vector2.new(self.rotateInput.x, 0)) * desiredDist
	
					local newPos = cameraFocusP - vecToSubject
					local desiredLookDir = camera.CFrame.lookVector
					if self.rotateInput.x ~= 0 then
						desiredLookDir = vecToSubject
					end
					local lookAt = Vector3.new(newPos.x + desiredLookDir.x, newPos.y, newPos.z + desiredLookDir.z)
					self.RotateInput = ZERO_VECTOR2
	
					newCameraCFrame = CFrame.new(newPos, lookAt) + Vector3.new(0, cameraHeight, 0)
				end
			else
				-- self.RotateInput is a Vector2 of mouse movement deltas since last update
				self.curAzimuthRad = self.curAzimuthRad - self.rotateInput.x
	
				if self.useAzimuthLimits then
					self.curAzimuthRad = math.clamp(self.curAzimuthRad, self.minAzimuthAbsoluteRad, self.maxAzimuthAbsoluteRad)
				else
					self.curAzimuthRad = (self.curAzimuthRad ~= 0) and (math.sign(self.curAzimuthRad) * (math.abs(self.curAzimuthRad) % TAU)) or 0
				end
	
				self.curElevationRad = math.clamp(self.curElevationRad + self.rotateInput.y, self.minElevationRad, self.maxElevationRad)
	
				local cameraPosVector = self.currentSubjectDistance * ( CFrame.fromEulerAnglesYXZ( -self.curElevationRad, self.curAzimuthRad, 0 ) * UNIT_Z )
				local camPos = subjectPosition + cameraPosVector
	
				newCameraCFrame = CFrame.new(camPos, subjectPosition)
	
				self.rotateInput = ZERO_VECTOR2
			end
	
			self.lastCameraTransform = newCameraCFrame
			self.lastCameraFocus = newCameraFocus
			if (isInVehicle or isOnASkateboard) and cameraSubject:IsA('BasePart') then
				self.lastSubjectCFrame = cameraSubject.CFrame
			else
				self.lastSubjectCFrame = nil
			end
		end
	
		self.lastUpdate = now
		return newCameraCFrame, newCameraFocus
	end
	
	return OrbitalCamera
	end

	function _ClassicCamera()
	
	-- Local private variables and constants
	local ZERO_VECTOR2 = Vector2.new(0,0)
	
	local tweenAcceleration = math.rad(220)		--Radians/Second^2
	local tweenSpeed = math.rad(0)				--Radians/Second
	local tweenMaxSpeed = math.rad(250)			--Radians/Second
	local TIME_BEFORE_AUTO_ROTATE = 2.0 		--Seconds, used when auto-aligning camera with vehicles
	
	local INITIAL_CAMERA_ANGLE = CFrame.fromOrientation(math.rad(-15), 0, 0)
	
	local FFlagUserCameraToggle do
		local success, result = pcall(function()
			return UserSettings():IsUserFeatureEnabled("UserCameraToggle")
		end)
		FFlagUserCameraToggle = success and result
	end
	
	--[[ Services ]]--
	local PlayersService = game:GetService('Players')
	local VRService = game:GetService("VRService")
	
	local CameraInput = _CameraInput()
	local Util = _CameraUtils()
	
	--[[ The Module ]]--
	local BaseCamera = _BaseCamera()
	local ClassicCamera = setmetatable({}, BaseCamera)
	ClassicCamera.__index = ClassicCamera
	
	function ClassicCamera.new()
		local self = setmetatable(BaseCamera.new(), ClassicCamera)
	
		self.isFollowCamera = false
		self.isCameraToggle = false
		self.lastUpdate = tick()
		self.cameraToggleSpring = Util.Spring.new(5, 0)
	
		return self
	end
	
	function ClassicCamera:GetCameraToggleOffset(dt)
		assert(FFlagUserCameraToggle)
	
		if self.isCameraToggle then
			local zoom = self.currentSubjectDistance
	
			if CameraInput.getTogglePan() then
				self.cameraToggleSpring.goal = math.clamp(Util.map(zoom, 0.5, self.FIRST_PERSON_DISTANCE_THRESHOLD, 0, 1), 0, 1)
			else
				self.cameraToggleSpring.goal = 0
			end
	
			local distanceOffset = math.clamp(Util.map(zoom, 0.5, 64, 0, 1), 0, 1) + 1
			return Vector3.new(0, self.cameraToggleSpring:step(dt)*distanceOffset, 0)
		end
	
		return Vector3.new()
	end
	
	-- Movement mode standardized to Enum.ComputerCameraMovementMode values
	function ClassicCamera:SetCameraMovementMode(cameraMovementMode)
		BaseCamera.SetCameraMovementMode(self, cameraMovementMode)
	
		self.isFollowCamera = cameraMovementMode == Enum.ComputerCameraMovementMode.Follow
		self.isCameraToggle = cameraMovementMode == Enum.ComputerCameraMovementMode.CameraToggle
	end
	
	function ClassicCamera:Update()
		local now = tick()
		local timeDelta = now - self.lastUpdate
	
		local camera = workspace.CurrentCamera
		local newCameraCFrame = camera.CFrame
		local newCameraFocus = camera.Focus
	
		local overrideCameraLookVector = nil
		if self.resetCameraAngle then
			local rootPart = self:GetHumanoidRootPart()
			if rootPart then
				overrideCameraLookVector = (rootPart.CFrame * INITIAL_CAMERA_ANGLE).lookVector
			else
				overrideCameraLookVector = INITIAL_CAMERA_ANGLE.lookVector
			end
			self.resetCameraAngle = false
		end
	
		local player = PlayersService.LocalPlayer
		local humanoid = self:GetHumanoid()
		local cameraSubject = camera.CameraSubject
		local isInVehicle = cameraSubject and cameraSubject:IsA('VehicleSeat')
		local isOnASkateboard = cameraSubject and cameraSubject:IsA('SkateboardPlatform')
		local isClimbing = humanoid and humanoid:GetState() == Enum.HumanoidStateType.Climbing
	
		if self.lastUpdate == nil or timeDelta > 1 then
			self.lastCameraTransform = nil
		end
	
		if self.lastUpdate then
			local gamepadRotation = self:UpdateGamepad()
	
			if self:ShouldUseVRRotation() then
				self.rotateInput = self.rotateInput + self:GetVRRotationInput()
			else
				-- Cap out the delta to 0.1 so we don't get some crazy things when we re-resume from
				local delta = math.min(0.1, timeDelta)
	
				if gamepadRotation ~= ZERO_VECTOR2 then
					self.rotateInput = self.rotateInput + (gamepadRotation * delta)
				end
	
				local angle = 0
				if not (isInVehicle or isOnASkateboard) then
					angle = angle + (self.turningLeft and -120 or 0)
					angle = angle + (self.turningRight and 120 or 0)
				end
	
				if angle ~= 0 then
					self.rotateInput = self.rotateInput +  Vector2.new(math.rad(angle * delta), 0)
				end
			end
		end
	
		local cameraHeight = self:GetCameraHeight()
	
		-- Reset tween speed if user is panning
		if self.userPanningTheCamera then
			tweenSpeed = 0
			self.lastUserPanCamera = tick()
		end
	
		local userRecentlyPannedCamera = now - self.lastUserPanCamera < TIME_BEFORE_AUTO_ROTATE
		local subjectPosition = self:GetSubjectPosition()
	
		if subjectPosition and player and camera then
			local zoom = self:GetCameraToSubjectDistance()
			if zoom < 0.5 then
				zoom = 0.5
			end
	
			if self:GetIsMouseLocked() and not self:IsInFirstPerson() then
				-- We need to use the right vector of the camera after rotation, not before
				local newLookCFrame = self:CalculateNewLookCFrame(overrideCameraLookVector)
	
				local offset = self:GetMouseLockOffset()
				local cameraRelativeOffset = offset.X * newLookCFrame.rightVector + offset.Y * newLookCFrame.upVector + offset.Z * newLookCFrame.lookVector
	
				--offset can be NAN, NAN, NAN if newLookVector has only y component
				if Util.IsFiniteVector3(cameraRelativeOffset) then
					subjectPosition = subjectPosition + cameraRelativeOffset
				end
			else
				if not self.userPanningTheCamera and self.lastCameraTransform then
	
					local isInFirstPerson = self:IsInFirstPerson()
	
					if (isInVehicle or isOnASkateboard or (self.isFollowCamera and isClimbing)) and self.lastUpdate and humanoid and humanoid.Torso then
						if isInFirstPerson then
							if self.lastSubjectCFrame and (isInVehicle or isOnASkateboard) and cameraSubject:IsA('BasePart') then
								local y = -Util.GetAngleBetweenXZVectors(self.lastSubjectCFrame.lookVector, cameraSubject.CFrame.lookVector)
								if Util.IsFinite(y) then
									self.rotateInput = self.rotateInput + Vector2.new(y, 0)
								end
								tweenSpeed = 0
							end
						elseif not userRecentlyPannedCamera then
							local forwardVector = humanoid.Torso.CFrame.lookVector
							if isOnASkateboard then
								forwardVector = cameraSubject.CFrame.lookVector
							end
	
							tweenSpeed = math.clamp(tweenSpeed + tweenAcceleration * timeDelta, 0, tweenMaxSpeed)
	
							local percent = math.clamp(tweenSpeed * timeDelta, 0, 1)
							if self:IsInFirstPerson() and not (self.isFollowCamera and self.isClimbing) then
								percent = 1
							end
	
							local y = Util.GetAngleBetweenXZVectors(forwardVector, self:GetCameraLookVector())
							if Util.IsFinite(y) and math.abs(y) > 0.0001 then
								self.rotateInput = self.rotateInput + Vector2.new(y * percent, 0)
							end
						end
	
					elseif self.isFollowCamera and (not (isInFirstPerson or userRecentlyPannedCamera) and not VRService.VREnabled) then
						-- Logic that was unique to the old FollowCamera module
						local lastVec = -(self.lastCameraTransform.p - subjectPosition)
	
						local y = Util.GetAngleBetweenXZVectors(lastVec, self:GetCameraLookVector())
	
						-- This cutoff is to decide if the humanoid's angle of movement,
						-- relative to the camera's look vector, is enough that
						-- we want the camera to be following them. The point is to provide
						-- a sizable dead zone to allow more precise forward movements.
						local thetaCutoff = 0.4
	
						-- Check for NaNs
						if Util.IsFinite(y) and math.abs(y) > 0.0001 and math.abs(y) > thetaCutoff * timeDelta then
							self.rotateInput = self.rotateInput + Vector2.new(y, 0)
						end
					end
				end
			end
	
			if not self.isFollowCamera then
				local VREnabled = VRService.VREnabled
	
				if VREnabled then
					newCameraFocus = self:GetVRFocus(subjectPosition, timeDelta)
				else
					newCameraFocus = CFrame.new(subjectPosition)
				end
	
				local cameraFocusP = newCameraFocus.p
				if VREnabled and not self:IsInFirstPerson() then
					local vecToSubject = (subjectPosition - camera.CFrame.p)
					local distToSubject = vecToSubject.magnitude
	
					-- Only move the camera if it exceeded a maximum distance to the subject in VR
					if distToSubject > zoom or self.rotateInput.x ~= 0 then
						local desiredDist = math.min(distToSubject, zoom)
						vecToSubject = self:CalculateNewLookVectorVR() * desiredDist
						local newPos = cameraFocusP - vecToSubject
						local desiredLookDir = camera.CFrame.lookVector
						if self.rotateInput.x ~= 0 then
							desiredLookDir = vecToSubject
						end
						local lookAt = Vector3.new(newPos.x + desiredLookDir.x, newPos.y, newPos.z + desiredLookDir.z)
						self.rotateInput = ZERO_VECTOR2
	
						newCameraCFrame = CFrame.new(newPos, lookAt) + Vector3.new(0, cameraHeight, 0)
					end
				else
					local newLookVector = self:CalculateNewLookVector(overrideCameraLookVector)
					self.rotateInput = ZERO_VECTOR2
					newCameraCFrame = CFrame.new(cameraFocusP - (zoom * newLookVector), cameraFocusP)
				end
			else -- is FollowCamera
				local newLookVector = self:CalculateNewLookVector(overrideCameraLookVector)
				self.rotateInput = ZERO_VECTOR2
	
				if VRService.VREnabled then
					newCameraFocus = self:GetVRFocus(subjectPosition, timeDelta)
				else
					newCameraFocus = CFrame.new(subjectPosition)
				end
				newCameraCFrame = CFrame.new(newCameraFocus.p - (zoom * newLookVector), newCameraFocus.p) + Vector3.new(0, cameraHeight, 0)
			end
	
			if FFlagUserCameraToggle then
				local toggleOffset = self:GetCameraToggleOffset(timeDelta)
				newCameraFocus = newCameraFocus + toggleOffset
				newCameraCFrame = newCameraCFrame + toggleOffset
			end
	
			self.lastCameraTransform = newCameraCFrame
			self.lastCameraFocus = newCameraFocus
			if (isInVehicle or isOnASkateboard) and cameraSubject:IsA('BasePart') then
				self.lastSubjectCFrame = cameraSubject.CFrame
			else
				self.lastSubjectCFrame = nil
			end
		end
	
		self.lastUpdate = now
		return newCameraCFrame, newCameraFocus
	end
	
	function ClassicCamera:EnterFirstPerson()
		self.inFirstPerson = true
		self:UpdateMouseBehavior()
	end
	
	function ClassicCamera:LeaveFirstPerson()
		self.inFirstPerson = false
		self:UpdateMouseBehavior()
	end
	
	return ClassicCamera
	end

	function _CameraUtils()

	local CameraUtils = {}
	
	local FFlagUserCameraToggle do
		local success, result = pcall(function()
			return UserSettings():IsUserFeatureEnabled("UserCameraToggle")
		end)
		FFlagUserCameraToggle = success and result
	end
	
	local function round(num)
		return math.floor(num + 0.5)
	end
	
	-- Critically damped spring class for fluid motion effects
	local Spring = {} do
		Spring.__index = Spring
	
		-- Initialize to a given undamped frequency and default position
		function Spring.new(freq, pos)
			return setmetatable({
				freq = freq,
				goal = pos,
				pos = pos,
				vel = 0,
			}, Spring)
		end
	
		-- Advance the spring simulation by `dt` seconds
		function Spring:step(dt)
			local f = self.freq*2*math.pi
			local g = self.goal
			local p0 = self.pos
			local v0 = self.vel
	
			local offset = p0 - g
			local decay = math.exp(-f*dt)
	
			local p1 = (offset*(1 + f*dt) + v0*dt)*decay + g
			local v1 = (v0*(1 - f*dt) - offset*(f*f*dt))*decay
	
			self.pos = p1
			self.vel = v1
	
			return p1
		end
	end
	
	CameraUtils.Spring = Spring
	
	-- map a value from one range to another
	function CameraUtils.map(x, inMin, inMax, outMin, outMax)
		return (x - inMin)*(outMax - outMin)/(inMax - inMin) + outMin
	end
	
	-- From TransparencyController
	function CameraUtils.Round(num, places)
		local decimalPivot = 10^places
		return math.floor(num * decimalPivot + 0.5) / decimalPivot
	end
	
	function CameraUtils.IsFinite(val)
		return val == val and val ~= math.huge and val ~= -math.huge
	end
	
	function CameraUtils.IsFiniteVector3(vec3)
		return CameraUtils.IsFinite(vec3.X) and CameraUtils.IsFinite(vec3.Y) and CameraUtils.IsFinite(vec3.Z)
	end
	
	-- Legacy implementation renamed
	function CameraUtils.GetAngleBetweenXZVectors(v1, v2)
		return math.atan2(v2.X*v1.Z-v2.Z*v1.X, v2.X*v1.X+v2.Z*v1.Z)
	end
	
	function  CameraUtils.RotateVectorByAngleAndRound(camLook, rotateAngle, roundAmount)
		if camLook.Magnitude > 0 then
			camLook = camLook.unit
			local currAngle = math.atan2(camLook.z, camLook.x)
			local newAngle = round((math.atan2(camLook.z, camLook.x) + rotateAngle) / roundAmount) * roundAmount
			return newAngle - currAngle
		end
		return 0
	end
	
	-- K is a tunable parameter that changes the shape of the S-curve
	-- the larger K is the more straight/linear the curve gets
	local k = 0.35
	local lowerK = 0.8
	local function SCurveTranform(t)
		t = math.clamp(t, -1, 1)
		if t >= 0 then
			return (k*t) / (k - t + 1)
		end
		return -((lowerK*-t) / (lowerK + t + 1))
	end
	
	local DEADZONE = 0.1
	local function toSCurveSpace(t)
		return (1 + DEADZONE) * (2*math.abs(t) - 1) - DEADZONE
	end
	
	local function fromSCurveSpace(t)
		return t/2 + 0.5
	end
	
	function CameraUtils.GamepadLinearToCurve(thumbstickPosition)
		local function onAxis(axisValue)
			local sign = 1
			if axisValue < 0 then
				sign = -1
			end
			local point = fromSCurveSpace(SCurveTranform(toSCurveSpace(math.abs(axisValue))))
			point = point * sign
			return math.clamp(point, -1, 1)
		end
		return Vector2.new(onAxis(thumbstickPosition.x), onAxis(thumbstickPosition.y))
	end
	
	-- This function converts 4 different, redundant enumeration types to one standard so the values can be compared
	function CameraUtils.ConvertCameraModeEnumToStandard(enumValue)
		if enumValue == Enum.TouchCameraMovementMode.Default then
			return Enum.ComputerCameraMovementMode.Follow
		end
	
		if enumValue == Enum.ComputerCameraMovementMode.Default then
			return Enum.ComputerCameraMovementMode.Classic
		end
	
		if enumValue == Enum.TouchCameraMovementMode.Classic or
			enumValue == Enum.DevTouchCameraMovementMode.Classic or
			enumValue == Enum.DevComputerCameraMovementMode.Classic or
			enumValue == Enum.ComputerCameraMovementMode.Classic then
			return Enum.ComputerCameraMovementMode.Classic
		end
	
		if enumValue == Enum.TouchCameraMovementMode.Follow or
			enumValue == Enum.DevTouchCameraMovementMode.Follow or
			enumValue == Enum.DevComputerCameraMovementMode.Follow or
			enumValue == Enum.ComputerCameraMovementMode.Follow then
			return Enum.ComputerCameraMovementMode.Follow
		end
	
		if enumValue == Enum.TouchCameraMovementMode.Orbital or
			enumValue == Enum.DevTouchCameraMovementMode.Orbital or
			enumValue == Enum.DevComputerCameraMovementMode.Orbital or
			enumValue == Enum.ComputerCameraMovementMode.Orbital then
			return Enum.ComputerCameraMovementMode.Orbital
		end
	
		if FFlagUserCameraToggle then
			if enumValue == Enum.ComputerCameraMovementMode.CameraToggle or
				enumValue == Enum.DevComputerCameraMovementMode.CameraToggle then
				return Enum.ComputerCameraMovementMode.CameraToggle
			end
		end
	
		-- Note: Only the Dev versions of the Enums have UserChoice as an option
		if enumValue == Enum.DevTouchCameraMovementMode.UserChoice or
			enumValue == Enum.DevComputerCameraMovementMode.UserChoice then
			return Enum.DevComputerCameraMovementMode.UserChoice
		end
	
		-- For any unmapped options return Classic camera
		return Enum.ComputerCameraMovementMode.Classic
	end
	
	return CameraUtils
	end

	function _CameraModule()
	local CameraModule = {}
	CameraModule.__index = CameraModule
	
	local FFlagUserCameraToggle do
		local success, result = pcall(function()
			return UserSettings():IsUserFeatureEnabled("UserCameraToggle")
		end)
		FFlagUserCameraToggle = success and result
	end
	
	local FFlagUserRemoveTheCameraApi do
		local success, result = pcall(function()
			return UserSettings():IsUserFeatureEnabled("UserRemoveTheCameraApi")
		end)
		FFlagUserRemoveTheCameraApi = success and result
	end
	
	-- NOTICE: Player property names do not all match their StarterPlayer equivalents,
	-- with the differences noted in the comments on the right
	local PLAYER_CAMERA_PROPERTIES =
	{
		"CameraMinZoomDistance",
		"CameraMaxZoomDistance",
		"CameraMode",
		"DevCameraOcclusionMode",
		"DevComputerCameraMode",			-- Corresponds to StarterPlayer.DevComputerCameraMovementMode
		"DevTouchCameraMode",				-- Corresponds to StarterPlayer.DevTouchCameraMovementMode
	
		-- Character movement mode
		"DevComputerMovementMode",
		"DevTouchMovementMode",
		"DevEnableMouseLock",				-- Corresponds to StarterPlayer.EnableMouseLockOption
	}
	
	local USER_GAME_SETTINGS_PROPERTIES =
	{
		"ComputerCameraMovementMode",
		"ComputerMovementMode",
		"ControlMode",
		"GamepadCameraSensitivity",
		"MouseSensitivity",
		"RotationType",
		"TouchCameraMovementMode",
		"TouchMovementMode",
	}
	
	--[[ Roblox Services ]]--
	local Players = game:GetService("Players")
	local RunService = game:GetService("RunService")
	local UserInputService = game:GetService("UserInputService")
	local UserGameSettings = UserSettings():GetService("UserGameSettings")
	
	-- Camera math utility library
	local CameraUtils = _CameraUtils()
	
	-- Load Roblox Camera Controller Modules
	local ClassicCamera = _ClassicCamera()
	local OrbitalCamera = _OrbitalCamera()
	local LegacyCamera = _LegacyCamera()
	
	-- Load Roblox Occlusion Modules
	local Invisicam = _Invisicam()
	local Poppercam = _Poppercam()
	
	-- Load the near-field character transparency controller and the mouse lock "shift lock" controller
	local TransparencyController = _TransparencyController()
	local MouseLockController = _MouseLockController()
	
	-- Table of camera controllers that have been instantiated. They are instantiated as they are used.
	local instantiatedCameraControllers = {}
	local instantiatedOcclusionModules = {}
	
	-- Management of which options appear on the Roblox User Settings screen
	do
		local PlayerScripts = Players.LocalPlayer:WaitForChild("PlayerScripts")
	
		PlayerScripts:RegisterTouchCameraMovementMode(Enum.TouchCameraMovementMode.Default)
		PlayerScripts:RegisterTouchCameraMovementMode(Enum.TouchCameraMovementMode.Follow)
		PlayerScripts:RegisterTouchCameraMovementMode(Enum.TouchCameraMovementMode.Classic)
	
		PlayerScripts:RegisterComputerCameraMovementMode(Enum.ComputerCameraMovementMode.Default)
		PlayerScripts:RegisterComputerCameraMovementMode(Enum.ComputerCameraMovementMode.Follow)
		PlayerScripts:RegisterComputerCameraMovementMode(Enum.ComputerCameraMovementMode.Classic)
		if FFlagUserCameraToggle then
			PlayerScripts:RegisterComputerCameraMovementMode(Enum.ComputerCameraMovementMode.CameraToggle)
		end
	end
	
	CameraModule.FFlagUserCameraToggle = FFlagUserCameraToggle
	
	
	function CameraModule.new()
		local self = setmetatable({},CameraModule)
	
		-- Current active controller instances
		self.activeCameraController = nil
		self.activeOcclusionModule = nil
		self.activeTransparencyController = nil
		self.activeMouseLockController = nil
	
		self.currentComputerCameraMovementMode = nil
	
		-- Connections to events
		self.cameraSubjectChangedConn = nil
		self.cameraTypeChangedConn = nil
	
		-- Adds CharacterAdded and CharacterRemoving event handlers for all current players
		for _,player in pairs(Players:GetPlayers()) do
			self:OnPlayerAdded(player)
		end
	
		-- Adds CharacterAdded and CharacterRemoving event handlers for all players who join in the future
		Players.PlayerAdded:Connect(function(player)
			self:OnPlayerAdded(player)
		end)
	
		self.activeTransparencyController = TransparencyController.new()
		self.activeTransparencyController:Enable(true)
	
		if not UserInputService.TouchEnabled then
			self.activeMouseLockController = MouseLockController.new()
			local toggleEvent = self.activeMouseLockController:GetBindableToggleEvent()
			if toggleEvent then
				toggleEvent:Connect(function()
					self:OnMouseLockToggled()
				end)
			end
		end
	
		self:ActivateCameraController(self:GetCameraControlChoice())
		self:ActivateOcclusionModule(Players.LocalPlayer.DevCameraOcclusionMode)
		self:OnCurrentCameraChanged() -- Does initializations and makes first camera controller
		RunService:BindToRenderStep("cameraRenderUpdate", Enum.RenderPriority.Camera.Value, function(dt) self:Update(dt) end)
	
		-- Connect listeners to camera-related properties
		for _, propertyName in pairs(PLAYER_CAMERA_PROPERTIES) do
			Players.LocalPlayer:GetPropertyChangedSignal(propertyName):Connect(function()
				self:OnLocalPlayerCameraPropertyChanged(propertyName)
			end)
		end
	
		for _, propertyName in pairs(USER_GAME_SETTINGS_PROPERTIES) do
			UserGameSettings:GetPropertyChangedSignal(propertyName):Connect(function()
				self:OnUserGameSettingsPropertyChanged(propertyName)
			end)
		end
		game.Workspace:GetPropertyChangedSignal("CurrentCamera"):Connect(function()
			self:OnCurrentCameraChanged()
		end)
	
		self.lastInputType = UserInputService:GetLastInputType()
		UserInputService.LastInputTypeChanged:Connect(function(newLastInputType)
			self.lastInputType = newLastInputType
		end)
	
		return self
	end
	
	function CameraModule:GetCameraMovementModeFromSettings()
		local cameraMode = Players.LocalPlayer.CameraMode
	
		-- Lock First Person trumps all other settings and forces ClassicCamera
		if cameraMode == Enum.CameraMode.LockFirstPerson then
			return CameraUtils.ConvertCameraModeEnumToStandard(Enum.ComputerCameraMovementMode.Classic)
		end
	
		local devMode, userMode
		if UserInputService.TouchEnabled then
			devMode = CameraUtils.ConvertCameraModeEnumToStandard(Players.LocalPlayer.DevTouchCameraMode)
			userMode = CameraUtils.ConvertCameraModeEnumToStandard(UserGameSettings.TouchCameraMovementMode)
		else
			devMode = CameraUtils.ConvertCameraModeEnumToStandard(Players.LocalPlayer.DevComputerCameraMode)
			userMode = CameraUtils.ConvertCameraModeEnumToStandard(UserGameSettings.ComputerCameraMovementMode)
		end
	
		if devMode == Enum.DevComputerCameraMovementMode.UserChoice then
			-- Developer is allowing user choice, so user setting is respected
			return userMode
		end
	
		return devMode
	end
	
	function CameraModule:ActivateOcclusionModule( occlusionMode )
		local newModuleCreator
		if occlusionMode == Enum.DevCameraOcclusionMode.Zoom then
			newModuleCreator = Poppercam
		elseif occlusionMode == Enum.DevCameraOcclusionMode.Invisicam then
			newModuleCreator = Invisicam
		else
			warn("CameraScript ActivateOcclusionModule called with unsupported mode")
			return
		end
	
		-- First check to see if there is actually a change. If the module being requested is already
		-- the currently-active solution then just make sure it's enabled and exit early
		if self.activeOcclusionModule and self.activeOcclusionModule:GetOcclusionMode() == occlusionMode then
			if not self.activeOcclusionModule:GetEnabled() then
				self.activeOcclusionModule:Enable(true)
			end
			return
		end
	
		-- Save a reference to the current active module (may be nil) so that we can disable it if
		-- we are successful in activating its replacement
		local prevOcclusionModule = self.activeOcclusionModule
	
		-- If there is no active module, see if the one we need has already been instantiated
		self.activeOcclusionModule = instantiatedOcclusionModules[newModuleCreator]
	
		-- If the module was not already instantiated and selected above, instantiate it
		if not self.activeOcclusionModule then
			self.activeOcclusionModule = newModuleCreator.new()
			if self.activeOcclusionModule then
				instantiatedOcclusionModules[newModuleCreator] = self.activeOcclusionModule
			end
		end
	
		-- If we were successful in either selecting or instantiating the module,
		-- enable it if it's not already the currently-active enabled module
		if self.activeOcclusionModule then
			local newModuleOcclusionMode = self.activeOcclusionModule:GetOcclusionMode()
			-- Sanity check that the module we selected or instantiated actually supports the desired occlusionMode
			if newModuleOcclusionMode ~= occlusionMode then
				warn("CameraScript ActivateOcclusionModule mismatch: ",self.activeOcclusionModule:GetOcclusionMode(),"~=",occlusionMode)
			end
	
			-- Deactivate current module if there is one
			if prevOcclusionModule then
				-- Sanity check that current module is not being replaced by itself (that should have been handled above)
				if prevOcclusionModule ~= self.activeOcclusionModule then
					prevOcclusionModule:Enable(false)
				else
					warn("CameraScript ActivateOcclusionModule failure to detect already running correct module")
				end
			end
	
			-- Occlusion modules need to be initialized with information about characters and cameraSubject
			-- Invisicam needs the LocalPlayer's character
			-- Poppercam needs all player characters and the camera subject
			if occlusionMode == Enum.DevCameraOcclusionMode.Invisicam then
				-- Optimization to only send Invisicam what we know it needs
				if Players.LocalPlayer.Character then
					self.activeOcclusionModule:CharacterAdded(Players.LocalPlayer.Character, Players.LocalPlayer )
				end
			else
				-- When Poppercam is enabled, we send it all existing player characters for its raycast ignore list
				for _, player in pairs(Players:GetPlayers()) do
					if player and player.Character then
						self.activeOcclusionModule:CharacterAdded(player.Character, player)
					end
				end
				self.activeOcclusionModule:OnCameraSubjectChanged(game.Workspace.CurrentCamera.CameraSubject)
			end
	
			-- Activate new choice
			self.activeOcclusionModule:Enable(true)
		end
	end
	
	-- When supplied, legacyCameraType is used and cameraMovementMode is ignored (should be nil anyways)
	-- Next, if userCameraCreator is passed in, that is used as the cameraCreator
	function CameraModule:ActivateCameraController(cameraMovementMode, legacyCameraType)
		local newCameraCreator = nil
	
		if legacyCameraType~=nil then
			--[[
				This function has been passed a CameraType enum value. Some of these map to the use of
				the LegacyCamera module, the value "Custom" will be translated to a movementMode enum
				value based on Dev and User settings, and "Scriptable" will disable the camera controller.
			--]]
	
			if legacyCameraType == Enum.CameraType.Scriptable then
				if self.activeCameraController then
					self.activeCameraController:Enable(false)
					self.activeCameraController = nil
					return
				end
			elseif legacyCameraType == Enum.CameraType.Custom then
				cameraMovementMode = self:GetCameraMovementModeFromSettings()
	
			elseif legacyCameraType == Enum.CameraType.Track then
				-- Note: The TrackCamera module was basically an older, less fully-featured
				-- version of ClassicCamera, no longer actively maintained, but it is re-implemented in
				-- case a game was dependent on its lack of ClassicCamera's extra functionality.
				cameraMovementMode = Enum.ComputerCameraMovementMode.Classic
	
			elseif legacyCameraType == Enum.CameraType.Follow then
				cameraMovementMode = Enum.ComputerCameraMovementMode.Follow
	
			elseif legacyCameraType == Enum.CameraType.Orbital then
				cameraMovementMode = Enum.ComputerCameraMovementMode.Orbital
	
			elseif legacyCameraType == Enum.CameraType.Attach or
				   legacyCameraType == Enum.CameraType.Watch or
				   legacyCameraType == Enum.CameraType.Fixed then
				newCameraCreator = LegacyCamera
			else
				warn("CameraScript encountered an unhandled Camera.CameraType value: ",legacyCameraType)
			end
		end
	
		if not newCameraCreator then
			if cameraMovementMode == Enum.ComputerCameraMovementMode.Classic or
				cameraMovementMode == Enum.ComputerCameraMovementMode.Follow or
				cameraMovementMode == Enum.ComputerCameraMovementMode.Default or
				(FFlagUserCameraToggle and cameraMovementMode == Enum.ComputerCameraMovementMode.CameraToggle) then
				newCameraCreator = ClassicCamera
			elseif cameraMovementMode == Enum.ComputerCameraMovementMode.Orbital then
				newCameraCreator = OrbitalCamera
			else
				warn("ActivateCameraController did not select a module.")
				return
			end
		end
	
		-- Create the camera control module we need if it does not already exist in instantiatedCameraControllers
		local newCameraController
		if not instantiatedCameraControllers[newCameraCreator] then
			newCameraController = newCameraCreator.new()
			instantiatedCameraControllers[newCameraCreator] = newCameraController
		else
			newCameraController = instantiatedCameraControllers[newCameraCreator]
		end
	
		-- If there is a controller active and it's not the one we need, disable it,
		-- if it is the one we need, make sure it's enabled
		if self.activeCameraController then
			if self.activeCameraController ~= newCameraController then
				self.activeCameraController:Enable(false)
				self.activeCameraController = newCameraController
				self.activeCameraController:Enable(true)
			elseif not self.activeCameraController:GetEnabled() then
				self.activeCameraController:Enable(true)
			end
		elseif newCameraController ~= nil then
			self.activeCameraController = newCameraController
			self.activeCameraController:Enable(true)
		end
	
		if self.activeCameraController then
			if cameraMovementMode~=nil then
				self.activeCameraController:SetCameraMovementMode(cameraMovementMode)
			elseif legacyCameraType~=nil then
				-- Note that this is only called when legacyCameraType is not a type that
				-- was convertible to a ComputerCameraMovementMode value, i.e. really only applies to LegacyCamera
				self.activeCameraController:SetCameraType(legacyCameraType)
			end
		end
	end
	
	-- Note: The active transparency controller could be made to listen for this event itself.
	function CameraModule:OnCameraSubjectChanged()
		if self.activeTransparencyController then
			self.activeTransparencyController:SetSubject(game.Workspace.CurrentCamera.CameraSubject)
		end
	
		if self.activeOcclusionModule then
			self.activeOcclusionModule:OnCameraSubjectChanged(game.Workspace.CurrentCamera.CameraSubject)
		end
	end
	
	function CameraModule:OnCameraTypeChanged(newCameraType)
		if newCameraType == Enum.CameraType.Scriptable then
			if UserInputService.MouseBehavior == Enum.MouseBehavior.LockCenter then
				UserInputService.MouseBehavior = Enum.MouseBehavior.Default
			end
		end
	
		-- Forward the change to ActivateCameraController to handle
		self:ActivateCameraController(nil, newCameraType)
	end
	
	-- Note: Called whenever workspace.CurrentCamera changes, but also on initialization of this script
	function CameraModule:OnCurrentCameraChanged()
		local currentCamera = game.Workspace.CurrentCamera
		if not currentCamera then return end
	
		if self.cameraSubjectChangedConn then
			self.cameraSubjectChangedConn:Disconnect()
		end
	
		if self.cameraTypeChangedConn then
			self.cameraTypeChangedConn:Disconnect()
		end
	
		self.cameraSubjectChangedConn = currentCamera:GetPropertyChangedSignal("CameraSubject"):Connect(function()
			self:OnCameraSubjectChanged(currentCamera.CameraSubject)
		end)
	
		self.cameraTypeChangedConn = currentCamera:GetPropertyChangedSignal("CameraType"):Connect(function()
			self:OnCameraTypeChanged(currentCamera.CameraType)
		end)
	
		self:OnCameraSubjectChanged(currentCamera.CameraSubject)
		self:OnCameraTypeChanged(currentCamera.CameraType)
	end
	
	function CameraModule:OnLocalPlayerCameraPropertyChanged(propertyName)
		if propertyName == "CameraMode" then
			-- CameraMode is only used to turn on/off forcing the player into first person view. The
			-- Note: The case "Classic" is used for all other views and does not correspond only to the ClassicCamera module
			if Players.LocalPlayer.CameraMode == Enum.CameraMode.LockFirstPerson then
				-- Locked in first person, use ClassicCamera which supports this
				if not self.activeCameraController or self.activeCameraController:GetModuleName() ~= "ClassicCamera" then
					self:ActivateCameraController(CameraUtils.ConvertCameraModeEnumToStandard(Enum.DevComputerCameraMovementMode.Classic))
				end
	
				if self.activeCameraController then
					self.activeCameraController:UpdateForDistancePropertyChange()
				end
			elseif Players.LocalPlayer.CameraMode == Enum.CameraMode.Classic then
				-- Not locked in first person view
				local cameraMovementMode =self: GetCameraMovementModeFromSettings()
				self:ActivateCameraController(CameraUtils.ConvertCameraModeEnumToStandard(cameraMovementMode))
			else
				warn("Unhandled value for property player.CameraMode: ",Players.LocalPlayer.CameraMode)
			end
	
		elseif propertyName == "DevComputerCameraMode" or 
			   propertyName == "DevTouchCameraMode" then
			local cameraMovementMode = self:GetCameraMovementModeFromSettings()
			self:ActivateCameraController(CameraUtils.ConvertCameraModeEnumToStandard(cameraMovementMode))
	
		elseif propertyName == "DevCameraOcclusionMode" then
			self:ActivateOcclusionModule(Players.LocalPlayer.DevCameraOcclusionMode)
	
		elseif propertyName == "CameraMinZoomDistance" or propertyName == "CameraMaxZoomDistance" then
			if self.activeCameraController then
				self.activeCameraController:UpdateForDistancePropertyChange()
			end
		elseif propertyName == "DevTouchMovementMode" then
		elseif propertyName == "DevComputerMovementMode" then
		elseif propertyName == "DevEnableMouseLock" then
			-- This is the enabling/disabling of "Shift Lock" mode, not LockFirstPerson (which is a CameraMode)
			-- Note: Enabling and disabling of MouseLock mode is normally only a publish-time choice made via
			-- the corresponding EnableMouseLockOption checkbox of StarterPlayer, and this script does not have
			-- support for changing the availability of MouseLock at runtime (this would require listening to
			-- Player.DevEnableMouseLock changes)
		end
	end
	
	function CameraModule:OnUserGameSettingsPropertyChanged(propertyName)
		if propertyName == 	"ComputerCameraMovementMode" then
			local cameraMovementMode = self:GetCameraMovementModeFromSettings()
			self:ActivateCameraController(CameraUtils.ConvertCameraModeEnumToStandard(cameraMovementMode))
		end
	end
	
	--[[
		Main RenderStep Update. The camera controller and occlusion module both have opportunities
		to set and modify (respectively) the CFrame and Focus before it is set once on CurrentCamera.
		The camera and occlusion modules should only return CFrames, not set the CFrame property of
		CurrentCamera directly.
	--]]
	function CameraModule:Update(dt)
		if self.activeCameraController then
			if FFlagUserCameraToggle then
				self.activeCameraController:UpdateMouseBehavior()
			end
	
			local newCameraCFrame, newCameraFocus = self.activeCameraController:Update(dt)
			self.activeCameraController:ApplyVRTransform()
			if self.activeOcclusionModule then
				newCameraCFrame, newCameraFocus = self.activeOcclusionModule:Update(dt, newCameraCFrame, newCameraFocus)
			end
	
			-- Here is where the new CFrame and Focus are set for this render frame
			game.Workspace.CurrentCamera.CFrame = newCameraCFrame
			game.Workspace.CurrentCamera.Focus = newCameraFocus
	
			-- Update to character local transparency as needed based on camera-to-subject distance
			if self.activeTransparencyController then
				self.activeTransparencyController:Update()
			end
		end
	end
	
	-- Formerly getCurrentCameraMode, this function resolves developer and user camera control settings to
	-- decide which camera control module should be instantiated. The old method of converting redundant enum types
	function CameraModule:GetCameraControlChoice()
		local player = Players.LocalPlayer
	
		if player then
			if self.lastInputType == Enum.UserInputType.Touch or UserInputService.TouchEnabled then
				-- Touch
				if player.DevTouchCameraMode == Enum.DevTouchCameraMovementMode.UserChoice then
					return CameraUtils.ConvertCameraModeEnumToStandard( UserGameSettings.TouchCameraMovementMode )
				else
					return CameraUtils.ConvertCameraModeEnumToStandard( player.DevTouchCameraMode )
				end
			else
				-- Computer
				if player.DevComputerCameraMode == Enum.DevComputerCameraMovementMode.UserChoice then
					local computerMovementMode = CameraUtils.ConvertCameraModeEnumToStandard(UserGameSettings.ComputerCameraMovementMode)
					return CameraUtils.ConvertCameraModeEnumToStandard(computerMovementMode)
				else
					return CameraUtils.ConvertCameraModeEnumToStandard(player.DevComputerCameraMode)
				end
			end
		end
	end
	
	function CameraModule:OnCharacterAdded(char, player)
		if self.activeOcclusionModule then
			self.activeOcclusionModule:CharacterAdded(char, player)
		end
	end
	
	function CameraModule:OnCharacterRemoving(char, player)
		if self.activeOcclusionModule then
			self.activeOcclusionModule:CharacterRemoving(char, player)
		end
	end
	
	function CameraModule:OnPlayerAdded(player)
		player.CharacterAdded:Connect(function(char)
			self:OnCharacterAdded(char, player)
		end)
		player.CharacterRemoving:Connect(function(char)
			self:OnCharacterRemoving(char, player)
		end)
	end
	
	function CameraModule:OnMouseLockToggled()
		if self.activeMouseLockController then
			local mouseLocked = self.activeMouseLockController:GetIsMouseLocked()
			local mouseLockOffset = self.activeMouseLockController:GetMouseLockOffset()
			if self.activeCameraController then
				self.activeCameraController:SetIsMouseLocked(mouseLocked)
				self.activeCameraController:SetMouseLockOffset(mouseLockOffset)
			end
		end
	end
	--begin edit
	local Camera = CameraModule
	local IDENTITYCF = CFrame.new()
	local lastUpCFrame = IDENTITYCF
	
	Camera.UpVector = Vector3.new(0, 1, 0)
	Camera.TransitionRate = 0.15
	Camera.UpCFrame = IDENTITYCF
	
	function Camera:GetUpVector(oldUpVector)
		return oldUpVector
	end
	local function getRotationBetween(u, v, axis)
		local dot, uxv = u:Dot(v), u:Cross(v)
		if (dot < -0.99999) then return CFrame.fromAxisAngle(axis, math.pi) end
		return CFrame.new(0, 0, 0, uxv.x, uxv.y, uxv.z, 1 + dot)
	end
	function Camera:CalculateUpCFrame()
		local oldUpVector = self.UpVector
		local newUpVector = self:GetUpVector(oldUpVector)
		
		local backup = game.Workspace.CurrentCamera.CFrame.RightVector
		local transitionCF = getRotationBetween(oldUpVector, newUpVector, backup)
		local vecSlerpCF = IDENTITYCF:Lerp(transitionCF, self.TransitionRate)
		
		self.UpVector = vecSlerpCF * oldUpVector
		self.UpCFrame = vecSlerpCF * self.UpCFrame
		
		lastUpCFrame = self.UpCFrame
	end
	
	function Camera:Update(dt)
		if self.activeCameraController then
			if Camera.FFlagUserCameraToggle then
				self.activeCameraController:UpdateMouseBehavior()
			end
			
			local newCameraCFrame, newCameraFocus = self.activeCameraController:Update(dt)
			self.activeCameraController:ApplyVRTransform()
			
			self:CalculateUpCFrame()
			self.activeCameraController:UpdateUpCFrame(self.UpCFrame)
			
			-- undo shift-lock offset
	
			local lockOffset = Vector3.new(0, 0, 0)
			if (self.activeMouseLockController and self.activeMouseLockController:GetIsMouseLocked()) then
				lockOffset = self.activeMouseLockController:GetMouseLockOffset()
			end
			
			local offset = newCameraFocus:ToObjectSpace(newCameraCFrame)
			local camRotation = self.UpCFrame * offset
			newCameraFocus = newCameraFocus - newCameraCFrame:VectorToWorldSpace(lockOffset) + camRotation:VectorToWorldSpace(lockOffset)
			newCameraCFrame = newCameraFocus * camRotation
			
			--local offset = newCameraFocus:Inverse() * newCameraCFrame
			--newCameraCFrame = newCameraFocus * self.UpCFrame * offset
			
			if (self.activeCameraController.lastCameraTransform) then
				self.activeCameraController.lastCameraTransform = newCameraCFrame
				self.activeCameraController.lastCameraFocus = newCameraFocus
			end
			
			if self.activeOcclusionModule then
				newCameraCFrame, newCameraFocus = self.activeOcclusionModule:Update(dt, newCameraCFrame, newCameraFocus)
			end
	
			game.Workspace.CurrentCamera.CFrame = newCameraCFrame
			game.Workspace.CurrentCamera.Focus = newCameraFocus
	
			if self.activeTransparencyController then
				self.activeTransparencyController:Update()
			end
		end
	end
	
	function Camera:IsFirstPerson()
		if self.activeCameraController then
			return self.activeCameraController:InFirstPerson()
		end
		return false
	end
	
	function Camera:IsMouseLocked()
		if self.activeCameraController then
			return self.activeCameraController:GetIsMouseLocked()
		end
		return false
	end
	function Camera:IsToggleMode()
		if self.activeCameraController then
			return self.activeCameraController.isCameraToggle
		end
		return false
	end
	function Camera:IsCamRelative()
		return self:IsMouseLocked() or self:IsFirstPerson()
		--return self:IsToggleMode(), self:IsMouseLocked(), self:IsFirstPerson()
	end
	--
	local Utils = _CameraUtils()
	function Utils.GetAngleBetweenXZVectors(v1, v2)
		local upCFrame = lastUpCFrame
		v1 = upCFrame:VectorToObjectSpace(v1)
		v2 = upCFrame:VectorToObjectSpace(v2)
		return math.atan2(v2.X*v1.Z-v2.Z*v1.X, v2.X*v1.X+v2.Z*v1.Z)
	end
	--end edit
	local cameraModuleObject = CameraModule.new()
	local cameraApi = {}
	return cameraModuleObject
	end

	function _ClickToMoveDisplay()
	local ClickToMoveDisplay = {}
	
	local FAILURE_ANIMATION_ID = "rbxassetid://2874840706"
	
	local TrailDotIcon = "rbxasset://textures/ui/traildot.png"
	local EndWaypointIcon = "rbxasset://textures/ui/waypoint.png"
	
	local WaypointsAlwaysOnTop = false
	
	local WAYPOINT_INCLUDE_FACTOR = 2
	local LAST_DOT_DISTANCE = 3
	
	local WAYPOINT_BILLBOARD_SIZE = UDim2.new(0, 1.68 * 25, 0, 2 * 25)
	
	local ENDWAYPOINT_SIZE_OFFSET_MIN = Vector2.new(0, 0.5)
	local ENDWAYPOINT_SIZE_OFFSET_MAX = Vector2.new(0, 1)
	
	local FAIL_WAYPOINT_SIZE_OFFSET_CENTER = Vector2.new(0, 0.5)
	local FAIL_WAYPOINT_SIZE_OFFSET_LEFT = Vector2.new(0.1, 0.5)
	local FAIL_WAYPOINT_SIZE_OFFSET_RIGHT = Vector2.new(-0.1, 0.5)
	
	local FAILURE_TWEEN_LENGTH = 0.125
	local FAILURE_TWEEN_COUNT = 4
	
	local TWEEN_WAYPOINT_THRESHOLD = 5
	
	local TRAIL_DOT_PARENT_NAME = "ClickToMoveDisplay"
	
	local TrailDotSize = Vector2.new(1.5, 1.5)
	
	local TRAIL_DOT_MIN_SCALE = 1
	local TRAIL_DOT_MIN_DISTANCE = 10
	local TRAIL_DOT_MAX_SCALE = 2.5
	local TRAIL_DOT_MAX_DISTANCE = 100
	
	local PlayersService = game:GetService("Players")
	local TweenService = game:GetService("TweenService")
	local RunService = game:GetService("RunService")
	local Workspace = game:GetService("Workspace")
	
	local LocalPlayer = PlayersService.LocalPlayer
	
	local function CreateWaypointTemplates()
		local TrailDotTemplate = Instance.new("Part")
		TrailDotTemplate.Size = Vector3.new(1, 1, 1)
		TrailDotTemplate.Anchored = true
		TrailDotTemplate.CanCollide = false
		TrailDotTemplate.Name = "TrailDot"
		TrailDotTemplate.Transparency = 1
		local TrailDotImage = Instance.new("ImageHandleAdornment")
		TrailDotImage.Name = "TrailDotImage"
		TrailDotImage.Size = TrailDotSize
		TrailDotImage.SizeRelativeOffset = Vector3.new(0, 0, -0.1)
		TrailDotImage.AlwaysOnTop = WaypointsAlwaysOnTop
		TrailDotImage.Image = TrailDotIcon
		TrailDotImage.Adornee = TrailDotTemplate
		TrailDotImage.Parent = TrailDotTemplate
	
		local EndWaypointTemplate = Instance.new("Part")
		EndWaypointTemplate.Size = Vector3.new(2, 2, 2)
		EndWaypointTemplate.Anchored = true
		EndWaypointTemplate.CanCollide = false
		EndWaypointTemplate.Name = "EndWaypoint"
		EndWaypointTemplate.Transparency = 1
		local EndWaypointImage = Instance.new("ImageHandleAdornment")
		EndWaypointImage.Name = "TrailDotImage"
		EndWaypointImage.Size = TrailDotSize
		EndWaypointImage.SizeRelativeOffset = Vector3.new(0, 0, -0.1)
		EndWaypointImage.AlwaysOnTop = WaypointsAlwaysOnTop
		EndWaypointImage.Image = TrailDotIcon
		EndWaypointImage.Adornee = EndWaypointTemplate
		EndWaypointImage.Parent = EndWaypointTemplate
		local EndWaypointBillboard = Instance.new("BillboardGui")
		EndWaypointBillboard.Name = "EndWaypointBillboard"
		EndWaypointBillboard.Size = WAYPOINT_BILLBOARD_SIZE
		EndWaypointBillboard.LightInfluence = 0
		EndWaypointBillboard.SizeOffset = ENDWAYPOINT_SIZE_OFFSET_MIN
		EndWaypointBillboard.AlwaysOnTop = true
		EndWaypointBillboard.Adornee = EndWaypointTemplate
		EndWaypointBillboard.Parent = EndWaypointTemplate
		local EndWaypointImageLabel = Instance.new("ImageLabel")
		EndWaypointImageLabel.Image = EndWaypointIcon
		EndWaypointImageLabel.BackgroundTransparency = 1
		EndWaypointImageLabel.Size = UDim2.new(1, 0, 1, 0)
		EndWaypointImageLabel.Parent = EndWaypointBillboard
	
	
		local FailureWaypointTemplate = Instance.new("Part")
		FailureWaypointTemplate.Size = Vector3.new(2, 2, 2)
		FailureWaypointTemplate.Anchored = true
		FailureWaypointTemplate.CanCollide = false
		FailureWaypointTemplate.Name = "FailureWaypoint"
		FailureWaypointTemplate.Transparency = 1
		local FailureWaypointImage = Instance.new("ImageHandleAdornment")
		FailureWaypointImage.Name = "TrailDotImage"
		FailureWaypointImage.Size = TrailDotSize
		FailureWaypointImage.SizeRelativeOffset = Vector3.new(0, 0, -0.1)
		FailureWaypointImage.AlwaysOnTop = WaypointsAlwaysOnTop
		FailureWaypointImage.Image = TrailDotIcon
		FailureWaypointImage.Adornee = FailureWaypointTemplate
		FailureWaypointImage.Parent = FailureWaypointTemplate
		local FailureWaypointBillboard = Instance.new("BillboardGui")
		FailureWaypointBillboard.Name = "FailureWaypointBillboard"
		FailureWaypointBillboard.Size = WAYPOINT_BILLBOARD_SIZE
		FailureWaypointBillboard.LightInfluence = 0
		FailureWaypointBillboard.SizeOffset = FAIL_WAYPOINT_SIZE_OFFSET_CENTER
		FailureWaypointBillboard.AlwaysOnTop = true
		FailureWaypointBillboard.Adornee = FailureWaypointTemplate
		FailureWaypointBillboard.Parent = FailureWaypointTemplate
		local FailureWaypointFrame = Instance.new("Frame")
		FailureWaypointFrame.BackgroundTransparency = 1
		FailureWaypointFrame.Size = UDim2.new(0, 0, 0, 0)
		FailureWaypointFrame.Position = UDim2.new(0.5, 0, 1, 0)
		FailureWaypointFrame.Parent = FailureWaypointBillboard
		local FailureWaypointImageLabel = Instance.new("ImageLabel")
		FailureWaypointImageLabel.Image = EndWaypointIcon
		FailureWaypointImageLabel.BackgroundTransparency = 1
		FailureWaypointImageLabel.Position = UDim2.new(
			0, -WAYPOINT_BILLBOARD_SIZE.X.Offset/2, 0, -WAYPOINT_BILLBOARD_SIZE.Y.Offset
		)
		FailureWaypointImageLabel.Size = WAYPOINT_BILLBOARD_SIZE
		FailureWaypointImageLabel.Parent = FailureWaypointFrame
	
		return TrailDotTemplate, EndWaypointTemplate, FailureWaypointTemplate
	end
	
	local TrailDotTemplate, EndWaypointTemplate, FailureWaypointTemplate = CreateWaypointTemplates()
	
	local function getTrailDotParent()
		local camera = Workspace.CurrentCamera
		local trailParent = camera:FindFirstChild(TRAIL_DOT_PARENT_NAME)
		if not trailParent then
			trailParent = Instance.new("Model")
			trailParent.Name = TRAIL_DOT_PARENT_NAME
			trailParent.Parent = camera
		end
		return trailParent
	end
	
	local function placePathWaypoint(waypointModel, position)
		local ray = Ray.new(position + Vector3.new(0, 2.5, 0), Vector3.new(0, -10, 0))
		local hitPart, hitPoint, hitNormal = Workspace:FindPartOnRayWithIgnoreList(
			ray,
			{ Workspace.CurrentCamera, LocalPlayer.Character }
		)
		if hitPart then
			waypointModel.CFrame = CFrame.new(hitPoint, hitPoint + hitNormal)
			waypointModel.Parent = getTrailDotParent()
		end
	end
	
	local TrailDot = {}
	TrailDot.__index = TrailDot
	
	function TrailDot:Destroy()
		self.DisplayModel:Destroy()
	end
	
	function TrailDot:NewDisplayModel(position)
		local newDisplayModel = TrailDotTemplate:Clone()
		placePathWaypoint(newDisplayModel, position)
		return newDisplayModel
	end
	
	function TrailDot.new(position, closestWaypoint)
		local self = setmetatable({}, TrailDot)
	
		self.DisplayModel = self:NewDisplayModel(position)
		self.ClosestWayPoint = closestWaypoint
	
		return self
	end
	
	local EndWaypoint = {}
	EndWaypoint.__index = EndWaypoint
	
	function EndWaypoint:Destroy()
		self.Destroyed = true
		self.Tween:Cancel()
		self.DisplayModel:Destroy()
	end
	
	function EndWaypoint:NewDisplayModel(position)
		local newDisplayModel = EndWaypointTemplate:Clone()
		placePathWaypoint(newDisplayModel, position)
		return newDisplayModel
	end
	
	function EndWaypoint:CreateTween()
		local tweenInfo = TweenInfo.new(0.5, Enum.EasingStyle.Sine, Enum.EasingDirection.Out, -1, true)
		local tween = TweenService:Create(
			self.DisplayModel.EndWaypointBillboard,
			tweenInfo,
			{ SizeOffset = ENDWAYPOINT_SIZE_OFFSET_MAX }
		)
		tween:Play()
		return tween
	end
	
	function EndWaypoint:TweenInFrom(originalPosition)
		local currentPositon = self.DisplayModel.Position
		local studsOffset = originalPosition - currentPositon
		self.DisplayModel.EndWaypointBillboard.StudsOffset = Vector3.new(0, studsOffset.Y, 0)
		local tweenInfo = TweenInfo.new(1, Enum.EasingStyle.Sine, Enum.EasingDirection.Out)
		local tween = TweenService:Create(
			self.DisplayModel.EndWaypointBillboard,
			tweenInfo,
			{ StudsOffset = Vector3.new(0, 0, 0) }
		)
		tween:Play()
		return tween
	end
	
	function EndWaypoint.new(position, closestWaypoint, originalPosition)
		local self = setmetatable({}, EndWaypoint)
	
		self.DisplayModel = self:NewDisplayModel(position)
		self.Destroyed = false
		if originalPosition and (originalPosition - position).magnitude > TWEEN_WAYPOINT_THRESHOLD then
			self.Tween = self:TweenInFrom(originalPosition)
			coroutine.wrap(function()
				self.Tween.Completed:Wait()
				if not self.Destroyed then
					self.Tween = self:CreateTween()
				end
			end)()
		else
			self.Tween = self:CreateTween()
		end
		self.ClosestWayPoint = closestWaypoint
	
		return self
	end
	
	local FailureWaypoint = {}
	FailureWaypoint.__index = FailureWaypoint
	
	function FailureWaypoint:Hide()
		self.DisplayModel.Parent = nil
	end
	
	function FailureWaypoint:Destroy()
		self.DisplayModel:Destroy()
	end
	
	function FailureWaypoint:NewDisplayModel(position)
		local newDisplayModel = FailureWaypointTemplate:Clone()
		placePathWaypoint(newDisplayModel, position)
		local ray = Ray.new(position + Vector3.new(0, 2.5, 0), Vector3.new(0, -10, 0))
		local hitPart, hitPoint, hitNormal = Workspace:FindPartOnRayWithIgnoreList(
			ray, { Workspace.CurrentCamera, LocalPlayer.Character }
		)
		if hitPart then
			newDisplayModel.CFrame = CFrame.new(hitPoint, hitPoint + hitNormal)
			newDisplayModel.Parent = getTrailDotParent()
		end
		return newDisplayModel
	end
	
	function FailureWaypoint:RunFailureTween()
		wait(FAILURE_TWEEN_LENGTH) -- Delay one tween length betfore starting tweening
		-- Tween out from center
		local tweenInfo = TweenInfo.new(FAILURE_TWEEN_LENGTH/2, Enum.EasingStyle.Sine, Enum.EasingDirection.Out)
		local tweenLeft = TweenService:Create(self.DisplayModel.FailureWaypointBillboard, tweenInfo,
			{ SizeOffset = FAIL_WAYPOINT_SIZE_OFFSET_LEFT })
		tweenLeft:Play()
	
		local tweenLeftRoation = TweenService:Create(self.DisplayModel.FailureWaypointBillboard.Frame, tweenInfo,
			{ Rotation = 10 })
		tweenLeftRoation:Play()
	
		tweenLeft.Completed:wait()
	
		-- Tween back and forth
		tweenInfo = TweenInfo.new(FAILURE_TWEEN_LENGTH, Enum.EasingStyle.Sine, Enum.EasingDirection.Out,
			FAILURE_TWEEN_COUNT - 1, true)
		local tweenSideToSide = TweenService:Create(self.DisplayModel.FailureWaypointBillboard, tweenInfo,
			{ SizeOffset = FAIL_WAYPOINT_SIZE_OFFSET_RIGHT})
		tweenSideToSide:Play()
	
		-- Tween flash dark and roate left and right
		tweenInfo = TweenInfo.new(FAILURE_TWEEN_LENGTH, Enum.EasingStyle.Sine, Enum.EasingDirection.Out,
			FAILURE_TWEEN_COUNT - 1, true)
		local tweenFlash = TweenService:Create(self.DisplayModel.FailureWaypointBillboard.Frame.ImageLabel, tweenInfo,
			{ ImageColor3 = Color3.new(0.75, 0.75, 0.75)})
		tweenFlash:Play()
	
		local tweenRotate = TweenService:Create(self.DisplayModel.FailureWaypointBillboard.Frame, tweenInfo,
			{ Rotation = -10 })
		tweenRotate:Play()
	
		tweenSideToSide.Completed:wait()
	
		-- Tween back to center
		tweenInfo = TweenInfo.new(FAILURE_TWEEN_LENGTH/2, Enum.EasingStyle.Sine, Enum.EasingDirection.Out)
		local tweenCenter = TweenService:Create(self.DisplayModel.FailureWaypointBillboard, tweenInfo,
			{ SizeOffset = FAIL_WAYPOINT_SIZE_OFFSET_CENTER })
		tweenCenter:Play()
	
		local tweenRoation = TweenService:Create(self.DisplayModel.FailureWaypointBillboard.Frame, tweenInfo,
			{ Rotation = 0 })
		tweenRoation:Play()
	
		tweenCenter.Completed:wait()
	
		wait(FAILURE_TWEEN_LENGTH) -- Delay one tween length betfore removing
	end
	
	function FailureWaypoint.new(position)
		local self = setmetatable({}, FailureWaypoint)
	
		self.DisplayModel = self:NewDisplayModel(position)
	
		return self
	end
	
	local failureAnimation = Instance.new("Animation")
	failureAnimation.AnimationId = FAILURE_ANIMATION_ID
	
	local lastHumanoid = nil
	local lastFailureAnimationTrack = nil
	
	local function getFailureAnimationTrack(myHumanoid)
		if myHumanoid == lastHumanoid then
			return lastFailureAnimationTrack
		end
		lastFailureAnimationTrack = myHumanoid:LoadAnimation(failureAnimation)
		lastFailureAnimationTrack.Priority = Enum.AnimationPriority.Action
		lastFailureAnimationTrack.Looped = false
		return lastFailureAnimationTrack
	end
	
	local function findPlayerHumanoid()
		local character = LocalPlayer.Character
		if character then
			return character:FindFirstChildOfClass("Humanoid")
		end
	end
	
	local function createTrailDots(wayPoints, originalEndWaypoint)
		local newTrailDots = {}
		local count = 1
		for i = 1, #wayPoints - 1 do
			local closeToEnd = (wayPoints[i].Position - wayPoints[#wayPoints].Position).magnitude < LAST_DOT_DISTANCE
			local includeWaypoint = i % WAYPOINT_INCLUDE_FACTOR == 0 and not closeToEnd
			if includeWaypoint then
				local trailDot = TrailDot.new(wayPoints[i].Position, i)
				newTrailDots[count] = trailDot
				count = count + 1
			end
		end
	
		local newEndWaypoint = EndWaypoint.new(wayPoints[#wayPoints].Position, #wayPoints, originalEndWaypoint)
		table.insert(newTrailDots, newEndWaypoint)
	
		local reversedTrailDots = {}
		count = 1
		for i = #newTrailDots, 1, -1 do
			reversedTrailDots[count] = newTrailDots[i]
			count = count + 1
		end
		return reversedTrailDots
	end
	
	local function getTrailDotScale(distanceToCamera, defaultSize)
		local rangeLength = TRAIL_DOT_MAX_DISTANCE - TRAIL_DOT_MIN_DISTANCE
		local inRangePoint = math.clamp(distanceToCamera - TRAIL_DOT_MIN_DISTANCE, 0, rangeLength)/rangeLength
		local scale = TRAIL_DOT_MIN_SCALE + (TRAIL_DOT_MAX_SCALE - TRAIL_DOT_MIN_SCALE)*inRangePoint
		return defaultSize * scale
	end
	
	local createPathCount = 0
	-- originalEndWaypoint is optional, causes the waypoint to tween from that position.
	function ClickToMoveDisplay.CreatePathDisplay(wayPoints, originalEndWaypoint)
		createPathCount = createPathCount + 1
		local trailDots = createTrailDots(wayPoints, originalEndWaypoint)
	
		local function removePathBeforePoint(wayPointNumber)
			-- kill all trailDots before and at wayPointNumber
			for i = #trailDots, 1, -1 do
				local trailDot = trailDots[i]
				if trailDot.ClosestWayPoint <= wayPointNumber then
					trailDot:Destroy()
					trailDots[i] = nil
				else
					break
				end
			end
		end
	
		local reiszeTrailDotsUpdateName = "ClickToMoveResizeTrail" ..createPathCount
		local function resizeTrailDots()
			if #trailDots == 0 then
				RunService:UnbindFromRenderStep(reiszeTrailDotsUpdateName)
				return
			end
			local cameraPos = Workspace.CurrentCamera.CFrame.p
			for i = 1, #trailDots do
				local trailDotImage = trailDots[i].DisplayModel:FindFirstChild("TrailDotImage")
				if trailDotImage then
					local distanceToCamera = (trailDots[i].DisplayModel.Position - cameraPos).magnitude
					trailDotImage.Size = getTrailDotScale(distanceToCamera, TrailDotSize)
				end
			end
		end
		RunService:BindToRenderStep(reiszeTrailDotsUpdateName, Enum.RenderPriority.Camera.Value - 1, resizeTrailDots)
	
		local function removePath()
			removePathBeforePoint(#wayPoints)
		end
	
		return removePath, removePathBeforePoint
	end
	
	local lastFailureWaypoint = nil
	function ClickToMoveDisplay.DisplayFailureWaypoint(position)
		if lastFailureWaypoint then
			lastFailureWaypoint:Hide()
		end
		local failureWaypoint = FailureWaypoint.new(position)
		lastFailureWaypoint = failureWaypoint
		coroutine.wrap(function()
			failureWaypoint:RunFailureTween()
			failureWaypoint:Destroy()
			failureWaypoint = nil
		end)()
	end
	
	function ClickToMoveDisplay.CreateEndWaypoint(position)
		return EndWaypoint.new(position)
	end
	
	function ClickToMoveDisplay.PlayFailureAnimation()
		local myHumanoid = findPlayerHumanoid()
		if myHumanoid then
			local animationTrack = getFailureAnimationTrack(myHumanoid)
			animationTrack:Play()
		end
	end
	
	function ClickToMoveDisplay.CancelFailureAnimation()
		if lastFailureAnimationTrack ~= nil and lastFailureAnimationTrack.IsPlaying then
			lastFailureAnimationTrack:Stop()
		end
	end
	
	function ClickToMoveDisplay.SetWaypointTexture(texture)
		TrailDotIcon = texture
		TrailDotTemplate, EndWaypointTemplate, FailureWaypointTemplate = CreateWaypointTemplates()
	end
	
	function ClickToMoveDisplay.GetWaypointTexture()
		return TrailDotIcon
	end
	
	function ClickToMoveDisplay.SetWaypointRadius(radius)
		TrailDotSize = Vector2.new(radius, radius)
		TrailDotTemplate, EndWaypointTemplate, FailureWaypointTemplate = CreateWaypointTemplates()
	end
	
	function ClickToMoveDisplay.GetWaypointRadius()
		return TrailDotSize.X
	end
	
	function ClickToMoveDisplay.SetEndWaypointTexture(texture)
		EndWaypointIcon = texture
		TrailDotTemplate, EndWaypointTemplate, FailureWaypointTemplate = CreateWaypointTemplates()
	end
	
	function ClickToMoveDisplay.GetEndWaypointTexture()
		return EndWaypointIcon
	end
	
	function ClickToMoveDisplay.SetWaypointsAlwaysOnTop(alwaysOnTop)
		WaypointsAlwaysOnTop = alwaysOnTop
		TrailDotTemplate, EndWaypointTemplate, FailureWaypointTemplate = CreateWaypointTemplates()
	end
	
	function ClickToMoveDisplay.GetWaypointsAlwaysOnTop()
		return WaypointsAlwaysOnTop
	end
	
	return ClickToMoveDisplay
	end

	function _BaseCharacterController()

	local ZERO_VECTOR3 = Vector3.new(0,0,0)
	
	--[[ The Module ]]--
	local BaseCharacterController = {}
	BaseCharacterController.__index = BaseCharacterController
	
	function BaseCharacterController.new()
		local self = setmetatable({}, BaseCharacterController)
		self.enabled = false
		self.moveVector = ZERO_VECTOR3
		self.moveVectorIsCameraRelative = true
		self.isJumping = false
		return self
	end
	
	function BaseCharacterController:OnRenderStepped(dt)
		-- By default, nothing to do
	end
	
	function BaseCharacterController:GetMoveVector()
		return self.moveVector
	end
	
	function BaseCharacterController:IsMoveVectorCameraRelative()
		return self.moveVectorIsCameraRelative
	end
	
	function BaseCharacterController:GetIsJumping()
		return self.isJumping
	end
	
	-- Override in derived classes to set self.enabled and return boolean indicating
	-- whether Enable/Disable was successful. Return true if controller is already in the requested state.
	function BaseCharacterController:Enable(enable)
		error("BaseCharacterController:Enable must be overridden in derived classes and should not be called.")
		return false
	end
	
	return BaseCharacterController
	end

	function _VehicleController()
	local ContextActionService = game:GetService("ContextActionService")
	
	--[[ Constants ]]--
	-- Set this to true if you want to instead use the triggers for the throttle
	local useTriggersForThrottle = true
	-- Also set this to true if you want the thumbstick to not affect throttle, only triggers when a gamepad is conected
	local onlyTriggersForThrottle = false
	local ZERO_VECTOR3 = Vector3.new(0,0,0)
	
	local AUTO_PILOT_DEFAULT_MAX_STEERING_ANGLE = 35
	
	
	-- Note that VehicleController does not derive from BaseCharacterController, it is a special case
	local VehicleController = {}
	VehicleController.__index = VehicleController
	
	function VehicleController.new(CONTROL_ACTION_PRIORITY)
		local self = setmetatable({}, VehicleController)
	
		self.CONTROL_ACTION_PRIORITY = CONTROL_ACTION_PRIORITY
	
		self.enabled = false
		self.vehicleSeat = nil
		self.throttle = 0
		self.steer = 0
	
		self.acceleration = 0
		self.decceleration = 0
		self.turningRight = 0
		self.turningLeft = 0
	
		self.vehicleMoveVector = ZERO_VECTOR3
	
		self.autoPilot = {}
		self.autoPilot.MaxSpeed = 0
		self.autoPilot.MaxSteeringAngle = 0
	
		return self
	end
	
	function VehicleController:BindContextActions()
		if useTriggersForThrottle then
			ContextActionService:BindActionAtPriority("throttleAccel", (function(actionName, inputState, inputObject)
				self:OnThrottleAccel(actionName, inputState, inputObject)
				return Enum.ContextActionResult.Pass
			end), false, self.CONTROL_ACTION_PRIORITY, Enum.KeyCode.ButtonR2)
			ContextActionService:BindActionAtPriority("throttleDeccel", (function(actionName, inputState, inputObject)
				self:OnThrottleDeccel(actionName, inputState, inputObject)
				return Enum.ContextActionResult.Pass
			end), false, self.CONTROL_ACTION_PRIORITY, Enum.KeyCode.ButtonL2)
		end
		ContextActionService:BindActionAtPriority("arrowSteerRight", (function(actionName, inputState, inputObject)
			self:OnSteerRight(actionName, inputState, inputObject)
			return Enum.ContextActionResult.Pass
		end), false, self.CONTROL_ACTION_PRIORITY, Enum.KeyCode.Right)
		ContextActionService:BindActionAtPriority("arrowSteerLeft", (function(actionName, inputState, inputObject)
			self:OnSteerLeft(actionName, inputState, inputObject)
			return Enum.ContextActionResult.Pass
		end), false, self.CONTROL_ACTION_PRIORITY, Enum.KeyCode.Left)
	end
	
	function VehicleController:Enable(enable, vehicleSeat)
		if enable == self.enabled and vehicleSeat == self.vehicleSeat then
			return
		end
	
		self.enabled = enable
		self.vehicleMoveVector = ZERO_VECTOR3
	
		if enable then
			if vehicleSeat then
				self.vehicleSeat = vehicleSeat
	
				self:SetupAutoPilot()
				self:BindContextActions()
			end
		else
			if useTriggersForThrottle then
				ContextActionService:UnbindAction("throttleAccel")
				ContextActionService:UnbindAction("throttleDeccel")
			end
			ContextActionService:UnbindAction("arrowSteerRight")
			ContextActionService:UnbindAction("arrowSteerLeft")
			self.vehicleSeat = nil
		end
	end
	
	function VehicleController:OnThrottleAccel(actionName, inputState, inputObject)
		if inputState == Enum.UserInputState.End or inputState == Enum.UserInputState.Cancel then
			self.acceleration = 0
		else
			self.acceleration = -1
		end
		self.throttle = self.acceleration + self.decceleration
	end
	
	function VehicleController:OnThrottleDeccel(actionName, inputState, inputObject)
		if inputState == Enum.UserInputState.End or inputState == Enum.UserInputState.Cancel then
			self.decceleration = 0
		else
			self.decceleration = 1
		end
		self.throttle = self.acceleration + self.decceleration
	end
	
	function VehicleController:OnSteerRight(actionName, inputState, inputObject)
		if inputState == Enum.UserInputState.End or inputState == Enum.UserInputState.Cancel then
			self.turningRight = 0
		else
			self.turningRight = 1
		end
		self.steer = self.turningRight + self.turningLeft
	end
	
	function VehicleController:OnSteerLeft(actionName, inputState, inputObject)
		if inputState == Enum.UserInputState.End or inputState == Enum.UserInputState.Cancel then
			self.turningLeft = 0
		else
			self.turningLeft = -1
		end
		self.steer = self.turningRight + self.turningLeft
	end
	
	-- Call this from a function bound to Renderstep with Input Priority
	function VehicleController:Update(moveVector, cameraRelative, usingGamepad)
		if self.vehicleSeat then
			if cameraRelative then
				-- This is the default steering mode
				moveVector = moveVector + Vector3.new(self.steer, 0, self.throttle)
				if usingGamepad and onlyTriggersForThrottle and useTriggersForThrottle then
					self.vehicleSeat.ThrottleFloat = -self.throttle
				else
					self.vehicleSeat.ThrottleFloat = -moveVector.Z
				end
				self.vehicleSeat.SteerFloat = moveVector.X
	
				return moveVector, true
			else
				-- This is the path following mode
				local localMoveVector = self.vehicleSeat.Occupant.RootPart.CFrame:VectorToObjectSpace(moveVector)
	
				self.vehicleSeat.ThrottleFloat = self:ComputeThrottle(localMoveVector)
				self.vehicleSeat.SteerFloat = self:ComputeSteer(localMoveVector)
	
				return ZERO_VECTOR3, true
			end
		end
		return moveVector, false
	end
	
	function VehicleController:ComputeThrottle(localMoveVector)
		if localMoveVector ~= ZERO_VECTOR3 then
			local throttle = -localMoveVector.Z
			return throttle
		else
			return 0.0
		end
	end
	
	function VehicleController:ComputeSteer(localMoveVector)
		if localMoveVector ~= ZERO_VECTOR3 then
			local steerAngle = -math.atan2(-localMoveVector.x, -localMoveVector.z) * (180 / math.pi)
			return steerAngle / self.autoPilot.MaxSteeringAngle
		else
			return 0.0
		end
	end
	
	function VehicleController:SetupAutoPilot()
		-- Setup default
		self.autoPilot.MaxSpeed = self.vehicleSeat.MaxSpeed
		self.autoPilot.MaxSteeringAngle = AUTO_PILOT_DEFAULT_MAX_STEERING_ANGLE
	
		-- VehicleSeat should have a MaxSteeringAngle as well.
		-- Or we could look for a child "AutoPilotConfigModule" to find these values
		-- Or allow developer to set them through the API as like the CLickToMove customization API
	end
	
	return VehicleController
	end

	function _TouchJump()
	
	local Players = game:GetService("Players")
	local GuiService = game:GetService("GuiService")
	
	--[[ Constants ]]--
	local TOUCH_CONTROL_SHEET = "rbxasset://textures/ui/Input/TouchControlsSheetV2.png"
	
	--[[ The Module ]]--
	local BaseCharacterController = _BaseCharacterController()
	local TouchJump = setmetatable({}, BaseCharacterController)
	TouchJump.__index = TouchJump
	
	function TouchJump.new()
		local self = setmetatable(BaseCharacterController.new(), TouchJump)
	
		self.parentUIFrame = nil
		self.jumpButton = nil
		self.characterAddedConn = nil
		self.humanoidStateEnabledChangedConn = nil
		self.humanoidJumpPowerConn = nil
		self.humanoidParentConn = nil
		self.externallyEnabled = false
		self.jumpPower = 0
		self.jumpStateEnabled = true
		self.isJumping = false
		self.humanoid = nil -- saved reference because property change connections are made using it
	
		return self
	end
	
	function TouchJump:EnableButton(enable)
		if enable then
			if not self.jumpButton then
				self:Create()
			end
			local humanoid = Players.LocalPlayer.Character and Players.LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
			if humanoid and self.externallyEnabled then
				if self.externallyEnabled then
					if humanoid.JumpPower > 0 then
						self.jumpButton.Visible = true
					end
				end
			end
		else
			self.jumpButton.Visible = false
			self.isJumping = false
			self.jumpButton.ImageRectOffset = Vector2.new(1, 146)
		end
	end
	
	function TouchJump:UpdateEnabled()
		if self.jumpPower > 0 and self.jumpStateEnabled then
			self:EnableButton(true)
		else
			self:EnableButton(false)
		end
	end
	
	function TouchJump:HumanoidChanged(prop)
		local humanoid = Players.LocalPlayer.Character and Players.LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
		if humanoid then
			if prop == "JumpPower" then
				self.jumpPower =  humanoid.JumpPower
				self:UpdateEnabled()
			elseif prop == "Parent" then
				if not humanoid.Parent then
					self.humanoidChangeConn:Disconnect()
				end
			end
		end
	end
	
	function TouchJump:HumanoidStateEnabledChanged(state, isEnabled)
		if state == Enum.HumanoidStateType.Jumping then
			self.jumpStateEnabled = isEnabled
			self:UpdateEnabled()
		end
	end
	
	function TouchJump:CharacterAdded(char)
		if self.humanoidChangeConn then
			self.humanoidChangeConn:Disconnect()
			self.humanoidChangeConn = nil
		end
	
		self.humanoid = char:FindFirstChildOfClass("Humanoid")
		while not self.humanoid do
			char.ChildAdded:wait()
			self.humanoid = char:FindFirstChildOfClass("Humanoid")
		end
	
		self.humanoidJumpPowerConn = self.humanoid:GetPropertyChangedSignal("JumpPower"):Connect(function()
			self.jumpPower =  self.humanoid.JumpPower
			self:UpdateEnabled()
		end)
	
		self.humanoidParentConn = self.humanoid:GetPropertyChangedSignal("Parent"):Connect(function()
			if not self.humanoid.Parent then
				self.humanoidJumpPowerConn:Disconnect()
				self.humanoidJumpPowerConn = nil
				self.humanoidParentConn:Disconnect()
				self.humanoidParentConn = nil
			end
		end)
	
		self.humanoidStateEnabledChangedConn = self.humanoid.StateEnabledChanged:Connect(function(state, enabled)
			self:HumanoidStateEnabledChanged(state, enabled)
		end)
	
		self.jumpPower = self.humanoid.JumpPower
		self.jumpStateEnabled = self.humanoid:GetStateEnabled(Enum.HumanoidStateType.Jumping)
		self:UpdateEnabled()
	end
	
	function TouchJump:SetupCharacterAddedFunction()
		self.characterAddedConn = Players.LocalPlayer.CharacterAdded:Connect(function(char)
			self:CharacterAdded(char)
		end)
		if Players.LocalPlayer.Character then
			self:CharacterAdded(Players.LocalPlayer.Character)
		end
	end
	
	function TouchJump:Enable(enable, parentFrame)
		if parentFrame then
			self.parentUIFrame = parentFrame
		end
		self.externallyEnabled = enable
		self:EnableButton(enable)
	end
	
	function TouchJump:Create()
		if not self.parentUIFrame then
			return
		end
	
		if self.jumpButton then
			self.jumpButton:Destroy()
			self.jumpButton = nil
		end
	
		local minAxis = math.min(self.parentUIFrame.AbsoluteSize.x, self.parentUIFrame.AbsoluteSize.y)
		local isSmallScreen = minAxis <= 500
		local jumpButtonSize = isSmallScreen and 70 or 120
	
		self.jumpButton = Instance.new("ImageButton")
		self.jumpButton.Name = "JumpButton"
		self.jumpButton.Visible = false
		self.jumpButton.BackgroundTransparency = 1
		self.jumpButton.Image = TOUCH_CONTROL_SHEET
		self.jumpButton.ImageRectOffset = Vector2.new(1, 146)
		self.jumpButton.ImageRectSize = Vector2.new(144, 144)
		self.jumpButton.Size = UDim2.new(0, jumpButtonSize, 0, jumpButtonSize)
	
	    self.jumpButton.Position = isSmallScreen and UDim2.new(1, -(jumpButtonSize*1.5-10), 1, -jumpButtonSize - 20) or
	        UDim2.new(1, -(jumpButtonSize*1.5-10), 1, -jumpButtonSize * 1.75)
	
		local touchObject = nil
		self.jumpButton.InputBegan:connect(function(inputObject)
			--A touch that starts elsewhere on the screen will be sent to a frame's InputBegan event
			--if it moves over the frame. So we check that this is actually a new touch (inputObject.UserInputState ~= Enum.UserInputState.Begin)
			if touchObject or inputObject.UserInputType ~= Enum.UserInputType.Touch
				or inputObject.UserInputState ~= Enum.UserInputState.Begin then
				return
			end
	
			touchObject = inputObject
			self.jumpButton.ImageRectOffset = Vector2.new(146, 146)
			self.isJumping = true
		end)
	
		local OnInputEnded = function()
			touchObject = nil
			self.isJumping = false
			self.jumpButton.ImageRectOffset = Vector2.new(1, 146)
		end
	
		self.jumpButton.InputEnded:connect(function(inputObject)
			if inputObject == touchObject then
				OnInputEnded()
			end
		end)
	
		GuiService.MenuOpened:connect(function()
			if touchObject then
				OnInputEnded()
			end
		end)
	
		if not self.characterAddedConn then
			self:SetupCharacterAddedFunction()
		end
	
		self.jumpButton.Parent = self.parentUIFrame
	end
	
	return TouchJump
	end

	function _ClickToMoveController()
	--[[ Roblox Services ]]--
	local UserInputService = game:GetService("UserInputService")
	local PathfindingService = game:GetService("PathfindingService")
	local Players = game:GetService("Players")
	local DebrisService = game:GetService('Debris')
	local StarterGui = game:GetService("StarterGui")
	local Workspace = game:GetService("Workspace")
	local CollectionService = game:GetService("CollectionService")
	local GuiService = game:GetService("GuiService")
	
	--[[ Configuration ]]
	local ShowPath = true
	local PlayFailureAnimation = true
	local UseDirectPath = false
	local UseDirectPathForVehicle = true
	local AgentSizeIncreaseFactor = 1.0
	local UnreachableWaypointTimeout = 8
	
	--[[ Constants ]]--
	local movementKeys = {
		[Enum.KeyCode.W] = true;
		[Enum.KeyCode.A] = true;
		[Enum.KeyCode.S] = true;
		[Enum.KeyCode.D] = true;
		[Enum.KeyCode.Up] = true;
		[Enum.KeyCode.Down] = true;
	}
	
	local FFlagUserNavigationClickToMoveSkipPassedWaypointsSuccess, FFlagUserNavigationClickToMoveSkipPassedWaypointsResult = pcall(function() return UserSettings():IsUserFeatureEnabled("UserNavigationClickToMoveSkipPassedWaypoints") end)
	local FFlagUserNavigationClickToMoveSkipPassedWaypoints = FFlagUserNavigationClickToMoveSkipPassedWaypointsSuccess and FFlagUserNavigationClickToMoveSkipPassedWaypointsResult
	
	local Player = Players.LocalPlayer
	
	local ClickToMoveDisplay = _ClickToMoveDisplay()
	
	local ZERO_VECTOR3 = Vector3.new(0,0,0)
	local ALMOST_ZERO = 0.000001
	
	
	--------------------------UTIL LIBRARY-------------------------------
	local Utility = {}
	do
		local function FindCharacterAncestor(part)
			if part then
				local humanoid = part:FindFirstChildOfClass("Humanoid")
				if humanoid then
					return part, humanoid
				else
					return FindCharacterAncestor(part.Parent)
				end
			end
		end
		Utility.FindCharacterAncestor = FindCharacterAncestor
	
		local function Raycast(ray, ignoreNonCollidable, ignoreList)
			ignoreList = ignoreList or {}
			local hitPart, hitPos, hitNorm, hitMat = Workspace:FindPartOnRayWithIgnoreList(ray, ignoreList)
			if hitPart then
				if ignoreNonCollidable and hitPart.CanCollide == false then
					-- We always include character parts so a user can click on another character
					-- to walk to them.
					local _, humanoid = FindCharacterAncestor(hitPart)
					if humanoid == nil then
						table.insert(ignoreList, hitPart)
						return Raycast(ray, ignoreNonCollidable, ignoreList)
					end
				end
				return hitPart, hitPos, hitNorm, hitMat
			end
			return nil, nil
		end
		Utility.Raycast = Raycast
	end
	
	local humanoidCache = {}
	local function findPlayerHumanoid(player)
		local character = player and player.Character
		if character then
			local resultHumanoid = humanoidCache[player]
			if resultHumanoid and resultHumanoid.Parent == character then
				return resultHumanoid
			else
				humanoidCache[player] = nil -- Bust Old Cache
				local humanoid = character:FindFirstChildOfClass("Humanoid")
				if humanoid then
					humanoidCache[player] = humanoid
				end
				return humanoid
			end
		end
	end
	
	--------------------------CHARACTER CONTROL-------------------------------
	local CurrentIgnoreList
	local CurrentIgnoreTag = nil
	
	local TaggedInstanceAddedConnection = nil
	local TaggedInstanceRemovedConnection = nil
	
	local function GetCharacter()
		return Player and Player.Character
	end
	
	local function UpdateIgnoreTag(newIgnoreTag)
		if newIgnoreTag == CurrentIgnoreTag then
			return
		end
		if TaggedInstanceAddedConnection then
			TaggedInstanceAddedConnection:Disconnect()
			TaggedInstanceAddedConnection = nil
		end
		if TaggedInstanceRemovedConnection then
			TaggedInstanceRemovedConnection:Disconnect()
			TaggedInstanceRemovedConnection = nil
		end
		CurrentIgnoreTag = newIgnoreTag
		CurrentIgnoreList = {GetCharacter()}
		if CurrentIgnoreTag ~= nil then
			local ignoreParts = CollectionService:GetTagged(CurrentIgnoreTag)
			for _, ignorePart in ipairs(ignoreParts) do
				table.insert(CurrentIgnoreList, ignorePart)
			end
			TaggedInstanceAddedConnection = CollectionService:GetInstanceAddedSignal(
				CurrentIgnoreTag):Connect(function(ignorePart)
				table.insert(CurrentIgnoreList, ignorePart)
			end)
			TaggedInstanceRemovedConnection = CollectionService:GetInstanceRemovedSignal(
				CurrentIgnoreTag):Connect(function(ignorePart)
				for i = 1, #CurrentIgnoreList do
					if CurrentIgnoreList[i] == ignorePart then
						CurrentIgnoreList[i] = CurrentIgnoreList[#CurrentIgnoreList]
						table.remove(CurrentIgnoreList)
						break
					end
				end
			end)
		end
	end
	
	local function getIgnoreList()
		if CurrentIgnoreList then
			return CurrentIgnoreList
		end
		CurrentIgnoreList = {}
		table.insert(CurrentIgnoreList, GetCharacter())
		return CurrentIgnoreList
	end
	
	-----------------------------------PATHER--------------------------------------
	
	local function Pather(endPoint, surfaceNormal, overrideUseDirectPath)
		local this = {}
	
		local directPathForHumanoid
		local directPathForVehicle
		if overrideUseDirectPath ~= nil then
			directPathForHumanoid = overrideUseDirectPath
			directPathForVehicle = overrideUseDirectPath
		else
			directPathForHumanoid = UseDirectPath
			directPathForVehicle = UseDirectPathForVehicle
		end
	
		this.Cancelled = false
		this.Started = false
	
		this.Finished = Instance.new("BindableEvent")
		this.PathFailed = Instance.new("BindableEvent")
	
		this.PathComputing = false
		this.PathComputed = false
	
		this.OriginalTargetPoint = endPoint
		this.TargetPoint = endPoint
		this.TargetSurfaceNormal = surfaceNormal
	
		this.DiedConn = nil
		this.SeatedConn = nil
		this.BlockedConn = nil
		this.TeleportedConn = nil
	
		this.CurrentPoint = 0
	
		this.HumanoidOffsetFromPath = ZERO_VECTOR3
	
		this.CurrentWaypointPosition = nil
		this.CurrentWaypointPlaneNormal = ZERO_VECTOR3
		this.CurrentWaypointPlaneDistance = 0
		this.CurrentWaypointNeedsJump = false;
	
		this.CurrentHumanoidPosition = ZERO_VECTOR3
		this.CurrentHumanoidVelocity = 0
	
		this.NextActionMoveDirection = ZERO_VECTOR3
		this.NextActionJump = false
	
		this.Timeout = 0
	
		this.Humanoid = findPlayerHumanoid(Player)
		this.OriginPoint = nil
		this.AgentCanFollowPath = false
		this.DirectPath = false
		this.DirectPathRiseFirst = false
	
		local rootPart = this.Humanoid and this.Humanoid.RootPart
		if rootPart then
			-- Setup origin
			this.OriginPoint = rootPart.CFrame.p
	
			-- Setup agent
			local agentRadius = 2
			local agentHeight = 5
			local agentCanJump = true
	
			local seat = this.Humanoid.SeatPart
			if seat and seat:IsA("VehicleSeat") then
				-- Humanoid is seated on a vehicle
				local vehicle = seat:FindFirstAncestorOfClass("Model")
				if vehicle then
					-- Make sure the PrimaryPart is set to the vehicle seat while we compute the extends.
					local tempPrimaryPart = vehicle.PrimaryPart
					vehicle.PrimaryPart = seat
	
					-- For now, only direct path
					if directPathForVehicle then
						local extents = vehicle:GetExtentsSize()
						agentRadius = AgentSizeIncreaseFactor * 0.5 * math.sqrt(extents.X * extents.X + extents.Z * extents.Z)
						agentHeight = AgentSizeIncreaseFactor * extents.Y
						agentCanJump = false
						this.AgentCanFollowPath = true
						this.DirectPath = directPathForVehicle
					end
	
					-- Reset PrimaryPart
					vehicle.PrimaryPart = tempPrimaryPart
				end
			else
				local extents = GetCharacter():GetExtentsSize()
				agentRadius = AgentSizeIncreaseFactor * 0.5 * math.sqrt(extents.X * extents.X + extents.Z * extents.Z)
				agentHeight = AgentSizeIncreaseFactor * extents.Y
				agentCanJump = (this.Humanoid.JumpPower > 0)
				this.AgentCanFollowPath = true
				this.DirectPath = directPathForHumanoid
				this.DirectPathRiseFirst = this.Humanoid.Sit
			end
	
			-- Build path object
			this.pathResult = PathfindingService:CreatePath({AgentRadius = agentRadius, AgentHeight = agentHeight, AgentCanJump = agentCanJump})
		end
	
		function this:Cleanup()
			if this.stopTraverseFunc then
				this.stopTraverseFunc()
				this.stopTraverseFunc = nil
			end
	
			if this.MoveToConn then
				this.MoveToConn:Disconnect()
				this.MoveToConn = nil
			end
	
			if this.BlockedConn then
				this.BlockedConn:Disconnect()
				this.BlockedConn = nil
			end
	
			if this.DiedConn then
				this.DiedConn:Disconnect()
				this.DiedConn = nil
			end
	
			if this.SeatedConn then
				this.SeatedConn:Disconnect()
				this.SeatedConn = nil
			end
	
			if this.TeleportedConn then
				this.TeleportedConn:Disconnect()
				this.TeleportedConn = nil
			end
	
			this.Started = false
		end
	
		function this:Cancel()
			this.Cancelled = true
			this:Cleanup()
		end
	
		function this:IsActive()
			return this.AgentCanFollowPath and this.Started and not this.Cancelled
		end
	
		function this:OnPathInterrupted()
			-- Stop moving
			this.Cancelled = true
			this:OnPointReached(false)
		end
	
		function this:ComputePath()
			if this.OriginPoint then
				if this.PathComputed or this.PathComputing then return end
				this.PathComputing = true
				if this.AgentCanFollowPath then
					if this.DirectPath then
						this.pointList = {
							PathWaypoint.new(this.OriginPoint, Enum.PathWaypointAction.Walk),
							PathWaypoint.new(this.TargetPoint, this.DirectPathRiseFirst and Enum.PathWaypointAction.Jump or Enum.PathWaypointAction.Walk)
						}
						this.PathComputed = true
					else
						this.pathResult:ComputeAsync(this.OriginPoint, this.TargetPoint)
						this.pointList = this.pathResult:GetWaypoints()
						this.BlockedConn = this.pathResult.Blocked:Connect(function(blockedIdx) this:OnPathBlocked(blockedIdx) end)
						this.PathComputed = this.pathResult.Status == Enum.PathStatus.Success
					end
				end
				this.PathComputing = false
			end
		end
	
		function this:IsValidPath()
			this:ComputePath()
			return this.PathComputed and this.AgentCanFollowPath
		end
	
		this.Recomputing = false
		function this:OnPathBlocked(blockedWaypointIdx)
			local pathBlocked = blockedWaypointIdx >= this.CurrentPoint
			if not pathBlocked or this.Recomputing then
				return
			end
	
			this.Recomputing = true
	
			if this.stopTraverseFunc then
				this.stopTraverseFunc()
				this.stopTraverseFunc = nil
			end
	
			this.OriginPoint = this.Humanoid.RootPart.CFrame.p
	
			this.pathResult:ComputeAsync(this.OriginPoint, this.TargetPoint)
			this.pointList = this.pathResult:GetWaypoints()
			if #this.pointList > 0 then
				this.HumanoidOffsetFromPath = this.pointList[1].Position - this.OriginPoint
			end
			this.PathComputed = this.pathResult.Status == Enum.PathStatus.Success
	
			if ShowPath then
				this.stopTraverseFunc, this.setPointFunc = ClickToMoveDisplay.CreatePathDisplay(this.pointList)
			end
			if this.PathComputed then
				this.CurrentPoint = 1 -- The first waypoint is always the start location. Skip it.
				this:OnPointReached(true) -- Move to first point
			else
				this.PathFailed:Fire()
				this:Cleanup()
			end
	
			this.Recomputing = false
		end
	
		function this:OnRenderStepped(dt)
			if this.Started and not this.Cancelled then
				-- Check for Timeout (if a waypoint is not reached within the delay, we fail)
				this.Timeout = this.Timeout + dt
				if this.Timeout > UnreachableWaypointTimeout then
					this:OnPointReached(false)
					return
				end
	
				-- Get Humanoid position and velocity
				this.CurrentHumanoidPosition = this.Humanoid.RootPart.Position + this.HumanoidOffsetFromPath
				this.CurrentHumanoidVelocity = this.Humanoid.RootPart.Velocity
	
				-- Check if it has reached some waypoints
				while this.Started and this:IsCurrentWaypointReached() do
					this:OnPointReached(true)
				end
	
				-- If still started, update actions
				if this.Started then
					-- Move action
					this.NextActionMoveDirection = this.CurrentWaypointPosition - this.CurrentHumanoidPosition
					if this.NextActionMoveDirection.Magnitude > ALMOST_ZERO then
						this.NextActionMoveDirection = this.NextActionMoveDirection.Unit
					else
						this.NextActionMoveDirection = ZERO_VECTOR3
					end
					-- Jump action
					if this.CurrentWaypointNeedsJump then
						this.NextActionJump = true
						this.CurrentWaypointNeedsJump = false	-- Request jump only once
					else
						this.NextActionJump = false
					end
				end
			end
		end
	
		function this:IsCurrentWaypointReached()
			local reached = false
	
			-- Check we do have a plane, if not, we consider the waypoint reached
			if this.CurrentWaypointPlaneNormal ~= ZERO_VECTOR3 then
				-- Compute distance of Humanoid from destination plane
				local dist = this.CurrentWaypointPlaneNormal:Dot(this.CurrentHumanoidPosition) - this.CurrentWaypointPlaneDistance
				-- Compute the component of the Humanoid velocity that is towards the plane
				local velocity = -this.CurrentWaypointPlaneNormal:Dot(this.CurrentHumanoidVelocity)
				-- Compute the threshold from the destination plane based on Humanoid velocity
				local threshold = math.max(1.0, 0.0625 * velocity)
				-- If we are less then threshold in front of the plane (between 0 and threshold) or if we are behing the plane (less then 0), we consider we reached it
				reached = dist < threshold
			else
				reached = true
			end
	
			if reached then
				this.CurrentWaypointPosition = nil
				this.CurrentWaypointPlaneNormal	= ZERO_VECTOR3
				this.CurrentWaypointPlaneDistance = 0
			end
	
			return reached
		end
	
		function this:OnPointReached(reached)
	
			if reached and not this.Cancelled then
				-- First, destroyed the current displayed waypoint
				if this.setPointFunc then
					this.setPointFunc(this.CurrentPoint)
				end
	
				local nextWaypointIdx = this.CurrentPoint + 1
	
				if nextWaypointIdx > #this.pointList then
					-- End of path reached
					if this.stopTraverseFunc then
						this.stopTraverseFunc()
					end
					this.Finished:Fire()
					this:Cleanup()
				else
					local currentWaypoint = this.pointList[this.CurrentPoint]
					local nextWaypoint = this.pointList[nextWaypointIdx]
	
					-- If airborne, only allow to keep moving
					-- if nextWaypoint.Action ~= Jump, or path mantains a direction
					-- Otherwise, wait until the humanoid gets to the ground
					local currentState = this.Humanoid:GetState()
					local isInAir = currentState == Enum.HumanoidStateType.FallingDown
						or currentState == Enum.HumanoidStateType.Freefall
						or currentState == Enum.HumanoidStateType.Jumping
	
					if isInAir then
						local shouldWaitForGround = nextWaypoint.Action == Enum.PathWaypointAction.Jump
						if not shouldWaitForGround and this.CurrentPoint > 1 then
							local prevWaypoint = this.pointList[this.CurrentPoint - 1]
	
							local prevDir = currentWaypoint.Position - prevWaypoint.Position
							local currDir = nextWaypoint.Position - currentWaypoint.Position
	
							local prevDirXZ = Vector2.new(prevDir.x, prevDir.z).Unit
							local currDirXZ = Vector2.new(currDir.x, currDir.z).Unit
	
							local THRESHOLD_COS = 0.996 -- ~cos(5 degrees)
							shouldWaitForGround = prevDirXZ:Dot(currDirXZ) < THRESHOLD_COS
						end
	
						if shouldWaitForGround then
							this.Humanoid.FreeFalling:Wait()
	
							-- Give time to the humanoid's state to change
							-- Otherwise, the jump flag in Humanoid
							-- will be reset by the state change
							wait(0.1)
						end
					end
	
					-- Move to the next point
					if FFlagUserNavigationClickToMoveSkipPassedWaypoints then
						this:MoveToNextWayPoint(currentWaypoint, nextWaypoint, nextWaypointIdx)
					else
						if this.setPointFunc then
							this.setPointFunc(nextWaypointIdx)
						end
						if nextWaypoint.Action == Enum.PathWaypointAction.Jump then
							this.Humanoid.Jump = true
						end
						this.Humanoid:MoveTo(nextWaypoint.Position)
	
						this.CurrentPoint = nextWaypointIdx
					end
				end
			else
				this.PathFailed:Fire()
				this:Cleanup()
			end
		end
	
		function this:MoveToNextWayPoint(currentWaypoint, nextWaypoint, nextWaypointIdx)
			-- Build next destination plane
			-- (plane normal is perpendicular to the y plane and is from next waypoint towards current one (provided the two waypoints are not at the same location))
			-- (plane location is at next waypoint)
			this.CurrentWaypointPlaneNormal = currentWaypoint.Position - nextWaypoint.Position
			this.CurrentWaypointPlaneNormal = Vector3.new(this.CurrentWaypointPlaneNormal.X, 0, this.CurrentWaypointPlaneNormal.Z)
			if this.CurrentWaypointPlaneNormal.Magnitude > ALMOST_ZERO then
				this.CurrentWaypointPlaneNormal	= this.CurrentWaypointPlaneNormal.Unit
				this.CurrentWaypointPlaneDistance = this.CurrentWaypointPlaneNormal:Dot(nextWaypoint.Position)
			else
				-- Next waypoint is the same as current waypoint so no plane
				this.CurrentWaypointPlaneNormal	= ZERO_VECTOR3
				this.CurrentWaypointPlaneDistance = 0
			end
	
			-- Should we jump
			this.CurrentWaypointNeedsJump = nextWaypoint.Action == Enum.PathWaypointAction.Jump;
	
			-- Remember next waypoint position
			this.CurrentWaypointPosition = nextWaypoint.Position
	
			-- Move to next point
			this.CurrentPoint = nextWaypointIdx
	
			-- Finally reset Timeout
			this.Timeout = 0
		end
	
		function this:Start(overrideShowPath)
			if not this.AgentCanFollowPath then
				this.PathFailed:Fire()
				return
			end
	
			if this.Started then return end
			this.Started = true
	
			ClickToMoveDisplay.CancelFailureAnimation()
	
			if ShowPath then
				if overrideShowPath == nil or overrideShowPath then
					this.stopTraverseFunc, this.setPointFunc = ClickToMoveDisplay.CreatePathDisplay(this.pointList, this.OriginalTargetPoint)
				end
			end
	
			if #this.pointList > 0 then
				-- Determine the humanoid offset from the path's first point
				-- Offset of the first waypoint from the path's origin point
				this.HumanoidOffsetFromPath = Vector3.new(0, this.pointList[1].Position.Y - this.OriginPoint.Y, 0)
	
				-- As well as its current position and velocity
				this.CurrentHumanoidPosition = this.Humanoid.RootPart.Position + this.HumanoidOffsetFromPath
				this.CurrentHumanoidVelocity = this.Humanoid.RootPart.Velocity
	
				-- Connect to events
				this.SeatedConn = this.Humanoid.Seated:Connect(function(isSeated, seat) this:OnPathInterrupted() end)
				this.DiedConn = this.Humanoid.Died:Connect(function() this:OnPathInterrupted() end)
				this.TeleportedConn = this.Humanoid.RootPart:GetPropertyChangedSignal("CFrame"):Connect(function() this:OnPathInterrupted() end)
	
				-- Actually start
				this.CurrentPoint = 1 -- The first waypoint is always the start location. Skip it.
				this:OnPointReached(true) -- Move to first point
			else
				this.PathFailed:Fire()
				if this.stopTraverseFunc then
					this.stopTraverseFunc()
				end
			end
		end
	
		--We always raycast to the ground in the case that the user clicked a wall.
		local offsetPoint = this.TargetPoint + this.TargetSurfaceNormal*1.5
		local ray = Ray.new(offsetPoint, Vector3.new(0,-1,0)*50)
		local newHitPart, newHitPos = Workspace:FindPartOnRayWithIgnoreList(ray, getIgnoreList())
		if newHitPart then
			this.TargetPoint = newHitPos
		end
		this:ComputePath()
	
		return this
	end
	
	-------------------------------------------------------------------------
	
	local function CheckAlive()
		local humanoid = findPlayerHumanoid(Player)
		return humanoid ~= nil and humanoid.Health > 0
	end
	
	local function GetEquippedTool(character)
		if character ~= nil then
			for _, child in pairs(character:GetChildren()) do
				if child:IsA('Tool') then
					return child
				end
			end
		end
	end
	
	local ExistingPather = nil
	local ExistingIndicator = nil
	local PathCompleteListener = nil
	local PathFailedListener = nil
	
	local function CleanupPath()
		if ExistingPather then
			ExistingPather:Cancel()
			ExistingPather = nil
		end
		if PathCompleteListener then
			PathCompleteListener:Disconnect()
			PathCompleteListener = nil
		end
		if PathFailedListener then
			PathFailedListener:Disconnect()
			PathFailedListener = nil
		end
		if ExistingIndicator then
			ExistingIndicator:Destroy()
		end
	end
	
	local function HandleMoveTo(thisPather, hitPt, hitChar, character, overrideShowPath)
		if ExistingPather then
			CleanupPath()
		end
		ExistingPather = thisPather
		thisPather:Start(overrideShowPath)
	
		PathCompleteListener = thisPather.Finished.Event:Connect(function()
			CleanupPath()
			if hitChar then
				local currentWeapon = GetEquippedTool(character)
				if currentWeapon then
					currentWeapon:Activate()
				end
			end
		end)
		PathFailedListener = thisPather.PathFailed.Event:Connect(function()
			CleanupPath()
			if overrideShowPath == nil or overrideShowPath then
				local shouldPlayFailureAnim = PlayFailureAnimation and not (ExistingPather and ExistingPather:IsActive())
				if shouldPlayFailureAnim then
					ClickToMoveDisplay.PlayFailureAnimation()
				end
				ClickToMoveDisplay.DisplayFailureWaypoint(hitPt)
			end
		end)
	end
	
	local function ShowPathFailedFeedback(hitPt)
		if ExistingPather and ExistingPather:IsActive() then
			ExistingPather:Cancel()
		end
		if PlayFailureAnimation then
			ClickToMoveDisplay.PlayFailureAnimation()
		end
		ClickToMoveDisplay.DisplayFailureWaypoint(hitPt)
	end
	
	function OnTap(tapPositions, goToPoint, wasTouchTap)
		-- Good to remember if this is the latest tap event
		local camera = Workspace.CurrentCamera
		local character = Player.Character
	
		if not CheckAlive() then return end
	
		-- This is a path tap position
		if #tapPositions == 1 or goToPoint then
			if camera then
				local unitRay = camera:ScreenPointToRay(tapPositions[1].x, tapPositions[1].y)
				local ray = Ray.new(unitRay.Origin, unitRay.Direction*1000)
	
				local myHumanoid = findPlayerHumanoid(Player)
				local hitPart, hitPt, hitNormal = Utility.Raycast(ray, true, getIgnoreList())
	
				local hitChar, hitHumanoid = Utility.FindCharacterAncestor(hitPart)
				if wasTouchTap and hitHumanoid and StarterGui:GetCore("AvatarContextMenuEnabled") then
					local clickedPlayer = Players:GetPlayerFromCharacter(hitHumanoid.Parent)
					if clickedPlayer then
						CleanupPath()
						return
					end
				end
				if goToPoint then
					hitPt = goToPoint
					hitChar = nil
				end
				if hitPt and character then
					-- Clean up current path
					CleanupPath()
					local thisPather = Pather(hitPt, hitNormal)
					if thisPather:IsValidPath() then
						HandleMoveTo(thisPather, hitPt, hitChar, character)
					else
						-- Clean up
						thisPather:Cleanup()
						-- Feedback here for when we don't have a good path
						ShowPathFailedFeedback(hitPt)
					end
				end
			end
		elseif #tapPositions >= 2 then
			if camera then
				-- Do shoot
				local currentWeapon = GetEquippedTool(character)
				if currentWeapon then
					currentWeapon:Activate()
				end
			end
		end
	end
	
	local function DisconnectEvent(event)
		if event then
			event:Disconnect()
		end
	end
	
	--[[ The ClickToMove Controller Class ]]--
	local KeyboardController = _Keyboard()
	local ClickToMove = setmetatable({}, KeyboardController)
	ClickToMove.__index = ClickToMove
	
	function ClickToMove.new(CONTROL_ACTION_PRIORITY)
		local self = setmetatable(KeyboardController.new(CONTROL_ACTION_PRIORITY), ClickToMove)
	
		self.fingerTouches = {}
		self.numUnsunkTouches = 0
		-- PC simulation
		self.mouse1Down = tick()
		self.mouse1DownPos = Vector2.new()
		self.mouse2DownTime = tick()
		self.mouse2DownPos = Vector2.new()
		self.mouse2UpTime = tick()
	
		self.keyboardMoveVector = ZERO_VECTOR3
	
		self.tapConn = nil
		self.inputBeganConn = nil
		self.inputChangedConn = nil
		self.inputEndedConn = nil
		self.humanoidDiedConn = nil
		self.characterChildAddedConn = nil
		self.onCharacterAddedConn = nil
		self.characterChildRemovedConn = nil
		self.renderSteppedConn = nil
		self.menuOpenedConnection = nil
	
		self.running = false
	
		self.wasdEnabled = false
	
		return self
	end
	
	function ClickToMove:DisconnectEvents()
		DisconnectEvent(self.tapConn)
		DisconnectEvent(self.inputBeganConn)
		DisconnectEvent(self.inputChangedConn)
		DisconnectEvent(self.inputEndedConn)
		DisconnectEvent(self.humanoidDiedConn)
		DisconnectEvent(self.characterChildAddedConn)
		DisconnectEvent(self.onCharacterAddedConn)
		DisconnectEvent(self.renderSteppedConn)
		DisconnectEvent(self.characterChildRemovedConn)
		DisconnectEvent(self.menuOpenedConnection)
	end
	
	function ClickToMove:OnTouchBegan(input, processed)
		if self.fingerTouches[input] == nil and not processed then
			self.numUnsunkTouches = self.numUnsunkTouches + 1
		end
		self.fingerTouches[input] = processed
	end
	
	function ClickToMove:OnTouchChanged(input, processed)
		if self.fingerTouches[input] == nil then
			self.fingerTouches[input] = processed
			if not processed then
				self.numUnsunkTouches = self.numUnsunkTouches + 1
			end
		end
	end
	
	function ClickToMove:OnTouchEnded(input, processed)
		if self.fingerTouches[input] ~= nil and self.fingerTouches[input] == false then
			self.numUnsunkTouches = self.numUnsunkTouches - 1
		end
		self.fingerTouches[input] = nil
	end
	
	
	function ClickToMove:OnCharacterAdded(character)
		self:DisconnectEvents()
	
		self.inputBeganConn = UserInputService.InputBegan:Connect(function(input, processed)
			if input.UserInputType == Enum.UserInputType.Touch then
				self:OnTouchBegan(input, processed)
			end
	
			-- Cancel path when you use the keyboard controls if wasd is enabled.
			if self.wasdEnabled and processed == false and input.UserInputType == Enum.UserInputType.Keyboard
				and movementKeys[input.KeyCode] then
				CleanupPath()
				ClickToMoveDisplay.CancelFailureAnimation()
			end
			if input.UserInputType == Enum.UserInputType.MouseButton1 then
				self.mouse1DownTime = tick()
				self.mouse1DownPos = input.Position
			end
			if input.UserInputType == Enum.UserInputType.MouseButton2 then
				self.mouse2DownTime = tick()
				self.mouse2DownPos = input.Position
			end
		end)
	
		self.inputChangedConn = UserInputService.InputChanged:Connect(function(input, processed)
			if input.UserInputType == Enum.UserInputType.Touch then
				self:OnTouchChanged(input, processed)
			end
		end)
	
		self.inputEndedConn = UserInputService.InputEnded:Connect(function(input, processed)
			if input.UserInputType == Enum.UserInputType.Touch then
				self:OnTouchEnded(input, processed)
			end
	
			if input.UserInputType == Enum.UserInputType.MouseButton2 then
				self.mouse2UpTime = tick()
				local currPos = input.Position
				-- We allow click to move during path following or if there is no keyboard movement
				local allowed = ExistingPather or self.keyboardMoveVector.Magnitude <= 0
				if self.mouse2UpTime - self.mouse2DownTime < 0.25 and (currPos - self.mouse2DownPos).magnitude < 5 and allowed then
					local positions = {currPos}
					OnTap(positions)
				end
			end
		end)
	
		self.tapConn = UserInputService.TouchTap:Connect(function(touchPositions, processed)
			if not processed then
				OnTap(touchPositions, nil, true)
			end
		end)
	
		self.menuOpenedConnection = GuiService.MenuOpened:Connect(function()
			CleanupPath()
		end)
	
		local function OnCharacterChildAdded(child)
			if UserInputService.TouchEnabled then
				if child:IsA('Tool') then
					child.ManualActivationOnly = true
				end
			end
			if child:IsA('Humanoid') then
				DisconnectEvent(self.humanoidDiedConn)
				self.humanoidDiedConn = child.Died:Connect(function()
					if ExistingIndicator then
						DebrisService:AddItem(ExistingIndicator.Model, 1)
					end
				end)
			end
		end
	
		self.characterChildAddedConn = character.ChildAdded:Connect(function(child)
			OnCharacterChildAdded(child)
		end)
		self.characterChildRemovedConn = character.ChildRemoved:Connect(function(child)
			if UserInputService.TouchEnabled then
				if child:IsA('Tool') then
					child.ManualActivationOnly = false
				end
			end
		end)
		for _, child in pairs(character:GetChildren()) do
			OnCharacterChildAdded(child)
		end
	end
	
	function ClickToMove:Start()
		self:Enable(true)
	end
	
	function ClickToMove:Stop()
		self:Enable(false)
	end
	
	function ClickToMove:CleanupPath()
		CleanupPath()
	end
	
	function ClickToMove:Enable(enable, enableWASD, touchJumpController)
		if enable then
			if not self.running then
				if Player.Character then -- retro-listen
					self:OnCharacterAdded(Player.Character)
				end
				self.onCharacterAddedConn = Player.CharacterAdded:Connect(function(char)
					self:OnCharacterAdded(char)
				end)
				self.running = true
			end
			self.touchJumpController = touchJumpController
			if self.touchJumpController then
				self.touchJumpController:Enable(self.jumpEnabled)
			end
		else
			if self.running then
				self:DisconnectEvents()
				CleanupPath()
				-- Restore tool activation on shutdown
				if UserInputService.TouchEnabled then
					local character = Player.Character
					if character then
						for _, child in pairs(character:GetChildren()) do
							if child:IsA('Tool') then
								child.ManualActivationOnly = false
							end
						end
					end
				end
				self.running = false
			end
			if self.touchJumpController and not self.jumpEnabled then
				self.touchJumpController:Enable(true)
			end
			self.touchJumpController = nil
		end
	
		-- Extension for initializing Keyboard input as this class now derives from Keyboard
		if UserInputService.KeyboardEnabled and enable ~= self.enabled then
	
			self.forwardValue  = 0
			self.backwardValue = 0
			self.leftValue = 0
			self.rightValue = 0
	
			self.moveVector = ZERO_VECTOR3
	
			if enable then
				self:BindContextActions()
				self:ConnectFocusEventListeners()
			else
				self:UnbindContextActions()
				self:DisconnectFocusEventListeners()
			end
		end
	
		self.wasdEnabled = enable and enableWASD or false
		self.enabled = enable
	end
	
	function ClickToMove:OnRenderStepped(dt)
		-- Reset jump
		self.isJumping = false
	
		-- Handle Pather
		if ExistingPather then
			-- Let the Pather update
			ExistingPather:OnRenderStepped(dt)
	
			-- If we still have a Pather, set the resulting actions
			if ExistingPather then
				-- Setup move (NOT relative to camera)
				self.moveVector = ExistingPather.NextActionMoveDirection
				self.moveVectorIsCameraRelative = false
	
				-- Setup jump (but do NOT prevent the base Keayboard class from requesting jumps as well)
				if ExistingPather.NextActionJump then
					self.isJumping = true
				end
			else
				self.moveVector = self.keyboardMoveVector
				self.moveVectorIsCameraRelative = true
			end
		else
			self.moveVector = self.keyboardMoveVector
			self.moveVectorIsCameraRelative = true
		end
	
		-- Handle Keyboard's jump
		if self.jumpRequested then
			self.isJumping = true
		end
	end
	
	-- Overrides Keyboard:UpdateMovement(inputState) to conditionally consider self.wasdEnabled and let OnRenderStepped handle the movement
	function ClickToMove:UpdateMovement(inputState)
		if inputState == Enum.UserInputState.Cancel then
			self.keyboardMoveVector = ZERO_VECTOR3
		elseif self.wasdEnabled then
			self.keyboardMoveVector = Vector3.new(self.leftValue + self.rightValue, 0, self.forwardValue + self.backwardValue)
		end
	end
	
	-- Overrides Keyboard:UpdateJump() because jump is handled in OnRenderStepped
	function ClickToMove:UpdateJump()
		-- Nothing to do (handled in OnRenderStepped)
	end
	
	--Public developer facing functions
	function ClickToMove:SetShowPath(value)
		ShowPath = value
	end
	
	function ClickToMove:GetShowPath()
		return ShowPath
	end
	
	function ClickToMove:SetWaypointTexture(texture)
		ClickToMoveDisplay.SetWaypointTexture(texture)
	end
	
	function ClickToMove:GetWaypointTexture()
		return ClickToMoveDisplay.GetWaypointTexture()
	end
	
	function ClickToMove:SetWaypointRadius(radius)
		ClickToMoveDisplay.SetWaypointRadius(radius)
	end
	
	function ClickToMove:GetWaypointRadius()
		return ClickToMoveDisplay.GetWaypointRadius()
	end
	
	function ClickToMove:SetEndWaypointTexture(texture)
		ClickToMoveDisplay.SetEndWaypointTexture(texture)
	end
	
	function ClickToMove:GetEndWaypointTexture()
		return ClickToMoveDisplay.GetEndWaypointTexture()
	end
	
	function ClickToMove:SetWaypointsAlwaysOnTop(alwaysOnTop)
		ClickToMoveDisplay.SetWaypointsAlwaysOnTop(alwaysOnTop)
	end
	
	function ClickToMove:GetWaypointsAlwaysOnTop()
		return ClickToMoveDisplay.GetWaypointsAlwaysOnTop()
	end
	
	function ClickToMove:SetFailureAnimationEnabled(enabled)
		PlayFailureAnimation = enabled
	end
	
	function ClickToMove:GetFailureAnimationEnabled()
		return PlayFailureAnimation
	end
	
	function ClickToMove:SetIgnoredPartsTag(tag)
		UpdateIgnoreTag(tag)
	end
	
	function ClickToMove:GetIgnoredPartsTag()
		return CurrentIgnoreTag
	end
	
	function ClickToMove:SetUseDirectPath(directPath)
		UseDirectPath = directPath
	end
	
	function ClickToMove:GetUseDirectPath()
		return UseDirectPath
	end
	
	function ClickToMove:SetAgentSizeIncreaseFactor(increaseFactorPercent)
		AgentSizeIncreaseFactor = 1.0 + (increaseFactorPercent / 100.0)
	end
	
	function ClickToMove:GetAgentSizeIncreaseFactor()
		return (AgentSizeIncreaseFactor - 1.0) * 100.0
	end
	
	function ClickToMove:SetUnreachableWaypointTimeout(timeoutInSec)
		UnreachableWaypointTimeout = timeoutInSec
	end
	
	function ClickToMove:GetUnreachableWaypointTimeout()
		return UnreachableWaypointTimeout
	end
	
	function ClickToMove:SetUserJumpEnabled(jumpEnabled)
		self.jumpEnabled = jumpEnabled
		if self.touchJumpController then
			self.touchJumpController:Enable(jumpEnabled)
		end
	end
	
	function ClickToMove:GetUserJumpEnabled()
		return self.jumpEnabled
	end
	
	function ClickToMove:MoveTo(position, showPath, useDirectPath)
		local character = Player.Character
		if character == nil then
			return false
		end
		local thisPather = Pather(position, Vector3.new(0, 1, 0), useDirectPath)
		if thisPather and thisPather:IsValidPath() then
			HandleMoveTo(thisPather, position, nil, character, showPath)
			return true
		end
		return false
	end
	
	return ClickToMove
	end

	function _TouchThumbstick()
	local Players = game:GetService("Players")
	local GuiService = game:GetService("GuiService")
	local UserInputService = game:GetService("UserInputService")
	--[[ Constants ]]--
	local ZERO_VECTOR3 = Vector3.new(0,0,0)
	local TOUCH_CONTROL_SHEET = "rbxasset://textures/ui/TouchControlsSheet.png"
	--[[ The Module ]]--
	local BaseCharacterController = _BaseCharacterController()
	local TouchThumbstick = setmetatable({}, BaseCharacterController)
	TouchThumbstick.__index = TouchThumbstick
	function TouchThumbstick.new()
		local self = setmetatable(BaseCharacterController.new(), TouchThumbstick)
		
		self.isFollowStick = false
		
		self.thumbstickFrame = nil
		self.moveTouchObject = nil
		self.onTouchMovedConn = nil
		self.onTouchEndedConn = nil
		self.screenPos = nil
		self.stickImage = nil
		self.thumbstickSize = nil -- Float
		
		return self
	end
	function TouchThumbstick:Enable(enable, uiParentFrame)
		if enable == nil then return false end			-- If nil, return false (invalid argument)
		enable = enable and true or false				-- Force anything non-nil to boolean before comparison
		if self.enabled == enable then return true end	-- If no state change, return true indicating already in requested state
		
		self.moveVector = ZERO_VECTOR3
		self.isJumping = false
		
		if enable then
			-- Enable
			if not self.thumbstickFrame then
				self:Create(uiParentFrame)
			end
			self.thumbstickFrame.Visible = true
		else 
			-- Disable
			self.thumbstickFrame.Visible = false
			self:OnInputEnded()
		end
		self.enabled = enable
	end
	function TouchThumbstick:OnInputEnded()
		self.thumbstickFrame.Position = self.screenPos
		self.stickImage.Position = UDim2.new(0, self.thumbstickFrame.Size.X.Offset/2 - self.thumbstickSize/4, 0, self.thumbstickFrame.Size.Y.Offset/2 - self.thumbstickSize/4)
		
		self.moveVector = ZERO_VECTOR3
		self.isJumping = false
		self.thumbstickFrame.Position = self.screenPos
		self.moveTouchObject = nil
	end
	function TouchThumbstick:Create(parentFrame)
		
		if self.thumbstickFrame then
			self.thumbstickFrame:Destroy()
			self.thumbstickFrame = nil
			if self.onTouchMovedConn then
				self.onTouchMovedConn:Disconnect()
				self.onTouchMovedConn = nil
			end
			if self.onTouchEndedConn then
				self.onTouchEndedConn:Disconnect()
				self.onTouchEndedConn = nil
			end
		end
		
		local minAxis = math.min(parentFrame.AbsoluteSize.x, parentFrame.AbsoluteSize.y)
		local isSmallScreen = minAxis <= 500
		self.thumbstickSize = isSmallScreen and 70 or 120
		self.screenPos = isSmallScreen and UDim2.new(0, (self.thumbstickSize/2) - 10, 1, -self.thumbstickSize - 20) or
			UDim2.new(0, self.thumbstickSize/2, 1, -self.thumbstickSize * 1.75)
			
		self.thumbstickFrame = Instance.new("Frame")
		self.thumbstickFrame.Name = "ThumbstickFrame"
		self.thumbstickFrame.Active = true
		self.thumbstickFrame.Visible = false
		self.thumbstickFrame.Size = UDim2.new(0, self.thumbstickSize, 0, self.thumbstickSize)
		self.thumbstickFrame.Position = self.screenPos
		self.thumbstickFrame.BackgroundTransparency = 1
		
		local outerImage = Instance.new("ImageLabel")
		outerImage.Name = "OuterImage"
		outerImage.Image = TOUCH_CONTROL_SHEET
		outerImage.ImageRectOffset = Vector2.new()
		outerImage.ImageRectSize = Vector2.new(220, 220)
		outerImage.BackgroundTransparency = 1
		outerImage.Size = UDim2.new(0, self.thumbstickSize, 0, self.thumbstickSize)
		outerImage.Position = UDim2.new(0, 0, 0, 0)
		outerImage.Parent = self.thumbstickFrame
		
		self.stickImage = Instance.new("ImageLabel")
		self.stickImage.Name = "StickImage"
		self.stickImage.Image = TOUCH_CONTROL_SHEET
		self.stickImage.ImageRectOffset = Vector2.new(220, 0)
		self.stickImage.ImageRectSize = Vector2.new(111, 111)
		self.stickImage.BackgroundTransparency = 1
		self.stickImage.Size = UDim2.new(0, self.thumbstickSize/2, 0, self.thumbstickSize/2)
		self.stickImage.Position = UDim2.new(0, self.thumbstickSize/2 - self.thumbstickSize/4, 0, self.thumbstickSize/2 - self.thumbstickSize/4)
		self.stickImage.ZIndex = 2
		self.stickImage.Parent = self.thumbstickFrame
		
		local centerPosition = nil
		local deadZone = 0.05
		
		local function DoMove(direction)
			
			local currentMoveVector = direction / (self.thumbstickSize/2)
			
			-- Scaled Radial Dead Zone
			local inputAxisMagnitude = currentMoveVector.magnitude
			if inputAxisMagnitude < deadZone then
				currentMoveVector = Vector3.new()
			else
				currentMoveVector = currentMoveVector.unit * ((inputAxisMagnitude - deadZone) / (1 - deadZone))
				-- NOTE: Making currentMoveVector a unit vector will cause the player to instantly go max speed
				-- must check for zero length vector is using unit
				currentMoveVector = Vector3.new(currentMoveVector.x, 0, currentMoveVector.y)
			end
			
			self.moveVector = currentMoveVector
		end
		
		local function MoveStick(pos)
			local relativePosition = Vector2.new(pos.x - centerPosition.x, pos.y - centerPosition.y)
			local length = relativePosition.magnitude
			local maxLength = self.thumbstickFrame.AbsoluteSize.x/2
			if self.isFollowStick and length > maxLength then
				local offset = relativePosition.unit * maxLength
				self.thumbstickFrame.Position = UDim2.new(
					0, pos.x - self.thumbstickFrame.AbsoluteSize.x/2 - offset.x,
					0, pos.y - self.thumbstickFrame.AbsoluteSize.y/2 - offset.y)
			else
				length = math.min(length, maxLength)
				relativePosition = relativePosition.unit * length
			end
			self.stickImage.Position = UDim2.new(0, relativePosition.x + self.stickImage.AbsoluteSize.x/2, 0, relativePosition.y + self.stickImage.AbsoluteSize.y/2)
		end
		
		-- input connections
		self.thumbstickFrame.InputBegan:Connect(function(inputObject)
			--A touch that starts elsewhere on the screen will be sent to a frame's InputBegan event
			--if it moves over the frame. So we check that this is actually a new touch (inputObject.UserInputState ~= Enum.UserInputState.Begin)
			if self.moveTouchObject or inputObject.UserInputType ~= Enum.UserInputType.Touch
				or inputObject.UserInputState ~= Enum.UserInputState.Begin then
				return
			end
			
			self.moveTouchObject = inputObject
			self.thumbstickFrame.Position = UDim2.new(0, inputObject.Position.x - self.thumbstickFrame.Size.X.Offset/2, 0, inputObject.Position.y - self.thumbstickFrame.Size.Y.Offset/2)
			centerPosition = Vector2.new(self.thumbstickFrame.AbsolutePosition.x + self.thumbstickFrame.AbsoluteSize.x/2,
				self.thumbstickFrame.AbsolutePosition.y + self.thumbstickFrame.AbsoluteSize.y/2)
			local direction = Vector2.new(inputObject.Position.x - centerPosition.x, inputObject.Position.y - centerPosition.y)
		end)
		
		self.onTouchMovedConn = UserInputService.TouchMoved:Connect(function(inputObject, isProcessed)
			if inputObject == self.moveTouchObject then
				centerPosition = Vector2.new(self.thumbstickFrame.AbsolutePosition.x + self.thumbstickFrame.AbsoluteSize.x/2,
					self.thumbstickFrame.AbsolutePosition.y + self.thumbstickFrame.AbsoluteSize.y/2)
				local direction = Vector2.new(inputObject.Position.x - centerPosition.x, inputObject.Position.y - centerPosition.y)
				DoMove(direction)
				MoveStick(inputObject.Position)
			end
		end)
		
		self.onTouchEndedConn = UserInputService.TouchEnded:Connect(function(inputObject, isProcessed)
			if inputObject == self.moveTouchObject then
				self:OnInputEnded()
			end
		end)
		
		GuiService.MenuOpened:Connect(function()
			if self.moveTouchObject then
				self:OnInputEnded()
			end
		end)	
		
		self.thumbstickFrame.Parent = parentFrame
	end
	return TouchThumbstick
	end

	function _DynamicThumbstick()
	local ZERO_VECTOR3 = Vector3.new(0,0,0)
	local TOUCH_CONTROLS_SHEET = "rbxasset://textures/ui/Input/TouchControlsSheetV2.png"
	
	local DYNAMIC_THUMBSTICK_ACTION_NAME = "DynamicThumbstickAction"
	local DYNAMIC_THUMBSTICK_ACTION_PRIORITY = Enum.ContextActionPriority.High.Value
	
	local MIDDLE_TRANSPARENCIES = {
		1 - 0.89,
		1 - 0.70,
		1 - 0.60,
		1 - 0.50,
		1 - 0.40,
		1 - 0.30,
		1 - 0.25
	}
	local NUM_MIDDLE_IMAGES = #MIDDLE_TRANSPARENCIES
	
	local FADE_IN_OUT_BACKGROUND = true
	local FADE_IN_OUT_MAX_ALPHA = 0.35
	
	local FADE_IN_OUT_HALF_DURATION_DEFAULT = 0.3
	local FADE_IN_OUT_BALANCE_DEFAULT = 0.5
	local ThumbstickFadeTweenInfo = TweenInfo.new(0.15, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut)
	
	local Players = game:GetService("Players")
	local GuiService = game:GetService("GuiService")
	local UserInputService = game:GetService("UserInputService")
	local ContextActionService = game:GetService("ContextActionService")
	local RunService = game:GetService("RunService")
	local TweenService = game:GetService("TweenService")
	
	local LocalPlayer = Players.LocalPlayer
	if not LocalPlayer then
		Players:GetPropertyChangedSignal("LocalPlayer"):Wait()
		LocalPlayer = Players.LocalPlayer
	end
	
	--[[ The Module ]]--
	local BaseCharacterController = _BaseCharacterController()
	local DynamicThumbstick = setmetatable({}, BaseCharacterController)
	DynamicThumbstick.__index = DynamicThumbstick
	
	function DynamicThumbstick.new()
		local self = setmetatable(BaseCharacterController.new(), DynamicThumbstick)
	
		self.moveTouchObject = nil
		self.moveTouchLockedIn = false
		self.moveTouchFirstChanged = false
		self.moveTouchStartPosition = nil
	
		self.startImage = nil
		self.endImage = nil
		self.middleImages = {}
	
		self.startImageFadeTween = nil
		self.endImageFadeTween = nil
		self.middleImageFadeTweens = {}
	
		self.isFirstTouch = true
	
		self.thumbstickFrame = nil
	
		self.onRenderSteppedConn = nil
	
		self.fadeInAndOutBalance = FADE_IN_OUT_BALANCE_DEFAULT
		self.fadeInAndOutHalfDuration = FADE_IN_OUT_HALF_DURATION_DEFAULT
		self.hasFadedBackgroundInPortrait = false
		self.hasFadedBackgroundInLandscape = false
	
		self.tweenInAlphaStart = nil
		self.tweenOutAlphaStart = nil
	
		return self
	end
	
	-- Note: Overrides base class GetIsJumping with get-and-clear behavior to do a single jump
	-- rather than sustained jumping. This is only to preserve the current behavior through the refactor.
	function DynamicThumbstick:GetIsJumping()
		local wasJumping = self.isJumping
		self.isJumping = false
		return wasJumping
	end
	
	function DynamicThumbstick:Enable(enable, uiParentFrame)
		if enable == nil then return false end			-- If nil, return false (invalid argument)
		enable = enable and true or false				-- Force anything non-nil to boolean before comparison
		if self.enabled == enable then return true end	-- If no state change, return true indicating already in requested state
	
		if enable then
			-- Enable
			if not self.thumbstickFrame then
				self:Create(uiParentFrame)
			end
	
			self:BindContextActions()
		else
			ContextActionService:UnbindAction(DYNAMIC_THUMBSTICK_ACTION_NAME)
			-- Disable
			self:OnInputEnded() -- Cleanup
		end
	
		self.enabled = enable
		self.thumbstickFrame.Visible = enable
	end
	
	-- Was called OnMoveTouchEnded in previous version
	function DynamicThumbstick:OnInputEnded()
		self.moveTouchObject = nil
		self.moveVector = ZERO_VECTOR3
		self:FadeThumbstick(false)
	end
	
	function DynamicThumbstick:FadeThumbstick(visible)
		if not visible and self.moveTouchObject then
			return
		end
		if self.isFirstTouch then return end
	
		if self.startImageFadeTween then
			self.startImageFadeTween:Cancel()
		end
		if self.endImageFadeTween then
			self.endImageFadeTween:Cancel()
		end
		for i = 1, #self.middleImages do
			if self.middleImageFadeTweens[i] then
				self.middleImageFadeTweens[i]:Cancel()
			end
		end
	
		if visible then
			self.startImageFadeTween = TweenService:Create(self.startImage, ThumbstickFadeTweenInfo, { ImageTransparency = 0 })
			self.startImageFadeTween:Play()
	
			self.endImageFadeTween = TweenService:Create(self.endImage, ThumbstickFadeTweenInfo, { ImageTransparency = 0.2 })
			self.endImageFadeTween:Play()
	
			for i = 1, #self.middleImages do
				self.middleImageFadeTweens[i] = TweenService:Create(self.middleImages[i], ThumbstickFadeTweenInfo, { ImageTransparency = MIDDLE_TRANSPARENCIES[i] })
				self.middleImageFadeTweens[i]:Play()
			end
		else
			self.startImageFadeTween = TweenService:Create(self.startImage, ThumbstickFadeTweenInfo, { ImageTransparency = 1 })
			self.startImageFadeTween:Play()
	
			self.endImageFadeTween = TweenService:Create(self.endImage, ThumbstickFadeTweenInfo, { ImageTransparency = 1 })
			self.endImageFadeTween:Play()
	
			for i = 1, #self.middleImages do
				self.middleImageFadeTweens[i] = TweenService:Create(self.middleImages[i], ThumbstickFadeTweenInfo, { ImageTransparency = 1 })
				self.middleImageFadeTweens[i]:Play()
			end
		end
	end
	
	function DynamicThumbstick:FadeThumbstickFrame(fadeDuration, fadeRatio)
		self.fadeInAndOutHalfDuration = fadeDuration * 0.5
		self.fadeInAndOutBalance = fadeRatio
		self.tweenInAlphaStart = tick()
	end
	
	function DynamicThumbstick:InputInFrame(inputObject)
		local frameCornerTopLeft = self.thumbstickFrame.AbsolutePosition
		local frameCornerBottomRight = frameCornerTopLeft + self.thumbstickFrame.AbsoluteSize
		local inputPosition = inputObject.Position
		if inputPosition.X >= frameCornerTopLeft.X and inputPosition.Y >= frameCornerTopLeft.Y then
			if inputPosition.X <= frameCornerBottomRight.X and inputPosition.Y <= frameCornerBottomRight.Y then
				return true
			end
		end
		return false
	end
	
	function DynamicThumbstick:DoFadeInBackground()
		local playerGui = LocalPlayer:FindFirstChildOfClass("PlayerGui")
		local hasFadedBackgroundInOrientation = false
	
		-- only fade in/out the background once per orientation
		if playerGui then
			if playerGui.CurrentScreenOrientation == Enum.ScreenOrientation.LandscapeLeft or
				playerGui.CurrentScreenOrientation == Enum.ScreenOrientation.LandscapeRight then
					hasFadedBackgroundInOrientation = self.hasFadedBackgroundInLandscape
					self.hasFadedBackgroundInLandscape = true
			elseif playerGui.CurrentScreenOrientation == Enum.ScreenOrientation.Portrait then
					hasFadedBackgroundInOrientation = self.hasFadedBackgroundInPortrait
					self.hasFadedBackgroundInPortrait = true
			end
		end
	
		if not hasFadedBackgroundInOrientation then
			self.fadeInAndOutHalfDuration = FADE_IN_OUT_HALF_DURATION_DEFAULT
			self.fadeInAndOutBalance = FADE_IN_OUT_BALANCE_DEFAULT
			self.tweenInAlphaStart = tick()
		end
	end
	
	function DynamicThumbstick:DoMove(direction)
		local currentMoveVector = direction
	
		-- Scaled Radial Dead Zone
		local inputAxisMagnitude = currentMoveVector.magnitude
		if inputAxisMagnitude < self.radiusOfDeadZone then
			currentMoveVector = ZERO_VECTOR3
		else
			currentMoveVector = currentMoveVector.unit*(
				1 - math.max(0, (self.radiusOfMaxSpeed - currentMoveVector.magnitude)/self.radiusOfMaxSpeed)
			)
			currentMoveVector = Vector3.new(currentMoveVector.x, 0, currentMoveVector.y)
		end
	
		self.moveVector = currentMoveVector
	end
	
	
	function DynamicThumbstick:LayoutMiddleImages(startPos, endPos)
		local startDist = (self.thumbstickSize / 2) + self.middleSize
		local vector = endPos - startPos
		local distAvailable = vector.magnitude - (self.thumbstickRingSize / 2) - self.middleSize
		local direction = vector.unit
	
		local distNeeded = self.middleSpacing * NUM_MIDDLE_IMAGES
		local spacing = self.middleSpacing
	
		if distNeeded < distAvailable then
			spacing = distAvailable / NUM_MIDDLE_IMAGES
		end
	
		for i = 1, NUM_MIDDLE_IMAGES do
			local image = self.middleImages[i]
			local distWithout = startDist + (spacing * (i - 2))
			local currentDist = startDist + (spacing * (i - 1))
	
			if distWithout < distAvailable then
				local pos = endPos - direction * currentDist
				local exposedFraction = math.clamp(1 - ((currentDist - distAvailable) / spacing), 0, 1)
	
				image.Visible = true
				image.Position = UDim2.new(0, pos.X, 0, pos.Y)
				image.Size = UDim2.new(0, self.middleSize * exposedFraction, 0, self.middleSize * exposedFraction)
			else
				image.Visible = false
			end
		end
	end
	
	function DynamicThumbstick:MoveStick(pos)
		local vector2StartPosition = Vector2.new(self.moveTouchStartPosition.X, self.moveTouchStartPosition.Y)
		local startPos = vector2StartPosition - self.thumbstickFrame.AbsolutePosition
		local endPos = Vector2.new(pos.X, pos.Y) - self.thumbstickFrame.AbsolutePosition
		self.endImage.Position = UDim2.new(0, endPos.X, 0, endPos.Y)
		self:LayoutMiddleImages(startPos, endPos)
	end
	
	function DynamicThumbstick:BindContextActions()
		local function inputBegan(inputObject)
			if self.moveTouchObject then
				return Enum.ContextActionResult.Pass
			end
	
			if not self:InputInFrame(inputObject) then
				return Enum.ContextActionResult.Pass
			end
	
			if self.isFirstTouch then
				self.isFirstTouch = false
				local tweenInfo = TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.Out,0,false,0)
				TweenService:Create(self.startImage, tweenInfo, {Size = UDim2.new(0, 0, 0, 0)}):Play()
				TweenService:Create(
					self.endImage,
					tweenInfo,
					{Size = UDim2.new(0, self.thumbstickSize, 0, self.thumbstickSize), ImageColor3 = Color3.new(0,0,0)}
				):Play()
			end
	
			self.moveTouchLockedIn = false
			self.moveTouchObject = inputObject
			self.moveTouchStartPosition = inputObject.Position
			self.moveTouchFirstChanged = true
	
			if FADE_IN_OUT_BACKGROUND then
				self:DoFadeInBackground()
			end
	
			return Enum.ContextActionResult.Pass
		end
	
		local function inputChanged(inputObject)
			if inputObject == self.moveTouchObject then
				if self.moveTouchFirstChanged then
					self.moveTouchFirstChanged = false
	
					local startPosVec2 = Vector2.new(
						inputObject.Position.X - self.thumbstickFrame.AbsolutePosition.X,
						inputObject.Position.Y - self.thumbstickFrame.AbsolutePosition.Y
					)
					self.startImage.Visible = true
					self.startImage.Position = UDim2.new(0, startPosVec2.X, 0, startPosVec2.Y)
					self.endImage.Visible = true
					self.endImage.Position = self.startImage.Position
	
					self:FadeThumbstick(true)
					self:MoveStick(inputObject.Position)
				end
	
				self.moveTouchLockedIn = true
	
				local direction = Vector2.new(
					inputObject.Position.x - self.moveTouchStartPosition.x,
					inputObject.Position.y - self.moveTouchStartPosition.y
				)
				if math.abs(direction.x) > 0 or math.abs(direction.y) > 0 then
					self:DoMove(direction)
					self:MoveStick(inputObject.Position)
				end
				return Enum.ContextActionResult.Sink
			end
			return Enum.ContextActionResult.Pass
		end
	
		local function inputEnded(inputObject)
			if inputObject == self.moveTouchObject then
				self:OnInputEnded()
				if self.moveTouchLockedIn then
					return Enum.ContextActionResult.Sink
				end
			end
			return Enum.ContextActionResult.Pass
		end
	
		local function handleInput(actionName, inputState, inputObject)
			if inputState == Enum.UserInputState.Begin then
				return inputBegan(inputObject)
			elseif inputState == Enum.UserInputState.Change then
				return inputChanged(inputObject)
			elseif inputState == Enum.UserInputState.End then
				return inputEnded(inputObject)
			elseif inputState == Enum.UserInputState.Cancel then
				self:OnInputEnded()
			end
		end
	
		ContextActionService:BindActionAtPriority(
			DYNAMIC_THUMBSTICK_ACTION_NAME,
			handleInput,
			false,
			DYNAMIC_THUMBSTICK_ACTION_PRIORITY,
			Enum.UserInputType.Touch)
	end
	
	function DynamicThumbstick:Create(parentFrame)
		if self.thumbstickFrame then
			self.thumbstickFrame:Destroy()
			self.thumbstickFrame = nil
			if self.onRenderSteppedConn then
				self.onRenderSteppedConn:Disconnect()
				self.onRenderSteppedConn = nil
			end
		end
	
		self.thumbstickSize = 45
		self.thumbstickRingSize = 20
		self.middleSize = 10
		self.middleSpacing = self.middleSize + 4
		self.radiusOfDeadZone = 2
		self.radiusOfMaxSpeed = 20
	
		local screenSize = parentFrame.AbsoluteSize
		local isBigScreen = math.min(screenSize.x, screenSize.y) > 500
		if isBigScreen then
			self.thumbstickSize = self.thumbstickSize * 2
			self.thumbstickRingSize = self.thumbstickRingSize * 2
			self.middleSize = self.middleSize * 2
			self.middleSpacing = self.middleSpacing * 2
			self.radiusOfDeadZone = self.radiusOfDeadZone * 2
			self.radiusOfMaxSpeed = self.radiusOfMaxSpeed * 2
		end
	
		local function layoutThumbstickFrame(portraitMode)
			if portraitMode then
				self.thumbstickFrame.Size = UDim2.new(1, 0, 0.4, 0)
				self.thumbstickFrame.Position = UDim2.new(0, 0, 0.6, 0)
			else
				self.thumbstickFrame.Size = UDim2.new(0.4, 0, 2/3, 0)
				self.thumbstickFrame.Position = UDim2.new(0, 0, 1/3, 0)
			end
		end
	
		self.thumbstickFrame = Instance.new("Frame")
		self.thumbstickFrame.BorderSizePixel = 0
		self.thumbstickFrame.Name = "DynamicThumbstickFrame"
		self.thumbstickFrame.Visible = false
		self.thumbstickFrame.BackgroundTransparency = 1.0
		self.thumbstickFrame.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
		self.thumbstickFrame.Active = false
		layoutThumbstickFrame(false)
	
		self.startImage = Instance.new("ImageLabel")
		self.startImage.Name = "ThumbstickStart"
		self.startImage.Visible = true
		self.startImage.BackgroundTransparency = 1
		self.startImage.Image = TOUCH_CONTROLS_SHEET
		self.startImage.ImageRectOffset = Vector2.new(1,1)
		self.startImage.ImageRectSize = Vector2.new(144, 144)
		self.startImage.ImageColor3 = Color3.new(0, 0, 0)
		self.startImage.AnchorPoint = Vector2.new(0.5, 0.5)
		self.startImage.Position = UDim2.new(0, self.thumbstickRingSize * 3.3, 1, -self.thumbstickRingSize  * 2.8)
		self.startImage.Size = UDim2.new(0, self.thumbstickRingSize  * 3.7, 0, self.thumbstickRingSize  * 3.7)
		self.startImage.ZIndex = 10
		self.startImage.Parent = self.thumbstickFrame
	
		self.endImage = Instance.new("ImageLabel")
		self.endImage.Name = "ThumbstickEnd"
		self.endImage.Visible = true
		self.endImage.BackgroundTransparency = 1
		self.endImage.Image = TOUCH_CONTROLS_SHEET
		self.endImage.ImageRectOffset = Vector2.new(1,1)
		self.endImage.ImageRectSize =  Vector2.new(144, 144)
		self.endImage.AnchorPoint = Vector2.new(0.5, 0.5)
		self.endImage.Position = self.startImage.Position
		self.endImage.Size = UDim2.new(0, self.thumbstickSize * 0.8, 0, self.thumbstickSize * 0.8)
		self.endImage.ZIndex = 10
		self.endImage.Parent = self.thumbstickFrame
	
		for i = 1, NUM_MIDDLE_IMAGES do
			self.middleImages[i] = Instance.new("ImageLabel")
			self.middleImages[i].Name = "ThumbstickMiddle"
			self.middleImages[i].Visible = false
			self.middleImages[i].BackgroundTransparency = 1
			self.middleImages[i].Image = TOUCH_CONTROLS_SHEET
			self.middleImages[i].ImageRectOffset = Vector2.new(1,1)
			self.middleImages[i].ImageRectSize = Vector2.new(144, 144)
			self.middleImages[i].ImageTransparency = MIDDLE_TRANSPARENCIES[i]
			self.middleImages[i].AnchorPoint = Vector2.new(0.5, 0.5)
			self.middleImages[i].ZIndex = 9
			self.middleImages[i].Parent = self.thumbstickFrame
		end
	
		local CameraChangedConn = nil
		local function onCurrentCameraChanged()
			if CameraChangedConn then
				CameraChangedConn:Disconnect()
				CameraChangedConn = nil
			end
			local newCamera = workspace.CurrentCamera
			if newCamera then
				local function onViewportSizeChanged()
					local size = newCamera.ViewportSize
					local portraitMode = size.X < size.Y
					layoutThumbstickFrame(portraitMode)
				end
				CameraChangedConn = newCamera:GetPropertyChangedSignal("ViewportSize"):Connect(onViewportSizeChanged)
				onViewportSizeChanged()
			end
		end
		workspace:GetPropertyChangedSignal("CurrentCamera"):Connect(onCurrentCameraChanged)
		if workspace.CurrentCamera then
			onCurrentCameraChanged()
		end
	
		self.moveTouchStartPosition = nil
	
		self.startImageFadeTween = nil
		self.endImageFadeTween = nil
		self.middleImageFadeTweens = {}
	
		self.onRenderSteppedConn = RunService.RenderStepped:Connect(function()
			if self.tweenInAlphaStart ~= nil then
				local delta = tick() - self.tweenInAlphaStart
				local fadeInTime = (self.fadeInAndOutHalfDuration * 2 * self.fadeInAndOutBalance)
				self.thumbstickFrame.BackgroundTransparency = 1 - FADE_IN_OUT_MAX_ALPHA*math.min(delta/fadeInTime, 1)
				if delta > fadeInTime then
					self.tweenOutAlphaStart = tick()
					self.tweenInAlphaStart = nil
				end
			elseif self.tweenOutAlphaStart ~= nil then
				local delta = tick() - self.tweenOutAlphaStart
				local fadeOutTime = (self.fadeInAndOutHalfDuration * 2) - (self.fadeInAndOutHalfDuration * 2 * self.fadeInAndOutBalance)
				self.thumbstickFrame.BackgroundTransparency = 1 - FADE_IN_OUT_MAX_ALPHA + FADE_IN_OUT_MAX_ALPHA*math.min(delta/fadeOutTime, 1)
				if delta > fadeOutTime  then
					self.tweenOutAlphaStart = nil
				end
			end
		end)
	
		self.onTouchEndedConn = UserInputService.TouchEnded:connect(function(inputObject)
			if inputObject == self.moveTouchObject then
				self:OnInputEnded()
			end
		end)
	
		GuiService.MenuOpened:connect(function()
			if self.moveTouchObject then
				self:OnInputEnded()
			end
		end)
	
		local playerGui = LocalPlayer:FindFirstChildOfClass("PlayerGui")
		while not playerGui do
			LocalPlayer.ChildAdded:wait()
			playerGui = LocalPlayer:FindFirstChildOfClass("PlayerGui")
		end
	
		local playerGuiChangedConn = nil
		local originalScreenOrientationWasLandscape =	playerGui.CurrentScreenOrientation == Enum.ScreenOrientation.LandscapeLeft or
														playerGui.CurrentScreenOrientation == Enum.ScreenOrientation.LandscapeRight
	
		local function longShowBackground()
			self.fadeInAndOutHalfDuration = 2.5
			self.fadeInAndOutBalance = 0.05
			self.tweenInAlphaStart = tick()
		end
	
		playerGuiChangedConn = playerGui:GetPropertyChangedSignal("CurrentScreenOrientation"):Connect(function()
			if (originalScreenOrientationWasLandscape and playerGui.CurrentScreenOrientation == Enum.ScreenOrientation.Portrait) or
				(not originalScreenOrientationWasLandscape and playerGui.CurrentScreenOrientation ~= Enum.ScreenOrientation.Portrait) then
	
				playerGuiChangedConn:disconnect()
				longShowBackground()
	
				if originalScreenOrientationWasLandscape then
					self.hasFadedBackgroundInPortrait = true
				else
					self.hasFadedBackgroundInLandscape = true
				end
			end
		end)
	
		self.thumbstickFrame.Parent = parentFrame
	
		if game:IsLoaded() then
			longShowBackground()
		else
			coroutine.wrap(function()
				game.Loaded:Wait()
				longShowBackground()
			end)()
		end
	end
	
	return DynamicThumbstick
	end

	function _Gamepad()
	local UserInputService = game:GetService("UserInputService")
	local ContextActionService = game:GetService("ContextActionService")
	
	--[[ Constants ]]--
	local ZERO_VECTOR3 = Vector3.new(0,0,0)
	local NONE = Enum.UserInputType.None
	local thumbstickDeadzone = 0.2
	
	--[[ The Module ]]--
	local BaseCharacterController = _BaseCharacterController()
	local Gamepad = setmetatable({}, BaseCharacterController)
	Gamepad.__index = Gamepad
	
	function Gamepad.new(CONTROL_ACTION_PRIORITY)
		local self = setmetatable(BaseCharacterController.new(), Gamepad)
	
		self.CONTROL_ACTION_PRIORITY = CONTROL_ACTION_PRIORITY
	
		self.forwardValue  = 0
		self.backwardValue = 0
		self.leftValue = 0
		self.rightValue = 0
	
		self.activeGamepad = NONE	-- Enum.UserInputType.Gamepad1, 2, 3...
		self.gamepadConnectedConn = nil
		self.gamepadDisconnectedConn = nil
		return self
	end
	
	function Gamepad:Enable(enable)
		if not UserInputService.GamepadEnabled then
			return false
		end
	
		if enable == self.enabled then
			-- Module is already in the state being requested. True is returned here since the module will be in the state
			-- expected by the code that follows the Enable() call. This makes more sense than returning false to indicate
			-- no action was necessary. False indicates failure to be in requested/expected state.
			return true
		end
	
		self.forwardValue  = 0
		self.backwardValue = 0
		self.leftValue = 0
		self.rightValue = 0
		self.moveVector = ZERO_VECTOR3
		self.isJumping = false
	
		if enable then
			self.activeGamepad = self:GetHighestPriorityGamepad()
			if self.activeGamepad ~= NONE then
				self:BindContextActions()
				self:ConnectGamepadConnectionListeners()
			else
				-- No connected gamepads, failure to enable
				return false
			end
		else
			self:UnbindContextActions()
			self:DisconnectGamepadConnectionListeners()
			self.activeGamepad = NONE
		end
	
		self.enabled = enable
		return true
	end
	
	-- This function selects the lowest number gamepad from the currently-connected gamepad
	-- and sets it as the active gamepad
	function Gamepad:GetHighestPriorityGamepad()
		local connectedGamepads = UserInputService:GetConnectedGamepads()
		local bestGamepad = NONE -- Note that this value is higher than all valid gamepad values
		for _, gamepad in pairs(connectedGamepads) do
			if gamepad.Value < bestGamepad.Value then
				bestGamepad = gamepad
			end
		end
		return bestGamepad
	end
	
	function Gamepad:BindContextActions()
	
		if self.activeGamepad == NONE then
			-- There must be an active gamepad to set up bindings
			return false
		end
	
		local handleJumpAction = function(actionName, inputState, inputObject)
			self.isJumping = (inputState == Enum.UserInputState.Begin)
			return Enum.ContextActionResult.Sink
		end
	
		local handleThumbstickInput = function(actionName, inputState, inputObject)
	
			if inputState == Enum.UserInputState.Cancel then
				self.moveVector = ZERO_VECTOR3
				return Enum.ContextActionResult.Sink
			end
	
			if self.activeGamepad ~= inputObject.UserInputType then
				return Enum.ContextActionResult.Pass
			end
			if inputObject.KeyCode ~= Enum.KeyCode.Thumbstick1 then return end
	
			if inputObject.Position.magnitude > thumbstickDeadzone then
				self.moveVector  =  Vector3.new(inputObject.Position.X, 0, -inputObject.Position.Y)
			else
				self.moveVector = ZERO_VECTOR3
			end
			return Enum.ContextActionResult.Sink
		end
	
		ContextActionService:BindActivate(self.activeGamepad, Enum.KeyCode.ButtonR2)
		ContextActionService:BindActionAtPriority("jumpAction", handleJumpAction, false,
			self.CONTROL_ACTION_PRIORITY, Enum.KeyCode.ButtonA)
		ContextActionService:BindActionAtPriority("moveThumbstick", handleThumbstickInput, false,
			self.CONTROL_ACTION_PRIORITY, Enum.KeyCode.Thumbstick1)
	
		return true
	end
	
	function Gamepad:UnbindContextActions()
		if self.activeGamepad ~= NONE then
			ContextActionService:UnbindActivate(self.activeGamepad, Enum.KeyCode.ButtonR2)
		end
		ContextActionService:UnbindAction("moveThumbstick")
		ContextActionService:UnbindAction("jumpAction")
	end
	
	function Gamepad:OnNewGamepadConnected()
		-- A new gamepad has been connected.
		local bestGamepad = self:GetHighestPriorityGamepad()
	
		if bestGamepad == self.activeGamepad then
			-- A new gamepad was connected, but our active gamepad is not changing
			return
		end
	
		if bestGamepad == NONE then
			-- There should be an active gamepad when GamepadConnected fires, so this should not
			-- normally be hit. If there is no active gamepad, unbind actions but leave
			-- the module enabled and continue to listen for a new gamepad connection.
			warn("Gamepad:OnNewGamepadConnected found no connected gamepads")
			self:UnbindContextActions()
			return
		end
	
		if self.activeGamepad ~= NONE then
			-- Switching from one active gamepad to another
			self:UnbindContextActions()
		end
	
		self.activeGamepad = bestGamepad
		self:BindContextActions()
	end
	
	function Gamepad:OnCurrentGamepadDisconnected()
		if self.activeGamepad ~= NONE then
			ContextActionService:UnbindActivate(self.activeGamepad, Enum.KeyCode.ButtonR2)
		end
	
		local bestGamepad = self:GetHighestPriorityGamepad()
	
		if self.activeGamepad ~= NONE and bestGamepad == self.activeGamepad then
			warn("Gamepad:OnCurrentGamepadDisconnected found the supposedly disconnected gamepad in connectedGamepads.")
			self:UnbindContextActions()
			self.activeGamepad = NONE
			return
		end
	
		if bestGamepad == NONE then
			-- No active gamepad, unbinding actions but leaving gamepad connection listener active
			self:UnbindContextActions()
			self.activeGamepad = NONE
		else
			-- Set new gamepad as active and bind to tool activation
			self.activeGamepad = bestGamepad
			ContextActionService:BindActivate(self.activeGamepad, Enum.KeyCode.ButtonR2)
		end
	end
	
	function Gamepad:ConnectGamepadConnectionListeners()
		self.gamepadConnectedConn = UserInputService.GamepadConnected:Connect(function(gamepadEnum)
			self:OnNewGamepadConnected()
		end)
	
		self.gamepadDisconnectedConn = UserInputService.GamepadDisconnected:Connect(function(gamepadEnum)
			if self.activeGamepad == gamepadEnum then
				self:OnCurrentGamepadDisconnected()
			end
		end)
	
	end
	
	function Gamepad:DisconnectGamepadConnectionListeners()
		if self.gamepadConnectedConn then
			self.gamepadConnectedConn:Disconnect()
			self.gamepadConnectedConn = nil
		end
	
		if self.gamepadDisconnectedConn then
			self.gamepadDisconnectedConn:Disconnect()
			self.gamepadDisconnectedConn = nil
		end
	end
	
	return Gamepad
end

function _Keyboard()
	
	--[[ Roblox Services ]]--
	local UserInputService = game:GetService("UserInputService")
	local ContextActionService = game:GetService("ContextActionService")
	
	--[[ Constants ]]--
	local ZERO_VECTOR3 = Vector3.new(0,0,0)
	
	--[[ The Module ]]--
	local BaseCharacterController = _BaseCharacterController()
	local Keyboard = setmetatable({}, BaseCharacterController)
	Keyboard.__index = Keyboard
	
	function Keyboard.new(CONTROL_ACTION_PRIORITY)
		local self = setmetatable(BaseCharacterController.new(), Keyboard)
	
		self.CONTROL_ACTION_PRIORITY = CONTROL_ACTION_PRIORITY
	
		self.textFocusReleasedConn = nil
		self.textFocusGainedConn = nil
		self.windowFocusReleasedConn = nil
	
		self.forwardValue  = 0
		self.backwardValue = 0
		self.leftValue = 0
		self.rightValue = 0
	
		self.jumpEnabled = true
	
		return self
	end
	
	function Keyboard:Enable(enable)
		if not UserInputService.KeyboardEnabled then
			return false
		end
	
		if enable == self.enabled then
			-- Module is already in the state being requested. True is returned here since the module will be in the state
			-- expected by the code that follows the Enable() call. This makes more sense than returning false to indicate
			-- no action was necessary. False indicates failure to be in requested/expected state.
			return true
		end
	
		self.forwardValue  = 0
		self.backwardValue = 0
		self.leftValue = 0
		self.rightValue = 0
		self.moveVector = ZERO_VECTOR3
		self.jumpRequested = false
		self:UpdateJump()
	
		if enable then
			self:BindContextActions()
			self:ConnectFocusEventListeners()
		else
			self:UnbindContextActions()
			self:DisconnectFocusEventListeners()
		end
	
		self.enabled = enable
		return true
	end
	
	function Keyboard:UpdateMovement(inputState)
		if inputState == Enum.UserInputState.Cancel then
			self.moveVector = ZERO_VECTOR3
		else
			self.moveVector = Vector3.new(self.leftValue + self.rightValue, 0, self.forwardValue + self.backwardValue)
		end
	end
	
	function Keyboard:UpdateJump()
		self.isJumping = self.jumpRequested
	end
	
	function Keyboard:BindContextActions()
	
		-- Note: In the previous version of this code, the movement values were not zeroed-out on UserInputState. Cancel, now they are,
		-- which fixes them from getting stuck on.
		-- We return ContextActionResult.Pass here for legacy reasons.
		-- Many games rely on gameProcessedEvent being false on UserInputService.InputBegan for these control actions.
		local handleMoveForward = function(actionName, inputState, inputObject)
			self.forwardValue = (inputState == Enum.UserInputState.Begin) and -1 or 0
			self:UpdateMovement(inputState)
			return Enum.ContextActionResult.Pass
		end
	
		local handleMoveBackward = function(actionName, inputState, inputObject)
			self.backwardValue = (inputState == Enum.UserInputState.Begin) and 1 or 0
			self:UpdateMovement(inputState)
			return Enum.ContextActionResult.Pass
		end
	
		local handleMoveLeft = function(actionName, inputState, inputObject)
			self.leftValue = (inputState == Enum.UserInputState.Begin) and -1 or 0
			self:UpdateMovement(inputState)
			return Enum.ContextActionResult.Pass
		end
	
		local handleMoveRight = function(actionName, inputState, inputObject)
			self.rightValue = (inputState == Enum.UserInputState.Begin) and 1 or 0
			self:UpdateMovement(inputState)
			return Enum.ContextActionResult.Pass
		end
	
		local handleJumpAction = function(actionName, inputState, inputObject)
			self.jumpRequested = self.jumpEnabled and (inputState == Enum.UserInputState.Begin)
			self:UpdateJump()
			return Enum.ContextActionResult.Pass
		end
	
		-- TODO: Revert to KeyCode bindings so that in the future the abstraction layer from actual keys to
		-- movement direction is done in Lua
		ContextActionService:BindActionAtPriority("moveForwardAction", handleMoveForward, false,
			self.CONTROL_ACTION_PRIORITY, Enum.PlayerActions.CharacterForward)
		ContextActionService:BindActionAtPriority("moveBackwardAction", handleMoveBackward, false,
			self.CONTROL_ACTION_PRIORITY, Enum.PlayerActions.CharacterBackward)
		ContextActionService:BindActionAtPriority("moveLeftAction", handleMoveLeft, false,
			self.CONTROL_ACTION_PRIORITY, Enum.PlayerActions.CharacterLeft)
		ContextActionService:BindActionAtPriority("moveRightAction", handleMoveRight, false,
			self.CONTROL_ACTION_PRIORITY, Enum.PlayerActions.CharacterRight)
		ContextActionService:BindActionAtPriority("jumpAction", handleJumpAction, false,
			self.CONTROL_ACTION_PRIORITY, Enum.PlayerActions.CharacterJump)
	end
	
	function Keyboard:UnbindContextActions()
		ContextActionService:UnbindAction("moveForwardAction")
		ContextActionService:UnbindAction("moveBackwardAction")
		ContextActionService:UnbindAction("moveLeftAction")
		ContextActionService:UnbindAction("moveRightAction")
		ContextActionService:UnbindAction("jumpAction")
	end
	
	function Keyboard:ConnectFocusEventListeners()
		local function onFocusReleased()
			self.moveVector = ZERO_VECTOR3
			self.forwardValue  = 0
			self.backwardValue = 0
			self.leftValue = 0
			self.rightValue = 0
			self.jumpRequested = false
			self:UpdateJump()
		end
	
		local function onTextFocusGained(textboxFocused)
			self.jumpRequested = false
			self:UpdateJump()
		end
	
		self.textFocusReleasedConn = UserInputService.TextBoxFocusReleased:Connect(onFocusReleased)
		self.textFocusGainedConn = UserInputService.TextBoxFocused:Connect(onTextFocusGained)
		self.windowFocusReleasedConn = UserInputService.WindowFocused:Connect(onFocusReleased)
	end
	
	function Keyboard:DisconnectFocusEventListeners()
		if self.textFocusReleasedCon then
			self.textFocusReleasedCon:Disconnect()
			self.textFocusReleasedCon = nil
		end
		if self.textFocusGainedConn then
			self.textFocusGainedConn:Disconnect()
			self.textFocusGainedConn = nil
		end
		if self.windowFocusReleasedConn then
			self.windowFocusReleasedConn:Disconnect()
			self.windowFocusReleasedConn = nil
		end
	end
	
	return Keyboard
end

function _ControlModule()
	local ControlModule = {}
	ControlModule.__index = ControlModule
	
	--[[ Roblox Services ]]--
	local Players = game:GetService("Players")
	local RunService = game:GetService("RunService")
	local UserInputService = game:GetService("UserInputService")
	local Workspace = game:GetService("Workspace")
	local UserGameSettings = UserSettings():GetService("UserGameSettings")
	
	-- Roblox User Input Control Modules - each returns a new() constructor function used to create controllers as needed
	local Keyboard = _Keyboard()
	local Gamepad = _Gamepad()
	local DynamicThumbstick = _DynamicThumbstick()
	
	local FFlagUserMakeThumbstickDynamic do
		local success, value = pcall(function()
			return UserSettings():IsUserFeatureEnabled("UserMakeThumbstickDynamic")
		end)
		FFlagUserMakeThumbstickDynamic = success and value
	end
	
	local TouchThumbstick = FFlagUserMakeThumbstickDynamic and DynamicThumbstick or _TouchThumbstick()
	
	-- These controllers handle only walk/run movement, jumping is handled by the
	-- TouchJump controller if any of these are active
	local ClickToMove = _ClickToMoveController()
	local TouchJump = _TouchJump()
	
	local VehicleController = _VehicleController()
	
	local CONTROL_ACTION_PRIORITY = Enum.ContextActionPriority.Default.Value
	
	-- Mapping from movement mode and lastInputType enum values to control modules to avoid huge if elseif switching
	local movementEnumToModuleMap = {
		[Enum.TouchMovementMode.DPad] = DynamicThumbstick,
		[Enum.DevTouchMovementMode.DPad] = DynamicThumbstick,
		[Enum.TouchMovementMode.Thumbpad] = DynamicThumbstick,
		[Enum.DevTouchMovementMode.Thumbpad] = DynamicThumbstick,
		[Enum.TouchMovementMode.Thumbstick] = TouchThumbstick,
		[Enum.DevTouchMovementMode.Thumbstick] = TouchThumbstick,
		[Enum.TouchMovementMode.DynamicThumbstick] = DynamicThumbstick,
		[Enum.DevTouchMovementMode.DynamicThumbstick] = DynamicThumbstick,
		[Enum.TouchMovementMode.ClickToMove] = ClickToMove,
		[Enum.DevTouchMovementMode.ClickToMove] = ClickToMove,
	
		-- Current default
		[Enum.TouchMovementMode.Default] = DynamicThumbstick,
	
		[Enum.ComputerMovementMode.Default] = Keyboard,
		[Enum.ComputerMovementMode.KeyboardMouse] = Keyboard,
		[Enum.DevComputerMovementMode.KeyboardMouse] = Keyboard,
		[Enum.DevComputerMovementMode.Scriptable] = nil,
		[Enum.ComputerMovementMode.ClickToMove] = ClickToMove,
		[Enum.DevComputerMovementMode.ClickToMove] = ClickToMove,
	}
	
	-- Keyboard controller is really keyboard and mouse controller
	local computerInputTypeToModuleMap = {
		[Enum.UserInputType.Keyboard] = Keyboard,
		[Enum.UserInputType.MouseButton1] = Keyboard,
		[Enum.UserInputType.MouseButton2] = Keyboard,
		[Enum.UserInputType.MouseButton3] = Keyboard,
		[Enum.UserInputType.MouseWheel] = Keyboard,
		[Enum.UserInputType.MouseMovement] = Keyboard,
		[Enum.UserInputType.Gamepad1] = Gamepad,
		[Enum.UserInputType.Gamepad2] = Gamepad,
		[Enum.UserInputType.Gamepad3] = Gamepad,
		[Enum.UserInputType.Gamepad4] = Gamepad,
	}
	
	local lastInputType
	
	function ControlModule.new()
		local self = setmetatable({},ControlModule)
	
		-- The Modules above are used to construct controller instances as-needed, and this
		-- table is a map from Module to the instance created from it
		self.controllers = {}
	
		self.activeControlModule = nil	-- Used to prevent unnecessarily expensive checks on each input event
		self.activeController = nil
		self.touchJumpController = nil
		self.moveFunction = Players.LocalPlayer.Move
		self.humanoid = nil
		self.lastInputType = Enum.UserInputType.None
	
		-- For Roblox self.vehicleController
		self.humanoidSeatedConn = nil
		self.vehicleController = nil
	
		self.touchControlFrame = nil
	
		self.vehicleController = VehicleController.new(CONTROL_ACTION_PRIORITY)
	
		Players.LocalPlayer.CharacterAdded:Connect(function(char) self:OnCharacterAdded(char) end)
		Players.LocalPlayer.CharacterRemoving:Connect(function(char) self:OnCharacterRemoving(char) end)
		if Players.LocalPlayer.Character then
			self:OnCharacterAdded(Players.LocalPlayer.Character)
		end
	
		RunService:BindToRenderStep("ControlScriptRenderstep", Enum.RenderPriority.Input.Value, function(dt)
			self:OnRenderStepped(dt)
		end)
	
		UserInputService.LastInputTypeChanged:Connect(function(newLastInputType)
			self:OnLastInputTypeChanged(newLastInputType)
		end)
	
	
		UserGameSettings:GetPropertyChangedSignal("TouchMovementMode"):Connect(function()
			self:OnTouchMovementModeChange()
		end)
		Players.LocalPlayer:GetPropertyChangedSignal("DevTouchMovementMode"):Connect(function()
			self:OnTouchMovementModeChange()
		end)
	
		UserGameSettings:GetPropertyChangedSignal("ComputerMovementMode"):Connect(function()
			self:OnComputerMovementModeChange()
		end)
		Players.LocalPlayer:GetPropertyChangedSignal("DevComputerMovementMode"):Connect(function()
			self:OnComputerMovementModeChange()
		end)
	
		--[[ Touch Device UI ]]--
		self.playerGui = nil
		self.touchGui = nil
		self.playerGuiAddedConn = nil
	
		if UserInputService.TouchEnabled then
			self.playerGui = Players.LocalPlayer:FindFirstChildOfClass("PlayerGui")
			if self.playerGui then
				self:CreateTouchGuiContainer()
				self:OnLastInputTypeChanged(UserInputService:GetLastInputType())
			else
				self.playerGuiAddedConn = Players.LocalPlayer.ChildAdded:Connect(function(child)
					if child:IsA("PlayerGui") then
						self.playerGui = child
						self:CreateTouchGuiContainer()
						self.playerGuiAddedConn:Disconnect()
						self.playerGuiAddedConn = nil
						self:OnLastInputTypeChanged(UserInputService:GetLastInputType())
					end
				end)
			end
		else
			self:OnLastInputTypeChanged(UserInputService:GetLastInputType())
		end
	
		return self
	end
	
	-- Convenience function so that calling code does not have to first get the activeController
	-- and then call GetMoveVector on it. When there is no active controller, this function returns
	-- nil so that this case can be distinguished from no current movement (which returns zero vector).
	function ControlModule:GetMoveVector()
		if self.activeController then
			return self.activeController:GetMoveVector()
		end
		return Vector3.new(0,0,0)
	end
	
	function ControlModule:GetActiveController()
		return self.activeController
	end
	
	function ControlModule:EnableActiveControlModule()
		if self.activeControlModule == ClickToMove then
			-- For ClickToMove, when it is the player's choice, we also enable the full keyboard controls.
			-- When the developer is forcing click to move, the most keyboard controls (WASD) are not available, only jump.
			self.activeController:Enable(
				true,
				Players.LocalPlayer.DevComputerMovementMode == Enum.DevComputerMovementMode.UserChoice,
				self.touchJumpController
			)
		elseif self.touchControlFrame then
			self.activeController:Enable(true, self.touchControlFrame)
		else
			self.activeController:Enable(true)
		end
	end
	
	function ControlModule:Enable(enable)
		if not self.activeController then
			return
		end
	
		if enable == nil then
			enable = true
		end
		if enable then
			self:EnableActiveControlModule()
		else
			self:Disable()
		end
	end
	
	-- For those who prefer distinct functions
	function ControlModule:Disable()
		if self.activeController then
			self.activeController:Enable(false)
	
			if self.moveFunction then
				self.moveFunction(Players.LocalPlayer, Vector3.new(0,0,0), true)
			end
		end
	end
	
	
	-- Returns module (possibly nil) and success code to differentiate returning nil due to error vs Scriptable
	function ControlModule:SelectComputerMovementModule()
		if not (UserInputService.KeyboardEnabled or UserInputService.GamepadEnabled) then
			return nil, false
		end
	
		local computerModule
		local DevMovementMode = Players.LocalPlayer.DevComputerMovementMode
	
		if DevMovementMode == Enum.DevComputerMovementMode.UserChoice then
			computerModule = computerInputTypeToModuleMap[lastInputType]
			if UserGameSettings.ComputerMovementMode == Enum.ComputerMovementMode.ClickToMove and computerModule == Keyboard then
				-- User has ClickToMove set in Settings, prefer ClickToMove controller for keyboard and mouse lastInputTypes
				computerModule = ClickToMove
			end
		else
			-- Developer has selected a mode that must be used.
			computerModule = movementEnumToModuleMap[DevMovementMode]
	
			-- computerModule is expected to be nil here only when developer has selected Scriptable
			if (not computerModule) and DevMovementMode ~= Enum.DevComputerMovementMode.Scriptable then
				warn("No character control module is associated with DevComputerMovementMode ", DevMovementMode)
			end
		end
	
		if computerModule then
			return computerModule, true
		elseif DevMovementMode == Enum.DevComputerMovementMode.Scriptable then
			-- Special case where nil is returned and we actually want to set self.activeController to nil for Scriptable
			return nil, true
		else
			-- This case is for when computerModule is nil because of an error and no suitable control module could
			-- be found.
			return nil, false
		end
	end
	
	-- Choose current Touch control module based on settings (user, dev)
	-- Returns module (possibly nil) and success code to differentiate returning nil due to error vs Scriptable
	function ControlModule:SelectTouchModule()
		if not UserInputService.TouchEnabled then
			return nil, false
		end
		local touchModule
		local DevMovementMode = Players.LocalPlayer.DevTouchMovementMode
		if DevMovementMode == Enum.DevTouchMovementMode.UserChoice then
			touchModule = movementEnumToModuleMap[UserGameSettings.TouchMovementMode]
		elseif DevMovementMode == Enum.DevTouchMovementMode.Scriptable then
			return nil, true
		else
			touchModule = movementEnumToModuleMap[DevMovementMode]
		end
		return touchModule, true
	end
	
	local function calculateRawMoveVector(humanoid, cameraRelativeMoveVector)
		local camera = Workspace.CurrentCamera
		if not camera then
			return cameraRelativeMoveVector
		end
	
		if humanoid:GetState() == Enum.HumanoidStateType.Swimming then
			return camera.CFrame:VectorToWorldSpace(cameraRelativeMoveVector)
		end
	
		local c, s
		local _, _, _, R00, R01, R02, _, _, R12, _, _, R22 = camera.CFrame:GetComponents()
		if R12 < 1 and R12 > -1 then
			-- X and Z components from back vector.
			c = R22
			s = R02
		else
			-- In this case the camera is looking straight up or straight down.
			-- Use X components from right and up vectors.
			c = R00
			s = -R01*math.sign(R12)
		end
		local norm = math.sqrt(c*c + s*s)
		return Vector3.new(
			(c*cameraRelativeMoveVector.x + s*cameraRelativeMoveVector.z)/norm,
			0,
			(c*cameraRelativeMoveVector.z - s*cameraRelativeMoveVector.x)/norm
		)
	end
	
	function ControlModule:OnRenderStepped(dt)
		if self.activeController and self.activeController.enabled and self.humanoid then
			-- Give the controller a chance to adjust its state
			self.activeController:OnRenderStepped(dt)
	
			-- Now retrieve info from the controller
			local moveVector = self.activeController:GetMoveVector()
			local cameraRelative = self.activeController:IsMoveVectorCameraRelative()
	
			local clickToMoveController = self:GetClickToMoveController()
			if self.activeController ~= clickToMoveController then
				if moveVector.magnitude > 0 then
					-- Clean up any developer started MoveTo path
					clickToMoveController:CleanupPath()
				else
					-- Get move vector for developer started MoveTo
					clickToMoveController:OnRenderStepped(dt)
					moveVector = clickToMoveController:GetMoveVector()
					cameraRelative = clickToMoveController:IsMoveVectorCameraRelative()
				end
			end
	
			-- Are we driving a vehicle ?
			local vehicleConsumedInput = false
			if self.vehicleController then
				moveVector, vehicleConsumedInput = self.vehicleController:Update(moveVector, cameraRelative, self.activeControlModule==Gamepad)
			end
	
			-- If not, move the player
			-- Verification of vehicleConsumedInput is commented out to preserve legacy behavior,
			-- in case some game relies on Humanoid.MoveDirection still being set while in a VehicleSeat
			--if not vehicleConsumedInput then
				if cameraRelative then
					moveVector = calculateRawMoveVector(self.humanoid, moveVector)
				end
				self.moveFunction(Players.LocalPlayer, moveVector, false)
			--end
	
			-- And make them jump if needed
			self.humanoid.Jump = self.activeController:GetIsJumping() or (self.touchJumpController and self.touchJumpController:GetIsJumping())
		end
	end
	
	function ControlModule:OnHumanoidSeated(active, currentSeatPart)
		if active then
			if currentSeatPart and currentSeatPart:IsA("VehicleSeat") then
				if not self.vehicleController then
					self.vehicleController = self.vehicleController.new(CONTROL_ACTION_PRIORITY)
				end
				self.vehicleController:Enable(true, currentSeatPart)
			end
		else
			if self.vehicleController then
				self.vehicleController:Enable(false, currentSeatPart)
			end
		end
	end
	
	function ControlModule:OnCharacterAdded(char)
		self.humanoid = char:FindFirstChildOfClass("Humanoid")
		while not self.humanoid do
			char.ChildAdded:wait()
			self.humanoid = char:FindFirstChildOfClass("Humanoid")
		end
	
		if self.touchGui then
			self.touchGui.Enabled = true
		end
	
		if self.humanoidSeatedConn then
			self.humanoidSeatedConn:Disconnect()
			self.humanoidSeatedConn = nil
		end
		self.humanoidSeatedConn = self.humanoid.Seated:Connect(function(active, currentSeatPart)
			self:OnHumanoidSeated(active, currentSeatPart)
		end)
	end
	
	function ControlModule:OnCharacterRemoving(char)
		self.humanoid = nil
	
		if self.touchGui then
			self.touchGui.Enabled = false
		end
	end
	
	-- Helper function to lazily instantiate a controller if it does not yet exist,
	-- disable the active controller if it is different from the on being switched to,
	-- and then enable the requested controller. The argument to this function must be
	-- a reference to one of the control modules, i.e. Keyboard, Gamepad, etc.
	function ControlModule:SwitchToController(controlModule)
		if not controlModule then
			if self.activeController then
				self.activeController:Enable(false)
			end
			self.activeController = nil
			self.activeControlModule = nil
		else
			if not self.controllers[controlModule] then
				self.controllers[controlModule] = controlModule.new(CONTROL_ACTION_PRIORITY)
			end
	
			if self.activeController ~= self.controllers[controlModule] then
				if self.activeController then
					self.activeController:Enable(false)
				end
				self.activeController = self.controllers[controlModule]
				self.activeControlModule = controlModule -- Only used to check if controller switch is necessary
	
				if self.touchControlFrame and (self.activeControlModule == ClickToMove
							or self.activeControlModule == TouchThumbstick
							or self.activeControlModule == DynamicThumbstick) then
					if not self.controllers[TouchJump] then
						self.controllers[TouchJump] = TouchJump.new()
					end
					self.touchJumpController = self.controllers[TouchJump]
					self.touchJumpController:Enable(true, self.touchControlFrame)
				else
					if self.touchJumpController then
						self.touchJumpController:Enable(false)
					end
				end
	
				self:EnableActiveControlModule()
			end
		end
	end
	
	function ControlModule:OnLastInputTypeChanged(newLastInputType)
		if lastInputType == newLastInputType then
			warn("LastInputType Change listener called with current type.")
		end
		lastInputType = newLastInputType
	
		if lastInputType == Enum.UserInputType.Touch then
			-- TODO: Check if touch module already active
			local touchModule, success = self:SelectTouchModule()
			if success then
				while not self.touchControlFrame do
					wait()
				end
				self:SwitchToController(touchModule)
			end
		elseif computerInputTypeToModuleMap[lastInputType] ~= nil then
			local computerModule = self:SelectComputerMovementModule()
			if computerModule then
				self:SwitchToController(computerModule)
			end
		end
	end
	
	-- Called when any relevant values of GameSettings or LocalPlayer change, forcing re-evalulation of
	-- current control scheme
	function ControlModule:OnComputerMovementModeChange()
		local controlModule, success =  self:SelectComputerMovementModule()
		if success then
			self:SwitchToController(controlModule)
		end
	end
	
	function ControlModule:OnTouchMovementModeChange()
		local touchModule, success = self:SelectTouchModule()
		if success then
			while not self.touchControlFrame do
				wait()
			end
			self:SwitchToController(touchModule)
		end
	end
	
	function ControlModule:CreateTouchGuiContainer()
		if self.touchGui then self.touchGui:Destroy() end
	
		-- Container for all touch device guis
		self.touchGui = Instance.new("ScreenGui")
		self.touchGui.Name = "TouchGui"
		self.touchGui.ResetOnSpawn = false
		self.touchGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
		self.touchGui.Enabled = self.humanoid ~= nil
	
		self.touchControlFrame = Instance.new("Frame")
		self.touchControlFrame.Name = "TouchControlFrame"
		self.touchControlFrame.Size = UDim2.new(1, 0, 1, 0)
		self.touchControlFrame.BackgroundTransparency = 1
		self.touchControlFrame.Parent = self.touchGui
	
		self.touchGui.Parent = self.playerGui
	end
	
	function ControlModule:GetClickToMoveController()
		if not self.controllers[ClickToMove] then
			self.controllers[ClickToMove] = ClickToMove.new(CONTROL_ACTION_PRIORITY)
		end
		return self.controllers[ClickToMove]
	end
	
	function ControlModule:IsJumping()
		if self.activeController then
			return self.activeController:GetIsJumping() or (self.touchJumpController and self.touchJumpController:GetIsJumping())
		end
		return false
	end
	
	return ControlModule.new()
end

function _PlayerModule()
	local PlayerModule = {}
	PlayerModule.__index = PlayerModule
	function PlayerModule.new()
		local self = setmetatable({},PlayerModule)
		self.cameras = _CameraModule()
		self.controls = _ControlModule()
		return self
	end
	function PlayerModule:GetCameras()
		return self.cameras
	end
	function PlayerModule:GetControls()
		return self.controls
	end
	function PlayerModule:GetClickToMoveController()
		return self.controls:GetClickToMoveController()
	end
	return PlayerModule.new()
end

function _sounds()
	
	local SetState = Instance.new("BindableEvent",script)
	
	local Players = game:GetService("Players")
	local RunService = game:GetService("RunService")
	
	local SOUND_DATA = {
		Climbing = {
			SoundId = "rbxasset://sounds/action_footsteps_plastic.mp3",
			Looped = true,
		},
		Died = {
			SoundId = "rbxasset://sounds/uuhhh.mp3",
		},
		FreeFalling = {
			SoundId = "rbxasset://sounds/action_falling.mp3",
			Looped = true,
		},
		GettingUp = {
			SoundId = "rbxasset://sounds/action_get_up.mp3",
		},
		Jumping = {
			SoundId = "rbxasset://sounds/action_jump.mp3",
		},
		Landing = {
			SoundId = "rbxasset://sounds/action_jump_land.mp3",
		},
		Running = {
			SoundId = "rbxasset://sounds/action_footsteps_plastic.mp3",
			Looped = true,
			Pitch = 1.85,
		},
		Splash = {
			SoundId = "rbxasset://sounds/impact_water.mp3",
		},
		Swimming = {
			SoundId = "rbxasset://sounds/action_swim.mp3",
			Looped = true,
			Pitch = 1.6,
		},
	}
	
	 -- wait for the first of the passed signals to fire
	local function waitForFirst(...)
		local shunt = Instance.new("BindableEvent")
		local slots = {...}
	
		local function fire(...)
			for i = 1, #slots do
				slots[i]:Disconnect()
			end
	
			return shunt:Fire(...)
		end
	
		for i = 1, #slots do
			slots[i] = slots[i]:Connect(fire)
		end
	
		return shunt.Event:Wait()
	end
	
	-- map a value from one range to another
	local function map(x, inMin, inMax, outMin, outMax)
		return (x - inMin)*(outMax - outMin)/(inMax - inMin) + outMin
	end
	
	local function playSound(sound)
		sound.TimePosition = 0
		sound.Playing = true
	end
	
	local function stopSound(sound)
		sound.Playing = false
		sound.TimePosition = 0
	end
	
	local function shallowCopy(t)
		local out = {}
		for k, v in pairs(t) do
			out[k] = v
		end
		return out
	end
	
	local function initializeSoundSystem(player, humanoid, rootPart)
		local sounds = {}
	
		-- initialize sounds
		for name, props in pairs(SOUND_DATA) do
			local sound = Instance.new("Sound")
			sound.Name = name
	
			-- set default values
			sound.Archivable = false
			sound.EmitterSize = 5
			sound.MaxDistance = 150
			sound.Volume = 0.65
	
			for propName, propValue in pairs(props) do
				sound[propName] = propValue
			end
	
			sound.Parent = rootPart
			sounds[name] = sound
		end
	
		local playingLoopedSounds = {}
	
		local function stopPlayingLoopedSounds(except)
			for sound in pairs(shallowCopy(playingLoopedSounds)) do
				if sound ~= except then
					sound.Playing = false
					playingLoopedSounds[sound] = nil
				end
			end
		end
	
		-- state transition callbacks
		local stateTransitions = {
			[Enum.HumanoidStateType.FallingDown] = function()
				stopPlayingLoopedSounds()
			end,
	
			[Enum.HumanoidStateType.GettingUp] = function()
				stopPlayingLoopedSounds()
				playSound(sounds.GettingUp)
			end,
	
			[Enum.HumanoidStateType.Jumping] = function()
				stopPlayingLoopedSounds()
				playSound(sounds.Jumping)
			end,
	
			[Enum.HumanoidStateType.Swimming] = function()
				local verticalSpeed = math.abs(rootPart.Velocity.Y)
				if verticalSpeed > 0.1 then
					sounds.Splash.Volume = math.clamp(map(verticalSpeed, 100, 350, 0.28, 1), 0, 1)
					playSound(sounds.Splash)
				end
				stopPlayingLoopedSounds(sounds.Swimming)
				sounds.Swimming.Playing = true
				playingLoopedSounds[sounds.Swimming] = true
			end,
	
			[Enum.HumanoidStateType.Freefall] = function()
				sounds.FreeFalling.Volume = 0
				stopPlayingLoopedSounds(sounds.FreeFalling)
				playingLoopedSounds[sounds.FreeFalling] = true
			end,
	
			[Enum.HumanoidStateType.Landed] = function()
				stopPlayingLoopedSounds()
				local verticalSpeed = math.abs(rootPart.Velocity.Y)
				if verticalSpeed > 75 then
					sounds.Landing.Volume = math.clamp(map(verticalSpeed, 50, 100, 0, 1), 0, 1)
					playSound(sounds.Landing)
				end
			end,
	
			[Enum.HumanoidStateType.Running] = function()
				stopPlayingLoopedSounds(sounds.Running)
				sounds.Running.Playing = true
				playingLoopedSounds[sounds.Running] = true
			end,
	
			[Enum.HumanoidStateType.Climbing] = function()
				local sound = sounds.Climbing
				if math.abs(rootPart.Velocity.Y) > 0.1 then
					sound.Playing = true
					stopPlayingLoopedSounds(sound)
				else
					stopPlayingLoopedSounds()
				end
				playingLoopedSounds[sound] = true
			end,
	
			[Enum.HumanoidStateType.Seated] = function()
				stopPlayingLoopedSounds()
			end,
	
			[Enum.HumanoidStateType.Dead] = function()
				stopPlayingLoopedSounds()
				playSound(sounds.Died)
			end,
		}
	
		-- updaters for looped sounds
		local loopedSoundUpdaters = {
			[sounds.Climbing] = function(dt, sound, vel)
				sound.Playing = vel.Magnitude > 0.1
			end,
	
			[sounds.FreeFalling] = function(dt, sound, vel)
				if vel.Magnitude > 75 then
					sound.Volume = math.clamp(sound.Volume + 0.9*dt, 0, 1)
				else
					sound.Volume = 0
				end
			end,
	
			[sounds.Running] = function(dt, sound, vel)
				sound.Playing = vel.Magnitude > 0.5 and humanoid.MoveDirection.Magnitude > 0.5
			end,
		}
	
		-- state substitutions to avoid duplicating entries in the state table
		local stateRemap = {
			[Enum.HumanoidStateType.RunningNoPhysics] = Enum.HumanoidStateType.Running,
		}
	
		local activeState = stateRemap[humanoid:GetState()] or humanoid:GetState()
		local activeConnections = {}
	
		local stateChangedConn = humanoid.StateChanged:Connect(function(_, state)
			state = stateRemap[state] or state
	
			if state ~= activeState then
				local transitionFunc = stateTransitions[state]
	
				if transitionFunc then
					transitionFunc()
				end
	
				activeState = state
			end
		end)
		
		local customStateChangedConn = SetState.Event:Connect(function(state)
			state = stateRemap[state] or state
	
			if state ~= activeState then
				local transitionFunc = stateTransitions[state]
	
				if transitionFunc then
					transitionFunc()
				end
	
				activeState = state
			end
		end)
	
		local steppedConn = RunService.Stepped:Connect(function(_, worldDt)
			-- update looped sounds on stepped
			for sound in pairs(playingLoopedSounds) do
				local updater = loopedSoundUpdaters[sound]
	
				if updater then
					updater(worldDt, sound, rootPart.Velocity)
				end
			end
		end)
	
		local humanoidAncestryChangedConn
		local rootPartAncestryChangedConn
		local characterAddedConn
	
		local function terminate()
			stateChangedConn:Disconnect()
			customStateChangedConn:Disconnect()
			steppedConn:Disconnect()
			humanoidAncestryChangedConn:Disconnect()
			rootPartAncestryChangedConn:Disconnect()
			characterAddedConn:Disconnect()
		end
	
		humanoidAncestryChangedConn = humanoid.AncestryChanged:Connect(function(_, parent)
			if not parent then
				terminate()
			end
		end)
	
		rootPartAncestryChangedConn = rootPart.AncestryChanged:Connect(function(_, parent)
			if not parent then
				terminate()
			end
		end)
	
		characterAddedConn = player.CharacterAdded:Connect(terminate)
	end
	
	local function playerAdded(player)
		local function characterAdded(character)
			-- Avoiding memory leaks in the face of Character/Humanoid/RootPart lifetime has a few complications:
			-- * character deparenting is a Remove instead of a Destroy, so signals are not cleaned up automatically.
			-- ** must use a waitForFirst on everything and listen for hierarchy changes.
			-- * the character might not be in the dm by the time CharacterAdded fires
			-- ** constantly check consistency with player.Character and abort if CharacterAdded is fired again
			-- * Humanoid may not exist immediately, and by the time it's inserted the character might be deparented.
			-- * RootPart probably won't exist immediately.
			-- ** by the time RootPart is inserted and Humanoid.RootPart is set, the character or the humanoid might be deparented.
	
			if not character.Parent then
				waitForFirst(character.AncestryChanged, player.CharacterAdded)
			end
	
			if player.Character ~= character or not character.Parent then
				return
			end
	
			local humanoid = character:FindFirstChildOfClass("Humanoid")
			while character:IsDescendantOf(game) and not humanoid do
				waitForFirst(character.ChildAdded, character.AncestryChanged, player.CharacterAdded)
				humanoid = character:FindFirstChildOfClass("Humanoid")
			end
	
			if player.Character ~= character or not character:IsDescendantOf(game) then
				return
			end
	
			-- must rely on HumanoidRootPart naming because Humanoid.RootPart does not fire changed signals
			local rootPart = character:FindFirstChild("HumanoidRootPart")
			while character:IsDescendantOf(game) and not rootPart do
				waitForFirst(character.ChildAdded, character.AncestryChanged, humanoid.AncestryChanged, player.CharacterAdded)
				rootPart = character:FindFirstChild("HumanoidRootPart")
			end
	
			if rootPart and humanoid:IsDescendantOf(game) and character:IsDescendantOf(game) and player.Character == character then
				initializeSoundSystem(player, humanoid, rootPart)
			end
		end
	
		if player.Character then
			characterAdded(player.Character)
		end
		player.CharacterAdded:Connect(characterAdded)
	end
	
	Players.PlayerAdded:Connect(playerAdded)
	for _, player in ipairs(Players:GetPlayers()) do
		playerAdded(player)
	end
	return SetState
end

function _StateTracker()
	local EPSILON = 0.1
	
	local SPEED = {
		["onRunning"] = true,
		["onClimbing"] = true 
	}
	
	local INAIR = {
		["onFreeFall"] = true,
		["onJumping"] = true
	}
	
	local STATEMAP = {
		["onRunning"] = Enum.HumanoidStateType.Running,
		["onJumping"] = Enum.HumanoidStateType.Jumping,
		["onFreeFall"] = Enum.HumanoidStateType.Freefall
	}
	
	local StateTracker = {}
	StateTracker.__index = StateTracker
	
	function StateTracker.new(humanoid, soundState)
		local self = setmetatable({}, StateTracker)
		
		self.Humanoid = humanoid
		self.HRP = humanoid.RootPart
		
		self.Speed = 0
		self.State = "onRunning"
		self.Jumped = false
		self.JumpTick = tick()
		
		self.SoundState = soundState
		
		self._ChangedEvent = Instance.new("BindableEvent")
		self.Changed = self._ChangedEvent.Event
		
		return self
	end
	
	function StateTracker:Destroy()
		self._ChangedEvent:Destroy()
	end
	
	function StateTracker:RequestedJump()
		self.Jumped = true
		self.JumpTick = tick()
	end
	
	function StateTracker:OnStep(gravityUp, grounded, isMoving)
		local cVelocity = self.HRP.Velocity
		local gVelocity = cVelocity:Dot(gravityUp)
		
		local oldState, oldSpeed = self.State, self.Speed
		
		local newState
		local newSpeed = cVelocity.Magnitude
	
		if (not grounded) then
			if (gVelocity > 0) then
				if (self.Jumped) then
					newState = "onJumping"
				else
					newState = "onFreeFall"
				end
			else
				if (self.Jumped) then
					self.Jumped = false
				end
				newState = "onFreeFall"
			end
		else
			if (self.Jumped and tick() - self.JumpTick > 0.1) then
				self.Jumped = false
			end
			newSpeed = (cVelocity - gVelocity*gravityUp).Magnitude
			newState = "onRunning"
		end
		
		newSpeed = isMoving and newSpeed or 0
		
		if (oldState ~= newState or (SPEED[newState] and math.abs(oldSpeed - newSpeed) > EPSILON)) then
			self.State = newState
			self.Speed = newSpeed
			self.SoundState:Fire(STATEMAP[newState])
			self._ChangedEvent:Fire(self.State, self.Speed)
		end
	end
	
	return StateTracker
end
function _InitObjects()
	local model = workspace:FindFirstChild("objects") or game:GetObjects("rbxassetid://5045408489")[1]
	local SPHERE = model:WaitForChild("Sphere")
	local FLOOR = model:WaitForChild("Floor")
	local VFORCE = model:WaitForChild("VectorForce")
	local BGYRO = model:WaitForChild("BodyGyro")
	local function initObjects(self)
		local hrp = self.HRP
		local humanoid = self.Humanoid
		local sphere = SPHERE:Clone()
		sphere.Parent = self.Character
		local floor = FLOOR:Clone()
		floor.Parent = self.Character
		local isR15 = (humanoid.RigType == Enum.HumanoidRigType.R15)
		local height = isR15 and (humanoid.HipHeight + 0.05) or 2
		local weld = Instance.new("Weld")
		weld.C0 = CFrame.new(0, -height, 0.1)
		weld.Part0 = hrp
		weld.Part1 = sphere
		weld.Parent = sphere
		local weld2 = Instance.new("Weld")
		weld2.C0 = CFrame.new(0, -(height + 1.5), 0)
		weld2.Part0 = hrp
		weld2.Part1 = floor
		weld2.Parent = floor
		local gyro = BGYRO:Clone()
		gyro.CFrame = hrp.CFrame
		gyro.Parent = hrp
		local vForce = VFORCE:Clone()
		vForce.Attachment0 = isR15 and hrp:WaitForChild("RootRigAttachment") or hrp:WaitForChild("RootAttachment")
		vForce.Parent = hrp
		return sphere, gyro, vForce, floor
	end
	return initObjects
end
local plr = game.Players.LocalPlayer
local ms = plr:GetMouse()
local char
plr.CharacterAdded:Connect(function(c)
	char = c
end)
function _R6()
	function r6()
	local Figure = char
	local Torso = Figure:WaitForChild("Torso")
	local RightShoulder = Torso:WaitForChild("Right Shoulder")
	local LeftShoulder = Torso:WaitForChild("Left Shoulder")
	local RightHip = Torso:WaitForChild("Right Hip")
	local LeftHip = Torso:WaitForChild("Left Hip")
	local Neck = Torso:WaitForChild("Neck")
	local Humanoid = Figure:WaitForChild("Humanoid")
	local pose = "Standing"
	local currentAnim = ""
	local currentAnimInstance = nil
	local currentAnimTrack = nil
	local currentAnimKeyframeHandler = nil
	local currentAnimSpeed = 1.0
	local animTable = {}
	local animNames = { 
		idle = 	{	
					{ id = "http://www.roblox.com/asset/?id=180435571", weight = 9 },
					{ id = "http://www.roblox.com/asset/?id=180435792", weight = 1 }
				},
		walk = 	{ 	
					{ id = "http://www.roblox.com/asset/?id=180426354", weight = 10 } 
				}, 
		run = 	{
					{ id = "run.xml", weight = 10 } 
				}, 
		jump = 	{
					{ id = "http://www.roblox.com/asset/?id=125750702", weight = 10 } 
				}, 
		fall = 	{
					{ id = "http://www.roblox.com/asset/?id=180436148", weight = 10 } 
				}, 
		climb = {
					{ id = "http://www.roblox.com/asset/?id=180436334", weight = 10 } 
				}, 
		sit = 	{
					{ id = "http://www.roblox.com/asset/?id=178130996", weight = 10 } 
				},	
		toolnone = {
					{ id = "http://www.roblox.com/asset/?id=182393478", weight = 10 } 
				},
		toolslash = {
					{ id = "http://www.roblox.com/asset/?id=129967390", weight = 10 } 
	--				{ id = "slash.xml", weight = 10 } 
				},
		toollunge = {
					{ id = "http://www.roblox.com/asset/?id=129967478", weight = 10 } 
				},
		wave = {
					{ id = "http://www.roblox.com/asset/?id=128777973", weight = 10 } 
				},
		point = {
					{ id = "http://www.roblox.com/asset/?id=128853357", weight = 10 } 
				},
		dance1 = {
					{ id = "http://www.roblox.com/asset/?id=182435998", weight = 10 }, 
					{ id = "http://www.roblox.com/asset/?id=182491037", weight = 10 }, 
					{ id = "http://www.roblox.com/asset/?id=182491065", weight = 10 } 
				},
		dance2 = {
					{ id = "http://www.roblox.com/asset/?id=182436842", weight = 10 }, 
					{ id = "http://www.roblox.com/asset/?id=182491248", weight = 10 }, 
					{ id = "http://www.roblox.com/asset/?id=182491277", weight = 10 } 
				},
		dance3 = {
					{ id = "http://www.roblox.com/asset/?id=182436935", weight = 10 }, 
					{ id = "http://www.roblox.com/asset/?id=182491368", weight = 10 }, 
					{ id = "http://www.roblox.com/asset/?id=182491423", weight = 10 } 
				},
		laugh = {
					{ id = "http://www.roblox.com/asset/?id=129423131", weight = 10 } 
				},
		cheer = {
					{ id = "http://www.roblox.com/asset/?id=129423030", weight = 10 } 
				},
	}
	local dances = {"dance1", "dance2", "dance3"}
	-- Existance in this list signifies that it is an emote, the value indicates if it is a looping emote
	local emoteNames = { wave = false, point = false, dance1 = true, dance2 = true, dance3 = true, laugh = false, cheer = false}
	function configureAnimationSet(name, fileList)
		if (animTable[name] ~= nil) then
			for _, connection in pairs(animTable[name].connections) do
				connection:disconnect()
			end
		end
		animTable[name] = {}
		animTable[name].count = 0
		animTable[name].totalWeight = 0	
		animTable[name].connections = {}
		-- check for config values
		local config = script:FindFirstChild(name)
		if (config ~= nil) then
	--		print("Loading anims " .. name)
			table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))
			table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))
			local idx = 1
			for _, childPart in pairs(config:GetChildren()) do
				if (childPart:IsA("Animation")) then
					table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))
					animTable[name][idx] = {}
					animTable[name][idx].anim = childPart
					local weightObject = childPart:FindFirstChild("Weight")
					if (weightObject == nil) then
						animTable[name][idx].weight = 1
					else
						animTable[name][idx].weight = weightObject.Value
					end
					animTable[name].count = animTable[name].count + 1
					animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
		--			print(name .. " [" .. idx .. "] " .. animTable[name][idx].anim.AnimationId .. " (" .. animTable[name][idx].weight .. ")")
					idx = idx + 1
				end
			end
		end
		-- fallback to defaults
		if (animTable[name].count <= 0) then
			for idx, anim in pairs(fileList) do
				animTable[name][idx] = {}
				animTable[name][idx].anim = Instance.new("Animation")
				animTable[name][idx].anim.Name = name
				animTable[name][idx].anim.AnimationId = anim.id
				animTable[name][idx].weight = anim.weight
				animTable[name].count = animTable[name].count + 1
				animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
	--			print(name .. " [" .. idx .. "] " .. anim.id .. " (" .. anim.weight .. ")")
			end
		end
	end
	-- Setup animation objects
	function scriptChildModified(child)
		local fileList = animNames[child.Name]
		if (fileList ~= nil) then
			configureAnimationSet(child.Name, fileList)
		end	
	end
	
	script.ChildAdded:connect(scriptChildModified)
	script.ChildRemoved:connect(scriptChildModified)
	
	
	for name, fileList in pairs(animNames) do 
		configureAnimationSet(name, fileList)
	end	
	
	-- ANIMATION
	
	-- declarations
	local toolAnim = "None"
	local toolAnimTime = 0
	
	local jumpAnimTime = 0
	local jumpAnimDuration = 0.3
	
	local toolTransitionTime = 0.1
	local fallTransitionTime = 0.3
	local jumpMaxLimbVelocity = 0.75
	
	-- functions
	
	function stopAllAnimations()
		local oldAnim = currentAnim
	
		-- return to idle if finishing an emote
		if (emoteNames[oldAnim] ~= nil and emoteNames[oldAnim] == false) then
			oldAnim = "idle"
		end
	
		currentAnim = ""
		currentAnimInstance = nil
		if (currentAnimKeyframeHandler ~= nil) then
			currentAnimKeyframeHandler:disconnect()
		end
	
		if (currentAnimTrack ~= nil) then
			currentAnimTrack:Stop()
			currentAnimTrack:Destroy()
			currentAnimTrack = nil
		end
		return oldAnim
	end
	
	function setAnimationSpeed(speed)
		if speed ~= currentAnimSpeed then
			currentAnimSpeed = speed
			currentAnimTrack:AdjustSpeed(currentAnimSpeed)
		end
	end
	
	function keyFrameReachedFunc(frameName)
		if (frameName == "End") then
	
			local repeatAnim = currentAnim
			-- return to idle if finishing an emote
			if (emoteNames[repeatAnim] ~= nil and emoteNames[repeatAnim] == false) then
				repeatAnim = "idle"
			end
			
			local animSpeed = currentAnimSpeed
			playAnimation(repeatAnim, 0.0, Humanoid)
			setAnimationSpeed(animSpeed)
		end
	end
	
	-- Preload animations
	function playAnimation(animName, transitionTime, humanoid) 
			
		local roll = math.random(1, animTable[animName].totalWeight) 
		local origRoll = roll
		local idx = 1
		while (roll > animTable[animName][idx].weight) do
			roll = roll - animTable[animName][idx].weight
			idx = idx + 1
		end
	--		print(animName .. " " .. idx .. " [" .. origRoll .. "]")
		local anim = animTable[animName][idx].anim
	
		-- switch animation		
		if (anim ~= currentAnimInstance) then
			
			if (currentAnimTrack ~= nil) then
				currentAnimTrack:Stop(transitionTime)
				currentAnimTrack:Destroy()
			end
	
			currentAnimSpeed = 1.0
		
			-- load it to the humanoid; get AnimationTrack
			currentAnimTrack = humanoid:LoadAnimation(anim)
			currentAnimTrack.Priority = Enum.AnimationPriority.Core
			 
			-- play the animation
			currentAnimTrack:Play(transitionTime)
			currentAnim = animName
			currentAnimInstance = anim
	
			-- set up keyframe name triggers
			if (currentAnimKeyframeHandler ~= nil) then
				currentAnimKeyframeHandler:disconnect()
			end
			currentAnimKeyframeHandler = currentAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)
			
		end
	
	end
	
	-------------------------------------------------------------------------------------------
	-------------------------------------------------------------------------------------------
	
	local toolAnimName = ""
	local toolAnimTrack = nil
	local toolAnimInstance = nil
	local currentToolAnimKeyframeHandler = nil
	
	function toolKeyFrameReachedFunc(frameName)
		if (frameName == "End") then
	--		print("Keyframe : ".. frameName)	
			playToolAnimation(toolAnimName, 0.0, Humanoid)
		end
	end
	
	
	function playToolAnimation(animName, transitionTime, humanoid, priority)	 
			
			local roll = math.random(1, animTable[animName].totalWeight) 
			local origRoll = roll
			local idx = 1
			while (roll > animTable[animName][idx].weight) do
				roll = roll - animTable[animName][idx].weight
				idx = idx + 1
			end
	--		print(animName .. " * " .. idx .. " [" .. origRoll .. "]")
			local anim = animTable[animName][idx].anim
	
			if (toolAnimInstance ~= anim) then
				
				if (toolAnimTrack ~= nil) then
					toolAnimTrack:Stop()
					toolAnimTrack:Destroy()
					transitionTime = 0
				end
						
				-- load it to the humanoid; get AnimationTrack
				toolAnimTrack = humanoid:LoadAnimation(anim)
				if priority then
					toolAnimTrack.Priority = priority
				end
				 
				-- play the animation
				toolAnimTrack:Play(transitionTime)
				toolAnimName = animName
				toolAnimInstance = anim
	
				currentToolAnimKeyframeHandler = toolAnimTrack.KeyframeReached:connect(toolKeyFrameReachedFunc)
			end
	end
	
	function stopToolAnimations()
		local oldAnim = toolAnimName
	
		if (currentToolAnimKeyframeHandler ~= nil) then
			currentToolAnimKeyframeHandler:disconnect()
		end
	
		toolAnimName = ""
		toolAnimInstance = nil
		if (toolAnimTrack ~= nil) then
			toolAnimTrack:Stop()
			toolAnimTrack:Destroy()
			toolAnimTrack = nil
		end
	
	
		return oldAnim
	end
	
	-------------------------------------------------------------------------------------------
	-------------------------------------------------------------------------------------------
	
	
	function onRunning(speed)
		if speed > 0.01 then
			playAnimation("walk", 0.1, Humanoid)
			if currentAnimInstance and currentAnimInstance.AnimationId == "http://www.roblox.com/asset/?id=180426354" then
				setAnimationSpeed(speed / 14.5)
			end
			pose = "Running"
		else
			if emoteNames[currentAnim] == nil then
				playAnimation("idle", 0.1, Humanoid)
				pose = "Standing"
			end
		end
	end
	
	function onDied()
		pose = "Dead"
	end
	
	function onJumping()
		playAnimation("jump", 0.1, Humanoid)
		jumpAnimTime = jumpAnimDuration
		pose = "Jumping"
	end
	
	function onClimbing(speed)
		playAnimation("climb", 0.1, Humanoid)
		setAnimationSpeed(speed / 12.0)
		pose = "Climbing"
	end
	
	function onGettingUp()
		pose = "GettingUp"
	end
	
	function onFreeFall()
		if (jumpAnimTime <= 0) then
			playAnimation("fall", fallTransitionTime, Humanoid)
		end
		pose = "FreeFall"
	end
	
	function onFallingDown()
		pose = "FallingDown"
	end
	
	function onSeated()
		pose = "Seated"
	end
	
	function onPlatformStanding()
		pose = "PlatformStanding"
	end
	
	function onSwimming(speed)
		if speed > 0 then
			pose = "Running"
		else
			pose = "Standing"
		end
	end
	
	function getTool()	
		for _, kid in ipairs(Figure:GetChildren()) do
			if kid.className == "Tool" then return kid end
		end
		return nil
	end
	
	function getToolAnim(tool)
		for _, c in ipairs(tool:GetChildren()) do
			if c.Name == "toolanim" and c.className == "StringValue" then
				return c
			end
		end
		return nil
	end
	
	function animateTool()
		
		if (toolAnim == "None") then
			playToolAnimation("toolnone", toolTransitionTime, Humanoid, Enum.AnimationPriority.Idle)
			return
		end
	
		if (toolAnim == "Slash") then
			playToolAnimation("toolslash", 0, Humanoid, Enum.AnimationPriority.Action)
			return
		end
	
		if (toolAnim == "Lunge") then
			playToolAnimation("toollunge", 0, Humanoid, Enum.AnimationPriority.Action)
			return
		end
	end
	
	function moveSit()
		RightShoulder.MaxVelocity = 0.15
		LeftShoulder.MaxVelocity = 0.15
		RightShoulder:SetDesiredAngle(3.14 /2)
		LeftShoulder:SetDesiredAngle(-3.14 /2)
		RightHip:SetDesiredAngle(3.14 /2)
		LeftHip:SetDesiredAngle(-3.14 /2)
	end
	
	local lastTick = 0
	
	function move(time)
		local amplitude = 1
		local frequency = 1
	  	local deltaTime = time - lastTick
	  	lastTick = time
	
		local climbFudge = 0
		local setAngles = false
	
	  	if (jumpAnimTime > 0) then
	  		jumpAnimTime = jumpAnimTime - deltaTime
	  	end
	
		if (pose == "FreeFall" and jumpAnimTime <= 0) then
			playAnimation("fall", fallTransitionTime, Humanoid)
		elseif (pose == "Seated") then
			playAnimation("sit", 0.5, Humanoid)
			return
		elseif (pose == "Running") then
			playAnimation("walk", 0.1, Humanoid)
		elseif (pose == "Dead" or pose == "GettingUp" or pose == "FallingDown" or pose == "Seated" or pose == "PlatformStanding") then
	--		print("Wha " .. pose)
			stopAllAnimations()
			amplitude = 0.1
			frequency = 1
			setAngles = true
		end
	
		if (setAngles) then
			local desiredAngle = amplitude * math.sin(time * frequency)
	
			RightShoulder:SetDesiredAngle(desiredAngle + climbFudge)
			LeftShoulder:SetDesiredAngle(desiredAngle - climbFudge)
			RightHip:SetDesiredAngle(-desiredAngle)
			LeftHip:SetDesiredAngle(-desiredAngle)
		end
	
		-- Tool Animation handling
		local tool = getTool()
		if tool and tool:FindFirstChild("Handle") then
		
			local animStringValueObject = getToolAnim(tool)
	
			if animStringValueObject then
				toolAnim = animStringValueObject.Value
				-- message recieved, delete StringValue
				animStringValueObject.Parent = nil
				toolAnimTime = time + .3
			end
	
			if time > toolAnimTime then
				toolAnimTime = 0
				toolAnim = "None"
			end
	
			animateTool()		
		else
			stopToolAnimations()
			toolAnim = "None"
			toolAnimInstance = nil
			toolAnimTime = 0
		end
	end
	
	
	local events = {}
	local eventHum = Humanoid
	
	local function onUnhook()
		for i = 1, #events do
			events[i]:Disconnect()
		end
		events = {}
	end
	
	local function onHook()
		onUnhook()
		
		pose = eventHum.Sit and "Seated" or "Standing"
		
		events = {
			eventHum.Died:connect(onDied),
			eventHum.Running:connect(onRunning),
			eventHum.Jumping:connect(onJumping),
			eventHum.Climbing:connect(onClimbing),
			eventHum.GettingUp:connect(onGettingUp),
			eventHum.FreeFalling:connect(onFreeFall),
			eventHum.FallingDown:connect(onFallingDown),
			eventHum.Seated:connect(onSeated),
			eventHum.PlatformStanding:connect(onPlatformStanding),
			eventHum.Swimming:connect(onSwimming)
		}
	end
	
	
	onHook()
	
	-- setup emote chat hook
	game:GetService("Players").LocalPlayer.Chatted:connect(function(msg)
		local emote = ""
		if msg == "/e dance" then
			emote = dances[math.random(1, #dances)]
		elseif (string.sub(msg, 1, 3) == "/e ") then
			emote = string.sub(msg, 4)
		elseif (string.sub(msg, 1, 7) == "/emote ") then
			emote = string.sub(msg, 8)
		end
		
		if (pose == "Standing" and emoteNames[emote] ~= nil) then
			playAnimation(emote, 0.1, Humanoid)
		end
	
	end)
	
	
	-- main program
	
	-- initialize to idle
	playAnimation("idle", 0.1, Humanoid)
	pose = "Standing"
	
	spawn(function()
		while Figure.Parent ~= nil do
			local _, time = wait(0.1)
			move(time)
		end
	end)
	
	return {
		onRunning = onRunning, 
		onDied = onDied, 
		onJumping = onJumping, 
		onClimbing = onClimbing, 
		onGettingUp = onGettingUp, 
		onFreeFall = onFreeFall, 
		onFallingDown = onFallingDown, 
		onSeated = onSeated, 
		onPlatformStanding = onPlatformStanding,
		onHook = onHook,
		onUnhook = onUnhook
	}
	
	end
	return r6()
end

function _R15()
	local function r15()
		
	local Character = char
	local Humanoid = Character:WaitForChild("Humanoid")
	local pose = "Standing"
	
	local userNoUpdateOnLoopSuccess, userNoUpdateOnLoopValue = pcall(function() return UserSettings():IsUserFeatureEnabled("UserNoUpdateOnLoop") end)
	local userNoUpdateOnLoop = userNoUpdateOnLoopSuccess and userNoUpdateOnLoopValue
	local userAnimationSpeedDampeningSuccess, userAnimationSpeedDampeningValue = pcall(function() return UserSettings():IsUserFeatureEnabled("UserAnimationSpeedDampening") end)
	local userAnimationSpeedDampening = userAnimationSpeedDampeningSuccess and userAnimationSpeedDampeningValue
	
	local animateScriptEmoteHookFlagExists, animateScriptEmoteHookFlagEnabled = pcall(function()
		return UserSettings():IsUserFeatureEnabled("UserAnimateScriptEmoteHook")
	end)
	local FFlagAnimateScriptEmoteHook = animateScriptEmoteHookFlagExists and animateScriptEmoteHookFlagEnabled
	
	local AnimationSpeedDampeningObject = script:FindFirstChild("ScaleDampeningPercent")
	local HumanoidHipHeight = 2
	
	local EMOTE_TRANSITION_TIME = 0.1
	
	local currentAnim = ""
	local currentAnimInstance = nil
	local currentAnimTrack = nil
	local currentAnimKeyframeHandler = nil
	local currentAnimSpeed = 1.0
	
	local runAnimTrack = nil
	local runAnimKeyframeHandler = nil
	
	local animTable = {}
	local animNames = { 
		idle = 	{	
					{ id = "http://www.roblox.com/asset/?id=507766666", weight = 1 },
					{ id = "http://www.roblox.com/asset/?id=507766951", weight = 1 },
					{ id = "http://www.roblox.com/asset/?id=507766388", weight = 9 }
				},
		walk = 	{ 	
					{ id = "http://www.roblox.com/asset/?id=507777826", weight = 10 } 
				}, 
		run = 	{
					{ id = "http://www.roblox.com/asset/?id=507767714", weight = 10 } 
				}, 
		swim = 	{
					{ id = "http://www.roblox.com/asset/?id=507784897", weight = 10 } 
				}, 
		swimidle = 	{
					{ id = "http://www.roblox.com/asset/?id=507785072", weight = 10 } 
				}, 
		jump = 	{
					{ id = "http://www.roblox.com/asset/?id=507765000", weight = 10 } 
				}, 
		fall = 	{
					{ id = "http://www.roblox.com/asset/?id=507767968", weight = 10 } 
				}, 
		climb = {
					{ id = "http://www.roblox.com/asset/?id=507765644", weight = 10 } 
				}, 
		sit = 	{
					{ id = "http://www.roblox.com/asset/?id=2506281703", weight = 10 } 
				},	
		toolnone = {
					{ id = "http://www.roblox.com/asset/?id=507768375", weight = 10 } 
				},
		toolslash = {
					{ id = "http://www.roblox.com/asset/?id=522635514", weight = 10 } 
				},
		toollunge = {
					{ id = "http://www.roblox.com/asset/?id=522638767", weight = 10 } 
				},
		wave = {
					{ id = "http://www.roblox.com/asset/?id=507770239", weight = 10 } 
				},
		point = {
					{ id = "http://www.roblox.com/asset/?id=507770453", weight = 10 } 
				},
		dance = {
					{ id = "http://www.roblox.com/asset/?id=507771019", weight = 10 }, 
					{ id = "http://www.roblox.com/asset/?id=507771955", weight = 10 }, 
					{ id = "http://www.roblox.com/asset/?id=507772104", weight = 10 } 
				},
		dance2 = {
					{ id = "http://www.roblox.com/asset/?id=507776043", weight = 10 }, 
					{ id = "http://www.roblox.com/asset/?id=507776720", weight = 10 }, 
					{ id = "http://www.roblox.com/asset/?id=507776879", weight = 10 } 
				},
		dance3 = {
					{ id = "http://www.roblox.com/asset/?id=507777268", weight = 10 }, 
					{ id = "http://www.roblox.com/asset/?id=507777451", weight = 10 }, 
					{ id = "http://www.roblox.com/asset/?id=507777623", weight = 10 } 
				},
		laugh = {
					{ id = "http://www.roblox.com/asset/?id=507770818", weight = 10 } 
				},
		cheer = {
					{ id = "http://www.roblox.com/asset/?id=507770677", weight = 10 } 
				},
	}
	
	-- Existance in this list signifies that it is an emote, the value indicates if it is a looping emote
	local emoteNames = { wave = false, point = false, dance = true, dance2 = true, dance3 = true, laugh = false, cheer = false}
	
	local PreloadAnimsUserFlag = false
	local PreloadedAnims = {}
	local successPreloadAnim, msgPreloadAnim = pcall(function()
		PreloadAnimsUserFlag = UserSettings():IsUserFeatureEnabled("UserPreloadAnimations")
	end)
	if not successPreloadAnim then
		PreloadAnimsUserFlag = false
	end
	
	math.randomseed(tick())
	
	function findExistingAnimationInSet(set, anim)
		if set == nil or anim == nil then
			return 0
		end
		
		for idx = 1, set.count, 1 do 
			if set[idx].anim.AnimationId == anim.AnimationId then
				return idx
			end
		end
		
		return 0
	end
	
	function configureAnimationSet(name, fileList)
		if (animTable[name] ~= nil) then
			for _, connection in pairs(animTable[name].connections) do
				connection:disconnect()
			end
		end
		animTable[name] = {}
		animTable[name].count = 0
		animTable[name].totalWeight = 0	
		animTable[name].connections = {}
	
		local allowCustomAnimations = true
	
		local success, msg = pcall(function() allowCustomAnimations = game:GetService("StarterPlayer").AllowCustomAnimations end)
		if not success then
			allowCustomAnimations = true
		end
	
		-- check for config values
		local config = script:FindFirstChild(name)
		if (allowCustomAnimations and config ~= nil) then
			table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))
			table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))
			
			local idx = 0
			for _, childPart in pairs(config:GetChildren()) do
				if (childPart:IsA("Animation")) then
					local newWeight = 1
					local weightObject = childPart:FindFirstChild("Weight")
					if (weightObject ~= nil) then
						newWeight = weightObject.Value
					end
					animTable[name].count = animTable[name].count + 1
					idx = animTable[name].count
					animTable[name][idx] = {}
					animTable[name][idx].anim = childPart
					animTable[name][idx].weight = newWeight
					animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
					table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))
					table.insert(animTable[name].connections, childPart.ChildAdded:connect(function(property) configureAnimationSet(name, fileList) end))
					table.insert(animTable[name].connections, childPart.ChildRemoved:connect(function(property) configureAnimationSet(name, fileList) end))
				end
			end
		end
		
		-- fallback to defaults
		if (animTable[name].count <= 0) then
			for idx, anim in pairs(fileList) do
				animTable[name][idx] = {}
				animTable[name][idx].anim = Instance.new("Animation")
				animTable[name][idx].anim.Name = name
				animTable[name][idx].anim.AnimationId = anim.id
				animTable[name][idx].weight = anim.weight
				animTable[name].count = animTable[name].count + 1
				animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
			end
		end
		
		-- preload anims
		if PreloadAnimsUserFlag then
			for i, animType in pairs(animTable) do
				for idx = 1, animType.count, 1 do
					if PreloadedAnims[animType[idx].anim.AnimationId] == nil then
						Humanoid:LoadAnimation(animType[idx].anim)
						PreloadedAnims[animType[idx].anim.AnimationId] = true
					end				
				end
			end
		end
	end
	
	------------------------------------------------------------------------------------------------------------
	
	function configureAnimationSetOld(name, fileList)
		if (animTable[name] ~= nil) then
			for _, connection in pairs(animTable[name].connections) do
				connection:disconnect()
			end
		end
		animTable[name] = {}
		animTable[name].count = 0
		animTable[name].totalWeight = 0	
		animTable[name].connections = {}
	
		local allowCustomAnimations = true
	
		local success, msg = pcall(function() allowCustomAnimations = game:GetService("StarterPlayer").AllowCustomAnimations end)
		if not success then
			allowCustomAnimations = true
		end
	
		-- check for config values
		local config = script:FindFirstChild(name)
		if (allowCustomAnimations and config ~= nil) then
			table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))
			table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))
			local idx = 1
			for _, childPart in pairs(config:GetChildren()) do
				if (childPart:IsA("Animation")) then
					table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))
					animTable[name][idx] = {}
					animTable[name][idx].anim = childPart
					local weightObject = childPart:FindFirstChild("Weight")
					if (weightObject == nil) then
						animTable[name][idx].weight = 1
					else
						animTable[name][idx].weight = weightObject.Value
					end
					animTable[name].count = animTable[name].count + 1
					animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
					idx = idx + 1
				end
			end
		end
	
		-- fallback to defaults
		if (animTable[name].count <= 0) then
			for idx, anim in pairs(fileList) do
				animTable[name][idx] = {}
				animTable[name][idx].anim = Instance.new("Animation")
				animTable[name][idx].anim.Name = name
				animTable[name][idx].anim.AnimationId = anim.id
				animTable[name][idx].weight = anim.weight
				animTable[name].count = animTable[name].count + 1
				animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
				-- print(name .. " [" .. idx .. "] " .. anim.id .. " (" .. anim.weight .. ")")
			end
		end
		
		-- preload anims
		if PreloadAnimsUserFlag then
			for i, animType in pairs(animTable) do
				for idx = 1, animType.count, 1 do 
					Humanoid:LoadAnimation(animType[idx].anim)
				end
			end
		end
	end
	
	-- Setup animation objects
	function scriptChildModified(child)
		local fileList = animNames[child.Name]
		if (fileList ~= nil) then
			configureAnimationSet(child.Name, fileList)
		end	
	end
	
	script.ChildAdded:connect(scriptChildModified)
	script.ChildRemoved:connect(scriptChildModified)
	
	
	for name, fileList in pairs(animNames) do 
		configureAnimationSet(name, fileList)
	end	
	
	-- ANIMATION
	
	-- declarations
	local toolAnim = "None"
	local toolAnimTime = 0
	
	local jumpAnimTime = 0
	local jumpAnimDuration = 0.31
	
	local toolTransitionTime = 0.1
	local fallTransitionTime = 0.2
	
	local currentlyPlayingEmote = false
	
	-- functions
	
	function stopAllAnimations()
		local oldAnim = currentAnim
	
		-- return to idle if finishing an emote
		if (emoteNames[oldAnim] ~= nil and emoteNames[oldAnim] == false) then
			oldAnim = "idle"
		end
		
		if FFlagAnimateScriptEmoteHook and currentlyPlayingEmote then
			oldAnim = "idle"
			currentlyPlayingEmote = false
		end
	
		currentAnim = ""
		currentAnimInstance = nil
		if (currentAnimKeyframeHandler ~= nil) then
			currentAnimKeyframeHandler:disconnect()
		end
	
		if (currentAnimTrack ~= nil) then
			currentAnimTrack:Stop()
			currentAnimTrack:Destroy()
			currentAnimTrack = nil
		end
	
		-- clean up walk if there is one
		if (runAnimKeyframeHandler ~= nil) then
			runAnimKeyframeHandler:disconnect()
		end
		
		if (runAnimTrack ~= nil) then
			runAnimTrack:Stop()
			runAnimTrack:Destroy()
			runAnimTrack = nil
		end
		
		return oldAnim
	end
	
	function getHeightScale()
		if Humanoid then
			if not Humanoid.AutomaticScalingEnabled then
				return 1
			end
			
			local scale = Humanoid.HipHeight / HumanoidHipHeight
			if userAnimationSpeedDampening then
				if AnimationSpeedDampeningObject == nil then
					AnimationSpeedDampeningObject = script:FindFirstChild("ScaleDampeningPercent")
				end
				if AnimationSpeedDampeningObject ~= nil then
					scale = 1 + (Humanoid.HipHeight - HumanoidHipHeight) * AnimationSpeedDampeningObject.Value / HumanoidHipHeight
				end
			end
			return scale
		end	
		return 1
	end
	
	local smallButNotZero = 0.0001
	function setRunSpeed(speed)
		local speedScaled = speed * 1.25
		local heightScale = getHeightScale()
		local runSpeed = speedScaled / heightScale
	
		if runSpeed ~= currentAnimSpeed then
			if runSpeed < 0.33 then
				currentAnimTrack:AdjustWeight(1.0)		
				runAnimTrack:AdjustWeight(smallButNotZero)
			elseif runSpeed < 0.66 then
				local weight = ((runSpeed - 0.33) / 0.33)
				currentAnimTrack:AdjustWeight(1.0 - weight + smallButNotZero)
				runAnimTrack:AdjustWeight(weight + smallButNotZero)
			else
				currentAnimTrack:AdjustWeight(smallButNotZero)
				runAnimTrack:AdjustWeight(1.0)
			end
			currentAnimSpeed = runSpeed
			runAnimTrack:AdjustSpeed(runSpeed)
			currentAnimTrack:AdjustSpeed(runSpeed)
		end	
	end
	
	function setAnimationSpeed(speed)
		if currentAnim == "walk" then
				setRunSpeed(speed)
		else
			if speed ~= currentAnimSpeed then
				currentAnimSpeed = speed
				currentAnimTrack:AdjustSpeed(currentAnimSpeed)
			end
		end
	end
	
	function keyFrameReachedFunc(frameName)
		if (frameName == "End") then
			if currentAnim == "walk" then
				if userNoUpdateOnLoop == true then
					if runAnimTrack.Looped ~= true then
						runAnimTrack.TimePosition = 0.0
					end
					if currentAnimTrack.Looped ~= true then
						currentAnimTrack.TimePosition = 0.0
					end
				else
					runAnimTrack.TimePosition = 0.0
					currentAnimTrack.TimePosition = 0.0
				end
			else
				local repeatAnim = currentAnim
				-- return to idle if finishing an emote
				if (emoteNames[repeatAnim] ~= nil and emoteNames[repeatAnim] == false) then
					repeatAnim = "idle"
				end
				
				if FFlagAnimateScriptEmoteHook and currentlyPlayingEmote then
					if currentAnimTrack.Looped then
						-- Allow the emote to loop
						return
					end
					
					repeatAnim = "idle"
					currentlyPlayingEmote = false
				end
				
				local animSpeed = currentAnimSpeed
				playAnimation(repeatAnim, 0.15, Humanoid)
				setAnimationSpeed(animSpeed)
			end
		end
	end
	
	function rollAnimation(animName)
		local roll = math.random(1, animTable[animName].totalWeight) 
		local origRoll = roll
		local idx = 1
		while (roll > animTable[animName][idx].weight) do
			roll = roll - animTable[animName][idx].weight
			idx = idx + 1
		end
		return idx
	end
	
	local function switchToAnim(anim, animName, transitionTime, humanoid)
		-- switch animation		
		if (anim ~= currentAnimInstance) then
			
			if (currentAnimTrack ~= nil) then
				currentAnimTrack:Stop(transitionTime)
				currentAnimTrack:Destroy()
			end
	
			if (runAnimTrack ~= nil) then
				runAnimTrack:Stop(transitionTime)
				runAnimTrack:Destroy()
				if userNoUpdateOnLoop == true then
					runAnimTrack = nil
				end
			end
	
			currentAnimSpeed = 1.0
		
			-- load it to the humanoid; get AnimationTrack
			currentAnimTrack = humanoid:LoadAnimation(anim)
			currentAnimTrack.Priority = Enum.AnimationPriority.Core
			 
			-- play the animation
			currentAnimTrack:Play(transitionTime)
			currentAnim = animName
			currentAnimInstance = anim
	
			-- set up keyframe name triggers
			if (currentAnimKeyframeHandler ~= nil) then
				currentAnimKeyframeHandler:disconnect()
			end
			currentAnimKeyframeHandler = currentAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)
			
			-- check to see if we need to blend a walk/run animation
			if animName == "walk" then
				local runAnimName = "run"
				local runIdx = rollAnimation(runAnimName)
	
				runAnimTrack = humanoid:LoadAnimation(animTable[runAnimName][runIdx].anim)
				runAnimTrack.Priority = Enum.AnimationPriority.Core
				runAnimTrack:Play(transitionTime)		
				
				if (runAnimKeyframeHandler ~= nil) then
					runAnimKeyframeHandler:disconnect()
				end
				runAnimKeyframeHandler = runAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)	
			end
		end
	end
	
	function playAnimation(animName, transitionTime, humanoid) 	
		local idx = rollAnimation(animName)
		local anim = animTable[animName][idx].anim
	
		switchToAnim(anim, animName, transitionTime, humanoid)
		currentlyPlayingEmote = false
	end
	
	function playEmote(emoteAnim, transitionTime, humanoid)
		switchToAnim(emoteAnim, emoteAnim.Name, transitionTime, humanoid)
		currentlyPlayingEmote = true
	end
	
	-------------------------------------------------------------------------------------------
	-------------------------------------------------------------------------------------------
	
	local toolAnimName = ""
	local toolAnimTrack = nil
	local toolAnimInstance = nil
	local currentToolAnimKeyframeHandler = nil
	
	function toolKeyFrameReachedFunc(frameName)
		if (frameName == "End") then
			playToolAnimation(toolAnimName, 0.0, Humanoid)
		end
	end
	
	
	function playToolAnimation(animName, transitionTime, humanoid, priority)	 		
			local idx = rollAnimation(animName)
			local anim = animTable[animName][idx].anim
	
			if (toolAnimInstance ~= anim) then
				
				if (toolAnimTrack ~= nil) then
					toolAnimTrack:Stop()
					toolAnimTrack:Destroy()
					transitionTime = 0
				end
						
				-- load it to the humanoid; get AnimationTrack
				toolAnimTrack = humanoid:LoadAnimation(anim)
				if priority then
					toolAnimTrack.Priority = priority
				end
				 
				-- play the animation
				toolAnimTrack:Play(transitionTime)
				toolAnimName = animName
				toolAnimInstance = anim
	
				currentToolAnimKeyframeHandler = toolAnimTrack.KeyframeReached:connect(toolKeyFrameReachedFunc)
			end
	end
	
	function stopToolAnimations()
		local oldAnim = toolAnimName
	
		if (currentToolAnimKeyframeHandler ~= nil) then
			currentToolAnimKeyframeHandler:disconnect()
		end
	
		toolAnimName = ""
		toolAnimInstance = nil
		if (toolAnimTrack ~= nil) then
			toolAnimTrack:Stop()
			toolAnimTrack:Destroy()
			toolAnimTrack = nil
		end
	
		return oldAnim
	end
	
	-------------------------------------------------------------------------------------------
	-------------------------------------------------------------------------------------------
	-- STATE CHANGE HANDLERS
	
	function onRunning(speed)
		if speed > 0.75 then
			local scale = 16.0
			playAnimation("walk", 0.2, Humanoid)
			setAnimationSpeed(speed / scale)
			pose = "Running"
		else
			if emoteNames[currentAnim] == nil and not currentlyPlayingEmote then
				playAnimation("idle", 0.2, Humanoid)
				pose = "Standing"
			end
		end
	end
	
	function onDied()
		pose = "Dead"
	end
	
	function onJumping()
		playAnimation("jump", 0.1, Humanoid)
		jumpAnimTime = jumpAnimDuration
		pose = "Jumping"
	end
	
	function onClimbing(speed)
		local scale = 5.0
		playAnimation("climb", 0.1, Humanoid)
		setAnimationSpeed(speed / scale)
		pose = "Climbing"
	end
	
	function onGettingUp()
		pose = "GettingUp"
	end
	
	function onFreeFall()
		if (jumpAnimTime <= 0) then
			playAnimation("fall", fallTransitionTime, Humanoid)
		end
		pose = "FreeFall"
	end
	
	function onFallingDown()
		pose = "FallingDown"
	end
	
	function onSeated()
		pose = "Seated"
	end
	
	function onPlatformStanding()
		pose = "PlatformStanding"
	end
	
	-------------------------------------------------------------------------------------------
	-------------------------------------------------------------------------------------------
	
	function onSwimming(speed)
		if speed > 1.00 then
			local scale = 10.0
			playAnimation("swim", 0.4, Humanoid)
			setAnimationSpeed(speed / scale)
			pose = "Swimming"
		else
			playAnimation("swimidle", 0.4, Humanoid)
			pose = "Standing"
		end
	end
	
	function animateTool()
		if (toolAnim == "None") then
			playToolAnimation("toolnone", toolTransitionTime, Humanoid, Enum.AnimationPriority.Idle)
			return
		end
	
		if (toolAnim == "Slash") then
			playToolAnimation("toolslash", 0, Humanoid, Enum.AnimationPriority.Action)
			return
		end
	
		if (toolAnim == "Lunge") then
			playToolAnimation("toollunge", 0, Humanoid, Enum.AnimationPriority.Action)
			return
		end
	end
	
	function getToolAnim(tool)
		for _, c in ipairs(tool:GetChildren()) do
			if c.Name == "toolanim" and c.className == "StringValue" then
				return c
			end
		end
		return nil
	end
	
	local lastTick = 0
	
	function stepAnimate(currentTime)
		local amplitude = 1
		local frequency = 1
	  	local deltaTime = currentTime - lastTick
	  	lastTick = currentTime
	
		local climbFudge = 0
		local setAngles = false
	
	  	if (jumpAnimTime > 0) then
	  		jumpAnimTime = jumpAnimTime - deltaTime
	  	end
	
		if (pose == "FreeFall" and jumpAnimTime <= 0) then
			playAnimation("fall", fallTransitionTime, Humanoid)
		elseif (pose == "Seated") then
			playAnimation("sit", 0.5, Humanoid)
			return
		elseif (pose == "Running") then
			playAnimation("walk", 0.2, Humanoid)
		elseif (pose == "Dead" or pose == "GettingUp" or pose == "FallingDown" or pose == "Seated" or pose == "PlatformStanding") then
			stopAllAnimations()
			amplitude = 0.1
			frequency = 1
			setAngles = true
		end
	
		-- Tool Animation handling
		local tool = Character:FindFirstChildOfClass("Tool")
		if tool and tool:FindFirstChild("Handle") then
			local animStringValueObject = getToolAnim(tool)
	
			if animStringValueObject then
				toolAnim = animStringValueObject.Value
				-- message recieved, delete StringValue
				animStringValueObject.Parent = nil
				toolAnimTime = currentTime + .3
			end
	
			if currentTime > toolAnimTime then
				toolAnimTime = 0
				toolAnim = "None"
			end
	
			animateTool()		
		else
			stopToolAnimations()
			toolAnim = "None"
			toolAnimInstance = nil
			toolAnimTime = 0
		end
	end
	
	-- connect events
	
	local events = {}
	local eventHum = Humanoid
	
	local function onUnhook()
		for i = 1, #events do
			events[i]:Disconnect()
		end
		events = {}
	end
	
	local function onHook()
		onUnhook()
		
		pose = eventHum.Sit and "Seated" or "Standing"
		
		events = {
			eventHum.Died:connect(onDied),
			eventHum.Running:connect(onRunning),
			eventHum.Jumping:connect(onJumping),
			eventHum.Climbing:connect(onClimbing),
			eventHum.GettingUp:connect(onGettingUp),
			eventHum.FreeFalling:connect(onFreeFall),
			eventHum.FallingDown:connect(onFallingDown),
			eventHum.Seated:connect(onSeated),
			eventHum.PlatformStanding:connect(onPlatformStanding),
			eventHum.Swimming:connect(onSwimming)
		}
	end
	
	
	onHook()
	
	-- setup emote chat hook
	game:GetService("Players").LocalPlayer.Chatted:connect(function(msg)
		local emote = ""
		if (string.sub(msg, 1, 3) == "/e ") then
			emote = string.sub(msg, 4)
		elseif (string.sub(msg, 1, 7) == "/emote ") then
			emote = string.sub(msg, 8)
		end
		
		if (pose == "Standing" and emoteNames[emote] ~= nil) then
			playAnimation(emote, EMOTE_TRANSITION_TIME, Humanoid)
		end
	end)
	
	--[[ emote bindable hook
	if FFlagAnimateScriptEmoteHook then
		script:WaitForChild("PlayEmote").OnInvoke = function(emote)
			-- Only play emotes when idling
			if pose ~= "Standing" then
				return
			end
			if emoteNames[emote] ~= nil then
				-- Default emotes
				playAnimation(emote, EMOTE_TRANSITION_TIME, Humanoid)
				return true
			elseif typeof(emote) == "Instance" and emote:IsA("Animation") then
				-- Non-default emotes
				playEmote(emote, EMOTE_TRANSITION_TIME, Humanoid)
				return true
			end
			-- Return false to indicate that the emote could not be played
			return false
		end
	end
	]]
	-- initialize to idle
	playAnimation("idle", 0.1, Humanoid)
	pose = "Standing"
	-- loop to handle timed state transitions and tool animations
	spawn(function()
		while Character.Parent ~= nil do
			local _, currentGameTime = wait(0.1)
			stepAnimate(currentGameTime)
		end
	end)
	return {
		onRunning = onRunning, 
		onDied = onDied, 
		onJumping = onJumping, 
		onClimbing = onClimbing, 
		onGettingUp = onGettingUp, 
		onFreeFall = onFreeFall, 
		onFallingDown = onFallingDown, 
		onSeated = onSeated, 
		onPlatformStanding = onPlatformStanding,
		onHook = onHook,
		onUnhook = onUnhook
	}
	end
	return r15()
end
while true do
	wait(.1)
	if plr.Character ~= nil then
		char = plr.Character
		break
	end
end
function _Controller()
	local humanoid = char:WaitForChild("Humanoid")
	local animFuncs = {}
	if (humanoid.RigType == Enum.HumanoidRigType.R6) then
		animFuncs = _R6()
	else
		animFuncs = _R15()
	end
	print("Animation succes")
	return animFuncs
end
function _AnimationHandler()
local AnimationHandler = {}
AnimationHandler.__index = AnimationHandler

function AnimationHandler.new(humanoid, animate)
	local self = setmetatable({}, AnimationHandler)
	
	self._AnimFuncs = _Controller()
	self.Humanoid = humanoid
	
	return self
end

function AnimationHandler:EnableDefault(bool)
	if (bool) then
		self._AnimFuncs.onHook()
	else
		self._AnimFuncs.onUnhook()
	end
end

function AnimationHandler:Run(name, ...)
	self._AnimFuncs[name](...)
end

return AnimationHandler
end

function _GravityController()

local ZERO = Vector3.new(0, 0, 0)
local UNIT_X = Vector3.new(1, 0, 0)
local UNIT_Y = Vector3.new(0, 1, 0)
local UNIT_Z = Vector3.new(0, 0, 1)
local VEC_XY = Vector3.new(1, 0, 1)

local IDENTITYCF = CFrame.new()

local JUMPMODIFIER = 1.2
local TRANSITION = 0.15
local WALKF = 200 / 3

local UIS = game:GetService("UserInputService")
local RUNSERVICE = game:GetService("RunService")

local InitObjects = _InitObjects()
local AnimationHandler = _AnimationHandler()
local StateTracker = _StateTracker()

-- Class

local GravityController = {}
GravityController.__index = GravityController

-- Private Functions

local function getRotationBetween(u, v, axis)
	local dot, uxv = u:Dot(v), u:Cross(v)
	if (dot < -0.99999) then return CFrame.fromAxisAngle(axis, math.pi) end
	return CFrame.new(0, 0, 0, uxv.x, uxv.y, uxv.z, 1 + dot)
end

local function lookAt(pos, forward, up)
	local r = forward:Cross(up)
	local u = r:Cross(forward)
	return CFrame.fromMatrix(pos, r.Unit, u.Unit)
end

local function getMass(array)
	local mass = 0
	for _, part in next, array do
		if (part:IsA("BasePart")) then
			mass = mass + part:GetMass()
		end
	end
	return mass
	end

-- Public Constructor
local ExecutedPlayerModule = _PlayerModule()
local ExecutedSounds = _sounds()
	function GravityController.new(player)
	local self = setmetatable({}, GravityController)

	--[[ Camera
	local loaded = player.PlayerScripts:WaitForChild("PlayerScriptsLoader"):WaitForChild("Loaded")
	if (not loaded.Value) then
		--loaded.Changed:Wait()
	end
	]]
	local playerModule = ExecutedPlayerModule
	self.Controls = playerModule:GetControls()
	self.Camera = playerModule:GetCameras()
	
	-- Player and character
	self.Player = player
	self.Character = player.Character
	self.Humanoid = player.Character:WaitForChild("Humanoid")
	self.HRP = player.Character:WaitForChild("HumanoidRootPart")
	
	-- Animation
	self.AnimationHandler = AnimationHandler.new(self.Humanoid, self.Character:WaitForChild("Animate"))
	self.AnimationHandler:EnableDefault(false)
	local ssss = game:GetService("Players").LocalPlayer.PlayerScripts:FindFirstChild("SetState") or Instance.new("BindableEvent",game:GetService("Players").LocalPlayer.PlayerScripts)
	local soundState = ExecutedSounds
	ssss.Name = "SetState"
	
	self.StateTracker = StateTracker.new(self.Humanoid, soundState)
	self.StateTracker.Changed:Connect(function(name, speed)
		self.AnimationHandler:Run(name, speed)
	end)
	
	-- Collider and forces
	local collider, gyro, vForce, floor = InitObjects(self)
	
	floor.Touched:Connect(function() end)
	collider.Touched:Connect(function() end)
	
	self.Collider = collider
	self.VForce = vForce
	self.Gyro = gyro
	self.Floor = floor
	
	-- Attachment to parts
	self.LastPart = workspace.Terrain
	self.LastPartCFrame = IDENTITYCF
	
	-- Gravity properties
	self.GravityUp = UNIT_Y
	self.Ignores = {self.Character}
	
	function self.Camera.GetUpVector(this, oldUpVector)
		return self.GravityUp
	end
	
	-- Events etc
	self.Humanoid.PlatformStand = true
	
	self.CharacterMass = getMass(self.Character:GetDescendants())
	self.Character.AncestryChanged:Connect(function() self.CharacterMass = getMass(self.Character:GetDescendants()) end)
	
	self.JumpCon = RUNSERVICE.RenderStepped:Connect(function(dt) 
		if (self.Controls:IsJumping()) then
			self:OnJumpRequest()
		end
	end)
	
	self.DeathCon = self.Humanoid.Died:Connect(function() self:Destroy() end)
	self.SeatCon = self.Humanoid.Seated:Connect(function(active) if (active) then self:Destroy() end end)
	self.HeartCon = RUNSERVICE.Heartbeat:Connect(function(dt) self:OnHeartbeatStep(dt) end)
	RUNSERVICE:BindToRenderStep("GravityStep", Enum.RenderPriority.Input.Value + 1, function(dt) self:OnGravityStep(dt) end)
	
	
	return self
	end

-- Public Methods

	function GravityController:Destroy()
	self.JumpCon:Disconnect()
	self.DeathCon:Disconnect()
	self.SeatCon:Disconnect()
	self.HeartCon:Disconnect()
	
	RUNSERVICE:UnbindFromRenderStep("GravityStep")
	
	self.Collider:Destroy()
	self.VForce:Destroy()
	self.Gyro:Destroy()
	self.StateTracker:Destroy()
	
	self.Humanoid.PlatformStand = false
	self.AnimationHandler:EnableDefault(true)
	
	self.GravityUp = UNIT_Y
	end

	function GravityController:GetGravityUp(oldGravity)
	return oldGravity
	end

	function GravityController:IsGrounded(isJumpCheck)
	if (not isJumpCheck) then
		local parts = self.Floor:GetTouchingParts()
		for _, part in next, parts do
			if (not part:IsDescendantOf(self.Character)) then
				return true
			end
		end
	else
		if (self.StateTracker.Jumped) then
			return false
		end
	
		-- 1. check we are touching something with the collider
		local valid = {}
		local parts = self.Collider:GetTouchingParts()
		for _, part in next, parts do
			if (not part:IsDescendantOf(self.Character)) then
				table.insert(valid, part)
			end
		end
		
		if (#valid > 0) then
			-- 2. do a decently long downwards raycast
			local max = math.cos(self.Humanoid.MaxSlopeAngle)
			local ray = Ray.new(self.Collider.Position, -10 * self.GravityUp)
			local hit, pos, normal = workspace:FindPartOnRayWithWhitelist(ray, valid, true)
			
			-- 3. use slope to decide on jump
			if (hit and max <= self.GravityUp:Dot(normal)) then
				return true
			end
		end
	end
	return false
	end

	function GravityController:OnJumpRequest()
	if (not self.StateTracker.Jumped and self:IsGrounded(true)) then
		local hrpVel = self.HRP.Velocity
		self.HRP.Velocity = hrpVel + self.GravityUp*self.Humanoid.JumpPower*JUMPMODIFIER
		self.StateTracker:RequestedJump()
	end
	end

	function GravityController:GetMoveVector()
	return self.Controls:GetMoveVector()
	end

	function GravityController:OnHeartbeatStep(dt)
	local ray = Ray.new(self.Collider.Position, -1.1*self.GravityUp)
	local hit, pos, normal = workspace:FindPartOnRayWithIgnoreList(ray, self.Ignores)
	local lastPart = self.LastPart
	
	if (hit and lastPart and lastPart == hit) then
		local offset = self.LastPartCFrame:ToObjectSpace(self.HRP.CFrame)
		self.HRP.CFrame = hit.CFrame:ToWorldSpace(offset)
	end
	
	self.LastPart = hit
	self.LastPartCFrame = hit and hit.CFrame
	end

	function GravityController:OnGravityStep(dt)
	-- update gravity up vector
	local oldGravity = self.GravityUp
	local newGravity = self:GetGravityUp(oldGravity)
	
	local rotation = getRotationBetween(oldGravity, newGravity, workspace.CurrentCamera.CFrame.RightVector)
	rotation = IDENTITYCF:Lerp(rotation, TRANSITION)
	
	self.GravityUp = rotation * oldGravity
	
	-- get world move vector
	local camCF = workspace.CurrentCamera.CFrame
	local fDot = camCF.LookVector:Dot(newGravity)
	local cForward = math.abs(fDot) > 0.5 and -math.sign(fDot)*camCF.UpVector or camCF.LookVector
	
	local left = cForward:Cross(-newGravity).Unit
	local forward = -left:Cross(newGravity).Unit
	
	local move = self:GetMoveVector()
	local worldMove = forward*move.z - left*move.x
	worldMove = worldMove:Dot(worldMove) > 1 and worldMove.Unit or worldMove
	
	local isInputMoving = worldMove:Dot(worldMove) > 0
	
	-- get the desired character cframe
	local hrpCFLook = self.HRP.CFrame.LookVector
	local charF = hrpCFLook:Dot(forward)*forward + hrpCFLook:Dot(left)*left
	local charR = charF:Cross(newGravity).Unit
	local newCharCF = CFrame.fromMatrix(ZERO, charR, newGravity, -charF)
	
	local newCharRotation = IDENTITYCF
	if (isInputMoving) then
		newCharRotation = IDENTITYCF:Lerp(getRotationBetween(charF, worldMove, newGravity), 0.7)	
	end
	
	-- calculate forces
	local g = workspace.Gravity
	local gForce = g * self.CharacterMass * (UNIT_Y - newGravity)
	
	local cVelocity = self.HRP.Velocity
	local tVelocity = self.Humanoid.WalkSpeed * worldMove
	local gVelocity = cVelocity:Dot(newGravity)*newGravity
	local hVelocity = cVelocity - gVelocity
	
	if (hVelocity:Dot(hVelocity) < 1) then
		hVelocity = ZERO
	end
	
	local dVelocity = tVelocity - hVelocity
	local walkForceM = math.min(10000, WALKF * self.CharacterMass * dVelocity.Magnitude / (dt*60))
	local walkForce = walkForceM > 0 and dVelocity.Unit*walkForceM or ZERO
	
	-- mouse lock
	local charRotation = newCharRotation * newCharCF
	
	if (self.Camera:IsCamRelative()) then
		local lv = workspace.CurrentCamera.CFrame.LookVector
		local hlv = lv - charRotation.UpVector:Dot(lv)*charRotation.UpVector
		charRotation = lookAt(ZERO, hlv, charRotation.UpVector)
	end
	
	-- get state
	self.StateTracker:OnStep(self.GravityUp, self:IsGrounded(), isInputMoving)

	-- update values
	self.VForce.Force = walkForce + gForce
	self.Gyro.CFrame = charRotation
	end
	return GravityController
	end
	function _Draw3D()
	local module = {}
	
	-- Style Guide
	
	module.StyleGuide = {
		Point = {
			Thickness = 0.5;
			Color = Color3.new(0, 1, 0);
		},
		
		Line = {
			Thickness = 0.1;
			Color = Color3.new(1, 1, 0);
		},
		
		Ray = {
			Thickness = 0.1;
			Color = Color3.new(1, 0, 1);
		},
		
		Triangle = {
			Thickness = 0.05;
		};
		
		CFrame = {
			Thickness = 0.1;
			RightColor3 = Color3.new(1, 0, 0);
			UpColor3 = Color3.new(0, 1, 0);
			BackColor3 = Color3.new(0, 0, 1);
			PartProperties = {
				Material = Enum.Material.SmoothPlastic;
			};
		}
	}
	
	-- CONSTANTS
	
	local WEDGE = Instance.new("WedgePart")
	WEDGE.Material = Enum.Material.SmoothPlastic
	WEDGE.Anchored = true
	WEDGE.CanCollide = false
	
	local PART = Instance.new("Part")
	PART.Size = Vector3.new(0.1, 0.1, 0.1)
	PART.Anchored = true
	PART.CanCollide = false
	PART.TopSurface = Enum.SurfaceType.Smooth
	PART.BottomSurface = Enum.SurfaceType.Smooth
	PART.Material = Enum.Material.SmoothPlastic
	
	-- Functions
	
	local function draw(properties, style)
		local part = PART:Clone()
		for k, v in next, properties do
			part[k] = v
		end
		if (style) then
			for k, v in next, style do
				if (k ~= "Thickness") then
					part[k] = v
				end
			end
		end
		return part
	end
	
	function module.Draw(parent, properties)
		properties.Parent = parent
		return draw(properties, nil)
	end
	
	function module.Point(parent, cf_v3)
		local thickness = module.StyleGuide.Point.Thickness
		return draw({
			Size = Vector3.new(thickness, thickness, thickness);
			CFrame = (typeof(cf_v3) == "CFrame" and cf_v3 or CFrame.new(cf_v3));
			Parent = parent;
		}, module.StyleGuide.Point)
	end
	
	function module.Line(parent, a, b)
		local thickness = module.StyleGuide.Line.Thickness
		return draw({
			CFrame = CFrame.new((a + b)/2, b);
			Size = Vector3.new(thickness, thickness, (b - a).Magnitude);
			Parent = parent;
		}, module.StyleGuide.Line)
	end
	
	function module.Ray(parent, origin, direction)
		local thickness = module.StyleGuide.Ray.Thickness
		return draw({
			CFrame = CFrame.new(origin + direction/2, origin + direction);
			Size = Vector3.new(thickness, thickness, direction.Magnitude);
			Parent = parent;
		}, module.StyleGuide.Ray)
	end
	
	function module.Triangle(parent, a, b, c)
		local ab, ac, bc = b - a, c - a, c - b
		local abd, acd, bcd = ab:Dot(ab), ac:Dot(ac), bc:Dot(bc)
		
		if (abd > acd and abd > bcd) then
			c, a = a, c
		elseif (acd > bcd and acd > abd) then
			a, b = b, a
		end
		
		ab, ac, bc = b - a, c - a, c - b
		
		local right = ac:Cross(ab).Unit
		local up = bc:Cross(right).Unit
		local back = bc.Unit
		
		local height = math.abs(ab:Dot(up))
		local width1 = math.abs(ab:Dot(back))
		local width2 = math.abs(ac:Dot(back))
		
		local thickness = module.StyleGuide.Triangle.Thickness
		
		local w1 = WEDGE:Clone()
		w1.Size = Vector3.new(thickness, height, width1)
		w1.CFrame = CFrame.fromMatrix((a + b)/2, right, up, back)
		w1.Parent = parent
		
		local w2 = WEDGE:Clone()
		w2.Size = Vector3.new(thickness, height, width2)
		w2.CFrame = CFrame.fromMatrix((a + c)/2, -right, up, -back)
		w2.Parent = parent
		
		for k, v in next, module.StyleGuide.Triangle do
			if (k ~= "Thickness") then
				w1[k] = v
				w2[k] = v
			end
		end
		
		return w1, w2
	end
	
	function module.CFrame(parent, cf)
		local origin = cf.Position
		local r = cf.RightVector
		local u = cf.UpVector
		local b = -cf.LookVector
		
		local thickness = module.StyleGuide.CFrame.Thickness
		
		local right = draw({
			CFrame = CFrame.new(origin + r/2, origin + r);
			Size = Vector3.new(thickness, thickness, r.Magnitude);
			Color = module.StyleGuide.CFrame.RightColor3;
			Parent = parent;
		}, module.StyleGuide.CFrame.PartProperties)
		
		local up = draw({
			CFrame = CFrame.new(origin + u/2, origin + u);
			Size = Vector3.new(thickness, thickness, r.Magnitude);
			Color = module.StyleGuide.CFrame.UpColor3;
			Parent = parent;
		}, module.StyleGuide.CFrame.PartProperties)
		
		local back = draw({
			CFrame = CFrame.new(origin + b/2, origin + b);
			Size = Vector3.new(thickness, thickness, u.Magnitude);
			Color = module.StyleGuide.CFrame.BackColor3;
			Parent = parent;
		}, module.StyleGuide.CFrame.PartProperties)
		
		return right, up, back
	end
	
	-- Return
	
	return module
	end
	function _Draw2D()
	local module = {}
	
	-- Style Guide
	
	module.StyleGuide = {
		Point = {
			BorderSizePixel = 0;
			Size = UDim2.new(0, 4, 0, 4);
			BorderColor3 = Color3.new(0, 0, 0);
			BackgroundColor3 = Color3.new(0, 1, 0);
		},
		
		Line = {
			Thickness = 1;
			BorderSizePixel = 0;
			BorderColor3 = Color3.new(0, 0, 0);
			BackgroundColor3 = Color3.new(0, 1, 0);
		},
		
		Ray = {
			Thickness = 1;
			BorderSizePixel = 0;
			BorderColor3 = Color3.new(0, 0, 0);
			BackgroundColor3 = Color3.new(0, 1, 0);
		},
		
		Triangle = {
			ImageTransparency = 0;
			ImageColor3 = Color3.new(0, 1, 0);
		}
	}
	
	-- CONSTANTS
	
	local HALF = Vector2.new(0.5, 0.5)
	
	local RIGHT = "rbxassetid://2798177521"
	local LEFT = "rbxassetid://2798177955"
	
	local IMG = Instance.new("ImageLabel")
	IMG.BackgroundTransparency = 1
	IMG.AnchorPoint = HALF
	IMG.BorderSizePixel = 0
	
	local FRAME = Instance.new("Frame")
	FRAME.BorderSizePixel = 0
	FRAME.Size = UDim2.new(0, 0, 0, 0)
	FRAME.BackgroundColor3 = Color3.new(1, 1, 1)
	
	-- Functions
	
	function draw(properties, style)
		local frame = FRAME:Clone()
		for k, v in next, properties do
			frame[k] = v
		end
		if (style) then
			for k, v in next, style do
				if (k ~= "Thickness") then
					frame[k] = v
				end
			end
		end
		return frame
	end
	
	function module.Draw(parent, properties)
		properties.Parent = parent
		return draw(properties, nil)
	end
	
	function module.Point(parent, v2)
		return draw({
			AnchorPoint = HALF;
			Position = UDim2.new(0, v2.x, 0, v2.y);
			Parent = parent;
		}, module.StyleGuide.Point)
	end
	
	function module.Line(parent, a, b)
		local v = (b - a)
		local m = (a + b)/2
		
		return draw({
			AnchorPoint = HALF;
			Position = UDim2.new(0, m.x, 0, m.y);
			Size = UDim2.new(0, module.StyleGuide.Line.Thickness, 0, v.magnitude);
			Rotation = math.deg(math.atan2(v.y, v.x)) - 90;
			BackgroundColor3 = Color3.new(1, 1, 0);
			Parent = parent;
		}, module.StyleGuide.Line)
	end
	
	function module.Ray(parent, origin, direction)
		local a, b = origin, origin + direction
		local v = (b - a)
		local m = (a + b)/2
		
		return draw({
			AnchorPoint = HALF;
			Position = UDim2.new(0, m.x, 0, m.y);
			Size = UDim2.new(0, module.StyleGuide.Ray.Thickness, 0, v.magnitude);
			Rotation = math.deg(math.atan2(v.y, v.x)) - 90;
			Parent = parent;
		}, module.StyleGuide.Ray)
	end
	
	function module.Triangle(parent, a, b, c)
		local ab, ac, bc = b - a, c - a, c - b
		local abd, acd, bcd = ab:Dot(ab), ac:Dot(ac), bc:Dot(bc)
		
		if (abd > acd and abd > bcd) then
			c, a = a, c
		elseif (acd > bcd and acd > abd) then
			a, b = b, a
		end
		
		ab, ac, bc = b - a, c - a, c - b
		
		local unit = bc.unit
		local height = unit:Cross(ab)
		local flip = (height >= 0)
		local theta = math.deg(math.atan2(unit.y, unit.x)) + (flip and 0 or 180)
		
		local m1 = (a + b)/2
		local m2 = (a + c)/2
		
		local w1 = IMG:Clone()
		w1.Image = flip and RIGHT or LEFT
		w1.AnchorPoint = HALF
		w1.Size = UDim2.new(0, math.abs(unit:Dot(ab)), 0, height)
		w1.Position = UDim2.new(0, m1.x, 0, m1.y)
		w1.Rotation = theta
		w1.Parent = parent
		
		local w2 = IMG:Clone()
		w2.Image = flip and LEFT or RIGHT
		w2.AnchorPoint = HALF
		w2.Size = UDim2.new(0, math.abs(unit:Dot(ac)), 0, height)
		w2.Position = UDim2.new(0, m2.x, 0, m2.y)
		w2.Rotation = theta
		w2.Parent = parent
		
		for k, v in next, module.StyleGuide.Triangle do
			w1[k] = v
			w2[k] = v
		end
		
		return w1, w2
	end
	
	-- Return
	
	return module
	end
	function _DrawClass()
	local Draw2DModule = _Draw2D()
	local Draw3DModule = _Draw3D()
	
	--
	
	local DrawClass = {}
	local DrawClassStorage = setmetatable({}, {__mode = "k"})
	DrawClass.__index = DrawClass
	
	function DrawClass.new(parent)
		local self = setmetatable({}, DrawClass)
		
		self.Parent = parent
		DrawClassStorage[self] = {}
		
		self.Draw3D = {}
		for key, func in next, Draw3DModule do
			self.Draw3D[key] = function(...)
				local returns = {func(self.Parent, ...)}
				for i = 1, #returns do
					table.insert(DrawClassStorage[self], returns[i])
				end
				return unpack(returns)
			end
		end
		
		self.Draw2D = {}
		for key, func in next, Draw2DModule do
			self.Draw2D[key] = function(...)
				local returns = {func(self.Parent, ...)}
				for i = 1, #returns do
					table.insert(DrawClassStorage[self], returns[i])
				end
				return unpack(returns)
			end
		end
		
		return self
	end
	
	--
	
	function DrawClass:Clear()
		local t = DrawClassStorage[self]
		while (#t > 0) do
			local part = table.remove(t)
			if (part) then
				part:Destroy()
			end
		end
		DrawClassStorage[self] = {}
	end
	
	--
	
	return DrawClass
	end


--END TEST

local PLAYERS = game:GetService("Players")

local GravityController = _GravityController()
local Controller = GravityController.new(PLAYERS.LocalPlayer)

local DrawClass = _DrawClass()

local PI2 = math.pi*2
local ZERO = Vector3.new(0, 0, 0)

local LOWER_RADIUS_OFFSET = 3 
local NUM_DOWN_RAYS = 24
local ODD_DOWN_RAY_START_RADIUS = 3	
local EVEN_DOWN_RAY_START_RADIUS = 2
local ODD_DOWN_RAY_END_RADIUS = 1.66666
local EVEN_DOWN_RAY_END_RADIUS = 1

local NUM_FEELER_RAYS = 9
local FEELER_LENGTH = 2
local FEELER_START_OFFSET = 2
local FEELER_RADIUS = 3.5
local FEELER_APEX_OFFSET = 1
local FEELER_WEIGHTING = 8

	function GetGravityUp(self, oldGravityUp)
	local ignoreList = {}
	for i, player in next, PLAYERS:GetPlayers() do
		ignoreList[i] = player.Character
	end
	
	-- get the normal
	
	local hrpCF = self.HRP.CFrame
	local isR15 = (self.Humanoid.RigType == Enum.HumanoidRigType.R15)
	
	local origin = isR15 and hrpCF.p or hrpCF.p + 0.35*oldGravityUp
	local radialVector = math.abs(hrpCF.LookVector:Dot(oldGravityUp)) < 0.999 and hrpCF.LookVector:Cross(oldGravityUp) or hrpCF.RightVector:Cross(oldGravityUp)
	
	local centerRayLength = 25
	local centerRay = Ray.new(origin, -centerRayLength * oldGravityUp)
	local centerHit, centerHitPoint, centerHitNormal = workspace:FindPartOnRayWithIgnoreList(centerRay, ignoreList)
	
	--[[disable
	DrawClass:Clear()
	DrawClass.Draw3D.Ray(centerRay.Origin, centerRay.Direction)
	]]
	local downHitCount = 0
	local totalHitCount = 0
	local centerRayHitCount = 0
	local evenRayHitCount = 0
	local oddRayHitCount = 0
	
	local mainDownNormal = ZERO
	if (centerHit) then
		mainDownNormal = centerHitNormal
		centerRayHitCount = 0
	end
	
	local downRaySum = ZERO
	for i = 1, NUM_DOWN_RAYS do
		local dtheta = PI2 * ((i-1)/NUM_DOWN_RAYS)
		
		local angleWeight = 0.25 + 0.75 * math.abs(math.cos(dtheta))
		local isEvenRay = (i%2 == 0)
		local startRadius = isEvenRay and EVEN_DOWN_RAY_START_RADIUS or ODD_DOWN_RAY_START_RADIUS	
		local endRadius = isEvenRay and EVEN_DOWN_RAY_END_RADIUS or ODD_DOWN_RAY_END_RADIUS
		local downRayLength = centerRayLength
		
		local offset = CFrame.fromAxisAngle(oldGravityUp, dtheta) * radialVector
		local dir = (LOWER_RADIUS_OFFSET * -oldGravityUp + (endRadius - startRadius) * offset)
		local ray = Ray.new(origin + startRadius * offset, downRayLength * dir.unit)
		local hit, hitPoint, hitNormal = workspace:FindPartOnRayWithIgnoreList(ray, ignoreList)
		--[[disable
		DrawClass.Draw3D.Ray(ray.Origin, ray.Direction)
		]]
		if (hit) then
			downRaySum = downRaySum + angleWeight * hitNormal
			downHitCount = downHitCount + 1
			if isEvenRay then
				evenRayHitCount = evenRayHitCount + 1					
			else
				oddRayHitCount = oddRayHitCount + 1
			end
		end
	end
	
	local feelerHitCount = 0	
	local feelerNormalSum = ZERO
	
	for i = 1, NUM_FEELER_RAYS do
		local dtheta = 2 * math.pi * ((i-1)/NUM_FEELER_RAYS)
		local angleWeight =  0.25 + 0.75 * math.abs(math.cos(dtheta))	
		local offset = CFrame.fromAxisAngle(oldGravityUp, dtheta) * radialVector
		local dir = (FEELER_RADIUS * offset + LOWER_RADIUS_OFFSET * -oldGravityUp).unit
		local feelerOrigin = origin - FEELER_APEX_OFFSET * -oldGravityUp + FEELER_START_OFFSET * dir
		local ray = Ray.new(feelerOrigin, FEELER_LENGTH * dir)
		local hit, hitPoint, hitNormal = workspace:FindPartOnRayWithIgnoreList(ray, ignoreList)
		--[[disable
		DrawClass.Draw3D.Ray(ray.Origin, ray.Direction)
		]]
		if (hit) then
			feelerNormalSum = feelerNormalSum + FEELER_WEIGHTING * angleWeight * hitNormal --* hitDistSqInv
			feelerHitCount = feelerHitCount + 1
		end
	end
	
	if (centerRayHitCount + downHitCount + feelerHitCount > 0) then
		local normalSum = mainDownNormal + downRaySum + feelerNormalSum
		if (normalSum ~= ZERO) then
			return normalSum.unit
		end
	end
	
	return oldGravityUp
	end

	Controller.GetGravityUp = GetGravityUp

-- E is toggle
	game:GetService("ContextActionService"):BindAction("Toggle", function(action, state, input)
	if not (state == Enum.UserInputState.Begin) then
		return
	end
	
	if (Controller) then
		Controller:Destroy()
		Controller = nil
	else
		Controller = GravityController.new(PLAYERS.LocalPlayer)
		Controller.GetGravityUp = GetGravityUp
	end
	end, false, Enum.KeyCode.Z)

			game.StarterGui:SetCore("SendNotification", {
				Title = "Gravity Controller Enable";
				Text = "Press Z to toggle";
			})
		end
		if cmd == "ws" then
		game.StarterGui:SetCore("SendNotification", {
				Title = "Warning";
				Text = "Make sure the value is in Value Box";
			})

			game.Players.LocalPlayer.Character.Humanoid.WalkSpeed = ValueBox_2.Text -- studio solution -- normal value is 16
		end
		if cmd == "jp" then
		game.StarterGui:SetCore("SendNotification", {
				Title = "Warning";
				Text = "Make sure the value is in Value Box";
			})

			game.Players.LocalPlayer.Character.Humanoid.JumpPower = ValueBox_2.Text -- studio solution -- normal value is 50
		end
		if cmd == "skeletonesp" then
		game.StarterGui:SetCore("SendNotification", {
			Title = "Warning";
			Text = "Only work who is R6 and doesn't work with everyone";
			})
			_7QrHvlX2NvWQTEtp, Protected_by_MoonSecV2, Discord = 'discord.gg/gQEH2uZxUk'


			,nil,nil;(function() _msec=(function(_,__,_l)local __l__l=__[(-#'balls in ur jawz'+(94-0x3e))];local _ll__l=_l[_[(647+-#{'}',{};192;(function()return{','}end)(),1,'}'})]][_[((-22+0x2f8)+-#[[boy what the hell boy]])]];local _l___=(100-0x60)/(0x1fc/((-101+(71+-0x31))+0x14d))local __l_l=(-0x56+(((420090/0xc9)/0x16)+-#[[trolled]]))-(55+-0x36)local ___lll=_l[_[(-#"this file was obfuscated manually"+(425-0xfe))]][_[(-#[[can i put my balls if your jaws]]+(38962/0x79))]];local ___l_=((-#'free_lua_deobfuscator.hacker.com'+(-76+(-0x61+352)))/0x93)+(0x81-127)local _ll_ll=_l[_[(565+-#{",";(function()return#{('kpHObP'):find("\72")}>0 and 1 or 0 end);",";'}';'nil',(function()return{','}end)()})]][_[(-#"This file has been enchanted with uncrackable V, fuck the fuck off"+((-124+0x13596)/82))]]local _ll=(-#'moonsec top'+(1989/0x99))-(54-(((0x1184+-61)+-#'Why are you reading this')/0x53))local _l_ll=((-6-(-#[[are you maybe is the or the maybe is the or the maybe hm]]+(((-0x75+-6331)/0x3e)+179)))+0x1c)local _l_l=((-0x21de/(0x138-(0x1e4-274)))+0x58)local _llll=(-0x58+(0x2e36/((-52+(-#{93,{},93,(function()return{','}end)()}+193))+-#'im gay?')))local __ll=((513-(-#[[Federal is godly]]+((0xbaf9f0/162)/244)))/73)local __l_=((-#'chrome sex me'+(((0x13+-114)+-0x5)+0x128))/0x3d)local ____=(702/(((-#'load = dump (sukssesful deobfuskation)'+(0x6c640/8))/0x1)/0xed))local _ll_=(101-(-#[[Shouldve been the fbi bot]]+(0x11d-((488+-0x2c)-0x11b))))local __lll=(-0x3d+(66+-#{",",'}','nil'}))local ___l=(-#{118,(function()return#{('boPKBP'):find("\80")}>0 and 1 or 0 end),'}'}+5)local _lll=(-#"Nah the only nerve you can hit is a data breach and source leak"+(((-25+(214+-#{{},{};1,167}))+-#[[porn]])+-116))local _l__=(-#'Okay guys federal can notice you just stab a fork into your ass, write .gg/moonsec on your feet, and DONT send it to federal'+(0x14a-(((-#'You know math? sqrt(-2) * sqrt(-32) = ??'+(0x9142b+-83))/243)/0xc)))local ___=(6+-#{'nil','}',{},'nil'})local __l__=(0x344/((0xcd609/(-#"deez nuts"+(0x11c-160)))/0x23))local _l__l=(((28592+-#{(function()return#{('HbPMmp'):find("\80")}>0 and 1 or 0 end);(function()return#{('HbPMmp'):find("\80")}>0 and 1 or 0 end),109})/0xfd)-0x6d)local _l_l_=(-#'You know c#? What does << operator do?'+(190-(355-(214+-#{",";1,31,",",'}';90;'}'}))))local _ll__=((0xfc-(-#{'nil',(function()return{','}end)();(function()return#{('bHmBOl'):find("\109")}>0 and 1 or 0 end);(function()return{','}end)();1,153,(function()return#{('bHmBOl'):find("\109")}>0 and 1 or 0 end)}+155))/26)local _lll_=(-#[[You burned a minor!?!?]]+(((((-0x108b6c+542123)/141)+-#'One day ill make the onions cry')/0x22)+0x8c))local __ll_=(0x23+(((-#{",",(function()return{','}end)(),(function()return{','}end)(),32,(function()return#{('hmfmPh'):find("\102")}>0 and 1 or 0 end)}+40)+-0x3c)+-#[[it7ucd]]))local _l_l_l=_[(0xa7d-1366)];local _lll_l=_l[_[(-0x5e+232)]][_[(-#{{},'}',(function()return{','}end)(),(function()return{','}end)(),(function()return{','}end)()}+420)]];local __ll_l=_l[(function(_)return type(_):sub(1,1)..'\101\116'end)('')..'\109\101'..('\116\97'or'').._[(-#'<@761654159095103499> <@761654159095103499> <@761654159095103499> <@761654159095103499> <@761654159095103499>'+(1449-0x30d))]];local ____l=_l[_[(-#[[moonsec source leak]]+(-0x2e+624))]][_[(921+-#{(function()return#{('hBLKkl'):find("\76")}>0 and 1 or 0 end),{};'}'})]];local __llll=(236/0x76)-(-#[[This script was obfuscated by Herttfuscator]]+((0x290d+(-0x918/97))/233))local _lllll=((6984/(-#'I am only 13 shut the fuck up'+(-68+0xa9)))+-95)-(100-0x62)local _l__ll=_l[_[(339-0xc9)]][_[(0x3e04/49)]];local _l_=function(_,_l)return _.._l end local _l_lll=(-#'someone play kogama with perth please hes so lonely'+(0xab-116))*((-#[[Who is Joe?]]+(-122+(284+-0x41)))+-0x52)local ____ll=_l[_[((-0x58+1303)+-#[[turn around and dont you think about coming back here]])]];local ___ll=(0x1d2/233)*(((0x276-(0x321-459))+-#'psu more like psshit hahahaha laugh at my joke everyone')+-0x69)local __l_ll=(0x15c00/87)*(-#'moonsec pls add fivem choice'+(164-(0x125-((15486/0x59)+-#[[Join LD 2 nerds]]))))local ___l_l=(((2940192/(-0x50+326))+-#[[<@!847154787934011462> shut the fuck up@skid]])/229)local _____=((6660/(106+(0x6f+-127)))+-#"is it me or everyones feeling like ghostpinging <@!519139355118534656> ?")*(0x12+-16)local _ll_l=_l[_[(1030+-#{(function()return{','}end)(),55,108})]]or _l[_[((11016/0x12)+-#'turn around and dont you think about coming back here')]][_[(1030+-#{(function()return{','}end)(),55,108})]];local __l=(((-#[[me waiting for a memestring that isnt about sex or someone being a pedo]]+(-0x66+(1944-0x3ff)))-426)+-#'This file has been enchanted with uncrackable V, fuck the fuck off')local _=_l[_[(-#{'}',(function()return{','}end)(),'nil';'}';{},'}'}+1244)]];local _ll_ll=(function(_l_)local ___,__=2,0x10 local _l={j={},v={}}local __l=-_ll local _=__+__l_l while true do _l[_l_:sub(_,(function()_=___+_ return _-__l_l end)())]=(function()__l=__l+_ll return __l end)()if __l==(_l_lll-_ll)then __l=""__=__llll break end end local __l=#_l_ while _<__l+__l_l do _l.v[__]=_l_:sub(_,(function()_=___+_ return _-__l_l end)())__=__+_ll if __%_l___==__llll then __=_lllll ____l(_l.j,(_l__ll((_l[_l.v[_lllll]]*_l_lll)+_l[_l.v[_ll]])))end end return _ll_ll(_l.j)end)("..:::MoonSec::..");local ____l=(50-0x2a)local __=71 local _l=_ll;local _={}_={[(0x3d-60)]=function()local _ll,_,_l_,___=___lll(_ll_ll,_l,_l+___l_);_l=_l+_____;__=(__+(____l*_____))%__l;return(((___+__-(____l)+___ll*(_____*_l___))%___ll)*((_l___*__l_ll)^_l___))+(((_l_+__-(____l*_l___)+___ll*(_l___^___l_))%__l)*(___ll*__l))+(((_+__-(____l*___l_)+__l_ll)%__l)*___ll)+((_ll+__-(____l*_____)+__l_ll)%__l);end,[(97-0x5f)]=function(_,_,_)local _=___lll(_ll_ll,_l,_l);_l=_l+__l_l;__=(__+(____l))%__l;return((_+__-(____l)+__l_ll)%___ll);end,[(309/0x67)]=function()local _ll,_=___lll(_ll_ll,_l,_l+_l___);__=(__+(____l*_l___))%__l;_l=_l+_l___;return(((_+__-(____l)+___ll*(_l___*_____))%___ll)*__l)+((_ll+__-(____l*_l___)+__l*(_l___^___l_))%___ll);end,[(-#'Use a condom kids'+(4179/0xc7))]=function(_l,_,__)if __ then local _=(_l/_l___^(_-_ll))%_l___^((__-__l_l)-(_-_ll)+__l_l);return _-_%_ll;else local _=_l___^(_-__l_l);return(_l%(_+_)>=_)and _ll or _lllll;end;end,[(-#'i love perth'+(((0x207ec/55)+-#"Oh so you know C++? What does sizeof(int) equal to? (gcc)")/0x8b))]=function()local _l=_[(0xb7/183)]();local __=_[(-107+0x6c)]();local ___=_ll;local _l_=(_[((-0xf15/39)+0x67)](__,__l_l,_l_lll+_____)*(_l___^(_l_lll*_l___)))+_l;local _l=_[(38+-0x22)](__,21,31);local _=((-_ll)^_[(93-0x59)](__,32));if(_l==_lllll)then if(_l_==__llll)then return _*_lllll;else _l=__l_l;___=__llll;end;elseif(_l==(___ll*(_l___^___l_))-__l_l)then return(_l_==_lllll)and(_*(__l_l/__llll))or(_*(_lllll/__llll));end;return _ll__l(_,_l-((__l*(_____))-_ll))*(___+(_l_/(_l___^___l_l)));end,[(34+-0x1c)]=function(_l_,___,___)local ___;if(not _l_)then _l_=_[(0x96/150)]();if(_l_==_lllll)then return'';end;end;___=_lll_l(_ll_ll,_l,_l+_l_-_ll);_l=_l+_l_;local _=''for _l=__l_l,#___ do _=_l_l_l(_,_l__ll((___lll(_lll_l(___,_l,_l))+__)%__l))__=(__+____l)%___ll end return _;end}local function _lllll(...)return{...},____ll('#',...)end local function _lll_l()local __ll={};local _l_={};local _l={};local _lll={__ll,_l_,nil,_l};local __={}local _ll_=(216+-0x7d)local __l={[(0x24c/147)]=(function(_l)return not(#_l==_[(-#'HEY NO FAIR'+(-0x22+47))]())end),[(12/0x6)]=(function(_l)return _[(0x451/221)]()end),[(0x69-104)]=(function(_l)return _[(-#[[This script has been obfuscated using your mom]]+(185-0x85))]()end),[((2106/0x75)+-#"stfu and paint cat")]=(function(_l)local _ll=_[((0x80-105)+-#[[One Shot Was Here]])]()local _l=''local _=1 for __=1,#_ll do _=(_+_ll_)%__l _l=_l_l_l(_l,_l__ll((___lll(_ll:sub(__,__))+_)%___ll))end return _l end)};local _l=_[((227+-0x1a)/0xc9)]()for _l=1,_l do local _=_[(33-0x1f)]();local _ll;local _=__l[_%(0x5d8/88)];__[_l]=_ and _({});end;for _lll=1,_[(0x3/3)]()do local _l=_[(0x1e+-28)]();if(_[((96-(0x18b/5))+-#[[bit.bdiv(0,0)]])](_l,_ll,__l_l)==__llll)then local _ll_=_[(-#[[Roblox is written in assembly you dingus]]+(-0x5d+137))](_l,_l___,___l_);local __l=_[(0x1e4/121)](_l,_____,_l___+_____);local _l={_[(-#'shithub verified'+(0x76-99))](),_[(-#[[i love perth]]+(50-0x23))](),nil,nil};local _l_={[(58-0x3a)]=function()_l[_l_l]=_[(0x57/29)]();_l[__ll_]=_[(0x4c-73)]();end,[(-0x25+38)]=function()_l[_llll]=_[(159/(0x1a2-259))]();end,[(346/0xad)]=function()_l[____]=_[((506/0x2e)+-#[[dump = nil]])]()-(_l___^_l_lll)end,[(42-0x27)]=function()_l[_llll]=_[(0x1f-30)]()-(_l___^_l_lll)_l[__l__]=_[(61-0x3a)]();end};_l_[_ll_]();if(_[(-0x6b+(164+-0x35))](__l,__l_l,_ll)==__l_l)then _l[___l]=__[_l[___]]end if(_[(0x64+-96)](__l,_l___,_l___)==_ll)then _l[_l_ll]=__[_l[_llll]]end if(_[((210-(0x32eb/79))+-#"press this check button below the message")](__l,___l_,___l_)==__l_l)then _l[_l__l]=__[_l[_ll__]]end __ll[_lll]=_l;end end;for _=__l_l,_[(93-0x5c)]()do _l_[_-__l_l]=_lll_l();end;_lll[3]=_[((162-0x8f)+-#"JayZone Likes Men")]();return _lll;end;local function _l_lll(_,____l,___ll)local _l=_[_l___];local ___l_=_[___l_];local __l=_[_ll];return(function(...)local _=_ll _*=-1 local _____=_;local __llll=_lllll local ___lll=_l;local _l__ll={};local __={};local _lllll={};local _ll_ll={...};local _l=_ll;local __l=__l;local __l_ll=____ll('#',...)-__l_l;local ___l_=___l_;for _=0,__l_ll do if(_>=___l_)then _l__ll[_-___l_]=_ll_ll[_+__l_l];else __[_]=_ll_ll[_+_ll];end;end;local _=__l_ll-___l_+_ll local _;local ___l_;while true do _=__l[_l];___l_=_[(0x7b/123)];_l_=(2820510)while ___l_<=(189-0x76)do _l_-= _l_ _l_=(1939086)while((0x21f2/(-47+0x9d))+-#"fucking fuck fuck fucks fucker fucking fucka")>=___l_ do _l_-= _l_ _l_=(1458432)while ___l_<=(0x4d+-60)do _l_-= _l_ _l_=(8537550)while(0x768/237)>=___l_ do _l_-= _l_ _l_=(8203437)while ___l_<=(85-0x52)do _l_-= _l_ _l_=(1790880)while(19-(1368/0x4c))>=___l_ do _l_-= _l_ _l_=(833228)while ___l_>(0/0xdb)do _l_-= _l_ local _=_[_l__]__[_](__[_+__l_l])break end while 1276==(_l_)/((0x2b9+-44))do local _l_;local __ll_;__[_[_ll_]]=__[_[_llll]][_[_l__l]];_l=_l+_ll;_=__l[_l];__ll_={_,__};__ll_[_l___][__ll_[__l_l][_lll]]=__ll_[_l___][__ll_[_ll][__ll]]+__ll_[__l_l][_lll_];_l=_l+_ll;_=__l[_l];_l_=_[___]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[____]))_l=_l+_ll;_=__l[_l];__[_[__lll]][_[__l_]]=__[_[_ll__]];_l=_l+_ll;_=__l[_l];__[_[_lll]]=____l[_[_l_ll]];_l=_l+_ll;_=__l[_l];__[_[_l__]][_[__l_]]=_[_l__l];_l=_l+_ll;_=__l[_l];__[_[___]]=____l[_[__ll]];_l=_l+_ll;_=__l[_l];__[_[___]]=___ll[_[_llll]];_l=_l+_ll;_=__l[_l];__[_[___]]=__[_[_llll]][_[_lll_]];_l=_l+_ll;_=__l[_l];__[_[_lll]]=__[_[____]][_[__l__]];_l=_l+_ll;_=__l[_l];__[_[_lll]]=__[_[_llll]][_[_l__l]];_l=_l+_ll;_=__l[_l];_l_=_[__lll]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[__ll]))_l=_l+_ll;_=__l[_l];__[_[_lll]][_[_l_ll]]=__[_[_l__l]];_l=_l+_ll;_=__l[_l];__[_[___l]]=____l[_[_l_l]];_l=_l+_ll;_=__l[_l];__[_[__lll]]=___ll[_[_llll]];_l=_l+_ll;_=__l[_l];__[_[__lll]]=__[_[__l_]][_[_lll_]];_l=_l+_ll;_=__l[_l];__[_[___]]=__[_[_llll]][_[_lll_]];_l=_l+_ll;_=__l[_l];__[_[___]]=__[_[__ll]][_[__l__]];_l=_l+_ll;_=__l[_l];__ll_={_,__};__ll_[_l___][__ll_[__l_l][_ll_]]=__ll_[_l___][__ll_[_ll][_l_l]]+__ll_[__l_l][_l__l];_l=_l+_ll;_=__l[_l];_l_=_[_l__]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[_l_ll]))_l=_l+_ll;_=__l[_l];__[_[_lll]][_[_l_ll]]=__[_[_l_l_]];_l=_l+_ll;_=__l[_l];_l=_[__l_];break end;break;end while 1040==(_l_)/((-0x2a+((0x28068/92)+-#"stfu and paint cat")))do _l_=(1240170)while((46-0x26)+-#[[it7ucd]])<___l_ do _l_-= _l_ __[_[___]]=_[_l_l];break end while(_l_)/((0x2cd-382))==3702 do local ___l_;local _____;local _l___;local _l_;_l_=_[_lll];_l___=__[_[_l_l]];__[_l_+1]=_l___;__[_l_]=_l___[_[_lll_]];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=__[_[_l_l]][_[_l__l]];_l=_l+_ll;_=__l[_l];__[_[_lll]]=__[_[_l_ll]][_[_ll__]];_l=_l+_ll;_=__l[_l];__[_[___]]=__[_[_llll]][_[_l_l_]];_l=_l+_ll;_=__l[_l];_l_=_[___]_____={__[_l_](_ll_l(__,_l_+1,_[__l_]))};___l_=0;for _=_l_,_[__ll_]do ___l_=___l_+_ll;__[_]=_____[___l_];end _l=_l+_ll;_=__l[_l];__[_[_lll]]=____l[_[_l_l]];_l=_l+_ll;_=__l[_l];_l_=_[_ll_];_l___=__[_[____]];__[_l_+1]=_l___;__[_l_]=_l___[_[__l__]];_l=_l+_ll;_=__l[_l];__[_[___l]]=__[_[_llll]][_[_lll_]];_l=_l+_ll;_=__l[_l];__[_[___]]=__[_[__l_]][_[_l__l]];_l=_l+_ll;_=__l[_l];__[_[___]]=__[_[_l_l]][_[__ll_]];_l=_l+_ll;_=__l[_l];_l_=_[___]_____={__[_l_](_ll_l(__,_l_+1,_[_l_l]))};___l_=0;for _=_l_,_[_lll_]do ___l_=___l_+_ll;__[_]=_____[___l_];end _l=_l+_ll;_=__l[_l];__[_[___]]=____l[_[_llll]];_l=_l+_ll;_=__l[_l];_l_=_[_lll];_l___=__[_[__l_]];__[_l_+1]=_l___;__[_l_]=_l___[_[_l_l_]];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=__[_[_l_ll]][_[__ll_]];_l=_l+_ll;_=__l[_l];__[_[_lll]]=___ll[_[_llll]];_l=_l+_ll;_=__l[_l];__[_[_l__]]=_[__l_];_l=_l+_ll;_=__l[_l];__[_[___]]=_[_l_ll];_l=_l+_ll;_=__l[_l];__[_[___]]=_[_l_l];_l=_l+_ll;_=__l[_l];_l_=_[___l]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[__l_]))_l=_l+_ll;_=__l[_l];__[_[___l]]=__[_[__l_]][__[_[__ll_]]];_l=_l+_ll;_=__l[_l];__[_[___l]]=__[_[_l_ll]][_[__l__]];_l=_l+_ll;_=__l[_l];_l_=_[___l]_____={__[_l_](_ll_l(__,_l_+1,_[__ll]))};___l_=0;for _=_l_,_[_l_l_]do ___l_=___l_+_ll;__[_]=_____[___l_];end _l=_l+_ll;_=__l[_l];__[_[__lll]]=____l[_[_l_l]];_l=_l+_ll;_=__l[_l];_l_=_[_lll];_l___=__[_[_l_l]];__[_l_+1]=_l___;__[_l_]=_l___[_[_ll__]];_l=_l+_ll;_=__l[_l];__[_[___l]]=__[_[_l_l]][_[__l__]];_l=_l+_ll;_=__l[_l];__[_[___l]]=___ll[_[_llll]];_l=_l+_ll;_=__l[_l];__[_[___]]=_[_l_l];_l=_l+_ll;_=__l[_l];__[_[___]]=_[_l_l];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=_[_l_l];_l=_l+_ll;_=__l[_l];_l_=_[__lll]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[_llll]))_l=_l+_ll;_=__l[_l];__[_[__lll]]=__[_[__l_]][__[_[__l__]]];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=__[_[____]][_[__ll_]];_l=_l+_ll;_=__l[_l];_l_=_[__lll]_____={__[_l_](_ll_l(__,_l_+1,_[__l_]))};___l_=0;for _=_l_,_[_lll_]do ___l_=___l_+_ll;__[_]=_____[___l_];end _l=_l+_ll;_=__l[_l];__[_[_lll]]=____l[_[__l_]];_l=_l+_ll;_=__l[_l];_l_=_[___];_l___=__[_[____]];__[_l_+1]=_l___;__[_l_]=_l___[_[__l__]];_l=_l+_ll;_=__l[_l];__[_[___]]=__[_[_l_ll]][_[_l_l_]];_l=_l+_ll;_=__l[_l];__[_[___]]=___ll[_[__ll]];_l=_l+_ll;_=__l[_l];__[_[___]]=_[__l_];_l=_l+_ll;_=__l[_l];__[_[_l__]]=_[____];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=_[_l_l];_l=_l+_ll;_=__l[_l];_l_=_[___l]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[__ll]))_l=_l+_ll;_=__l[_l];__[_[_ll_]]=__[_[____]][__[_[_l__l]]];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=__[_[_l_l]][_[_l_l_]];_l=_l+_ll;_=__l[_l];_l_=_[_l__]_____={__[_l_](_ll_l(__,_l_+1,_[_l_ll]))};___l_=0;for _=_l_,_[_lll_]do ___l_=___l_+_ll;__[_]=_____[___l_];end _l=_l+_ll;_=__l[_l];__[_[___]]=____l[_[_llll]];_l=_l+_ll;_=__l[_l];_l_=_[___];_l___=__[_[__l_]];__[_l_+1]=_l___;__[_l_]=_l___[_[_ll__]];_l=_l+_ll;_=__l[_l];__[_[___l]]=__[_[__ll]][_[_ll__]];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=___ll[_[____]];_l=_l+_ll;_=__l[_l];__[_[_l__]]=_[____];_l=_l+_ll;_=__l[_l];__[_[___]]=_[_llll];_l=_l+_ll;_=__l[_l];__[_[___l]]=_[__l_];_l=_l+_ll;_=__l[_l];_l_=_[___l]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[__ll]))_l=_l+_ll;_=__l[_l];__[_[___]]=__[_[____]][__[_[_ll__]]];_l=_l+_ll;_=__l[_l];__[_[__lll]]=__[_[____]][_[_ll__]];_l=_l+_ll;_=__l[_l];_l_=_[___]_____={__[_l_](_ll_l(__,_l_+1,_[__l_]))};___l_=0;for _=_l_,_[_ll__]do ___l_=___l_+_ll;__[_]=_____[___l_];end _l=_l+_ll;_=__l[_l];__[_[_l__]]=___ll[_[__l_]];_l=_l+_ll;_=__l[_l];__[_[___]]=__[_[__ll]][_[_l__l]];_l=_l+_ll;_=__l[_l];__[_[_l__]]=___ll[_[__ll]];_l=_l+_ll;_=__l[_l];__[_[_l__]]=_[_llll];_l=_l+_ll;_=__l[_l];__[_[__lll]]=_[__ll];_l=_l+_ll;_=__l[_l];__[_[__lll]]=_[____];_l=_l+_ll;_=__l[_l];_l_=_[___l]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[_l_ll]))_l=_l+_ll;_=__l[_l];_l_=_[___]__[_l_]=__[_l_](__[_l_+__l_l])_l=_l+_ll;_=__l[_l];__[_[__lll]][_[__ll]]=_[_ll__];_l=_l+_ll;_=__l[_l];__[_[_lll]]=___ll[_[____]];_l=_l+_ll;_=__l[_l];__[_[___l]]=__[_[_llll]][_[_l_l_]];_l=_l+_ll;_=__l[_l];__[_[_l__]]=__[_[_l_ll]][_[_lll_]];_l=_l+_ll;_=__l[_l];__[_[___l]][_[_llll]]=__[_[_l__l]];_l=_l+_ll;_=__l[_l];__[_[___l]][_[__l_]]=_[_l__l];_l=_l+_ll;_=__l[_l];__[_[_l__]]=___ll[_[__l_]];_l=_l+_ll;_=__l[_l];__[_[__lll]]=__[_[_llll]][_[__l__]];_l=_l+_ll;_=__l[_l];__[_[_l__]]=__[_[____]][_[_l_l_]];_l=_l+_ll;_=__l[_l];__[_[_lll]]=__[_[_l_ll]][_[__l__]];_l=_l+_ll;_=__l[_l];_l_=_[___]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[_l_ll]))_l=_l+_ll;_=__l[_l];__[_[___l]][_[_llll]]=__[_[_ll__]];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=___ll[_[_llll]];_l=_l+_ll;_=__l[_l];__[_[_l__]]=__[_[_l_l]][_[__ll_]];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=__[_[__ll]][_[_lll_]];_l=_l+_ll;_=__l[_l];__[_[__lll]]=__[_[__l_]][_[__l__]];_l=_l+_ll;_=__l[_l];_l_=_[_ll_]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[_l_l]))break end;break;end break;end while 2511==(_l_)/((0x34a46/66))do _l_=(15785107)while(400/0x50)>=___l_ do _l_-= _l_ _l_=(496508)while ___l_>(0x33c/207)do _l_-= _l_ local _l_;__[_[_l__]]=___ll[_[_llll]];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=__[_[_llll]][_[_lll_]];_l=_l+_ll;_=__l[_l];__[_[___]]=__[_[_l_l]][_[_lll_]];_l=_l+_ll;_=__l[_l];__[_[___l]]=__[_[_llll]][_[__ll_]];_l=_l+_ll;_=__l[_l];_l_=_[_l__]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[____]))_l=_l+_ll;_=__l[_l];__[_[_lll]][_[_l_ll]]=__[_[_l_l_]];_l=_l+_ll;_=__l[_l];__[_[_l__]]=____l[_[_llll]];_l=_l+_ll;_=__l[_l];__[_[_lll]]=___ll[_[_llll]];_l=_l+_ll;_=__l[_l];__[_[_lll]]=__[_[_l_ll]][_[__ll_]];_l=_l+_ll;_=__l[_l];__[_[__lll]]=__[_[____]][_[_l__l]];_l=_l+_ll;_=__l[_l];__[_[__lll]][_[_l_l]]=__[_[_lll_]];_l=_l+_ll;_=__l[_l];_l=_[__l_];break end while(_l_)/(((408+-0x69)+-#[[Federla is good at coding]]))==1786 do __[_[___l]][_[_l_l]]=_[_lll_];break end;break;end while(_l_)/((-#'are you maybe is the or the maybe is the or the maybe hm'+(0xfcc+-101)))==4061 do _l_=(4767141)while((-0x58+138)+-#"ok. how about constants that dump themselves")>=___l_ do _l_-= _l_ local __ll;local ___;local _l_;__[_[_ll_]]=_[_llll];_l=_l+_ll;_=__l[_l];__[_[_lll]]=_[_l_ll];_l=_l+_ll;_=__l[_l];__[_[___l]]=#__[_[_l_ll]];_l=_l+_ll;_=__l[_l];__[_[_lll]]=_[____];_l=_l+_ll;_=__l[_l];_l_=_[_l__];___=__[_l_]__ll=__[_l_+2];if(__ll>0)then if(___>__[_l_+1])then _l=_[____];else __[_l_+3]=___;end elseif(___<__[_l_+1])then _l=_[____];else __[_l_+3]=___;end break;end while 1357==(_l_)/((0x1bc4-3595))do _l_=(1849764)while(987/0x8d)<___l_ do _l_-= _l_ if(__[_[___]]==_[_ll__])then _l=_l+__l_l;else _l=_[____];end;break end while 1281==(_l_)/(((1613+-0x67)+-#"this message was written on the 4th of August, 2021 at 4:50 PM GMT"))do local _l_;__[_[___l]]={};_l=_l+_ll;_=__l[_l];__[_[_ll_]][_[_l_l]]=_[_l_l_];_l=_l+_ll;_=__l[_l];__[_[___]][_[__ll]]=_[_ll__];_l=_l+_ll;_=__l[_l];__[_[___]]=___ll[_[____]];_l=_l+_ll;_=__l[_l];__[_[__lll]]=__[_[_l_l]][_[__ll_]];_l=_l+_ll;_=__l[_l];__[_[___l]]=_[____];_l=_l+_ll;_=__l[_l];__[_[__lll]]=_[__l_];_l=_l+_ll;_=__l[_l];__[_[___l]]=_[_llll];_l=_l+_ll;_=__l[_l];_l_=_[_lll]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[__l_]))_l=_l+_ll;_=__l[_l];__[_[___]][_[____]]=__[_[_l_l_]];break end;break;end break;end break;end break;end while 3290==(_l_)/((5254-0xa63))do _l_=(10863075)while(0x26+-26)>=___l_ do _l_-= _l_ _l_=(6845880)while ___l_<=(-0x4b+85)do _l_-= _l_ _l_=(14026512)while ___l_>(36-0x1b)do _l_-= _l_ __[_[_l__]][_[_l_l]]=_[_lll_];_l=_l+_ll;_=__l[_l];__[_[_l__]]=____l[_[__l_]];_l=_l+_ll;_=__l[_l];__[_[___]][_[__ll]]=_[_ll__];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=____l[_[_l_l]];_l=_l+_ll;_=__l[_l];__[_[_l__]][_[_l_l]]=_[_ll__];_l=_l+_ll;_=__l[_l];__[_[___]]=____l[_[_l_l]];_l=_l+_ll;_=__l[_l];__[_[_l__]][_[_l_ll]]=_[__l__];_l=_l+_ll;_=__l[_l];__[_[_l__]]=____l[_[__ll]];_l=_l+_ll;_=__l[_l];__[_[___l]][_[_llll]]=_[__ll_];_l=_l+_ll;_=__l[_l];__[_[_lll]]=____l[_[__l_]];_l=_l+_ll;_=__l[_l];__[_[_lll]][_[_l_l]]=_[__ll_];_l=_l+_ll;_=__l[_l];__[_[___]]=____l[_[__l_]];_l=_l+_ll;_=__l[_l];__[_[_l__]][_[_llll]]=_[_lll_];_l=_l+_ll;_=__l[_l];__[_[___l]]=____l[_[_llll]];_l=_l+_ll;_=__l[_l];__[_[__lll]][_[_llll]]=_[__ll_];_l=_l+_ll;_=__l[_l];__[_[__lll]]=____l[_[__ll]];_l=_l+_ll;_=__l[_l];__[_[_l__]][_[_llll]]=_[_lll_];_l=_l+_ll;_=__l[_l];__[_[_l__]]=____l[_[_l_ll]];_l=_l+_ll;_=__l[_l];__[_[_lll]][_[____]]=_[_l_l_];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=____l[_[____]];_l=_l+_ll;_=__l[_l];__[_[___]][_[____]]=_[_l_l_];break end while 4003==(_l_)/((-#'while true do end'+((-107+0xcf31c)/241)))do local ___l_;local _____;local _l___;local _l_;_l_=_[_ll_];_l___=__[_[_llll]];__[_l_+1]=_l___;__[_l_]=_l___[_[_ll__]];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=____l[_[_llll]];_l=_l+_ll;_=__l[_l];__[_[__lll]]=__[_[__ll]][_[_l_l_]];_l=_l+_ll;_=__l[_l];__[_[_l__]]=__[_[_l_l]][_[__ll_]];_l=_l+_ll;_=__l[_l];__[_[_l__]]=__[_[_l_ll]][_[_l_l_]];_l=_l+_ll;_=__l[_l];_l_=_[___]_____={__[_l_](_ll_l(__,_l_+1,_[_llll]))};___l_=0;for _=_l_,_[_lll_]do ___l_=___l_+_ll;__[_]=_____[___l_];end _l=_l+_ll;_=__l[_l];__[_[_ll_]]=____l[_[_l_ll]];_l=_l+_ll;_=__l[_l];_l_=_[_ll_];_l___=__[_[__l_]];__[_l_+1]=_l___;__[_l_]=_l___[_[__ll_]];_l=_l+_ll;_=__l[_l];__[_[___l]]=____l[_[__l_]];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=__[_[____]][_[__ll_]];_l=_l+_ll;_=__l[_l];__[_[_l__]]=__[_[_llll]][_[_l__l]];_l=_l+_ll;_=__l[_l];__[_[___l]]=__[_[_l_ll]][_[__l__]];_l=_l+_ll;_=__l[_l];_l_=_[_l__]_____={__[_l_](_ll_l(__,_l_+1,_[____]))};___l_=0;for _=_l_,_[_l_l_]do ___l_=___l_+_ll;__[_]=_____[___l_];end _l=_l+_ll;_=__l[_l];__[_[_ll_]]=____l[_[_llll]];_l=_l+_ll;_=__l[_l];_l_=_[___l];_l___=__[_[_llll]];__[_l_+1]=_l___;__[_l_]=_l___[_[_lll_]];_l=_l+_ll;_=__l[_l];__[_[_lll]]=____l[_[_l_ll]];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=__[_[__ll]][_[__ll_]];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=___ll[_[_l_l]];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=_[__ll];_l=_l+_ll;_=__l[_l];__[_[___]]=_[____];_l=_l+_ll;_=__l[_l];__[_[__lll]]=_[____];_l=_l+_ll;_=__l[_l];_l_=_[___l]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[__ll]))_l=_l+_ll;_=__l[_l];__[_[___]]=__[_[_l_ll]][__[_[_l_l_]]];_l=_l+_ll;_=__l[_l];__[_[___]]=__[_[_l_ll]][_[__ll_]];_l=_l+_ll;_=__l[_l];_l_=_[___l]_____={__[_l_](_ll_l(__,_l_+1,_[__ll]))};___l_=0;for _=_l_,_[_lll_]do ___l_=___l_+_ll;__[_]=_____[___l_];end _l=_l+_ll;_=__l[_l];__[_[__lll]]=____l[_[____]];_l=_l+_ll;_=__l[_l];_l_=_[___l];_l___=__[_[__l_]];__[_l_+1]=_l___;__[_l_]=_l___[_[_lll_]];_l=_l+_ll;_=__l[_l];__[_[_l__]]=____l[_[__ll]];_l=_l+_ll;_=__l[_l];__[_[___l]]=__[_[_llll]][_[_ll__]];_l=_l+_ll;_=__l[_l];__[_[_lll]]=___ll[_[_l_l]];_l=_l+_ll;_=__l[_l];__[_[_lll]]=_[__ll];_l=_l+_ll;_=__l[_l];__[_[__lll]]=_[__l_];_l=_l+_ll;_=__l[_l];__[_[__lll]]=_[____];_l=_l+_ll;_=__l[_l];_l_=_[_l__]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[__ll]))_l=_l+_ll;_=__l[_l];__[_[_l__]]=__[_[__ll]][__[_[_lll_]]];_l=_l+_ll;_=__l[_l];__[_[__lll]]=__[_[_l_l]][_[__ll_]];_l=_l+_ll;_=__l[_l];_l_=_[_l__]_____={__[_l_](_ll_l(__,_l_+1,_[_llll]))};___l_=0;for _=_l_,_[__ll_]do ___l_=___l_+_ll;__[_]=_____[___l_];end _l=_l+_ll;_=__l[_l];__[_[___]]=____l[_[_l_ll]];_l=_l+_ll;_=__l[_l];_l_=_[_lll];_l___=__[_[_l_l]];__[_l_+1]=_l___;__[_l_]=_l___[_[__l__]];_l=_l+_ll;_=__l[_l];__[_[_lll]]=____l[_[_l_ll]];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=__[_[____]][_[__ll_]];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=___ll[_[_l_ll]];_l=_l+_ll;_=__l[_l];__[_[___l]]=_[_llll];_l=_l+_ll;_=__l[_l];__[_[___]]=_[_llll];_l=_l+_ll;_=__l[_l];__[_[_lll]]=_[__l_];_l=_l+_ll;_=__l[_l];_l_=_[___l]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[__ll]))_l=_l+_ll;_=__l[_l];__[_[__lll]]=__[_[__l_]][__[_[_ll__]]];_l=_l+_ll;_=__l[_l];__[_[_lll]]=__[_[_l_ll]][_[_lll_]];_l=_l+_ll;_=__l[_l];_l_=_[_l__]_____={__[_l_](_ll_l(__,_l_+1,_[____]))};___l_=0;for _=_l_,_[__ll_]do ___l_=___l_+_ll;__[_]=_____[___l_];end _l=_l+_ll;_=__l[_l];__[_[___]]=____l[_[_l_l]];_l=_l+_ll;_=__l[_l];_l_=_[_l__];_l___=__[_[____]];__[_l_+1]=_l___;__[_l_]=_l___[_[_l__l]];_l=_l+_ll;_=__l[_l];__[_[_l__]]=____l[_[__l_]];_l=_l+_ll;_=__l[_l];__[_[_l__]]=__[_[_l_ll]][_[_l_l_]];_l=_l+_ll;_=__l[_l];__[_[__lll]]=___ll[_[_llll]];_l=_l+_ll;_=__l[_l];__[_[__lll]]=_[_l_ll];_l=_l+_ll;_=__l[_l];__[_[___l]]=_[_l_ll];_l=_l+_ll;_=__l[_l];__[_[__lll]]=_[__ll];_l=_l+_ll;_=__l[_l];_l_=_[__lll]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[_l_ll]))_l=_l+_ll;_=__l[_l];__[_[_l__]]=__[_[__ll]][__[_[__ll_]]];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=__[_[__l_]][_[__l__]];_l=_l+_ll;_=__l[_l];_l_=_[_lll]_____={__[_l_](_ll_l(__,_l_+1,_[_l_l]))};___l_=0;for _=_l_,_[__l__]do ___l_=___l_+_ll;__[_]=_____[___l_];end _l=_l+_ll;_=__l[_l];if not __[_[_lll]]then _l=_l+__l_l;else _l=_[__ll];end;break end;break;end while(_l_)/((-#"perth vs memcorrupt boxing match"+(3334+-0x61)))==2136 do _l_=(9505989)while(-#'did you solve the lua challenge yet?'+(3102/0x42))<___l_ do _l_-= _l_ local __l_;local _llll;local _lll;local ____;local _ll_l;local _l_;___ll[_[_l_ll]]=__[_[___l]];_l=_l+_ll;_=__l[_l];__[_[___l]]=___ll[_[__ll]];_l=_l+_ll;_=__l[_l];__[_[_l__]]=__[_[_l_l]][_[__l__]];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=___ll[_[_l_ll]];_l=_l+_ll;_=__l[_l];_l_=_[__lll]__[_l_]=__[_l_](__[_l_+__l_l])_l=_l+_ll;_=__l[_l];__[_[___]]();_l=_l+_ll;_=__l[_l];_l_=_[___];_ll_l={};for _=1,#_lllll do ____=_lllll[_];for _=0,#____ do _lll=____[_];_llll=_lll[1];__l_=_lll[2];if _llll==__ and __l_>=_l_ then _ll_l[__l_]=_llll[__l_];_lll[1]=_ll_l;end;end;end;break end while(_l_)/((3089+-0x6e))==3191 do local _={_,__};_[_l___][_[__l_l][_ll_]]=_[_l___][_[_ll][_l_ll]]+_[__l_l][_lll_];break end;break;end break;end while 3005==(_l_)/((0x1cb4-3733))do _l_=(1920477)while((263-0xb7)+-#[[This file has been enchanted with uncrackable V, fuck the fuck off]])>=___l_ do _l_-= _l_ _l_=(3022407)while ___l_>(0x42-53)do _l_-= _l_ local _={__,_};_[_ll][_[_l___][_lll]]=_[_l___][_l_l_]+_[_l___][____];break end while(_l_)/((0x4b330/144))==1413 do local _l=_[_l__]__[_l]=__[_l](_ll_l(__,_l+_ll,_[____]))break end;break;end while(_l_)/((0x1122-2245))==897 do _l_=(1768125)while(155-0x8c)>=___l_ do _l_-= _l_ __[_[_lll]]={};break;end while 2829==(_l_)/((0x1d9a2/194))do _l_=(3749985)while ___l_>(-#[[string]]+(0x153a/247))do _l_-= _l_ local __ll;local _l_ll;local __lll;local _l__l;local _ll_l;local _l_;___ll[_[_l_l]]=__[_[_ll_]];_l=_l+_ll;_=__l[_l];__[_[_lll]]=___ll[_[____]];_l=_l+_ll;_=__l[_l];__[_[_l__]]=__[_[_llll]][_[_lll_]];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=___ll[_[__l_]];_l=_l+_ll;_=__l[_l];_l_=_[___]__[_l_]=__[_l_](__[_l_+__l_l])_l=_l+_ll;_=__l[_l];__[_[___l]]();_l=_l+_ll;_=__l[_l];_l_=_[___l];_ll_l={};for _=1,#_lllll do _l__l=_lllll[_];for _=0,#_l__l do __lll=_l__l[_];_l_ll=__lll[1];__ll=__lll[2];if _l_ll==__ and __ll>=_l_ then _ll_l[__ll]=_l_ll[__ll];__lll[1]=_ll_l;end;end;end;break end while(_l_)/(((-126+0xa75)+-#[[This script has been obfuscated using your mom]]))==1497 do local _={__,_};_[__l_l][_[_l___][_lll]]=_[_ll][_[_l___][__l__]]+_[__l_l][_[_l___][__l_]];break end;break;end break;end break;end break;end break;end while 1152==(_l_)/(((0xa2e-1328)+-#"loadstring()"))do _l_=(3093024)while(0x62-72)>=___l_ do _l_-= _l_ _l_=(12326988)while((157+-0x3e)+-#"Arse Bloody Bugger Cow Crap Damn Ginger Git God Goddam Jesus Christ Minger")>=___l_ do _l_-= _l_ _l_=(6778563)while(-101+0x78)>=___l_ do _l_-= _l_ _l_=(4440787)while((238-(-0x79+302))+-#"<@!847154787934011462> shut the fuck up")<___l_ do _l_-= _l_ local __l_l;local _l___;local ___l_;local _l_;_l_=_[___l];___l_=__[_[__l_]];__[_l_+1]=___l_;__[_l_]=___l_[_[_lll_]];_l=_l+_ll;_=__l[_l];__[_[___l]]=____l[_[__l_]];_l=_l+_ll;_=__l[_l];__[_[___l]]=__[_[__ll]][_[__ll_]];_l=_l+_ll;_=__l[_l];__[_[__lll]]=__[_[__ll]][_[_l__l]];_l=_l+_ll;_=__l[_l];__[_[___]]=__[_[____]][_[_l__l]];_l=_l+_ll;_=__l[_l];_l_=_[___l]_l___={__[_l_](_ll_l(__,_l_+1,_[_l_ll]))};__l_l=0;for _=_l_,_[_ll__]do __l_l=__l_l+_ll;__[_]=_l___[__l_l];end _l=_l+_ll;_=__l[_l];__[_[___]]=____l[_[_l_l]];_l=_l+_ll;_=__l[_l];_l_=_[_lll];___l_=__[_[____]];__[_l_+1]=___l_;__[_l_]=___l_[_[_l__l]];_l=_l+_ll;_=__l[_l];__[_[___l]]=____l[_[____]];_l=_l+_ll;_=__l[_l];__[_[_l__]]=__[_[_l_ll]][_[_l__l]];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=__[_[__ll]][_[_ll__]];_l=_l+_ll;_=__l[_l];__[_[___l]]=__[_[_l_ll]][_[_lll_]];_l=_l+_ll;_=__l[_l];_l_=_[___]_l___={__[_l_](_ll_l(__,_l_+1,_[_l_l]))};__l_l=0;for _=_l_,_[_lll_]do __l_l=__l_l+_ll;__[_]=_l___[__l_l];end _l=_l+_ll;_=__l[_l];__[_[___]]=____l[_[_llll]];_l=_l+_ll;_=__l[_l];_l_=_[___l];___l_=__[_[_llll]];__[_l_+1]=___l_;__[_l_]=___l_[_[__l__]];_l=_l+_ll;_=__l[_l];__[_[___]]=____l[_[_l_ll]];_l=_l+_ll;_=__l[_l];__[_[___]]=__[_[__l_]][_[__l__]];_l=_l+_ll;_=__l[_l];__[_[_l__]]=___ll[_[_llll]];_l=_l+_ll;_=__l[_l];__[_[___l]]=_[__l_];_l=_l+_ll;_=__l[_l];__[_[_l__]]=_[__ll];_l=_l+_ll;_=__l[_l];__[_[__lll]]=_[__ll];_l=_l+_ll;_=__l[_l];_l_=_[___l]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[____]))_l=_l+_ll;_=__l[_l];__[_[___]]=__[_[_llll]][__[_[_ll__]]];_l=_l+_ll;_=__l[_l];__[_[___]]=__[_[__l_]][_[_lll_]];_l=_l+_ll;_=__l[_l];_l_=_[_ll_]_l___={__[_l_](_ll_l(__,_l_+1,_[_l_l]))};__l_l=0;for _=_l_,_[__ll_]do __l_l=__l_l+_ll;__[_]=_l___[__l_l];end _l=_l+_ll;_=__l[_l];__[_[___l]]=____l[_[_llll]];_l=_l+_ll;_=__l[_l];_l_=_[_ll_];___l_=__[_[____]];__[_l_+1]=___l_;__[_l_]=___l_[_[_l_l_]];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=____l[_[__ll]];_l=_l+_ll;_=__l[_l];__[_[___l]]=__[_[__l_]][_[_l__l]];_l=_l+_ll;_=__l[_l];__[_[_l__]]=___ll[_[_l_l]];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=_[_l_l];_l=_l+_ll;_=__l[_l];__[_[__lll]]=_[_l_l];_l=_l+_ll;_=__l[_l];__[_[___]]=_[__l_];_l=_l+_ll;_=__l[_l];_l_=_[__lll]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[_l_l]))_l=_l+_ll;_=__l[_l];__[_[_l__]]=__[_[__ll]][__[_[_lll_]]];_l=_l+_ll;_=__l[_l];__[_[_lll]]=__[_[__ll]][_[_ll__]];_l=_l+_ll;_=__l[_l];_l_=_[_lll]_l___={__[_l_](_ll_l(__,_l_+1,_[__ll]))};__l_l=0;for _=_l_,_[__ll_]do __l_l=__l_l+_ll;__[_]=_l___[__l_l];end _l=_l+_ll;_=__l[_l];__[_[_lll]]=____l[_[_l_l]];_l=_l+_ll;_=__l[_l];_l_=_[___l];___l_=__[_[_llll]];__[_l_+1]=___l_;__[_l_]=___l_[_[_lll_]];_l=_l+_ll;_=__l[_l];__[_[__lll]]=____l[_[__ll]];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=__[_[_llll]][_[_ll__]];_l=_l+_ll;_=__l[_l];__[_[___l]]=___ll[_[_l_l]];_l=_l+_ll;_=__l[_l];__[_[__lll]]=_[____];_l=_l+_ll;_=__l[_l];__[_[_lll]]=_[____];_l=_l+_ll;_=__l[_l];__[_[_lll]]=_[_l_ll];_l=_l+_ll;_=__l[_l];_l_=_[_ll_]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[_l_ll]))_l=_l+_ll;_=__l[_l];__[_[___l]]=__[_[__ll]][__[_[_lll_]]];_l=_l+_ll;_=__l[_l];__[_[___l]]=__[_[__l_]][_[_l__l]];_l=_l+_ll;_=__l[_l];_l_=_[_lll]_l___={__[_l_](_ll_l(__,_l_+1,_[_l_l]))};__l_l=0;for _=_l_,_[_lll_]do __l_l=__l_l+_ll;__[_]=_l___[__l_l];end _l=_l+_ll;_=__l[_l];__[_[___l]]=____l[_[_l_l]];_l=_l+_ll;_=__l[_l];_l_=_[_ll_];___l_=__[_[_l_ll]];__[_l_+1]=___l_;__[_l_]=___l_[_[_l_l_]];_l=_l+_ll;_=__l[_l];__[_[___]]=____l[_[_llll]];_l=_l+_ll;_=__l[_l];__[_[_lll]]=__[_[____]][_[_lll_]];_l=_l+_ll;_=__l[_l];__[_[___l]]=___ll[_[__ll]];_l=_l+_ll;_=__l[_l];__[_[___]]=_[_llll];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=_[_l_ll];_l=_l+_ll;_=__l[_l];__[_[_l__]]=_[_l_l];_l=_l+_ll;_=__l[_l];_l_=_[___l]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[__ll]))_l=_l+_ll;_=__l[_l];__[_[_l__]]=__[_[_l_l]][__[_[__ll_]]];_l=_l+_ll;_=__l[_l];__[_[__lll]]=__[_[__ll]][_[_lll_]];_l=_l+_ll;_=__l[_l];_l_=_[_l__]_l___={__[_l_](_ll_l(__,_l_+1,_[_l_ll]))};__l_l=0;for _=_l_,_[_lll_]do __l_l=__l_l+_ll;__[_]=_l___[__l_l];end _l=_l+_ll;_=__l[_l];if __[_[_ll_]]then _l=_l+_ll;else _l=_[_llll];end;break end while(_l_)/((-#"Fun fact if you ping everyone in this channel you will ping everyone without having perms"+((1420896/0x6)/0x98)))==3023 do local _ll=_[___l];local _l=__[_[_l_l]];__[_ll+1]=_l;__[_ll]=_l[_[_ll__]];break end;break;end while(_l_)/((3136+(43+-0x58)))==2193 do _l_=(8097665)while(126-0x6a)<___l_ do _l_-= _l_ __[_[_l__]]=__[_[_llll]][__[_[__l__]]];break end while 2935==(_l_)/((0x15d3-2828))do local _ll=__[_[_l__l]];if not _ll then _l=_l+__l_l;else __[_[___]]=_ll;_l=_[_llll];end;break end;break;end break;end while 4071==(_l_)/((-#[[certified hood classif]]+(-0x76+3168)))do _l_=(609675)while(-#'Penis Sucking Utilities source leak lol!!'+(-55+0x77))>=___l_ do _l_-= _l_ _l_=(1059881)while((0xd1-147)+-#[[nice executor bro. 2 HttpGets crash it..]])<___l_ do _l_-= _l_ local _=_[_lll]__[_]=__[_](__[_+__l_l])break end while(_l_)/((-#"This file has been enchanted with uncrackable V, fuck the fuck off"+((67805+-0x44)/201)))==3911 do __[_[_ll_]]=____l[_[__l_]];break end;break;end while(_l_)/((229+-0x40))==3695 do _l_=(1624728)while ___l_<=(-#[[JayZone Likes Men]]+(0x8f+-102))do _l_-= _l_ local _=_[_ll_]__[_]=__[_](__[_+__l_l])break;end while(_l_)/((4072/0x2))==798 do _l_=(6187804)while ___l_>((0x80-(175-0x60))+-#'Protected by wallysecure')do _l_-= _l_ local _lll;local _l_;_l_=_[_ll_];_lll=__[_[__ll]];__[_l_+1]=_lll;__[_l_]=_lll[_[_lll_]];_l=_l+_ll;_=__l[_l];__[_[___]]=_[_l_l];_l=_l+_ll;_=__l[_l];_l_=_[___]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[_l_ll]))_l=_l+_ll;_=__l[_l];__[_[__lll]]=__[_[_l_ll]][_[__ll_]];_l=_l+_ll;_=__l[_l];_l_=_[_l__];_lll=__[_[__l_]];__[_l_+1]=_lll;__[_l_]=_lll[_[_l_l_]];break end while(_l_)/((4009-0x7eb))==3122 do local __l=_[__lll]local _l_={__[__l](_ll_l(__,__l+1,_____))};local _l=0;for _=__l,_[_l__l]do _l=_l+_ll;__[_]=_l_[_l];end break end;break;end break;end break;end break;end while(_l_)/((801536/(0x13a+-66)))==957 do _l_=(2699840)while ___l_<=(-0x57+117)do _l_-= _l_ _l_=(5458870)while ___l_<=(-#[[Federal shackled his children]]+(-0x35+110))do _l_-= _l_ _l_=(2350024)while(0xaf-148)<___l_ do _l_-= _l_ __[_[_lll]][_[_llll]]=_[__ll_];break end while(_l_)/((0x6a129/247))==1336 do local ____l;local _l_;__[_[___l]]=___ll[_[_llll]];_l=_l+_ll;_=__l[_l];__[_[___]]=__[_[____]][_[_l_l_]];_l=_l+_ll;_=__l[_l];__[_[_l__]]=___ll[_[____]];_l=_l+_ll;_=__l[_l];__[_[___]]=_[__l_];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=_[__l_];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=_[__ll];_l=_l+_ll;_=__l[_l];_l_=_[_l__]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[__ll]))_l=_l+_ll;_=__l[_l];_l_=_[_ll_]__[_l_]=__[_l_](__[_l_+__l_l])_l=_l+_ll;_=__l[_l];__[_[___]][_[__ll]]=_[_l__l];_l=_l+_ll;_=__l[_l];__[_[_lll]]=___ll[_[_llll]];_l=_l+_ll;_=__l[_l];__[_[_lll]]=__[_[_llll]][_[__l__]];_l=_l+_ll;_=__l[_l];__[_[_lll]]=__[_[__ll]][_[__l__]];_l=_l+_ll;_=__l[_l];__[_[___]][_[_l_ll]]=__[_[__ll_]];_l=_l+_ll;_=__l[_l];__[_[_l__]][_[__l_]]=_[_l__l];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=___ll[_[____]];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=__[_[_l_l]][_[_l_l_]];_l=_l+_ll;_=__l[_l];__[_[__lll]]=__[_[__l_]][_[__l__]];_l=_l+_ll;_=__l[_l];__[_[_lll]]=__[_[_l_l]][_[_ll__]];_l=_l+_ll;_=__l[_l];_l_=_[_ll_]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[__ll]))_l=_l+_ll;_=__l[_l];__[_[__lll]][_[_l_l]]=__[_[__l__]];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=___ll[_[__ll]];_l=_l+_ll;_=__l[_l];__[_[__lll]]=__[_[____]][_[_lll_]];_l=_l+_ll;_=__l[_l];__[_[___]]=__[_[____]][_[__l__]];_l=_l+_ll;_=__l[_l];__[_[___l]]=__[_[_l_ll]][_[__l__]];_l=_l+_ll;_=__l[_l];_l_=_[___]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[__l_]))_l=_l+_ll;_=__l[_l];__[_[__lll]][_[_l_l]]=__[_[_l_l_]];_l=_l+_ll;_=__l[_l];__[_[_l__]]=___ll[_[__ll]];_l=_l+_ll;_=__l[_l];__[_[__lll]]=__[_[__l_]][_[__ll_]];_l=_l+_ll;_=__l[_l];__[_[_lll]]=___ll[_[__ll]];_l=_l+_ll;_=__l[_l];__[_[___l]]=_[_l_l];_l=_l+_ll;_=__l[_l];__[_[_lll]]=_[____];_l=_l+_ll;_=__l[_l];__[_[_lll]]=_[__l_];_l=_l+_ll;_=__l[_l];_l_=_[_lll]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[_llll]))_l=_l+_ll;_=__l[_l];_l_=_[__lll]__[_l_]=__[_l_](__[_l_+__l_l])_l=_l+_ll;_=__l[_l];__[_[___l]][_[_l_ll]]=_[__ll_];_l=_l+_ll;_=__l[_l];__[_[_lll]]=___ll[_[_llll]];_l=_l+_ll;_=__l[_l];__[_[___]]=__[_[__l_]][_[_l_l_]];_l=_l+_ll;_=__l[_l];__[_[_l__]]=__[_[_l_l]][_[_l__l]];_l=_l+_ll;_=__l[_l];__[_[___]][_[_l_l]]=__[_[_l_l_]];_l=_l+_ll;_=__l[_l];__[_[__lll]][_[__l_]]=_[_l_l_];_l=_l+_ll;_=__l[_l];__[_[___]]=___ll[_[_l_l]];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=__[_[_l_l]][_[_l_l_]];_l=_l+_ll;_=__l[_l];__[_[_lll]]=__[_[_l_ll]][_[__ll_]];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=__[_[__l_]][_[_l_l_]];_l=_l+_ll;_=__l[_l];_l_=_[___]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[__ll]))_l=_l+_ll;_=__l[_l];__[_[___l]][_[_l_l]]=__[_[_l_l_]];_l=_l+_ll;_=__l[_l];__[_[___l]]=___ll[_[__l_]];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=__[_[_l_l]][_[__l__]];_l=_l+_ll;_=__l[_l];__[_[_lll]]=__[_[____]][_[_ll__]];_l=_l+_ll;_=__l[_l];__[_[_lll]]=__[_[__ll]][_[__ll_]];_l=_l+_ll;_=__l[_l];_l_=_[_l__]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[_l_l]))_l=_l+_ll;_=__l[_l];__[_[_ll_]][_[__l_]]=__[_[_l_l_]];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=___ll[_[__ll]];_l=_l+_ll;_=__l[_l];__[_[___l]]=__[_[__ll]][_[_ll__]];_l=_l+_ll;_=__l[_l];__[_[_lll]]=___ll[_[_l_ll]];_l=_l+_ll;_=__l[_l];__[_[___]]=_[_l_ll];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=_[_l_l];_l=_l+_ll;_=__l[_l];__[_[__lll]]=_[_l_ll];_l=_l+_ll;_=__l[_l];_l_=_[_ll_]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[____]))_l=_l+_ll;_=__l[_l];_l_=_[__lll]__[_l_]=__[_l_](__[_l_+__l_l])_l=_l+_ll;_=__l[_l];__[_[_l__]][_[_l_l]]=_[_l__l];_l=_l+_ll;_=__l[_l];__[_[___l]]=___ll[_[_l_l]];_l=_l+_ll;_=__l[_l];__[_[__lll]]=__[_[_llll]][_[_lll_]];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=__[_[__ll]][_[_ll__]];_l=_l+_ll;_=__l[_l];__[_[___l]][_[__ll]]=__[_[__l__]];_l=_l+_ll;_=__l[_l];__[_[_ll_]][_[_l_ll]]=_[__l__];_l=_l+_ll;_=__l[_l];__[_[___]]=___ll[_[_l_ll]];_l=_l+_ll;_=__l[_l];__[_[_lll]]=__[_[_l_l]][_[_l_l_]];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=__[_[__l_]][_[_ll__]];_l=_l+_ll;_=__l[_l];__[_[___]]=__[_[__l_]][_[_l__l]];_l=_l+_ll;_=__l[_l];_l_=_[__lll]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[_llll]))_l=_l+_ll;_=__l[_l];__[_[_ll_]][_[_l_l]]=__[_[_l_l_]];_l=_l+_ll;_=__l[_l];__[_[_lll]]=___ll[_[____]];_l=_l+_ll;_=__l[_l];__[_[_lll]]=__[_[_l_l]][_[__ll_]];_l=_l+_ll;_=__l[_l];__[_[_l__]]=__[_[____]][_[_lll_]];_l=_l+_ll;_=__l[_l];__[_[_l__]]=__[_[_l_ll]][_[_lll_]];_l=_l+_ll;_=__l[_l];____l={_,__};____l[_l___][____l[__l_l][_lll]]=____l[_l___][____l[_ll][__l_]]+____l[__l_l][_l__l];_l=_l+_ll;_=__l[_l];_l_=_[__lll]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[_l_ll]))_l=_l+_ll;_=__l[_l];__[_[___]][_[____]]=__[_[_lll_]];_l=_l+_ll;_=__l[_l];__[_[_l__]]=___ll[_[__l_]];break end;break;end while(_l_)/((113611/0x29))==1970 do _l_=(10794581)while ___l_>(0x86-105)do _l_-= _l_ ___ll[_[_llll]]=__[_[_ll_]];break end while(_l_)/(((0xde2+-66)+-#[[invited]]))==3101 do ____l[_[_l_ll]]=__[_[_lll]];break end;break;end break;end while 2596==(_l_)/((-0x5f+1135))do _l_=(10536511)while ___l_<=(0xae-(-#'free_lua_deobfuscator.hacker.com'+(-0x4d+251)))do _l_-= _l_ _l_=(3264405)while(-#"Hellb64"+(-0x10+54))<___l_ do _l_-= _l_ local _=_[___l]local __l,_l=__llll(__[_](__[_+__l_l]))_____=_l+_-_ll local _l=0;for _=_,_____ do _l=_l+_ll;__[_]=__l[_l];end;break end while 1415==(_l_)/((0x1224-2337))do local _ll=_[___l];local _l_=__[_ll+2];local __l=__[_ll]+_l_;__[_ll]=__l;if(_l_>0)then if(__l<=__[_ll+1])then _l=_[_llll];__[_ll+3]=__l;end elseif(__l>=__[_ll+1])then _l=_[_llll];__[_ll+3]=__l;end break end;break;end while(_l_)/((0x520f/7))==3511 do _l_=(364104)while ___l_<=(0x55-52)do _l_-= _l_ local __l=_[_lll]local _l_={__[__l](_ll_l(__,__l+1,_[_llll]))};local _l=0;for _=__l,_[_l__l]do _l=_l+_ll;__[_]=_l_[_l];end break;end while(_l_)/((-#'Okay guys federal can notice you just stab a fork into your ass, write .gg/moonsec on your feet, and DONT send it to federal'+(0x278+-119)))==936 do _l_=(9434313)while((-0x48+125)+-#"How to dump moonsec")<___l_ do _l_-= _l_ local _ll_;local _l_;__[_[___]]=___ll[_[____]];_l=_l+_ll;_=__l[_l];__[_[___l]]=___ll[_[_llll]];_l=_l+_ll;_=__l[_l];__[_[___l]]=_[_llll];_l=_l+_ll;_=__l[_l];__[_[___]]=_[_l_l];_l=_l+_ll;_=__l[_l];__[_[__lll]]=_[_llll];_l=_l+_ll;_=__l[_l];_l_=_[___]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[__ll]))_l=_l+_ll;_=__l[_l];__[_[___l]]=__[_[____]][__[_[__ll_]]];_l=_l+_ll;_=__l[_l];_l_=_[_lll]__[_l_]=__[_l_](__[_l_+__l_l])_l=_l+_ll;_=__l[_l];_ll_=__[_[_lll_]];if not _ll_ then _l=_l+__l_l;else __[_[___]]=_ll_;_l=_[____];end;break end while(_l_)/((4000+-0x1f))==2377 do local ____l;local _l_;__[_[_l__]]=___ll[_[_l_ll]];_l=_l+_ll;_=__l[_l];__[_[_l__]]=_[_l_l];_l=_l+_ll;_=__l[_l];__[_[_l__]]=_[_l_ll];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=_[__ll];_l=_l+_ll;_=__l[_l];_l_=_[__lll]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[_llll]))_l=_l+_ll;_=__l[_l];_l_=_[___l]__[_l_]=__[_l_](__[_l_+__l_l])_l=_l+_ll;_=__l[_l];__[_[_l__]][_[__ll]]=_[__ll_];_l=_l+_ll;_=__l[_l];__[_[___l]]=___ll[_[_l_l]];_l=_l+_ll;_=__l[_l];__[_[__lll]]=__[_[_l_l]][_[_l__l]];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=__[_[__l_]][_[_l__l]];_l=_l+_ll;_=__l[_l];__[_[_ll_]][_[_l_ll]]=__[_[_lll_]];_l=_l+_ll;_=__l[_l];__[_[__lll]][_[_l_ll]]=_[_lll_];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=___ll[_[_l_l]];_l=_l+_ll;_=__l[_l];__[_[_lll]]=__[_[____]][_[_l__l]];_l=_l+_ll;_=__l[_l];__[_[___]]=__[_[__ll]][_[_ll__]];_l=_l+_ll;_=__l[_l];__[_[_lll]]=__[_[_llll]][_[_lll_]];_l=_l+_ll;_=__l[_l];_l_=_[_lll]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[_llll]))_l=_l+_ll;_=__l[_l];__[_[_lll]][_[_l_ll]]=__[_[_lll_]];_l=_l+_ll;_=__l[_l];__[_[___l]]=___ll[_[__ll]];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=__[_[_l_ll]][_[_ll__]];_l=_l+_ll;_=__l[_l];__[_[_l__]]=__[_[__l_]][_[_l__l]];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=__[_[_l_ll]][_[__ll_]];_l=_l+_ll;_=__l[_l];____l={_,__};____l[_l___][____l[__l_l][_l__]]=____l[_l___][____l[_ll][_l_l]]+____l[__l_l][_lll_];_l=_l+_ll;_=__l[_l];_l_=_[___]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[__ll]))_l=_l+_ll;_=__l[_l];__[_[_l__]][_[_l_l]]=__[_[_l_l_]];_l=_l+_ll;_=__l[_l];__[_[_l__]]=___ll[_[__l_]];_l=_l+_ll;_=__l[_l];__[_[___]]=__[_[__l_]][_[__ll_]];_l=_l+_ll;_=__l[_l];__[_[_l__]]=___ll[_[_l_l]];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=_[_llll];_l=_l+_ll;_=__l[_l];__[_[___]]=_[_l_ll];_l=_l+_ll;_=__l[_l];__[_[_l__]]=_[____];_l=_l+_ll;_=__l[_l];_l_=_[__lll]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[__ll]))_l=_l+_ll;_=__l[_l];_l_=_[___l]__[_l_]=__[_l_](__[_l_+__l_l])_l=_l+_ll;_=__l[_l];__[_[_lll]][_[_llll]]=_[_ll__];_l=_l+_ll;_=__l[_l];__[_[_l__]]=___ll[_[__l_]];_l=_l+_ll;_=__l[_l];__[_[_l__]]=__[_[_llll]][_[__ll_]];_l=_l+_ll;_=__l[_l];__[_[__lll]]=__[_[_l_l]][_[__l__]];_l=_l+_ll;_=__l[_l];__[_[___]][_[_llll]]=__[_[__l__]];_l=_l+_ll;_=__l[_l];__[_[___l]][_[____]]=_[_lll_];_l=_l+_ll;_=__l[_l];__[_[_lll]]=___ll[_[_llll]];_l=_l+_ll;_=__l[_l];__[_[___l]]=__[_[__ll]][_[_l__l]];_l=_l+_ll;_=__l[_l];__[_[_l__]]=__[_[_l_l]][_[__ll_]];_l=_l+_ll;_=__l[_l];__[_[_lll]]=__[_[____]][_[__l__]];_l=_l+_ll;_=__l[_l];_l_=_[_l__]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[_l_ll]))_l=_l+_ll;_=__l[_l];__[_[__lll]][_[_llll]]=__[_[_l__l]];_l=_l+_ll;_=__l[_l];__[_[___]]=___ll[_[_l_l]];_l=_l+_ll;_=__l[_l];__[_[__lll]]=__[_[__ll]][_[__l__]];_l=_l+_ll;_=__l[_l];__[_[__lll]]=__[_[____]][_[_lll_]];_l=_l+_ll;_=__l[_l];__[_[_lll]]=__[_[_l_ll]][_[__l__]];_l=_l+_ll;_=__l[_l];____l={_,__};____l[_l___][____l[__l_l][_l__]]=____l[_l___][____l[_ll][__l_]]+____l[__l_l][_l__l];_l=_l+_ll;_=__l[_l];_l_=_[__lll]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[__ll]))_l=_l+_ll;_=__l[_l];__[_[___l]][_[__ll]]=__[_[__l__]];_l=_l+_ll;_=__l[_l];__[_[___]]=___ll[_[__ll]];_l=_l+_ll;_=__l[_l];__[_[___]]=__[_[____]][_[__ll_]];_l=_l+_ll;_=__l[_l];__[_[_l__]]=___ll[_[_llll]];_l=_l+_ll;_=__l[_l];__[_[_l__]]=_[_llll];_l=_l+_ll;_=__l[_l];__[_[__lll]]=_[____];_l=_l+_ll;_=__l[_l];__[_[___]]=_[____];_l=_l+_ll;_=__l[_l];_l_=_[___]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[_l_l]))_l=_l+_ll;_=__l[_l];_l_=_[__lll]__[_l_]=__[_l_](__[_l_+__l_l])_l=_l+_ll;_=__l[_l];__[_[_l__]][_[____]]=_[__l__];_l=_l+_ll;_=__l[_l];__[_[_l__]]=___ll[_[__ll]];_l=_l+_ll;_=__l[_l];__[_[___]]=__[_[_llll]][_[_lll_]];_l=_l+_ll;_=__l[_l];__[_[_lll]]=__[_[____]][_[_l_l_]];_l=_l+_ll;_=__l[_l];__[_[_lll]][_[__l_]]=__[_[_l_l_]];_l=_l+_ll;_=__l[_l];__[_[___]][_[__l_]]=_[_l__l];_l=_l+_ll;_=__l[_l];__[_[__lll]]=___ll[_[__l_]];_l=_l+_ll;_=__l[_l];__[_[___l]]=__[_[_llll]][_[__l__]];_l=_l+_ll;_=__l[_l];__[_[___]]=__[_[_llll]][_[__ll_]];_l=_l+_ll;_=__l[_l];__[_[___]]=__[_[_llll]][_[_l_l_]];_l=_l+_ll;_=__l[_l];_l_=_[_lll]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[_llll]))_l=_l+_ll;_=__l[_l];__[_[___l]][_[_l_l]]=__[_[_ll__]];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=___ll[_[__ll]];_l=_l+_ll;_=__l[_l];__[_[___]]=__[_[____]][_[__ll_]];_l=_l+_ll;_=__l[_l];__[_[_l__]]=__[_[_llll]][_[__l__]];_l=_l+_ll;_=__l[_l];__[_[_lll]]=__[_[_l_l]][_[__l__]];_l=_l+_ll;_=__l[_l];____l={_,__};____l[_l___][____l[__l_l][_lll]]=____l[_l___][____l[_ll][__ll]]+____l[__l_l][__l__];_l=_l+_ll;_=__l[_l];_l_=_[_ll_]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[_l_ll]))_l=_l+_ll;_=__l[_l];__[_[___l]][_[__ll]]=__[_[_l__l]];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=___ll[_[_l_ll]];break end;break;end break;end break;end break;end break;end break;end while 1446==(_l_)/((-0x4e+(-#[[im giving 50k to the one who solves this challenge]]+(-76+0x609))))do _l_=(1655640)while ___l_<=(0xd9-164)do _l_-= _l_ _l_=(385280)while(6600/0x96)>=___l_ do _l_-= _l_ _l_=(2351556)while(205-0xa6)>=___l_ do _l_-= _l_ _l_=(3110264)while ___l_<=(3552/0x60)do _l_-= _l_ _l_=(1996550)while ___l_>(-88+0x7c)do _l_-= _l_ local ___l_;local _l_;__[_[___l]]=____l[_[_l_l]];_l=_l+_ll;_=__l[_l];__[_[_l__]][_[_l_l]]=_[_ll__];_l=_l+_ll;_=__l[_l];__[_[___]]=____l[_[__l_]];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=___ll[_[_l_l]];_l=_l+_ll;_=__l[_l];__[_[_l__]]=__[_[____]][_[_lll_]];_l=_l+_ll;_=__l[_l];__[_[___]]=__[_[__ll]][_[_l_l_]];_l=_l+_ll;_=__l[_l];__[_[__lll]]=__[_[_l_ll]][_[_lll_]];_l=_l+_ll;_=__l[_l];_l_=_[___]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[__ll]))_l=_l+_ll;_=__l[_l];__[_[_ll_]][_[_l_ll]]=__[_[__ll_]];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=____l[_[____]];_l=_l+_ll;_=__l[_l];__[_[__lll]]=___ll[_[_llll]];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=__[_[__ll]][_[_ll__]];_l=_l+_ll;_=__l[_l];__[_[___l]]=__[_[____]][_[_ll__]];_l=_l+_ll;_=__l[_l];__[_[___]]=__[_[____]][_[_l_l_]];_l=_l+_ll;_=__l[_l];___l_={_,__};___l_[_l___][___l_[__l_l][___]]=___l_[_l___][___l_[_ll][__ll]]+___l_[__l_l][__ll_];_l=_l+_ll;_=__l[_l];_l_=_[_l__]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[_l_l]))_l=_l+_ll;_=__l[_l];__[_[_lll]][_[____]]=__[_[_l__l]];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=____l[_[_llll]];_l=_l+_ll;_=__l[_l];__[_[___l]][_[____]]=_[_lll_];_l=_l+_ll;_=__l[_l];__[_[___l]]=____l[_[_l_ll]];_l=_l+_ll;_=__l[_l];__[_[___]]=___ll[_[_llll]];_l=_l+_ll;_=__l[_l];__[_[___l]]=__[_[_l_l]][_[__ll_]];_l=_l+_ll;_=__l[_l];__[_[__lll]]=__[_[_llll]][_[__l__]];_l=_l+_ll;_=__l[_l];__[_[__lll]]=__[_[_llll]][_[_l_l_]];_l=_l+_ll;_=__l[_l];_l_=_[_l__]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[_llll]))_l=_l+_ll;_=__l[_l];__[_[___l]][_[__ll]]=__[_[_l__l]];_l=_l+_ll;_=__l[_l];__[_[___l]]=____l[_[__l_]];_l=_l+_ll;_=__l[_l];__[_[_lll]]=___ll[_[_l_ll]];_l=_l+_ll;_=__l[_l];__[_[___]]=__[_[__ll]][_[_ll__]];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=__[_[__ll]][_[__l__]];_l=_l+_ll;_=__l[_l];__[_[_l__]]=__[_[_l_l]][_[__l__]];_l=_l+_ll;_=__l[_l];___l_={_,__};___l_[_l___][___l_[__l_l][___l]]=___l_[_l___][___l_[_ll][__ll]]+___l_[__l_l][_l__l];_l=_l+_ll;_=__l[_l];_l_=_[_l__]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[_llll]))_l=_l+_ll;_=__l[_l];__[_[___l]][_[__l_]]=__[_[_ll__]];_l=_l+_ll;_=__l[_l];__[_[__lll]]=____l[_[__ll]];_l=_l+_ll;_=__l[_l];__[_[_ll_]][_[____]]=_[_ll__];_l=_l+_ll;_=__l[_l];__[_[___]]=____l[_[__ll]];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=___ll[_[__ll]];_l=_l+_ll;_=__l[_l];__[_[___]]=__[_[__ll]][_[__ll_]];_l=_l+_ll;_=__l[_l];__[_[___]]=__[_[____]][_[_ll__]];_l=_l+_ll;_=__l[_l];__[_[___]]=__[_[____]][_[_l__l]];_l=_l+_ll;_=__l[_l];___l_={_,__};___l_[_l___][___l_[__l_l][___]]=___l_[_l___][___l_[_ll][_llll]]+___l_[__l_l][_l_l_];_l=_l+_ll;_=__l[_l];_l_=_[_l__]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[_l_ll]))_l=_l+_ll;_=__l[_l];__[_[__lll]][_[__ll]]=__[_[_ll__]];_l=_l+_ll;_=__l[_l];__[_[__lll]]=____l[_[_l_l]];_l=_l+_ll;_=__l[_l];__[_[___l]]=___ll[_[____]];_l=_l+_ll;_=__l[_l];__[_[___]]=__[_[__l_]][_[_l__l]];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=__[_[__ll]][_[_l__l]];_l=_l+_ll;_=__l[_l];__[_[___l]]=__[_[_l_l]][_[_ll__]];_l=_l+_ll;_=__l[_l];_l_=_[_ll_]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[_llll]))_l=_l+_ll;_=__l[_l];__[_[__lll]][_[____]]=__[_[_l__l]];_l=_l+_ll;_=__l[_l];__[_[_l__]]=____l[_[_l_l]];_l=_l+_ll;_=__l[_l];__[_[__lll]][_[____]]=_[_l_l_];_l=_l+_ll;_=__l[_l];__[_[_l__]]=____l[_[____]];_l=_l+_ll;_=__l[_l];__[_[___]]=___ll[_[____]];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=__[_[_l_ll]][_[__l__]];_l=_l+_ll;_=__l[_l];__[_[_l__]]=__[_[__ll]][_[_ll__]];_l=_l+_ll;_=__l[_l];__[_[_l__]]=__[_[_llll]][_[__ll_]];_l=_l+_ll;_=__l[_l];___l_={_,__};___l_[_l___][___l_[__l_l][___]]=___l_[_l___][___l_[_ll][____]]+___l_[__l_l][__l__];_l=_l+_ll;_=__l[_l];_l_=_[__lll]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[_llll]))_l=_l+_ll;_=__l[_l];__[_[__lll]][_[__ll]]=__[_[_l__l]];_l=_l+_ll;_=__l[_l];__[_[_l__]]=____l[_[_l_ll]];_l=_l+_ll;_=__l[_l];__[_[__lll]]=___ll[_[__ll]];_l=_l+_ll;_=__l[_l];__[_[__lll]]=__[_[_l_ll]][_[_ll__]];_l=_l+_ll;_=__l[_l];__[_[__lll]]=__[_[____]][_[__ll_]];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=__[_[_llll]][_[__l__]];_l=_l+_ll;_=__l[_l];_l_=_[_l__]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[__ll]))_l=_l+_ll;_=__l[_l];__[_[_ll_]][_[____]]=__[_[__l__]];_l=_l+_ll;_=__l[_l];__[_[___]]=____l[_[_llll]];_l=_l+_ll;_=__l[_l];__[_[_lll]][_[_l_l]]=_[_l_l_];_l=_l+_ll;_=__l[_l];__[_[_lll]]=____l[_[_l_ll]];_l=_l+_ll;_=__l[_l];__[_[___l]]=___ll[_[_llll]];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=__[_[__l_]][_[_l_l_]];_l=_l+_ll;_=__l[_l];__[_[___]]=__[_[____]][_[_l_l_]];_l=_l+_ll;_=__l[_l];__[_[_lll]]=__[_[____]][_[_lll_]];_l=_l+_ll;_=__l[_l];_l_=_[_ll_]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[____]))_l=_l+_ll;_=__l[_l];__[_[_lll]][_[____]]=__[_[_l__l]];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=____l[_[_l_ll]];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=___ll[_[_l_ll]];_l=_l+_ll;_=__l[_l];__[_[_lll]]=__[_[_l_ll]][_[_l_l_]];break end while(_l_)/((2210-((0x928-1221)+-#"Hellb64")))==1825 do local __ll=___lll[_[____]];local _lll;local _ll={};_lll=__ll_l({},{__index=function(_l,_)local _=_ll[_];return _[1][_[2]];end,__newindex=function(__,_,_l)local _=_ll[_]_[1][_[2]]=_l;end;});for _l_=1,_[__ll_]do _l=_l+__l_l;local _=__l[_l];if _[(0x6b-106)]==93 then _ll[_l_-1]={__,_[__l_]};else _ll[_l_-1]={____l,_[_l_ll]};end;_lllll[#_lllll+1]=_ll;end;__[_[___]]=_l_lll(__ll,_lll,___ll);break end;break;end while(_l_)/((((0x16d3+-126)+-#'<@!847154787934011462> shut the fuck up')-2881))==1112 do _l_=(5663545)while(-55+0x5d)<___l_ do _l_-= _l_ __[_[_lll]]=____l[_[_l_ll]];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=#__[_[_l_ll]];_l=_l+_ll;_=__l[_l];____l[_[__ll]]=__[_[___l]];_l=_l+_ll;_=__l[_l];__[_[___l]]=____l[_[_l_ll]];_l=_l+_ll;_=__l[_l];__[_[___]]=#__[_[_llll]];_l=_l+_ll;_=__l[_l];____l[_[_l_l]]=__[_[__lll]];_l=_l+_ll;_=__l[_l];do return end;break end while(_l_)/((733775/0xf5))==1891 do if(__[_[_ll_]]==__[_[__l__]])then _l=_l+__l_l;else _l=_[_l_l];end;break end;break;end break;end while 1494==(_l_)/((132216/0x54))do _l_=(2462415)while ___l_<=(0xc5-156)do _l_-= _l_ _l_=(2111508)while ___l_>(0x1810/154)do _l_-= _l_ __[_[___]]=____l[_[__ll]];break end while 588==(_l_)/((7240-0xe41))do __[_[___l]]=__[_[_l_ll]]-__[_[__ll_]];break end;break;end while(_l_)/((1993-0x3f2))==2505 do _l_=(4692234)while ___l_<=(0xae-132)do _l_-= _l_ local __l=_[_lll];local ___=_[_ll__];local _l_=__l+2 local __l={__[__l](__[__l+1],__[_l_])};for _=1,___ do __[_l_+_]=__l[_];end;local __l=__l[1]if __l then __[_l_]=__l _l=_[_l_l];else _l=_l+_ll;end;break;end while(_l_)/((37005/0xf))==1902 do _l_=(12462934)while ___l_>(0xcc-161)do _l_-= _l_ do return __[_[_lll]]end break end while 3707==(_l_)/((-#[[real]]+(0x1a8e-3432)))do local ___l_;local _l_;__[_[___]]=___ll[_[__ll]];_l=_l+_ll;_=__l[_l];__[_[_l__]]=__[_[_l_l]][_[_l_l_]];_l=_l+_ll;_=__l[_l];__[_[__lll]]=__[_[__ll]][_[__ll_]];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=__[_[_llll]][_[__ll_]];_l=_l+_ll;_=__l[_l];_l_=_[__lll]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[____]))_l=_l+_ll;_=__l[_l];__[_[___l]][_[____]]=__[_[_l_l_]];_l=_l+_ll;_=__l[_l];__[_[_l__]]=____l[_[_l_ll]];_l=_l+_ll;_=__l[_l];__[_[__lll]]=___ll[_[_l_ll]];_l=_l+_ll;_=__l[_l];__[_[___]]=__[_[_l_ll]][_[__l__]];_l=_l+_ll;_=__l[_l];__[_[_l__]]=__[_[_l_ll]][_[_lll_]];_l=_l+_ll;_=__l[_l];__[_[___]]=__[_[_l_ll]][_[__l__]];_l=_l+_ll;_=__l[_l];_l_=_[___l]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[__ll]))_l=_l+_ll;_=__l[_l];__[_[_l__]][_[_l_ll]]=__[_[__l__]];_l=_l+_ll;_=__l[_l];__[_[__lll]]=____l[_[_l_l]];_l=_l+_ll;_=__l[_l];__[_[_ll_]][_[_l_l]]=_[__l__];_l=_l+_ll;_=__l[_l];__[_[___l]]=____l[_[____]];_l=_l+_ll;_=__l[_l];__[_[___]]=___ll[_[_llll]];_l=_l+_ll;_=__l[_l];__[_[___l]]=__[_[_l_ll]][_[_ll__]];_l=_l+_ll;_=__l[_l];__[_[_lll]]=__[_[__l_]][_[__ll_]];_l=_l+_ll;_=__l[_l];__[_[__lll]]=__[_[__ll]][_[__l__]];_l=_l+_ll;_=__l[_l];_l_=_[___l]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[_llll]))_l=_l+_ll;_=__l[_l];__[_[_lll]][_[__l_]]=__[_[_l__l]];_l=_l+_ll;_=__l[_l];__[_[_l__]]=____l[_[__l_]];_l=_l+_ll;_=__l[_l];__[_[__lll]]=___ll[_[__ll]];_l=_l+_ll;_=__l[_l];__[_[___l]]=__[_[_llll]][_[_l__l]];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=__[_[____]][_[__l__]];_l=_l+_ll;_=__l[_l];__[_[_lll]]=__[_[_l_ll]][_[_ll__]];_l=_l+_ll;_=__l[_l];_l_=_[_ll_]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[__ll]))_l=_l+_ll;_=__l[_l];__[_[__lll]][_[_l_ll]]=__[_[_ll__]];_l=_l+_ll;_=__l[_l];__[_[__lll]]=____l[_[__l_]];_l=_l+_ll;_=__l[_l];__[_[___l]][_[_llll]]=_[_lll_];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=____l[_[____]];_l=_l+_ll;_=__l[_l];__[_[_ll_]][_[_llll]]=_[__ll_];_l=_l+_ll;_=__l[_l];__[_[__lll]]=____l[_[__ll]];_l=_l+_ll;_=__l[_l];__[_[__lll]]=___ll[_[____]];_l=_l+_ll;_=__l[_l];__[_[___l]]=__[_[__ll]][_[_ll__]];_l=_l+_ll;_=__l[_l];__[_[_l__]]=__[_[____]][_[__ll_]];_l=_l+_ll;_=__l[_l];__[_[_l__]]=__[_[_l_ll]][_[_l__l]];_l=_l+_ll;_=__l[_l];_l_=_[___l]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[_l_l]))_l=_l+_ll;_=__l[_l];__[_[__lll]][_[__ll]]=__[_[_ll__]];_l=_l+_ll;_=__l[_l];__[_[__lll]]=____l[_[_llll]];_l=_l+_ll;_=__l[_l];__[_[_l__]]=___ll[_[__l_]];_l=_l+_ll;_=__l[_l];__[_[__lll]]=__[_[_l_l]][_[_l_l_]];_l=_l+_ll;_=__l[_l];__[_[_l__]]=__[_[__ll]][_[_l__l]];_l=_l+_ll;_=__l[_l];__[_[_l__]]=__[_[____]][_[_l__l]];_l=_l+_ll;_=__l[_l];_l_=_[_ll_]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[_l_ll]))_l=_l+_ll;_=__l[_l];__[_[_ll_]][_[__l_]]=__[_[_l_l_]];_l=_l+_ll;_=__l[_l];__[_[___l]]=____l[_[_llll]];_l=_l+_ll;_=__l[_l];__[_[_l__]][_[__ll]]=_[__ll_];_l=_l+_ll;_=__l[_l];__[_[___l]]=____l[_[__ll]];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=___ll[_[__l_]];_l=_l+_ll;_=__l[_l];__[_[_lll]]=__[_[__l_]][_[_l__l]];_l=_l+_ll;_=__l[_l];__[_[__lll]]=__[_[_l_ll]][_[__l__]];_l=_l+_ll;_=__l[_l];__[_[___l]]=__[_[_l_ll]][_[_l_l_]];_l=_l+_ll;_=__l[_l];_l_=_[__lll]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[_llll]))_l=_l+_ll;_=__l[_l];__[_[_lll]][_[__l_]]=__[_[_lll_]];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=____l[_[_l_l]];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=___ll[_[____]];_l=_l+_ll;_=__l[_l];__[_[_lll]]=__[_[__ll]][_[_lll_]];_l=_l+_ll;_=__l[_l];__[_[___]]=__[_[_llll]][_[_l__l]];_l=_l+_ll;_=__l[_l];__[_[__lll]]=__[_[_llll]][_[_lll_]];_l=_l+_ll;_=__l[_l];___l_={_,__};___l_[_l___][___l_[__l_l][_ll_]]=___l_[_l___][___l_[_ll][_l_l]]+___l_[__l_l][__ll_];_l=_l+_ll;_=__l[_l];_l_=_[_lll]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[_l_ll]))_l=_l+_ll;_=__l[_l];__[_[_lll]][_[_l_ll]]=__[_[__ll_]];_l=_l+_ll;_=__l[_l];__[_[_lll]]=____l[_[__l_]];_l=_l+_ll;_=__l[_l];__[_[___]][_[_l_ll]]=_[__ll_];_l=_l+_ll;_=__l[_l];__[_[__lll]]=____l[_[__l_]];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=___ll[_[_llll]];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=__[_[_l_l]][_[_l_l_]];_l=_l+_ll;_=__l[_l];__[_[___l]]=__[_[____]][_[__l__]];_l=_l+_ll;_=__l[_l];__[_[__lll]]=__[_[_l_ll]][_[_l__l]];_l=_l+_ll;_=__l[_l];_l_=_[___]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[__ll]))_l=_l+_ll;_=__l[_l];__[_[_ll_]][_[____]]=__[_[_l_l_]];_l=_l+_ll;_=__l[_l];__[_[__lll]]=____l[_[_l_l]];_l=_l+_ll;_=__l[_l];__[_[___l]]=___ll[_[__l_]];_l=_l+_ll;_=__l[_l];__[_[___l]]=__[_[__l_]][_[__ll_]];_l=_l+_ll;_=__l[_l];__[_[__lll]]=__[_[_l_l]][_[_l_l_]];_l=_l+_ll;_=__l[_l];__[_[___]]=__[_[__ll]][_[_l_l_]];_l=_l+_ll;_=__l[_l];___l_={_,__};___l_[_l___][___l_[__l_l][___l]]=___l_[_l___][___l_[_ll][____]]+___l_[__l_l][__l__];_l=_l+_ll;_=__l[_l];_l_=_[___]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[__ll]))break end;break;end break;end break;end break;end while(_l_)/((0x5cd-797))==560 do _l_=(8273356)while ___l_<=((-0x25+117)+-#'<@847154787934011462> stupid ass')do _l_-= _l_ _l_=(14242125)while(-#'hey psst you the wrapper function is right there'+((-33+0x115)-0x96))>=___l_ do _l_-= _l_ _l_=(277936)while(0x2a03/239)<___l_ do _l_-= _l_ __[_[__lll]]=__[_[__ll]]-__[_[_ll__]];break end while 2396==(_l_)/((0x109-149))do __[_[___l]][_[_l_ll]]=_[__l__];_l=_l+_ll;_=__l[_l];__[_[_l__]]=____l[_[__l_]];_l=_l+_ll;_=__l[_l];__[_[___]][_[_llll]]=_[_l_l_];_l=_l+_ll;_=__l[_l];__[_[_lll]]=____l[_[_llll]];_l=_l+_ll;_=__l[_l];__[_[_l__]][_[_llll]]=_[_lll_];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=____l[_[_l_ll]];_l=_l+_ll;_=__l[_l];__[_[___]][_[__l_]]=_[_l__l];_l=_l+_ll;_=__l[_l];__[_[_lll]]=____l[_[_l_l]];_l=_l+_ll;_=__l[_l];__[_[__lll]][_[_l_l]]=_[_ll__];_l=_l+_ll;_=__l[_l];__[_[_lll]]=____l[_[_l_l]];_l=_l+_ll;_=__l[_l];__[_[_l__]][_[____]]=_[_l__l];_l=_l+_ll;_=__l[_l];__[_[___]]=____l[_[__l_]];_l=_l+_ll;_=__l[_l];__[_[_l__]][_[_l_l]]=_[_l_l_];_l=_l+_ll;_=__l[_l];__[_[_l__]]=____l[_[_l_l]];_l=_l+_ll;_=__l[_l];__[_[_lll]][_[__ll]]=_[_lll_];_l=_l+_ll;_=__l[_l];__[_[_lll]]=____l[_[_l_ll]];_l=_l+_ll;_=__l[_l];__[_[_ll_]][_[_l_l]]=_[_l__l];_l=_l+_ll;_=__l[_l];__[_[_lll]]=____l[_[_llll]];_l=_l+_ll;_=__l[_l];__[_[___l]][_[__ll]]=_[__l__];_l=_l+_ll;_=__l[_l];__[_[_lll]]=____l[_[__l_]];_l=_l+_ll;_=__l[_l];__[_[___]][_[__ll]]=_[__ll_];_l=_l+_ll;_=__l[_l];_l=_[_l_l];break end;break;end while 4075==(_l_)/((216690/0x3e))do _l_=(5574636)while ___l_>(-#[[I am albanian obfuscator I cannot hide this script please dont view it]]+(0x41d/9))do _l_-= _l_ local _l_=_[_lll];local _ll={};for _=1,#_lllll do local _=_lllll[_];for _l=0,#_ do local _l=_[_l];local __l=_l[1];local _=_l[2];if __l==__ and _>=_l_ then _ll[_]=__l[_];_l[1]=_ll;end;end;end;break end while(_l_)/((-#"I am eq opcode lmaooooo"+(0x33ca7/55)))==1454 do if __[_[_l__]]then _l=_l+_ll;else _l=_[_l_ll];end;break end;break;end break;end while(_l_)/((0x13aa-2551))==3332 do _l_=(481926)while ___l_<=(-0x35+103)do _l_-= _l_ _l_=(10777821)while(181-0x84)<___l_ do _l_-= _l_ ____l[_[_l_l]]=__[_[___]];break end while 2881==(_l_)/(((0x1de4-3874)+-#'you miss a father figure in your life'))do __[_[_lll]][_[__l_]]=_[_ll__];_l=_l+_ll;_=__l[_l];__[_[__lll]]=____l[_[____]];_l=_l+_ll;_=__l[_l];__[_[_lll]][_[__l_]]=_[_l_l_];_l=_l+_ll;_=__l[_l];__[_[___]]=____l[_[__ll]];_l=_l+_ll;_=__l[_l];__[_[___]][_[_llll]]=_[_l_l_];_l=_l+_ll;_=__l[_l];__[_[___]]=____l[_[__ll]];_l=_l+_ll;_=__l[_l];__[_[_l__]][_[_l_ll]]=_[__ll_];_l=_l+_ll;_=__l[_l];__[_[__lll]]=____l[_[_l_l]];_l=_l+_ll;_=__l[_l];__[_[_l__]][_[__l_]]=_[_l__l];_l=_l+_ll;_=__l[_l];__[_[___]]=____l[_[__l_]];_l=_l+_ll;_=__l[_l];__[_[_l__]][_[_l_l]]=_[_ll__];_l=_l+_ll;_=__l[_l];__[_[_l__]]=____l[_[____]];_l=_l+_ll;_=__l[_l];__[_[_ll_]][_[_l_l]]=_[__ll_];_l=_l+_ll;_=__l[_l];__[_[_l__]]=____l[_[_l_l]];_l=_l+_ll;_=__l[_l];__[_[___]][_[_llll]]=_[__l__];_l=_l+_ll;_=__l[_l];__[_[_lll]]=____l[_[_l_ll]];_l=_l+_ll;_=__l[_l];__[_[_lll]][_[____]]=_[_l__l];_l=_l+_ll;_=__l[_l];__[_[_lll]]=____l[_[_l_ll]];_l=_l+_ll;_=__l[_l];__[_[___l]][_[_l_l]]=_[_l__l];_l=_l+_ll;_=__l[_l];__[_[___l]]=____l[_[__l_]];_l=_l+_ll;_=__l[_l];__[_[___]][_[____]]=_[_l_l_];_l=_l+_ll;_=__l[_l];_l=_[__ll];break end;break;end while 186==(_l_)/((2700+-0x6d))do _l_=(4338264)while ___l_<=(0x29a3/209)do _l_-= _l_ __[_[___l]]=#__[_[__l_]];break;end while 2744==(_l_)/((-#'Me when moonsec:'+(0xc93-1622)))do _l_=(9413555)while((0x346c/220)+-#[[v3 has it]])<___l_ do _l_-= _l_ local _={__,_};_[_ll][_[_l___][___l]]=_[_l___][_ll__]+_[_l___][_l_l];break end while(_l_)/((584545/0xdd))==3559 do if __[_[_ll_]]then _l=_l+_ll;else _l=_[____];end;break end;break;end break;end break;end break;end break;end while 4088==(_l_)/((-#'cock and ball'+(74404/0xb2)))do _l_=(8163080)while ___l_<=(3534/0x39)do _l_-= _l_ _l_=(5206480)while(0xeb2/66)>=___l_ do _l_-= _l_ _l_=(6250805)while ___l_<=(227-(202+-0x1e))do _l_-= _l_ _l_=(628342)while ___l_>((0xc8+-33)-0x71)do _l_-= _l_ local ___;local __l_;local _ll_;local _l_;_l_=_[_l__];_ll_=__[_[_llll]];__[_l_+1]=_ll_;__[_l_]=_ll_[_[__ll_]];_l=_l+_ll;_=__l[_l];__[_[__lll]]=____l[_[_l_l]];_l=_l+_ll;_=__l[_l];__[_[___l]]=__[_[__ll]][_[_ll__]];_l=_l+_ll;_=__l[_l];__[_[___l]]=__[_[_l_ll]][_[_l__l]];_l=_l+_ll;_=__l[_l];__[_[__lll]]=__[_[_l_ll]][_[_l__l]];_l=_l+_ll;_=__l[_l];_l_=_[_lll]__l_={__[_l_](_ll_l(__,_l_+1,_[_l_ll]))};___=0;for _=_l_,_[__ll_]do ___=___+_ll;__[_]=__l_[___];end _l=_l+_ll;_=__l[_l];if __[_[_l__]]then _l=_l+_ll;else _l=_[_l_ll];end;break end while 3718==(_l_)/((((7980/0x1c)+-#'If you see this string you are going to be sued by memcorrupt')+-55))do local _l=_[_lll]local _l_={__[_l](_ll_l(__,_l+1,_____))};local __l=0;for _=_l,_[_ll__]do __l=__l+_ll;__[_]=_l_[__l];end break end;break;end while(_l_)/((3216-0x655))==3919 do _l_=(951600)while(0x2220/156)<___l_ do _l_-= _l_ local _l_;local ___l_;__[_[__lll]]=__[_[_l_l]][_[_ll__]];_l=_l+_ll;_=__l[_l];___l_={_,__};___l_[_l___][___l_[__l_l][___l]]=___l_[_l___][___l_[_ll][____]]+___l_[__l_l][_l_l_];_l=_l+_ll;_=__l[_l];_l_=_[__lll]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[__ll]))_l=_l+_ll;_=__l[_l];__[_[_ll_]][_[_llll]]=__[_[_l__l]];_l=_l+_ll;_=__l[_l];__[_[_l__]]=____l[_[__ll]];_l=_l+_ll;_=__l[_l];__[_[_lll]][_[__ll]]=_[_lll_];_l=_l+_ll;_=__l[_l];__[_[_l__]]=____l[_[_l_ll]];_l=_l+_ll;_=__l[_l];__[_[_lll]]=___ll[_[_l_ll]];_l=_l+_ll;_=__l[_l];__[_[___]]=__[_[__ll]][_[_lll_]];_l=_l+_ll;_=__l[_l];__[_[_lll]]=__[_[_l_ll]][_[_ll__]];_l=_l+_ll;_=__l[_l];__[_[___l]]=__[_[__l_]][_[__l__]];_l=_l+_ll;_=__l[_l];_l_=_[__lll]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[_llll]))_l=_l+_ll;_=__l[_l];__[_[___l]][_[_llll]]=__[_[_l__l]];_l=_l+_ll;_=__l[_l];__[_[___l]]=____l[_[__ll]];_l=_l+_ll;_=__l[_l];__[_[__lll]]=___ll[_[__ll]];_l=_l+_ll;_=__l[_l];__[_[___l]]=__[_[__l_]][_[__ll_]];_l=_l+_ll;_=__l[_l];__[_[_lll]]=__[_[____]][_[__ll_]];_l=_l+_ll;_=__l[_l];__[_[_lll]]=__[_[__ll]][_[_ll__]];_l=_l+_ll;_=__l[_l];___l_={_,__};___l_[_l___][___l_[__l_l][_ll_]]=___l_[_l___][___l_[_ll][_llll]]+___l_[__l_l][__ll_];_l=_l+_ll;_=__l[_l];_l_=_[_l__]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[__l_]))_l=_l+_ll;_=__l[_l];__[_[__lll]][_[__ll]]=__[_[__ll_]];_l=_l+_ll;_=__l[_l];_l=_[_l_l];break end while(_l_)/((158080/0x98))==915 do __[_[___]]=(_[_llll]~=0);_l=_l+__l_l;break end;break;end break;end while(_l_)/(((3133+-0x12)+-#[[Guys help theyve captured me and lock me inside the obfuscator!!!! debofuscate quick to save me]]))==1724 do _l_=(2701020)while(-0x38+115)>=___l_ do _l_-= _l_ _l_=(4628832)while ___l_>(132-0x4a)do _l_-= _l_ local ____l;local _l_;__[_[___l]]=___ll[_[__ll]];_l=_l+_ll;_=__l[_l];__[_[_lll]]=_[____];_l=_l+_ll;_=__l[_l];__[_[_l__]]=_[__l_];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=_[_l_ll];_l=_l+_ll;_=__l[_l];_l_=_[_lll]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[____]))_l=_l+_ll;_=__l[_l];_l_=_[___l]__[_l_]=__[_l_](__[_l_+__l_l])_l=_l+_ll;_=__l[_l];__[_[___]][_[__l_]]=_[_ll__];_l=_l+_ll;_=__l[_l];__[_[___l]]=___ll[_[__ll]];_l=_l+_ll;_=__l[_l];__[_[___]]=__[_[____]][_[_l_l_]];_l=_l+_ll;_=__l[_l];__[_[__lll]]=__[_[_l_l]][_[__ll_]];_l=_l+_ll;_=__l[_l];__[_[___]][_[_l_l]]=__[_[_l_l_]];_l=_l+_ll;_=__l[_l];__[_[_lll]][_[_l_ll]]=_[_ll__];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=___ll[_[_l_l]];_l=_l+_ll;_=__l[_l];__[_[___]]=__[_[_l_l]][_[__ll_]];_l=_l+_ll;_=__l[_l];__[_[___]]=__[_[__l_]][_[_l__l]];_l=_l+_ll;_=__l[_l];__[_[_lll]]=__[_[__l_]][_[_lll_]];_l=_l+_ll;_=__l[_l];_l_=_[__lll]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[_llll]))_l=_l+_ll;_=__l[_l];__[_[___l]][_[_llll]]=__[_[__ll_]];_l=_l+_ll;_=__l[_l];__[_[___l]]=___ll[_[_llll]];_l=_l+_ll;_=__l[_l];__[_[___l]]=__[_[_l_l]][_[_ll__]];_l=_l+_ll;_=__l[_l];__[_[_lll]]=__[_[_l_ll]][_[__l__]];_l=_l+_ll;_=__l[_l];__[_[__lll]]=__[_[__ll]][_[_lll_]];_l=_l+_ll;_=__l[_l];____l={_,__};____l[_l___][____l[__l_l][__lll]]=____l[_l___][____l[_ll][_llll]]+____l[__l_l][_l_l_];_l=_l+_ll;_=__l[_l];_l_=_[___]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[____]))_l=_l+_ll;_=__l[_l];__[_[_l__]][_[_llll]]=__[_[__l__]];break end while(_l_)/((0x1d3a-3773))==1248 do local ___l_;local _____;local _l___;local _l_;_l_=_[___l];_l___=__[_[_l_ll]];__[_l_+1]=_l___;__[_l_]=_l___[_[_l_l_]];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=__[_[__ll]][_[_l_l_]];_l=_l+_ll;_=__l[_l];__[_[___]]=__[_[____]][_[__l__]];_l=_l+_ll;_=__l[_l];__[_[___]]=__[_[_llll]][_[_ll__]];_l=_l+_ll;_=__l[_l];_l_=_[_ll_]_____={__[_l_](_ll_l(__,_l_+1,_[__l_]))};___l_=0;for _=_l_,_[__ll_]do ___l_=___l_+_ll;__[_]=_____[___l_];end _l=_l+_ll;_=__l[_l];__[_[___l]]=____l[_[__l_]];_l=_l+_ll;_=__l[_l];_l_=_[_lll];_l___=__[_[_l_l]];__[_l_+1]=_l___;__[_l_]=_l___[_[__ll_]];_l=_l+_ll;_=__l[_l];__[_[___l]]=__[_[____]][_[_l__l]];_l=_l+_ll;_=__l[_l];__[_[___]]=__[_[_l_l]][_[_l__l]];_l=_l+_ll;_=__l[_l];__[_[___]]=__[_[__ll]][_[_l__l]];_l=_l+_ll;_=__l[_l];_l_=_[_lll]_____={__[_l_](_ll_l(__,_l_+1,_[_llll]))};___l_=0;for _=_l_,_[_ll__]do ___l_=___l_+_ll;__[_]=_____[___l_];end _l=_l+_ll;_=__l[_l];__[_[_l__]]=____l[_[_l_l]];_l=_l+_ll;_=__l[_l];_l_=_[_lll];_l___=__[_[____]];__[_l_+1]=_l___;__[_l_]=_l___[_[_l__l]];_l=_l+_ll;_=__l[_l];__[_[_lll]]=__[_[_l_l]][_[_l__l]];_l=_l+_ll;_=__l[_l];__[_[_lll]]=___ll[_[____]];_l=_l+_ll;_=__l[_l];__[_[___]]=_[_llll];_l=_l+_ll;_=__l[_l];__[_[___]]=_[_l_ll];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=_[_l_l];_l=_l+_ll;_=__l[_l];_l_=_[___]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[__ll]))_l=_l+_ll;_=__l[_l];__[_[_ll_]]=__[_[__l_]][__[_[_lll_]]];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=__[_[_l_l]][_[__l__]];_l=_l+_ll;_=__l[_l];_l_=_[_ll_]_____={__[_l_](_ll_l(__,_l_+1,_[____]))};___l_=0;for _=_l_,_[_lll_]do ___l_=___l_+_ll;__[_]=_____[___l_];end _l=_l+_ll;_=__l[_l];__[_[_lll]]=____l[_[__l_]];_l=_l+_ll;_=__l[_l];_l_=_[_l__];_l___=__[_[__l_]];__[_l_+1]=_l___;__[_l_]=_l___[_[_ll__]];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=__[_[_l_l]][_[_l__l]];_l=_l+_ll;_=__l[_l];__[_[___]]=___ll[_[__l_]];_l=_l+_ll;_=__l[_l];__[_[___l]]=_[__ll];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=_[__ll];_l=_l+_ll;_=__l[_l];__[_[_lll]]=_[____];_l=_l+_ll;_=__l[_l];_l_=_[_ll_]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[__ll]))_l=_l+_ll;_=__l[_l];__[_[___]]=__[_[__l_]][__[_[_ll__]]];_l=_l+_ll;_=__l[_l];__[_[___]]=__[_[__l_]][_[_l_l_]];_l=_l+_ll;_=__l[_l];_l_=_[_l__]_____={__[_l_](_ll_l(__,_l_+1,_[____]))};___l_=0;for _=_l_,_[__ll_]do ___l_=___l_+_ll;__[_]=_____[___l_];end _l=_l+_ll;_=__l[_l];__[_[___]]=____l[_[__ll]];_l=_l+_ll;_=__l[_l];_l_=_[_ll_];_l___=__[_[_l_ll]];__[_l_+1]=_l___;__[_l_]=_l___[_[__ll_]];_l=_l+_ll;_=__l[_l];__[_[___l]]=__[_[__ll]][_[_ll__]];_l=_l+_ll;_=__l[_l];__[_[_lll]]=___ll[_[_l_l]];_l=_l+_ll;_=__l[_l];__[_[___l]]=_[__ll];_l=_l+_ll;_=__l[_l];__[_[__lll]]=_[_l_l];_l=_l+_ll;_=__l[_l];__[_[__lll]]=_[_l_ll];_l=_l+_ll;_=__l[_l];_l_=_[_l__]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[__l_]))_l=_l+_ll;_=__l[_l];__[_[___l]]=__[_[__ll]][__[_[_lll_]]];_l=_l+_ll;_=__l[_l];__[_[___l]]=__[_[__l_]][_[__ll_]];_l=_l+_ll;_=__l[_l];_l_=_[_lll]_____={__[_l_](_ll_l(__,_l_+1,_[_l_l]))};___l_=0;for _=_l_,_[_ll__]do ___l_=___l_+_ll;__[_]=_____[___l_];end _l=_l+_ll;_=__l[_l];__[_[_lll]]=____l[_[_l_l]];_l=_l+_ll;_=__l[_l];_l_=_[___];_l___=__[_[__ll]];__[_l_+1]=_l___;__[_l_]=_l___[_[_l__l]];_l=_l+_ll;_=__l[_l];__[_[_lll]]=__[_[__ll]][_[__ll_]];_l=_l+_ll;_=__l[_l];__[_[___]]=___ll[_[__ll]];_l=_l+_ll;_=__l[_l];__[_[_l__]]=_[__ll];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=_[_l_ll];_l=_l+_ll;_=__l[_l];__[_[_lll]]=_[__ll];_l=_l+_ll;_=__l[_l];_l_=_[___l]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[____]))_l=_l+_ll;_=__l[_l];__[_[_l__]]=__[_[__l_]][__[_[_lll_]]];_l=_l+_ll;_=__l[_l];__[_[_l__]]=__[_[__ll]][_[__l__]];_l=_l+_ll;_=__l[_l];_l_=_[_l__]_____={__[_l_](_ll_l(__,_l_+1,_[_llll]))};___l_=0;for _=_l_,_[_l__l]do ___l_=___l_+_ll;__[_]=_____[___l_];end _l=_l+_ll;_=__l[_l];__[_[_lll]]=___ll[_[_l_l]];_l=_l+_ll;_=__l[_l];__[_[___l]]=__[_[_l_l]][_[__l__]];_l=_l+_ll;_=__l[_l];__[_[_lll]]=___ll[_[_llll]];_l=_l+_ll;_=__l[_l];__[_[_lll]]=_[__ll];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=_[__l_];_l=_l+_ll;_=__l[_l];__[_[_lll]]=_[__ll];_l=_l+_ll;_=__l[_l];_l_=_[___l]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[_l_ll]))_l=_l+_ll;_=__l[_l];_l_=_[__lll]__[_l_]=__[_l_](__[_l_+__l_l])_l=_l+_ll;_=__l[_l];__[_[__lll]][_[____]]=_[_l__l];_l=_l+_ll;_=__l[_l];__[_[___l]]=___ll[_[_l_l]];_l=_l+_ll;_=__l[_l];__[_[___]]=__[_[_l_ll]][_[_ll__]];_l=_l+_ll;_=__l[_l];__[_[___l]]=__[_[_l_l]][_[__ll_]];_l=_l+_ll;_=__l[_l];__[_[___]][_[_l_ll]]=__[_[__ll_]];_l=_l+_ll;_=__l[_l];__[_[___l]][_[__l_]]=_[_l__l];_l=_l+_ll;_=__l[_l];__[_[_lll]]=___ll[_[_l_l]];_l=_l+_ll;_=__l[_l];__[_[_lll]]=__[_[__ll]][_[__l__]];_l=_l+_ll;_=__l[_l];__[_[_l__]]=__[_[__ll]][_[__ll_]];_l=_l+_ll;_=__l[_l];__[_[__lll]]=__[_[__l_]][_[_l__l]];_l=_l+_ll;_=__l[_l];_l_=_[_l__]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[____]))_l=_l+_ll;_=__l[_l];__[_[__lll]][_[__ll]]=__[_[_l__l]];_l=_l+_ll;_=__l[_l];__[_[_lll]]=___ll[_[_llll]];_l=_l+_ll;_=__l[_l];__[_[_l__]]=__[_[____]][_[__ll_]];_l=_l+_ll;_=__l[_l];__[_[___l]]=__[_[____]][_[_ll__]];_l=_l+_ll;_=__l[_l];__[_[___l]]=__[_[_l_l]][_[_l_l_]];_l=_l+_ll;_=__l[_l];_l_=_[___]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[_l_l]))break end;break;end while 826==(_l_)/((32700/0xa))do _l_=(12371550)while((0x1677/71)+-#'boy what the hell boy')>=___l_ do _l_-= _l_ local _={_,__};_[_l___][_[__l_l][__lll]]=_[_l___][_[_ll][__ll]]+_[__l_l][__l__];break;end while(_l_)/((0x1d2f-3778))==3350 do _l_=(2114052)while(-#[[trolled]]+(0xcc-136))<___l_ do _l_-= _l_ local _l_;__[_[_ll_]]=___ll[_[_llll]];_l=_l+_ll;_=__l[_l];__[_[___l]]=__[_[_l_ll]][_[_l_l_]];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=__[_[_l_l]][_[_ll__]];_l=_l+_ll;_=__l[_l];__[_[___]]=__[_[____]][_[_lll_]];_l=_l+_ll;_=__l[_l];_l_=_[__lll]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[____]))_l=_l+_ll;_=__l[_l];__[_[__lll]][_[_llll]]=__[_[_lll_]];_l=_l+_ll;_=__l[_l];__[_[_l__]]=____l[_[__ll]];_l=_l+_ll;_=__l[_l];__[_[_l__]]=___ll[_[_llll]];_l=_l+_ll;_=__l[_l];__[_[___l]]=__[_[__l_]][_[_l__l]];_l=_l+_ll;_=__l[_l];__[_[__lll]]=__[_[_llll]][_[__ll_]];_l=_l+_ll;_=__l[_l];__[_[_ll_]][_[_l_l]]=__[_[_l_l_]];_l=_l+_ll;_=__l[_l];_l=_[_l_l];break end while(_l_)/(((((0xcce-1668)+-#[[not using moonsec is like jumping of a bridge]])+-0x3b)+-#"the book continues: thy shall make the cock and ball torture"))==1462 do local _={__,_};_[__l_l][_[_l___][_lll]]=_[_ll][_[_l___][__l__]]+_[__l_l][_[_l___][__ll]];break end;break;end break;end break;end break;end while(_l_)/((462800/0x82))==2293 do _l_=(557510)while(0x313e/191)>=___l_ do _l_-= _l_ _l_=(191330)while ___l_<=(110+-0x2e)do _l_-= _l_ _l_=(4761476)while ___l_>(-#'did you solve the lua challenge yet?'+(0x122d/47))do _l_-= _l_ __[_[___]]=_l_lll(___lll[_[_l_l]],nil,___ll);break end while 1786==(_l_)/(((-0x2b+2726)+-#[[JayZone Likes Men]]))do local _ll=_[__lll];local _l_=__[_ll+2];local __l=__[_ll]+_l_;__[_ll]=__l;if(_l_>0)then if(__l<=__[_ll+1])then _l=_[_l_ll];__[_ll+3]=__l;end elseif(__l>=__[_ll+1])then _l=_[____];__[_ll+3]=__l;end break end;break;end while 530==(_l_)/((-#[[moonsec top]]+(42408/((0x1a3-265)+-#"PSU Deobfuscation Speedrun AnyPrecent WR"))))do _l_=(1822848)while(0xed-172)<___l_ do _l_-= _l_ local __lll;local _l_;__[_[___]]=___ll[_[_l_l]];_l=_l+_ll;_=__l[_l];__[_[___l]]=___ll[_[__ll]];_l=_l+_ll;_=__l[_l];__[_[___]]=_[__l_];_l=_l+_ll;_=__l[_l];__[_[_l__]]=_[__l_];_l=_l+_ll;_=__l[_l];__[_[_l__]]=_[____];_l=_l+_ll;_=__l[_l];_l_=_[_lll]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[____]))_l=_l+_ll;_=__l[_l];__[_[___]]=__[_[__ll]][__[_[__ll_]]];_l=_l+_ll;_=__l[_l];_l_=_[_ll_]__[_l_]=__[_l_](__[_l_+__l_l])_l=_l+_ll;_=__l[_l];__lll=__[_[__ll_]];if not __lll then _l=_l+__l_l;else __[_[___]]=__lll;_l=_[_llll];end;break end while(_l_)/((1233+((0xae-137)+-#"why do guys only want bitchy bimbos who walk all over them")))==1504 do local _l_;__[_[___l]]=___ll[_[_l_ll]];_l=_l+_ll;_=__l[_l];__[_[_lll]]=___ll[_[_l_ll]];_l=_l+_ll;_=__l[_l];__[_[__lll]]=_[_l_l];_l=_l+_ll;_=__l[_l];__[_[___l]]=_[__ll];_l=_l+_ll;_=__l[_l];__[_[__lll]]=_[_llll];_l=_l+_ll;_=__l[_l];_l_=_[___l]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[__l_]))_l=_l+_ll;_=__l[_l];__[_[_l__]]=__[_[_llll]][__[_[_l_l_]]];_l=_l+_ll;_=__l[_l];_l_=_[___]__[_l_]=__[_l_](__[_l_+__l_l])_l=_l+_ll;_=__l[_l];__[_[___]]=__[_[____]];_l=_l+_ll;_=__l[_l];_l=_[__l_];break end;break;end break;end while(_l_)/(((0x1f0-(26414/0x5e))+-#'paster haha paster'))==2830 do _l_=(13232384)while ___l_<=(((0x5ce2-11946)/102)+-#"perth thinks psu is bad (it is) and uses ms priv")do _l_-= _l_ _l_=(142740)while ___l_>(170-0x67)do _l_-= _l_ do return end;break end while(_l_)/((0x8dae/186))==732 do __[_[___]][__[_[_l_ll]]]=__[_[__ll_]];break end;break;end while 3256==(_l_)/((0x102e+-78))do _l_=(14758245)while ___l_<=(-#"reject psu return to moonsec"+(0xf6-149))do _l_-= _l_ local ____l;local _l___;local ___l_;local _l_;_l_=_[_lll];___l_=__[_[_l_ll]];__[_l_+1]=___l_;__[_l_]=___l_[_[_ll__]];_l=_l+_ll;_=__l[_l];__[_[_l__]]=__[_[__l_]][_[_l_l_]];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=__[_[_l_l]][_[__l__]];_l=_l+_ll;_=__l[_l];__[_[_lll]]=__[_[____]][_[__ll_]];_l=_l+_ll;_=__l[_l];_l_=_[__lll]_l___={__[_l_](_ll_l(__,_l_+1,_[_l_l]))};____l=0;for _=_l_,_[_ll__]do ____l=____l+_ll;__[_]=_l___[____l];end _l=_l+_ll;_=__l[_l];__[_[___]]=___ll[_[_l_ll]];_l=_l+_ll;_=__l[_l];__[_[___]]=__[_[_llll]][_[_l__l]];_l=_l+_ll;_=__l[_l];__[_[_lll]]=___ll[_[_l_ll]];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=_[____];_l=_l+_ll;_=__l[_l];__[_[__lll]]=_[_llll];_l=_l+_ll;_=__l[_l];__[_[__lll]]=_[____];_l=_l+_ll;_=__l[_l];_l_=_[_ll_]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[__l_]))_l=_l+_ll;_=__l[_l];_l_=_[___l]__[_l_]=__[_l_](__[_l_+__l_l])_l=_l+_ll;_=__l[_l];__[_[__lll]][_[_llll]]=_[_lll_];_l=_l+_ll;_=__l[_l];__[_[_lll]]=___ll[_[__ll]];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=__[_[____]][_[_l_l_]];_l=_l+_ll;_=__l[_l];__[_[_l__]]=__[_[_llll]][_[_l__l]];_l=_l+_ll;_=__l[_l];__[_[___]][_[__l_]]=__[_[_lll_]];_l=_l+_ll;_=__l[_l];__[_[_lll]]=___ll[_[_l_ll]];_l=_l+_ll;_=__l[_l];__[_[___l]]=__[_[__ll]][_[_ll__]];_l=_l+_ll;_=__l[_l];__[_[___l]]=__[_[_llll]][_[__ll_]];_l=_l+_ll;_=__l[_l];__[_[___]][_[_l_l]]=__[_[_l_l_]];_l=_l+_ll;_=__l[_l];__[_[__lll]]=___ll[_[__ll]];_l=_l+_ll;_=__l[_l];__[_[_lll]]=__[_[____]][_[_l_l_]];_l=_l+_ll;_=__l[_l];__[_[__lll]]=__[_[_llll]][_[__l__]];_l=_l+_ll;_=__l[_l];__[_[_lll]][_[_l_ll]]=__[_[_ll__]];_l=_l+_ll;_=__l[_l];__[_[___]][_[__l_]]=_[_l_l_];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=___ll[_[__l_]];_l=_l+_ll;_=__l[_l];__[_[___l]]=__[_[_l_l]][_[_lll_]];_l=_l+_ll;_=__l[_l];__[_[_lll]]=__[_[_l_ll]][_[_l__l]];_l=_l+_ll;_=__l[_l];__[_[__lll]]=__[_[_l_ll]][_[__ll_]];_l=_l+_ll;_=__l[_l];_l_=_[___]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[_llll]))_l=_l+_ll;_=__l[_l];__[_[___l]][_[_l_l]]=__[_[__ll_]];break;end while 3741==(_l_)/((-#"how to opcode"+(0x1f4f-4057)))do _l_=(7818690)while ___l_>(-#[[This file has been enchanted with uncrackable V, fuck the fuck off]]+(339-(-#"broooo u/thatHEXdude slapped the server"+(0x24d-347))))do _l_-= _l_ __[_[__lll]]=__[_[__ll]]%_[_l__l];break end while 2838==(_l_)/(((359060/0x82)+-#[[bitcoin]]))do local _ll=_[__l_];local _l=__[_ll]for _=_ll+1,_[_lll_]do _l=_l..__[_];end;__[_[_l__]]=_l;break end;break;end break;end break;end break;end break;end break;end break;end while(_l_)/((-#'obfuscated with proxide shitting utilities'+(5808-0xb65)))==990 do _l_=(3359800)while(0x140-213)>=___l_ do _l_-= _l_ _l_=(295256)while(0x3de2/178)>=___l_ do _l_-= _l_ _l_=(648634)while(0x1450/65)>=___l_ do _l_-= _l_ _l_=(148732)while(1650/0x16)>=___l_ do _l_-= _l_ _l_=(7690320)while ___l_<=(-0x3c+133)do _l_-= _l_ _l_=(2180893)while(6264/(-#'Gav is shitty'+(125+-0x19)))<___l_ do _l_-= _l_ __[_[__lll]]=_[__ll];break end while(_l_)/((0xd1e-1697))==1313 do _l=_[_l_l];break end;break;end while 2913==(_l_)/((0xa7b+-43))do _l_=(2398275)while ___l_>((-21+0x6f)+-#[[balls in ur jawz]])do _l_-= _l_ __[_[_lll]][_[_llll]]=_[__l__];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=____l[_[__l_]];_l=_l+_ll;_=__l[_l];__[_[_l__]][_[____]]=_[__ll_];_l=_l+_ll;_=__l[_l];__[_[_lll]]=____l[_[____]];_l=_l+_ll;_=__l[_l];__[_[___]][_[__ll]]=_[_l_l_];_l=_l+_ll;_=__l[_l];__[_[_l__]]=____l[_[__ll]];_l=_l+_ll;_=__l[_l];__[_[___l]][_[__l_]]=_[_lll_];_l=_l+_ll;_=__l[_l];__[_[_lll]]=____l[_[_l_ll]];_l=_l+_ll;_=__l[_l];__[_[___]][_[__l_]]=_[_lll_];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=____l[_[__ll]];_l=_l+_ll;_=__l[_l];__[_[___]][_[__l_]]=_[_lll_];_l=_l+_ll;_=__l[_l];__[_[_lll]]=____l[_[_l_ll]];_l=_l+_ll;_=__l[_l];__[_[___l]][_[_l_l]]=_[_ll__];_l=_l+_ll;_=__l[_l];__[_[___l]]=____l[_[__l_]];_l=_l+_ll;_=__l[_l];__[_[___l]][_[_l_l]]=_[_lll_];_l=_l+_ll;_=__l[_l];__[_[_l__]]=____l[_[____]];_l=_l+_ll;_=__l[_l];__[_[___]][_[__l_]]=_[__l__];_l=_l+_ll;_=__l[_l];__[_[___l]]=____l[_[__ll]];_l=_l+_ll;_=__l[_l];__[_[__lll]][_[____]]=_[_ll__];_l=_l+_ll;_=__l[_l];__[_[_l__]]=____l[_[____]];_l=_l+_ll;_=__l[_l];__[_[___l]][_[_l_l]]=_[_l__l];break end while(_l_)/((-#[[<@!847154787934011462> shut the fuck up]]+(25974/0x27)))==3825 do local _lll;local _l_;__[_[_l__]]=___ll[_[_l_l]];_l=_l+_ll;_=__l[_l];_l_=_[___l];_lll=__[_[__ll]];__[_l_+1]=_lll;__[_l_]=_lll[_[_l__l]];_l=_l+_ll;_=__l[_l];__[_[__lll]]=___ll[_[__l_]];_l=_l+_ll;_=__l[_l];__[_[__lll]]=_[__ll];_l=_l+_ll;_=__l[_l];__[_[___l]]=_[_l_ll];_l=_l+_ll;_=__l[_l];__[_[__lll]]=_[__l_];_l=_l+_ll;_=__l[_l];_l_=_[__lll]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[_l_ll]))_l=_l+_ll;_=__l[_l];_l_=_[___]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[_l_l]))_l=_l+_ll;_=__l[_l];__[_[_l__]]=__[_[_llll]][_[_lll_]];_l=_l+_ll;_=__l[_l];_l_=_[__lll];_lll=__[_[_l_ll]];__[_l_+1]=_lll;__[_l_]=_lll[_[_l_l_]];break end;break;end break;end while(_l_)/((0x6c95/(0xeb-158)))==412 do _l_=(3029915)while ___l_<=(-62+0x8b)do _l_-= _l_ _l_=(5845251)while((355-(0x63c0/114))+-#[[federal u suck let me do fucking emojis in here asshole]])<___l_ do _l_-= _l_ if(__[_[___l]]~=__[_[__ll_]])then _l=_l+__l_l;else _l=_[__ll];end;break end while(_l_)/((0x14b75/53))==3651 do __[_[_l__]][_[__ll]]=__[_[_l_l_]];break end;break;end while 745==(_l_)/(((-#[[sorry i am not gay but ur dad kinda hot]]+(168580142/0xb5))/229))do _l_=(575532)while ___l_<=(151+-0x49)do _l_-= _l_ ___ll[_[__ll]]=__[_[___l]];_l=_l+_ll;_=__l[_l];__[_[_lll]]={};_l=_l+_ll;_=__l[_l];__[_[_lll]]={};_l=_l+_ll;_=__l[_l];___ll[_[__l_]]=__[_[_lll]];_l=_l+_ll;_=__l[_l];__[_[___l]]=___ll[_[__l_]];_l=_l+_ll;_=__l[_l];if(__[_[___]]==_[_ll__])then _l=_l+__l_l;else _l=_[_llll];end;break;end while 3942==(_l_)/((0x18e-252))do _l_=(5057485)while ___l_>((0x169-237)+-#[[What is an upvalue?!? Answer the question!?*1]])do _l_-= _l_ local __l=_[___];local ___=_[__ll_];local _l_=__l+2 local __l={__[__l](__[__l+1],__[_l_])};for _=1,___ do __[_l_+_]=__l[_];end;local __l=__l[1]if __l then __[_l_]=__l _l=_[____];else _l=_l+_ll;end;break end while(_l_)/((-#[[perth vs memcorrupt boxing match]]+((1290096/0x11)/0x30)))==3265 do local ___l_;local _l_;__[_[_l__]]=___ll[_[__ll]];_l=_l+_ll;_=__l[_l];__[_[__lll]]=__[_[_llll]][_[_ll__]];_l=_l+_ll;_=__l[_l];__[_[___l]]=__[_[_llll]][_[_ll__]];_l=_l+_ll;_=__l[_l];__[_[__lll]]=__[_[__l_]][_[__ll_]];_l=_l+_ll;_=__l[_l];_l_=_[_l__]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[_l_ll]))_l=_l+_ll;_=__l[_l];__[_[_l__]][_[_l_ll]]=__[_[_lll_]];_l=_l+_ll;_=__l[_l];__[_[___l]]=____l[_[__l_]];_l=_l+_ll;_=__l[_l];__[_[_lll]]=___ll[_[_l_ll]];_l=_l+_ll;_=__l[_l];__[_[_l__]]=__[_[_llll]][_[__ll_]];_l=_l+_ll;_=__l[_l];__[_[___l]]=__[_[__l_]][_[_l_l_]];_l=_l+_ll;_=__l[_l];__[_[___l]]=__[_[_llll]][_[_lll_]];_l=_l+_ll;_=__l[_l];_l_=_[___]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[_l_l]))_l=_l+_ll;_=__l[_l];__[_[___l]][_[__l_]]=__[_[_l__l]];_l=_l+_ll;_=__l[_l];__[_[_lll]]=____l[_[__l_]];_l=_l+_ll;_=__l[_l];__[_[_l__]][_[____]]=_[_ll__];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=____l[_[__ll]];_l=_l+_ll;_=__l[_l];__[_[___]]=___ll[_[_llll]];_l=_l+_ll;_=__l[_l];__[_[_l__]]=__[_[__ll]][_[_l__l]];_l=_l+_ll;_=__l[_l];__[_[__lll]]=__[_[____]][_[_l__l]];_l=_l+_ll;_=__l[_l];__[_[_lll]]=__[_[__l_]][_[__l__]];_l=_l+_ll;_=__l[_l];_l_=_[_lll]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[_l_l]))_l=_l+_ll;_=__l[_l];__[_[_l__]][_[____]]=__[_[__l__]];_l=_l+_ll;_=__l[_l];__[_[___l]]=____l[_[__ll]];_l=_l+_ll;_=__l[_l];__[_[_l__]]=___ll[_[_l_l]];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=__[_[__l_]][_[_l_l_]];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=__[_[_l_ll]][_[__l__]];_l=_l+_ll;_=__l[_l];__[_[___]]=__[_[_l_ll]][_[_ll__]];_l=_l+_ll;_=__l[_l];_l_=_[__lll]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[____]))_l=_l+_ll;_=__l[_l];__[_[_l__]][_[____]]=__[_[_lll_]];_l=_l+_ll;_=__l[_l];__[_[___l]]=____l[_[__l_]];_l=_l+_ll;_=__l[_l];__[_[_l__]][_[__l_]]=_[__ll_];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=____l[_[__ll]];_l=_l+_ll;_=__l[_l];__[_[_l__]][_[_l_l]]=_[_lll_];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=____l[_[__ll]];_l=_l+_ll;_=__l[_l];__[_[_l__]]=___ll[_[_l_l]];_l=_l+_ll;_=__l[_l];__[_[__lll]]=__[_[_llll]][_[_ll__]];_l=_l+_ll;_=__l[_l];__[_[___]]=__[_[__ll]][_[__ll_]];_l=_l+_ll;_=__l[_l];__[_[__lll]]=__[_[_l_l]][_[_l__l]];_l=_l+_ll;_=__l[_l];_l_=_[___l]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[__ll]))_l=_l+_ll;_=__l[_l];__[_[___l]][_[_l_l]]=__[_[__l__]];_l=_l+_ll;_=__l[_l];__[_[_l__]]=____l[_[_l_l]];_l=_l+_ll;_=__l[_l];__[_[_lll]]=___ll[_[__ll]];_l=_l+_ll;_=__l[_l];__[_[___l]]=__[_[_l_l]][_[_lll_]];_l=_l+_ll;_=__l[_l];__[_[___l]]=__[_[__l_]][_[_ll__]];_l=_l+_ll;_=__l[_l];__[_[_l__]]=__[_[__l_]][_[_lll_]];_l=_l+_ll;_=__l[_l];_l_=_[_l__]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[_llll]))_l=_l+_ll;_=__l[_l];__[_[_lll]][_[_llll]]=__[_[_lll_]];_l=_l+_ll;_=__l[_l];__[_[___l]]=____l[_[_l_l]];_l=_l+_ll;_=__l[_l];__[_[_l__]][_[____]]=_[__l__];_l=_l+_ll;_=__l[_l];__[_[_lll]]=____l[_[__l_]];_l=_l+_ll;_=__l[_l];__[_[_l__]]=___ll[_[__ll]];_l=_l+_ll;_=__l[_l];__[_[_lll]]=__[_[_l_l]][_[_lll_]];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=__[_[_l_l]][_[__l__]];_l=_l+_ll;_=__l[_l];__[_[_lll]]=__[_[_l_l]][_[_l__l]];_l=_l+_ll;_=__l[_l];_l_=_[_l__]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[__ll]))_l=_l+_ll;_=__l[_l];__[_[_lll]][_[____]]=__[_[_l_l_]];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=____l[_[__ll]];_l=_l+_ll;_=__l[_l];__[_[_l__]]=___ll[_[_l_ll]];_l=_l+_ll;_=__l[_l];__[_[_lll]]=__[_[_l_ll]][_[_ll__]];_l=_l+_ll;_=__l[_l];__[_[___l]]=__[_[_l_l]][_[_l__l]];_l=_l+_ll;_=__l[_l];__[_[_l__]]=__[_[_llll]][_[_l_l_]];_l=_l+_ll;_=__l[_l];___l_={_,__};___l_[_l___][___l_[__l_l][_lll]]=___l_[_l___][___l_[_ll][____]]+___l_[__l_l][_l_l_];_l=_l+_ll;_=__l[_l];_l_=_[___l]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[____]))_l=_l+_ll;_=__l[_l];__[_[_l__]][_[__l_]]=__[_[_l_l_]];_l=_l+_ll;_=__l[_l];__[_[___l]]=____l[_[_llll]];_l=_l+_ll;_=__l[_l];__[_[___l]][_[_llll]]=_[__l__];_l=_l+_ll;_=__l[_l];__[_[_lll]]=____l[_[_llll]];_l=_l+_ll;_=__l[_l];__[_[_lll]]=___ll[_[__l_]];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=__[_[__l_]][_[__l__]];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=__[_[_llll]][_[_ll__]];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=__[_[_llll]][_[__l__]];_l=_l+_ll;_=__l[_l];_l_=_[_lll]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[__l_]))_l=_l+_ll;_=__l[_l];__[_[___]][_[__l_]]=__[_[_l_l_]];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=____l[_[_l_l]];_l=_l+_ll;_=__l[_l];__[_[___]]=___ll[_[_l_ll]];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=__[_[_l_ll]][_[_lll_]];_l=_l+_ll;_=__l[_l];__[_[___l]]=__[_[____]][_[__l__]];_l=_l+_ll;_=__l[_l];__[_[_lll]]=__[_[_l_l]][_[_l_l_]];_l=_l+_ll;_=__l[_l];___l_={_,__};___l_[_l___][___l_[__l_l][__lll]]=___l_[_l___][___l_[_ll][_l_l]]+___l_[__l_l][_lll_];_l=_l+_ll;_=__l[_l];_l_=_[_l__]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[__l_]))break end;break;end break;end break;end break;end while 749==(_l_)/((1786-0x398))do _l_=(6578709)while((-#'somebody play minecraft with lerebox please hes so lonely'+(0x810a/199))+-0x19)>=___l_ do _l_-= _l_ _l_=(5035888)while ___l_<=(-#[[moonsec pls add fivem choice]]+(0xfe6/37))do _l_-= _l_ _l_=(5243460)while ___l_>(-0x1b+108)do _l_-= _l_ __[_[__lll]]={};break end while 1866==(_l_)/((-#'Perth is taken by sor'+(0x1667-2904)))do local ___l_;local _l_;__[_[_ll_]]=____l[_[____]];_l=_l+_ll;_=__l[_l];__[_[__lll]][_[__l_]]=_[_lll_];_l=_l+_ll;_=__l[_l];__[_[___l]]=____l[_[_l_ll]];_l=_l+_ll;_=__l[_l];__[_[_lll]]=___ll[_[_l_ll]];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=__[_[____]][_[_ll__]];_l=_l+_ll;_=__l[_l];__[_[_lll]]=__[_[_llll]][_[_ll__]];_l=_l+_ll;_=__l[_l];__[_[__lll]]=__[_[_l_ll]][_[__ll_]];_l=_l+_ll;_=__l[_l];_l_=_[_l__]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[_l_ll]))_l=_l+_ll;_=__l[_l];__[_[___l]][_[__ll]]=__[_[_l__l]];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=____l[_[__l_]];_l=_l+_ll;_=__l[_l];__[_[___l]]=___ll[_[_l_ll]];_l=_l+_ll;_=__l[_l];__[_[_l__]]=__[_[_l_ll]][_[_l__l]];_l=_l+_ll;_=__l[_l];__[_[_lll]]=__[_[_l_l]][_[__ll_]];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=__[_[__l_]][_[_l_l_]];_l=_l+_ll;_=__l[_l];___l_={_,__};___l_[_l___][___l_[__l_l][___l]]=___l_[_l___][___l_[_ll][__ll]]+___l_[__l_l][_l__l];_l=_l+_ll;_=__l[_l];_l_=_[_l__]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[_llll]))_l=_l+_ll;_=__l[_l];__[_[_l__]][_[_l_ll]]=__[_[__ll_]];_l=_l+_ll;_=__l[_l];__[_[_l__]]=____l[_[__l_]];_l=_l+_ll;_=__l[_l];__[_[_l__]][_[__l_]]=_[__ll_];_l=_l+_ll;_=__l[_l];__[_[__lll]]=____l[_[__l_]];_l=_l+_ll;_=__l[_l];__[_[_lll]]=___ll[_[_l_ll]];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=__[_[__l_]][_[_l__l]];_l=_l+_ll;_=__l[_l];__[_[__lll]]=__[_[____]][_[__l__]];_l=_l+_ll;_=__l[_l];__[_[_lll]]=__[_[_l_l]][_[_l__l]];_l=_l+_ll;_=__l[_l];_l_=_[___]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[__ll]))_l=_l+_ll;_=__l[_l];__[_[_l__]][_[_l_l]]=__[_[_lll_]];_l=_l+_ll;_=__l[_l];__[_[___]]=____l[_[____]];_l=_l+_ll;_=__l[_l];__[_[___]]=___ll[_[__l_]];_l=_l+_ll;_=__l[_l];__[_[__lll]]=__[_[__ll]][_[_l_l_]];_l=_l+_ll;_=__l[_l];__[_[__lll]]=__[_[__ll]][_[__ll_]];_l=_l+_ll;_=__l[_l];__[_[___]]=__[_[____]][_[__ll_]];_l=_l+_ll;_=__l[_l];___l_={_,__};___l_[_l___][___l_[__l_l][_l__]]=___l_[_l___][___l_[_ll][_l_ll]]+___l_[__l_l][_l_l_];_l=_l+_ll;_=__l[_l];_l_=_[_l__]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[_l_ll]))_l=_l+_ll;_=__l[_l];__[_[___l]][_[__l_]]=__[_[__ll_]];_l=_l+_ll;_=__l[_l];__[_[_lll]]=____l[_[____]];_l=_l+_ll;_=__l[_l];__[_[_ll_]][_[____]]=_[_lll_];_l=_l+_ll;_=__l[_l];__[_[_lll]]=____l[_[__ll]];_l=_l+_ll;_=__l[_l];__[_[__lll]]=___ll[_[_l_ll]];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=__[_[_l_l]][_[_l__l]];_l=_l+_ll;_=__l[_l];__[_[__lll]]=__[_[_l_l]][_[_lll_]];_l=_l+_ll;_=__l[_l];__[_[___l]]=__[_[__ll]][_[_l_l_]];_l=_l+_ll;_=__l[_l];___l_={_,__};___l_[_l___][___l_[__l_l][_lll]]=___l_[_l___][___l_[_ll][_l_ll]]+___l_[__l_l][__ll_];_l=_l+_ll;_=__l[_l];_l_=_[_lll]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[_l_ll]))_l=_l+_ll;_=__l[_l];__[_[___l]][_[_l_l]]=__[_[__l__]];_l=_l+_ll;_=__l[_l];__[_[___]]=____l[_[_l_ll]];_l=_l+_ll;_=__l[_l];__[_[___]]=___ll[_[__ll]];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=__[_[____]][_[_l_l_]];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=__[_[__ll]][_[_l_l_]];_l=_l+_ll;_=__l[_l];__[_[__lll]]=__[_[_l_l]][_[_lll_]];_l=_l+_ll;_=__l[_l];_l_=_[_ll_]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[__l_]))_l=_l+_ll;_=__l[_l];__[_[_l__]][_[__l_]]=__[_[_lll_]];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=____l[_[_l_l]];_l=_l+_ll;_=__l[_l];__[_[___]][_[_llll]]=_[_l_l_];_l=_l+_ll;_=__l[_l];__[_[__lll]]=____l[_[__ll]];_l=_l+_ll;_=__l[_l];__[_[__lll]]=___ll[_[__l_]];_l=_l+_ll;_=__l[_l];__[_[_lll]]=__[_[__ll]][_[_l_l_]];_l=_l+_ll;_=__l[_l];__[_[___l]]=__[_[__ll]][_[_l_l_]];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=__[_[_llll]][_[_lll_]];_l=_l+_ll;_=__l[_l];___l_={_,__};___l_[_l___][___l_[__l_l][__lll]]=___l_[_l___][___l_[_ll][__l_]]+___l_[__l_l][_l__l];_l=_l+_ll;_=__l[_l];_l_=_[_lll]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[__l_]))_l=_l+_ll;_=__l[_l];__[_[_ll_]][_[__ll]]=__[_[__ll_]];_l=_l+_ll;_=__l[_l];__[_[_l__]]=____l[_[_llll]];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=___ll[_[____]];_l=_l+_ll;_=__l[_l];__[_[_lll]]=__[_[_l_ll]][_[_l_l_]];_l=_l+_ll;_=__l[_l];__[_[___l]]=__[_[__l_]][_[__ll_]];_l=_l+_ll;_=__l[_l];__[_[_lll]]=__[_[____]][_[_lll_]];_l=_l+_ll;_=__l[_l];_l_=_[___]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[__l_]))_l=_l+_ll;_=__l[_l];__[_[_l__]][_[_llll]]=__[_[_lll_]];_l=_l+_ll;_=__l[_l];__[_[_lll]]=____l[_[_llll]];_l=_l+_ll;_=__l[_l];__[_[_l__]][_[____]]=_[__ll_];_l=_l+_ll;_=__l[_l];__[_[___]]=____l[_[__ll]];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=___ll[_[____]];_l=_l+_ll;_=__l[_l];__[_[_lll]]=__[_[__ll]][_[__l__]];_l=_l+_ll;_=__l[_l];__[_[___l]]=__[_[_llll]][_[_lll_]];_l=_l+_ll;_=__l[_l];__[_[___l]]=__[_[____]][_[_ll__]];_l=_l+_ll;_=__l[_l];_l_=_[___]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[__l_]))_l=_l+_ll;_=__l[_l];__[_[__lll]][_[__l_]]=__[_[__l__]];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=____l[_[__l_]];_l=_l+_ll;_=__l[_l];__[_[__lll]]=___ll[_[__ll]];_l=_l+_ll;_=__l[_l];__[_[_lll]]=__[_[_l_l]][_[_ll__]];break end;break;end while 1562==(_l_)/((0x1990-3320))do _l_=(3238053)while(0x116-195)<___l_ do _l_-= _l_ local _ll=_[_lll];local __l=__[_ll]local _l_=__[_ll+2];if(_l_>0)then if(__l>__[_ll+1])then _l=_[__l_];else __[_ll+3]=__l;end elseif(__l<__[_ll+1])then _l=_[_l_ll];else __[_ll+3]=__l;end break end while(_l_)/((-#[[Federal was here...]]+(-0x11+2675)))==1227 do local _l=_[_l__]__[_l](_ll_l(__,_l+__l_l,_[_l_l]))break end;break;end break;end while(_l_)/((0x1a19-3390))==1999 do _l_=(519156)while(-#[[obfuscated with proxide shitting utilities]]+(0x180/3))>=___l_ do _l_-= _l_ _l_=(1081561)while((0xe4-(-#[[You know lua? name every metamethod - skids of v3rm]]+(0x8dc2/191)))+-#"sexy")<___l_ do _l_-= _l_ __[_[___]]=__[_[____]][__[_[_lll_]]];break end while(_l_)/((-#[[This file has been enchanted with uncrackable V, fuck the fuck off]]+(8157-0x1004)))==271 do local _=_[_ll_]__[_](__[_+__l_l])break end;break;end while 1254==(_l_)/(((-#[[One day ill make the onions cry]]+(-0x41be/198))+530))do _l_=(602794)while ___l_<=(193-0x6a)do _l_-= _l_ local _lll=___lll[_[_l_ll]];local ___;local _ll={};___=__ll_l({},{__index=function(_l,_)local _=_ll[_];return _[1][_[2]];end,__newindex=function(__,_,_l)local _=_ll[_]_[1][_[2]]=_l;end;});for _l_=1,_[_ll__]do _l=_l+__l_l;local _=__l[_l];if _[(28/0x1c)]==93 then _ll[_l_-1]={__,_[_l_ll]};else _ll[_l_-1]={____l,_[_llll]};end;_lllll[#_lllll+1]=_ll;end;__[_[___l]]=_l_lll(_lll,___,___ll);break;end while 1094==(_l_)/((-0x11+568))do _l_=(6462308)while(-#'This file has been disenchanted with grindstone, fuck the fuck off'+(406-0xfc))<___l_ do _l_-= _l_ do return __[_[_l__]]end break end while(_l_)/((0x8cc90/184))==2062 do local _l_;local _l_l;__[_[_lll]]=___ll[_[__ll]];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=_[_l_ll];_l=_l+_ll;_=__l[_l];__[_[___]]=_[__l_];_l=_l+_ll;_=__l[_l];_l_l=_[__l_];_l_=__[_l_l]for _=_l_l+1,_[_l_l_]do _l_=_l_..__[_];end;__[_[_lll]]=_l_;_l=_l+_ll;_=__l[_l];if not __[_[__lll]]then _l=_l+__l_l;else _l=_[_llll];end;break end;break;end break;end break;end break;end break;end while 2171==(_l_)/((-104+0xf0))do _l_=(11560)while ___l_<=((206+-0x48)+-#"free moonsec cracked download 2022!!")do _l_-= _l_ _l_=(6352893)while(-127+(-#[[Federal spilled out the milk]]+(0x9058/149)))>=___l_ do _l_-= _l_ _l_=(5346120)while ___l_<=(5551/0x3d)do _l_-= _l_ _l_=(1876996)while(158+-0x44)<___l_ do _l_-= _l_ local ___l;local __l_;local _l_l;local _ll_;local _l__;local _l_;___ll[_[__ll]]=__[_[__lll]];_l=_l+_ll;_=__l[_l];__[_[__lll]]=___ll[_[_llll]];_l=_l+_ll;_=__l[_l];__[_[__lll]]=__[_[_llll]][_[_ll__]];_l=_l+_ll;_=__l[_l];__[_[_lll]]=___ll[_[_llll]];_l=_l+_ll;_=__l[_l];_l_=_[__lll]__[_l_]=__[_l_](__[_l_+__l_l])_l=_l+_ll;_=__l[_l];__[_[___]]();_l=_l+_ll;_=__l[_l];_l_=_[___];_l__={};for _=1,#_lllll do _ll_=_lllll[_];for _=0,#_ll_ do _l_l=_ll_[_];__l_=_l_l[1];___l=_l_l[2];if __l_==__ and ___l>=_l_ then _l__[___l]=__l_[___l];_l_l[1]=_l__;end;end;end;break end while(_l_)/(((766+(-0x83+27))+-#"Brick Lucas Deez Peanuts"))==2942 do do return end;break end;break;end while 1495==(_l_)/(((7357-0xe83)+-#"This file has been enchanted with uncrackable V, fuck the fuck off"))do _l_=(657180)while(0x44a4/191)<___l_ do _l_-= _l_ __[_[__lll]]=__[_[_l_ll]];break end while 270==(_l_)/((4952-0x9d6))do __[_[_ll_]]=(_[____]~=0);_l=_l+__l_l;break end;break;end break;end while 1941==(_l_)/((-#'proxide is epic'+(-0x6a+3394)))do _l_=(441000)while ___l_<=(209+-0x72)do _l_-= _l_ _l_=(1335188)while ___l_>(0x51e2/223)do _l_-= _l_ __[_[___]][__[_[____]]]=__[_[__l__]];break end while 541==(_l_)/(((5028-0x9e9)+-#"I am eq opcode lmaooooo"))do __[_[___]]();break end;break;end while(_l_)/(((0x5724c/180)+-#[[Consume the Cum Chalice]]))==225 do _l_=(7356384)while(16128/0xa8)>=___l_ do _l_-= _l_ if(__[_[__lll]]==_[_lll_])then _l=_l+__l_l;else _l=_[__ll];end;break;end while 3738==(_l_)/((-120+0x828))do _l_=(7572246)while ___l_>(0xee-141)do _l_-= _l_ local __ll;local __lll;local ___;local __l_;local _l_ll;local _l_;___ll[_[_l_l]]=__[_[___l]];_l=_l+_ll;_=__l[_l];__[_[_lll]]=___ll[_[____]];_l=_l+_ll;_=__l[_l];__[_[_l__]]=__[_[_llll]][_[_ll__]];_l=_l+_ll;_=__l[_l];__[_[_lll]]=___ll[_[_l_l]];_l=_l+_ll;_=__l[_l];_l_=_[_l__]__[_l_]=__[_l_](__[_l_+__l_l])_l=_l+_ll;_=__l[_l];__[_[_ll_]]();_l=_l+_ll;_=__l[_l];_l_=_[_lll];_l_ll={};for _=1,#_lllll do __l_=_lllll[_];for _=0,#__l_ do ___=__l_[_];__lll=___[1];__ll=___[2];if __lll==__ and __ll>=_l_ then _l_ll[__ll]=__lll[__ll];___[1]=_l_ll;end;end;end;break end while 2046==(_l_)/((-#[[<@847154787934011462> stupid ass]]+(-107+0xf00)))do local ____l;local _l___;local ___l_;local _l_;_l_=_[__lll];___l_=__[_[__l_]];__[_l_+1]=___l_;__[_l_]=___l_[_[_lll_]];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=__[_[_l_ll]][_[_l_l_]];_l=_l+_ll;_=__l[_l];__[_[___l]]=__[_[__ll]][_[_l_l_]];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=__[_[_l_l]][_[_l_l_]];_l=_l+_ll;_=__l[_l];_l_=_[__lll]_l___={__[_l_](_ll_l(__,_l_+1,_[____]))};____l=0;for _=_l_,_[_lll_]do ____l=____l+_ll;__[_]=_l___[____l];end _l=_l+_ll;_=__l[_l];__[_[_ll_]]=___ll[_[_llll]];_l=_l+_ll;_=__l[_l];__[_[_l__]]=__[_[____]][_[_ll__]];_l=_l+_ll;_=__l[_l];__[_[__lll]]=___ll[_[__l_]];_l=_l+_ll;_=__l[_l];__[_[__lll]]=_[_llll];_l=_l+_ll;_=__l[_l];__[_[___]]=_[__ll];_l=_l+_ll;_=__l[_l];__[_[___]]=_[_l_ll];_l=_l+_ll;_=__l[_l];_l_=_[_lll]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[____]))_l=_l+_ll;_=__l[_l];_l_=_[_ll_]__[_l_]=__[_l_](__[_l_+__l_l])_l=_l+_ll;_=__l[_l];__[_[_l__]][_[_l_ll]]=_[_l__l];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=___ll[_[__l_]];_l=_l+_ll;_=__l[_l];__[_[_l__]]=__[_[_l_ll]][_[__ll_]];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=__[_[__l_]][_[_lll_]];_l=_l+_ll;_=__l[_l];__[_[___l]][_[__l_]]=__[_[_l_l_]];_l=_l+_ll;_=__l[_l];__[_[___]]=___ll[_[__ll]];_l=_l+_ll;_=__l[_l];__[_[_lll]]=__[_[__ll]][_[_l__l]];_l=_l+_ll;_=__l[_l];__[_[___]]=__[_[_l_ll]][_[_ll__]];_l=_l+_ll;_=__l[_l];__[_[_lll]][_[__l_]]=__[_[_ll__]];_l=_l+_ll;_=__l[_l];__[_[___]]=___ll[_[__l_]];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=__[_[_llll]][_[_ll__]];_l=_l+_ll;_=__l[_l];__[_[___]]=__[_[_l_l]][_[__ll_]];_l=_l+_ll;_=__l[_l];__[_[_ll_]][_[__ll]]=__[_[_lll_]];_l=_l+_ll;_=__l[_l];__[_[_lll]][_[_l_l]]=_[__l__];_l=_l+_ll;_=__l[_l];__[_[__lll]]=___ll[_[_l_ll]];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=__[_[____]][_[__l__]];_l=_l+_ll;_=__l[_l];__[_[___l]]=__[_[_l_l]][_[_l__l]];_l=_l+_ll;_=__l[_l];__[_[__lll]]=__[_[__ll]][_[__ll_]];_l=_l+_ll;_=__l[_l];_l_=_[___l]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[__l_]))_l=_l+_ll;_=__l[_l];__[_[_ll_]][_[_l_ll]]=__[_[_ll__]];break end;break;end break;end break;end break;end while 170==(_l_)/((0xf4-176))do _l_=(4709818)while(-#[[lepopo]]+(233-0x7d))>=___l_ do _l_-= _l_ _l_=(9395730)while(((-103+0x192)-0xbd)+-#'dump = nil')>=___l_ do _l_-= _l_ _l_=(2757888)while ___l_>(-#"Who is Joe?"+(((9654+-0x40)+-#[[Slowmode is enabled.]])/87))do _l_-= _l_ local _ll=_[__lll];local __l=__[_ll]local _l_=__[_ll+2];if(_l_>0)then if(__l>__[_ll+1])then _l=_[_l_ll];else __[_ll+3]=__l;end elseif(__l<__[_ll+1])then _l=_[__l_];else __[_ll+3]=__l;end break end while(_l_)/((340416/0xc5))==1596 do __[_[_l__]]=__[_[_l_ll]]%_[__l__];break end;break;end while 3105==(_l_)/((-#[[psu is shitty]]+(0x182d-3150)))do _l_=(1045620)while ___l_>(-#[[There is no such thing as a coincidence]]+(0x104+-120))do _l_-= _l_ __[_[__lll]]=__[_[____]][_[_l_l_]];break end while(_l_)/((-115+(0x3b376/198)))==942 do __[_[___l]]=__[_[__l_]][_[_l_l_]];break end;break;end break;end while 2038==(_l_)/(((-0xc8a/30)+0x972))do _l_=(271413)while ___l_<=(-#[[im giving 50k to the one who solves this challenge]]+(0x16c-210))do _l_-= _l_ _l_=(8602003)while ___l_>(0x5b55/227)do _l_-= _l_ local _l=_[_l__]__[_l]=__[_l](_ll_l(__,_l+_ll,_[____]))break end while 2711==(_l_)/((790077/0xf9))do local _=_[_l__]local __l,_l=__llll(__[_](__[_+__l_l]))_____=_l+_-_ll local _l=0;for _=_,_____ do _l=_l+_ll;__[_]=__l[_l];end;break end;break;end while(_l_)/((-#'This file has been enchanted with uncrackable V, fuck the fuck off'+((-27-0x7)+1807)))==159 do _l_=(737260)while ___l_<=(-#"If you see this string you are going to be sued by memcorrupt"+(-117+0x11b))do _l_-= _l_ if not __[_[__lll]]then _l=_l+__l_l;else _l=_[____];end;break;end while(_l_)/((3875+-0x37))==193 do _l_=(9609331)while(0x101-(-#[[guys i am epic hackerman i just converted a script to string.byte]]+(0x144+-108)))<___l_ do _l_-= _l_ __[_[_ll_]]=__[_[_l_ll]];break end while(_l_)/((0x86c1/9))==2507 do __[_[_lll]]=(_[_l_l]~=0);break end;break;end break;end break;end break;end break;end break;end while(_l_)/(((-#[[suck on my peanut]]+(535180-0x41573))/0xd5))==2675 do _l_=(963642)while ___l_<=(247+-0x7a)do _l_-= _l_ _l_=(6151856)while(345-0xe5)>=___l_ do _l_-= _l_ _l_=(129220)while ___l_<=((0x124-(0x1a2-243))+-#"string")do _l_-= _l_ _l_=(7221834)while ___l_<=(340-0xe7)do _l_-= _l_ _l_=(3881088)while ___l_>(13716/0x7f)do _l_-= _l_ if(__[_[_lll]]==__[_[_ll__]])then _l=_l+__l_l;else _l=_[____];end;break end while(_l_)/(((380848/0xd0)+-0x67))==2246 do local ____l;local _l_;__[_[__lll]]=___ll[_[_l_l]];_l=_l+_ll;_=__l[_l];__[_[___]]=_[_llll];_l=_l+_ll;_=__l[_l];__[_[_l__]]=_[_l_ll];_l=_l+_ll;_=__l[_l];__[_[___]]=_[__l_];_l=_l+_ll;_=__l[_l];_l_=_[___l]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[_llll]))_l=_l+_ll;_=__l[_l];_l_=_[_ll_]__[_l_]=__[_l_](__[_l_+__l_l])_l=_l+_ll;_=__l[_l];__[_[__lll]][_[__ll]]=_[_ll__];_l=_l+_ll;_=__l[_l];__[_[_l__]]=___ll[_[_llll]];_l=_l+_ll;_=__l[_l];__[_[_lll]]=__[_[__ll]][_[_lll_]];_l=_l+_ll;_=__l[_l];__[_[___l]]=__[_[____]][_[_lll_]];_l=_l+_ll;_=__l[_l];__[_[_lll]][_[__ll]]=__[_[_ll__]];_l=_l+_ll;_=__l[_l];__[_[___l]][_[_l_ll]]=_[_l__l];_l=_l+_ll;_=__l[_l];__[_[___]]=___ll[_[_l_ll]];_l=_l+_ll;_=__l[_l];__[_[_lll]]=__[_[__ll]][_[_l_l_]];_l=_l+_ll;_=__l[_l];__[_[___l]]=__[_[_llll]][_[_ll__]];_l=_l+_ll;_=__l[_l];__[_[_l__]]=__[_[__ll]][_[_ll__]];_l=_l+_ll;_=__l[_l];_l_=_[___]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[__l_]))_l=_l+_ll;_=__l[_l];__[_[__lll]][_[__ll]]=__[_[__ll_]];_l=_l+_ll;_=__l[_l];__[_[_l__]]=___ll[_[_llll]];_l=_l+_ll;_=__l[_l];__[_[_lll]]=__[_[__l_]][_[__ll_]];_l=_l+_ll;_=__l[_l];__[_[_lll]]=__[_[____]][_[_ll__]];_l=_l+_ll;_=__l[_l];__[_[_lll]]=__[_[_l_l]][_[__l__]];_l=_l+_ll;_=__l[_l];____l={_,__};____l[_l___][____l[__l_l][__lll]]=____l[_l___][____l[_ll][____]]+____l[__l_l][_l_l_];_l=_l+_ll;_=__l[_l];_l_=_[_lll]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[_l_l]))_l=_l+_ll;_=__l[_l];__[_[__lll]][_[_llll]]=__[_[__ll_]];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=___ll[_[_l_ll]];_l=_l+_ll;_=__l[_l];__[_[_lll]]=__[_[_l_ll]][_[_l__l]];_l=_l+_ll;_=__l[_l];__[_[___l]]=___ll[_[_llll]];_l=_l+_ll;_=__l[_l];__[_[___]]=_[____];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=_[__ll];_l=_l+_ll;_=__l[_l];__[_[__lll]]=_[____];_l=_l+_ll;_=__l[_l];_l_=_[___]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[____]))_l=_l+_ll;_=__l[_l];_l_=_[_l__]__[_l_]=__[_l_](__[_l_+__l_l])_l=_l+_ll;_=__l[_l];__[_[___]][_[__ll]]=_[__l__];_l=_l+_ll;_=__l[_l];__[_[__lll]]=___ll[_[_llll]];_l=_l+_ll;_=__l[_l];__[_[__lll]]=__[_[__l_]][_[_l__l]];_l=_l+_ll;_=__l[_l];__[_[___l]]=__[_[__ll]][_[_lll_]];_l=_l+_ll;_=__l[_l];__[_[_ll_]][_[_l_l]]=__[_[__l__]];_l=_l+_ll;_=__l[_l];__[_[___l]][_[_llll]]=_[_lll_];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=___ll[_[_l_l]];_l=_l+_ll;_=__l[_l];__[_[___l]]=__[_[_llll]][_[__l__]];_l=_l+_ll;_=__l[_l];__[_[_l__]]=__[_[_l_ll]][_[__l__]];_l=_l+_ll;_=__l[_l];__[_[_lll]]=__[_[____]][_[__l__]];_l=_l+_ll;_=__l[_l];_l_=_[___]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[____]))_l=_l+_ll;_=__l[_l];__[_[_lll]][_[_l_ll]]=__[_[_l__l]];_l=_l+_ll;_=__l[_l];__[_[_lll]]=___ll[_[__l_]];_l=_l+_ll;_=__l[_l];__[_[___l]]=__[_[_l_l]][_[_l__l]];_l=_l+_ll;_=__l[_l];__[_[___l]]=__[_[____]][_[_l__l]];_l=_l+_ll;_=__l[_l];__[_[___]]=__[_[____]][_[__l__]];_l=_l+_ll;_=__l[_l];____l={_,__};____l[_l___][____l[__l_l][___]]=____l[_l___][____l[_ll][____]]+____l[__l_l][_ll__];_l=_l+_ll;_=__l[_l];_l_=_[_ll_]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[____]))_l=_l+_ll;_=__l[_l];__[_[___]][_[_l_ll]]=__[_[_ll__]];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=___ll[_[__ll]];_l=_l+_ll;_=__l[_l];__[_[_lll]]=__[_[__l_]][_[__ll_]];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=___ll[_[__l_]];_l=_l+_ll;_=__l[_l];__[_[___l]]=_[_l_ll];_l=_l+_ll;_=__l[_l];__[_[__lll]]=_[_l_l];_l=_l+_ll;_=__l[_l];__[_[__lll]]=_[____];_l=_l+_ll;_=__l[_l];_l_=_[__lll]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[_llll]))_l=_l+_ll;_=__l[_l];_l_=_[__lll]__[_l_]=__[_l_](__[_l_+__l_l])_l=_l+_ll;_=__l[_l];__[_[_lll]][_[_l_l]]=_[_l__l];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=___ll[_[____]];_l=_l+_ll;_=__l[_l];__[_[_l__]]=__[_[____]][_[__l__]];_l=_l+_ll;_=__l[_l];__[_[__lll]]=__[_[__l_]][_[_l__l]];_l=_l+_ll;_=__l[_l];__[_[_lll]][_[__ll]]=__[_[_l_l_]];_l=_l+_ll;_=__l[_l];__[_[_ll_]][_[__l_]]=_[_lll_];_l=_l+_ll;_=__l[_l];__[_[_lll]]=___ll[_[__l_]];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=__[_[__l_]][_[__l__]];_l=_l+_ll;_=__l[_l];__[_[___]]=__[_[____]][_[_l_l_]];_l=_l+_ll;_=__l[_l];__[_[_lll]]=__[_[_l_l]][_[_l_l_]];_l=_l+_ll;_=__l[_l];_l_=_[___]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[__ll]))_l=_l+_ll;_=__l[_l];__[_[_l__]][_[_llll]]=__[_[_l_l_]];_l=_l+_ll;_=__l[_l];__[_[___]]=___ll[_[____]];_l=_l+_ll;_=__l[_l];__[_[_l__]]=__[_[_llll]][_[_ll__]];_l=_l+_ll;_=__l[_l];__[_[___]]=__[_[____]][_[__l__]];_l=_l+_ll;_=__l[_l];__[_[_l__]]=__[_[_l_l]][_[_lll_]];_l=_l+_ll;_=__l[_l];____l={_,__};____l[_l___][____l[__l_l][_l__]]=____l[_l___][____l[_ll][__ll]]+____l[__l_l][__l__];_l=_l+_ll;_=__l[_l];_l_=_[___l]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[_llll]))_l=_l+_ll;_=__l[_l];__[_[___]][_[__ll]]=__[_[__ll_]];_l=_l+_ll;_=__l[_l];__[_[___]]=___ll[_[_l_l]];break end;break;end while(_l_)/((5157-0xa47))==2859 do _l_=(817180)while(0xdb+-109)<___l_ do _l_-= _l_ __[_[_ll_]]=_l_lll(___lll[_[__l_]],nil,___ll);break end while(_l_)/((-#[[while true do end]]+(170422/0x5e)))==455 do __[_[_lll]]=(_[__l_]~=0);break end;break;end break;end while 1846==(_l_)/((0xf96/57))do _l_=(110079)while ___l_<=(-0x1f+144)do _l_-= _l_ _l_=(7205539)while ___l_>(0x1340/44)do _l_-= _l_ local __ll;local _l_;__[_[___l]]=___ll[_[__l_]];_l=_l+_ll;_=__l[_l];_l_=_[___];__ll=__[_[__l_]];__[_l_+1]=__ll;__[_l_]=__ll[_[_ll__]];_l=_l+_ll;_=__l[_l];__[_[_lll]]=___ll[_[__l_]];_l=_l+_ll;_=__l[_l];__[_[__lll]]=_[_l_ll];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=_[__l_];_l=_l+_ll;_=__l[_l];__[_[__lll]]=_[__l_];_l=_l+_ll;_=__l[_l];_l_=_[___l]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[_l_ll]))_l=_l+_ll;_=__l[_l];_l_=_[_l__]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[_llll]))_l=_l+_ll;_=__l[_l];__[_[_ll_]]=__[_[_llll]][_[__ll_]];_l=_l+_ll;_=__l[_l];_l_=_[_ll_];__ll=__[_[_llll]];__[_l_+1]=__ll;__[_l_]=__ll[_[_lll_]];break end while 1979==(_l_)/((7397-0xeac))do _l=_[_l_l];break end;break;end while 729==(_l_)/((195+-0x2c))do _l_=(6131652)while ___l_<=(0x105-147)do _l_-= _l_ local ____l;local _l_;__[_[___]]=___ll[_[_l_l]];_l=_l+_ll;_=__l[_l];__[_[_l__]]=_[_l_ll];_l=_l+_ll;_=__l[_l];__[_[_l__]]=_[__ll];_l=_l+_ll;_=__l[_l];__[_[__lll]]=_[_l_l];_l=_l+_ll;_=__l[_l];_l_=_[_l__]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[_l_l]))_l=_l+_ll;_=__l[_l];_l_=_[___l]__[_l_]=__[_l_](__[_l_+__l_l])_l=_l+_ll;_=__l[_l];__[_[_lll]][_[_l_ll]]=_[_l__l];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=___ll[_[_llll]];_l=_l+_ll;_=__l[_l];__[_[___l]]=__[_[_l_ll]][_[__l__]];_l=_l+_ll;_=__l[_l];__[_[___l]]=__[_[__ll]][_[_l_l_]];_l=_l+_ll;_=__l[_l];__[_[_l__]][_[_l_l]]=__[_[_ll__]];_l=_l+_ll;_=__l[_l];__[_[_l__]][_[_l_ll]]=_[__ll_];_l=_l+_ll;_=__l[_l];__[_[___]]=___ll[_[_l_ll]];_l=_l+_ll;_=__l[_l];__[_[___l]]=__[_[____]][_[_l_l_]];_l=_l+_ll;_=__l[_l];__[_[___]]=__[_[__l_]][_[_l__l]];_l=_l+_ll;_=__l[_l];__[_[__lll]]=__[_[_l_l]][_[_ll__]];_l=_l+_ll;_=__l[_l];____l={_,__};____l[_l___][____l[__l_l][_ll_]]=____l[_l___][____l[_ll][____]]+____l[__l_l][_l__l];_l=_l+_ll;_=__l[_l];_l_=_[___]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[_llll]))_l=_l+_ll;_=__l[_l];__[_[_ll_]][_[____]]=__[_[_lll_]];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=___ll[_[_llll]];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=__[_[_l_l]][_[_l__l]];_l=_l+_ll;_=__l[_l];__[_[_lll]]=__[_[_l_ll]][_[__l__]];_l=_l+_ll;_=__l[_l];__[_[___]]=__[_[__l_]][_[_lll_]];_l=_l+_ll;_=__l[_l];_l_=_[___l]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[__ll]))_l=_l+_ll;_=__l[_l];__[_[_lll]][_[__l_]]=__[_[__l__]];_l=_l+_ll;_=__l[_l];__[_[___]]=___ll[_[_llll]];_l=_l+_ll;_=__l[_l];__[_[_l__]]=__[_[__l_]][_[__l__]];_l=_l+_ll;_=__l[_l];__[_[___]]=___ll[_[_l_ll]];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=_[_l_l];_l=_l+_ll;_=__l[_l];__[_[_lll]]=_[____];_l=_l+_ll;_=__l[_l];__[_[___l]]=_[_llll];_l=_l+_ll;_=__l[_l];_l_=_[_ll_]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[__l_]))_l=_l+_ll;_=__l[_l];_l_=_[_l__]__[_l_]=__[_l_](__[_l_+__l_l])_l=_l+_ll;_=__l[_l];__[_[___l]][_[_l_ll]]=_[__l__];_l=_l+_ll;_=__l[_l];__[_[___l]]=___ll[_[__ll]];_l=_l+_ll;_=__l[_l];__[_[_lll]]=__[_[_l_ll]][_[__l__]];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=__[_[____]][_[_l__l]];_l=_l+_ll;_=__l[_l];__[_[___]][_[__ll]]=__[_[_ll__]];_l=_l+_ll;_=__l[_l];__[_[__lll]][_[__l_]]=_[__l__];_l=_l+_ll;_=__l[_l];__[_[__lll]]=___ll[_[__l_]];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=__[_[_llll]][_[__ll_]];_l=_l+_ll;_=__l[_l];__[_[_lll]]=__[_[__l_]][_[__ll_]];_l=_l+_ll;_=__l[_l];__[_[___]]=__[_[____]][_[__ll_]];_l=_l+_ll;_=__l[_l];____l={_,__};____l[_l___][____l[__l_l][___l]]=____l[_l___][____l[_ll][_l_l]]+____l[__l_l][_l_l_];_l=_l+_ll;_=__l[_l];_l_=_[_l__]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[__l_]))_l=_l+_ll;_=__l[_l];__[_[_lll]][_[_l_ll]]=__[_[__ll_]];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=___ll[_[_l_ll]];_l=_l+_ll;_=__l[_l];__[_[_lll]]=__[_[_llll]][_[_l__l]];_l=_l+_ll;_=__l[_l];__[_[_lll]]=__[_[_llll]][_[__l__]];_l=_l+_ll;_=__l[_l];__[_[_l__]]=__[_[_llll]][_[__ll_]];_l=_l+_ll;_=__l[_l];_l_=_[__lll]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[_l_ll]))_l=_l+_ll;_=__l[_l];__[_[_lll]][_[____]]=__[_[_lll_]];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=___ll[_[__l_]];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=__[_[____]][_[_ll__]];_l=_l+_ll;_=__l[_l];__[_[___l]]=___ll[_[____]];_l=_l+_ll;_=__l[_l];__[_[__lll]]=_[_llll];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=_[____];_l=_l+_ll;_=__l[_l];__[_[___]]=_[__l_];_l=_l+_ll;_=__l[_l];_l_=_[__lll]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[__l_]))_l=_l+_ll;_=__l[_l];_l_=_[_ll_]__[_l_]=__[_l_](__[_l_+__l_l])_l=_l+_ll;_=__l[_l];__[_[_ll_]][_[__l_]]=_[_lll_];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=___ll[_[_llll]];_l=_l+_ll;_=__l[_l];__[_[_lll]]=__[_[____]][_[__l__]];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=__[_[_l_ll]][_[_lll_]];_l=_l+_ll;_=__l[_l];__[_[__lll]][_[_llll]]=__[_[_ll__]];_l=_l+_ll;_=__l[_l];__[_[_lll]][_[__l_]]=_[__ll_];_l=_l+_ll;_=__l[_l];__[_[__lll]]=___ll[_[____]];_l=_l+_ll;_=__l[_l];__[_[___]]=__[_[_l_l]][_[_l_l_]];_l=_l+_ll;_=__l[_l];__[_[__lll]]=__[_[_l_l]][_[_ll__]];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=__[_[____]][_[_ll__]];_l=_l+_ll;_=__l[_l];_l_=_[_ll_]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[__l_]))_l=_l+_ll;_=__l[_l];__[_[__lll]][_[_l_l]]=__[_[_l__l]];_l=_l+_ll;_=__l[_l];__[_[__lll]]=___ll[_[_llll]];_l=_l+_ll;_=__l[_l];__[_[__lll]]=__[_[____]][_[__ll_]];_l=_l+_ll;_=__l[_l];__[_[___]]=__[_[__ll]][_[_lll_]];_l=_l+_ll;_=__l[_l];__[_[___l]]=__[_[_llll]][_[_l__l]];_l=_l+_ll;_=__l[_l];____l={_,__};____l[_l___][____l[__l_l][_lll]]=____l[_l___][____l[_ll][__l_]]+____l[__l_l][_l__l];_l=_l+_ll;_=__l[_l];_l_=_[___l]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[_llll]))_l=_l+_ll;_=__l[_l];__[_[___]][_[__l_]]=__[_[_lll_]];_l=_l+_ll;_=__l[_l];__[_[___l]]=___ll[_[__ll]];break;end while(_l_)/(((0x1f4d-(-0x3c+4104))+-#'If you see this string you are going to be sued by memcorrupt'))==1569 do _l_=(8611016)while ___l_>(0x11e-171)do _l_-= _l_ local _lll;local _l_;__[_[_l__]]=___ll[_[_l_ll]];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=___ll[_[_llll]];_l=_l+_ll;_=__l[_l];__[_[_l__]]=_[__ll];_l=_l+_ll;_=__l[_l];__[_[___]]=_[____];_l=_l+_ll;_=__l[_l];__[_[___l]]=_[_l_l];_l=_l+_ll;_=__l[_l];_l_=_[_ll_]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[_l_ll]))_l=_l+_ll;_=__l[_l];__[_[__lll]]=__[_[_l_l]][__[_[__l__]]];_l=_l+_ll;_=__l[_l];_l_=_[_l__]__[_l_]=__[_l_](__[_l_+__l_l])_l=_l+_ll;_=__l[_l];_lll=__[_[_lll_]];if not _lll then _l=_l+__l_l;else __[_[_l__]]=_lll;_l=_[_l_l];end;break end while(_l_)/((-#[[This file has been enchanted with uncrackable V, fuck the fuck off]]+(0x13d1-2569)))==3532 do local _l_;local ___;local ____,_l_ll;local _ll_;local _l_;__[_[__lll]]=___ll[_[_llll]];_l=_l+_ll;_=__l[_l];_l_=_[_l__];_ll_=__[_[__ll]];__[_l_+1]=_ll_;__[_l_]=_ll_[_[_ll__]];_l=_l+_ll;_=__l[_l];__[_[___l]]=_[_l_l];_l=_l+_ll;_=__l[_l];_l_=_[_lll]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[__l_]))_l=_l+_ll;_=__l[_l];_l_=_[__lll];_ll_=__[_[_llll]];__[_l_+1]=_ll_;__[_l_]=_ll_[_[__l__]];_l=_l+_ll;_=__l[_l];_l_=_[___l]____,_l_ll=__llll(__[_l_](__[_l_+__l_l]))_____=_l_ll+_l_-_ll ___=0;for _=_l_,_____ do ___=___+_ll;__[_]=____[___];end;_l=_l+_ll;_=__l[_l];_l_=_[_lll]____={__[_l_](_ll_l(__,_l_+1,_____))};___=0;for _=_l_,_[__l__]do ___=___+_ll;__[_]=____[___];end _l=_l+_ll;_=__l[_l];_l=_[_l_l];break end;break;end break;end break;end break;end while(_l_)/((197856/0x6c))==3358 do _l_=(1526141)while ___l_<=((-#"Moonsec win"+(304+-0x15))-152)do _l_-= _l_ _l_=(14468965)while(0xcc+-86)>=___l_ do _l_-= _l_ _l_=(9402525)while ___l_>(15210/0x82)do _l_-= _l_ local ___;local _l_;__[_[___l]]=___ll[_[_l_l]];_l=_l+_ll;_=__l[_l];_l_=_[_ll_];___=__[_[__l_]];__[_l_+1]=___;__[_l_]=___[_[_l__l]];_l=_l+_ll;_=__l[_l];__[_[_lll]]=___ll[_[_l_l]];_l=_l+_ll;_=__l[_l];__[_[_lll]]=_[_l_ll];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=_[____];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=_[_llll];_l=_l+_ll;_=__l[_l];_l_=_[_lll]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[_l_l]))_l=_l+_ll;_=__l[_l];_l_=_[__lll]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[_l_ll]))_l=_l+_ll;_=__l[_l];__[_[_lll]]=__[_[____]][_[_l__l]];_l=_l+_ll;_=__l[_l];_l_=_[_ll_];___=__[_[____]];__[_l_+1]=___;__[_l_]=___[_[_ll__]];break end while 2475==(_l_)/((-#"<@!847154787934011462> shut the fuck up@skid"+(0x1774b/25)))do if not __[_[___l]]then _l=_l+__l_l;else _l=_[_l_l];end;break end;break;end while(_l_)/((-0x64+4145))==3577 do _l_=(2490318)while ___l_>(20230/0xaa)do _l_-= _l_ __[_[_ll_]]=___ll[_[__ll]];break end while 3879==(_l_)/((1389-0x2eb))do local _l=_[_lll]local _l_={__[_l](_ll_l(__,_l+1,_[_l_ll]))};local __l=0;for _=_l,_[_l__l]do __l=__l+_ll;__[_]=_l_[__l];end break end;break;end break;end while(_l_)/((-#"This script was obfuscated by Herttfuscator"+((-81+0x7)+0x3bc)))==1819 do _l_=(6868416)while ___l_<=((0x1110/26)+-#"This is my kingdom cum, this is my kingdom cum")do _l_-= _l_ _l_=(4304104)while ___l_>(158+-0x25)do _l_-= _l_ local ____l;local _ll_;local _l__l;local _l_;__[_[___]]=___ll[_[_llll]];_l=_l+_ll;_=__l[_l];__[_[_lll]]=__[_[_l_l]][_[__l__]];_l=_l+_ll;_=__l[_l];_l_=_[__lll];_l__l=__[_[__ll]];__[_l_+1]=_l__l;__[_l_]=_l__l[_[__l__]];_l=_l+_ll;_=__l[_l];__[_[___l]]=__[_[__l_]];_l=_l+_ll;_=__l[_l];__[_[_lll]]=__[_[__ll]];_l=_l+_ll;_=__l[_l];_l_=_[___]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[_l_ll]))_l=_l+_ll;_=__l[_l];_l_=_[__lll];_l__l=__[_[__l_]];__[_l_+1]=_l__l;__[_l_]=_l__l[_[_lll_]];_l=_l+_ll;_=__l[_l];_l_=_[_lll]__[_l_]=__[_l_](__[_l_+__l_l])_l=_l+_ll;_=__l[_l];_ll_={__,_};_ll_[__l_l][_ll_[_l___][_l__]]=_ll_[_ll][_ll_[_l___][_lll_]]+_ll_[__l_l][_ll_[_l___][____]];_l=_l+_ll;_=__l[_l];__[_[___l]]=__[_[____]]%_[_l_l_];_l=_l+_ll;_=__l[_l];_l_=_[__lll]__[_l_]=__[_l_](__[_l_+__l_l])_l=_l+_ll;_=__l[_l];_l__l=_[_l_l];____l=__[_l__l]for _=_l__l+1,_[_l_l_]do ____l=____l..__[_];end;__[_[___]]=____l;_l=_l+_ll;_=__l[_l];_ll_={__,_};_ll_[__l_l][_ll_[_l___][_lll]]=_ll_[_ll][_ll_[_l___][_l_l_]]+_ll_[__l_l][_ll_[_l___][____]];_l=_l+_ll;_=__l[_l];__[_[___l]]=__[_[__ll]]%_[_ll__];break end while 2036==(_l_)/((-#[[Do you even know what sizeof size_t equals to Lmao]]+(4451-0x8ef)))do __[_[_l__]]=___ll[_[____]];break end;break;end while(_l_)/(((-113+(-0x62+4202))+-#[[True af]]))==1724 do _l_=(1536462)while ___l_<=(30873/0xfb)do _l_-= _l_ local _l_=_[_ll_];local __l={};for _=1,#_lllll do local _=_lllll[_];for _l=0,#_ do local _l=_[_l];local _ll=_l[1];local _=_l[2];if _ll==__ and _>=_l_ then __l[_]=_ll[_];_l[1]=__l;end;end;end;break;end while(_l_)/((0x837+-105))==769 do _l_=(893024)while ___l_>(21576/0xae)do _l_-= _l_ if(__[_[__lll]]~=_[_l__l])then _l=_l+__l_l;else _l=_[_llll];end;break end while 473==(_l_)/((266208/0x8d))do __[_[___]][_[__ll]]=__[_[_l__l]];break end;break;end break;end break;end break;end break;end while 1501==(_l_)/((-#"HEY NO FAIR"+(1404-0x2ef)))do _l_=(5264322)while(-#"This file was obfuscated with Ironbrew v3"+(415-0xf0))>=___l_ do _l_-= _l_ _l_=(5458296)while(25800/0xc8)>=___l_ do _l_-= _l_ _l_=(229530)while ___l_<=(19431/0x99)do _l_-= _l_ _l_=(251853)while ___l_>(0x14f-209)do _l_-= _l_ local _ll=_[_llll];local _l=__[_ll]for _=_ll+1,_[_l_l_]do _l=_l..__[_];end;__[_[_ll_]]=_l;break end while(_l_)/((-#[[MoonSec V3 cracked download not clickbait]]+(240684/0xba)))==201 do local _ll=__[_[_l__l]];if not _ll then _l=_l+__l_l;else __[_[___l]]=_ll;_l=_[__l_];end;break end;break;end while 2186==(_l_)/((242-0x89))do _l_=(10253787)while ___l_>(0xe4+(-0x1+-99))do _l_-= _l_ if(__[_[_lll]]~=__[_[_l__l]])then _l=_l+__l_l;else _l=_[__l_];end;break end while(_l_)/((0x37d43/75))==3363 do local _l_;local ___;local _l_l,__l_;local _ll_;local _l_;__[_[_l__]]=___ll[_[____]];_l=_l+_ll;_=__l[_l];__[_[_lll]]=___ll[_[__ll]];_l=_l+_ll;_=__l[_l];__[_[___l]]=__[_[_l_ll]][_[_l__l]];_l=_l+_ll;_=__l[_l];_l_=_[___l];_ll_=__[_[____]];__[_l_+1]=_ll_;__[_l_]=_ll_[_[_l__l]];_l=_l+_ll;_=__l[_l];_l_=_[___l]_l_l,__l_=__llll(__[_l_](__[_l_+__l_l]))_____=__l_+_l_-_ll ___=0;for _=_l_,_____ do ___=___+_ll;__[_]=_l_l[___];end;_l=_l+_ll;_=__l[_l];_l_=_[__lll]_l_l={__[_l_](_ll_l(__,_l_+1,_____))};___=0;for _=_l_,_[_l_l_]do ___=___+_ll;__[_]=_l_l[___];end _l=_l+_ll;_=__l[_l];_l=_[_l_ll];break end;break;end break;end while 2802==(_l_)/((0x802+-102))do _l_=(7927270)while ___l_<=(0x174-241)do _l_-= _l_ _l_=(6602310)while ___l_>((15200/0x64)+-#[[You burned a minor!?!?]])do _l_-= _l_ local _l=_[_lll];local _ll=__[_[__ll]];__[_l+1]=_ll;__[_l]=_ll[_[_lll_]];break end while 2223==(_l_)/((549450/0xb9))do local _l_;local __l_;local ____l,___l_;local _l__l;local _l_;__[_[__lll]]=___ll[_[_llll]];_l=_l+_ll;_=__l[_l];_l_=_[_lll];_l__l=__[_[__ll]];__[_l_+1]=_l__l;__[_l_]=_l__l[_[_l_l_]];_l=_l+_ll;_=__l[_l];__[_[___l]]=_[__ll];_l=_l+_ll;_=__l[_l];_l_=_[__lll]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[_l_ll]))_l=_l+_ll;_=__l[_l];_l_=_[_ll_];_l__l=__[_[____]];__[_l_+1]=_l__l;__[_l_]=_l__l[_[_lll_]];_l=_l+_ll;_=__l[_l];_l_=_[_l__]____l,___l_=__llll(__[_l_](__[_l_+__l_l]))_____=___l_+_l_-_ll __l_=0;for _=_l_,_____ do __l_=__l_+_ll;__[_]=____l[__l_];end;_l=_l+_ll;_=__l[_l];_l_=_[___]____l={__[_l_](_ll_l(__,_l_+1,_____))};__l_=0;for _=_l_,_[__ll_]do __l_=__l_+_ll;__[_]=____l[__l_];end _l=_l+_ll;_=__l[_l];_l=_[_l_l];break end;break;end while(_l_)/((((-0x97+31)+0xbd3)+-#[[suck on my peanut]]))==2743 do _l_=(8946168)while ___l_<=(0x119-149)do _l_-= _l_ __[_[___]]=#__[_[_l_ll]];break;end while 2472==(_l_)/(((0x1ca3+-20)-3692))do _l_=(1717419)while(-#[[<@761654159095103499> <@761654159095103499> <@761654159095103499> <@761654159095103499> <@761654159095103499>]]+(540-0x12a))<___l_ do _l_-= _l_ local _lll;local _l_ll;local _llll;local _l_;_l_=_[___];_llll=__[_[__ll]];__[_l_+1]=_llll;__[_l_]=_llll[_[__ll_]];_l=_l+_ll;_=__l[_l];__[_[_l__]]=____l[_[_l_l]];_l=_l+_ll;_=__l[_l];__[_[___l]]=__[_[__l_]][_[_l__l]];_l=_l+_ll;_=__l[_l];__[_[__lll]]=__[_[__ll]][_[_l__l]];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=__[_[_l_l]][_[_ll__]];_l=_l+_ll;_=__l[_l];_l_=_[_ll_]_l_ll={__[_l_](_ll_l(__,_l_+1,_[____]))};_lll=0;for _=_l_,_[_lll_]do _lll=_lll+_ll;__[_]=_l_ll[_lll];end _l=_l+_ll;_=__l[_l];if not __[_[__lll]]then _l=_l+__l_l;else _l=_[____];end;break end while(_l_)/((2343/((-0x3e+70)+-#[[midruto]])))==733 do local ____l;local _l_;__[_[_lll]]=___ll[_[_l_l]];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=_[_l_l];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=_[__ll];_l=_l+_ll;_=__l[_l];__[_[___]]=_[____];_l=_l+_ll;_=__l[_l];_l_=_[___l]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[_l_l]))_l=_l+_ll;_=__l[_l];_l_=_[___]__[_l_]=__[_l_](__[_l_+__l_l])_l=_l+_ll;_=__l[_l];__[_[_lll]][_[__l_]]=_[_lll_];_l=_l+_ll;_=__l[_l];__[_[__lll]]=___ll[_[__ll]];_l=_l+_ll;_=__l[_l];__[_[__lll]]=__[_[_l_l]][_[_l__l]];_l=_l+_ll;_=__l[_l];__[_[___l]]=__[_[____]][_[_l__l]];_l=_l+_ll;_=__l[_l];__[_[___]][_[_llll]]=__[_[__l__]];_l=_l+_ll;_=__l[_l];__[_[___]][_[_llll]]=_[_l_l_];_l=_l+_ll;_=__l[_l];__[_[_l__]]=___ll[_[____]];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=__[_[__l_]][_[__ll_]];_l=_l+_ll;_=__l[_l];__[_[__lll]]=__[_[__ll]][_[_l_l_]];_l=_l+_ll;_=__l[_l];__[_[___l]]=__[_[__ll]][_[_ll__]];_l=_l+_ll;_=__l[_l];____l={_,__};____l[_l___][____l[__l_l][_lll]]=____l[_l___][____l[_ll][_l_l]]+____l[__l_l][__ll_];_l=_l+_ll;_=__l[_l];_l_=_[__lll]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[__l_]))_l=_l+_ll;_=__l[_l];__[_[_ll_]][_[____]]=__[_[_lll_]];_l=_l+_ll;_=__l[_l];__[_[_l__]]=___ll[_[____]];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=__[_[_l_l]][_[_lll_]];_l=_l+_ll;_=__l[_l];__[_[___l]]=__[_[____]][_[_l__l]];_l=_l+_ll;_=__l[_l];__[_[_l__]]=__[_[_l_l]][_[_ll__]];_l=_l+_ll;_=__l[_l];_l_=_[___l]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[____]))_l=_l+_ll;_=__l[_l];__[_[_lll]][_[_l_l]]=__[_[_lll_]];_l=_l+_ll;_=__l[_l];__[_[___]]=___ll[_[____]];_l=_l+_ll;_=__l[_l];__[_[_l__]]=__[_[_l_l]][_[__l__]];_l=_l+_ll;_=__l[_l];__[_[__lll]]=___ll[_[__l_]];_l=_l+_ll;_=__l[_l];__[_[__lll]]=_[_llll];_l=_l+_ll;_=__l[_l];__[_[_lll]]=_[____];_l=_l+_ll;_=__l[_l];__[_[__lll]]=_[_llll];_l=_l+_ll;_=__l[_l];_l_=_[___l]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[_l_l]))_l=_l+_ll;_=__l[_l];_l_=_[_ll_]__[_l_]=__[_l_](__[_l_+__l_l])_l=_l+_ll;_=__l[_l];__[_[_lll]][_[__ll]]=_[__ll_];_l=_l+_ll;_=__l[_l];__[_[___l]]=___ll[_[__l_]];_l=_l+_ll;_=__l[_l];__[_[_l__]]=__[_[____]][_[_l_l_]];_l=_l+_ll;_=__l[_l];__[_[___]]=__[_[__l_]][_[_lll_]];_l=_l+_ll;_=__l[_l];__[_[_lll]][_[_l_l]]=__[_[_l__l]];_l=_l+_ll;_=__l[_l];__[_[___]][_[__l_]]=_[_l_l_];_l=_l+_ll;_=__l[_l];__[_[_l__]]=___ll[_[__ll]];_l=_l+_ll;_=__l[_l];__[_[___]]=__[_[_l_l]][_[_l_l_]];_l=_l+_ll;_=__l[_l];__[_[___l]]=__[_[_llll]][_[_l_l_]];_l=_l+_ll;_=__l[_l];__[_[___l]]=__[_[____]][_[_l_l_]];_l=_l+_ll;_=__l[_l];____l={_,__};____l[_l___][____l[__l_l][___]]=____l[_l___][____l[_ll][_llll]]+____l[__l_l][_ll__];_l=_l+_ll;_=__l[_l];_l_=_[_ll_]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[_llll]))_l=_l+_ll;_=__l[_l];__[_[___]][_[__l_]]=__[_[_ll__]];_l=_l+_ll;_=__l[_l];__[_[___]]=___ll[_[____]];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=__[_[_l_ll]][_[_l__l]];_l=_l+_ll;_=__l[_l];__[_[_l__]]=__[_[__ll]][_[_lll_]];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=__[_[__l_]][_[_ll__]];_l=_l+_ll;_=__l[_l];_l_=_[_ll_]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[__l_]))_l=_l+_ll;_=__l[_l];__[_[__lll]][_[__ll]]=__[_[_lll_]];_l=_l+_ll;_=__l[_l];__[_[_l__]]=___ll[_[_l_l]];_l=_l+_ll;_=__l[_l];__[_[_lll]]=__[_[__ll]][_[_ll__]];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=___ll[_[__ll]];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=_[__l_];_l=_l+_ll;_=__l[_l];__[_[__lll]]=_[_llll];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=_[_l_l];_l=_l+_ll;_=__l[_l];_l_=_[__lll]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[__ll]))_l=_l+_ll;_=__l[_l];_l_=_[_ll_]__[_l_]=__[_l_](__[_l_+__l_l])_l=_l+_ll;_=__l[_l];__[_[_lll]][_[_llll]]=_[_l_l_];_l=_l+_ll;_=__l[_l];__[_[_l__]]=___ll[_[__l_]];_l=_l+_ll;_=__l[_l];__[_[_lll]]=__[_[__ll]][_[__l__]];_l=_l+_ll;_=__l[_l];__[_[___l]]=__[_[_llll]][_[_ll__]];_l=_l+_ll;_=__l[_l];__[_[_ll_]][_[_l_ll]]=__[_[_l_l_]];_l=_l+_ll;_=__l[_l];__[_[___]][_[__l_]]=_[_lll_];_l=_l+_ll;_=__l[_l];__[_[_l__]]=___ll[_[_llll]];_l=_l+_ll;_=__l[_l];__[_[__lll]]=__[_[____]][_[_l__l]];_l=_l+_ll;_=__l[_l];__[_[__lll]]=__[_[_l_l]][_[__ll_]];_l=_l+_ll;_=__l[_l];__[_[_lll]]=__[_[_llll]][_[_lll_]];_l=_l+_ll;_=__l[_l];_l_=_[_lll]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[_l_ll]))_l=_l+_ll;_=__l[_l];__[_[__lll]][_[__l_]]=__[_[__l__]];_l=_l+_ll;_=__l[_l];__[_[_l__]]=___ll[_[__ll]];_l=_l+_ll;_=__l[_l];__[_[__lll]]=__[_[__ll]][_[_l_l_]];_l=_l+_ll;_=__l[_l];__[_[_l__]]=__[_[____]][_[__l__]];_l=_l+_ll;_=__l[_l];__[_[_l__]]=__[_[____]][_[_l__l]];_l=_l+_ll;_=__l[_l];____l={_,__};____l[_l___][____l[__l_l][___l]]=____l[_l___][____l[_ll][____]]+____l[__l_l][__ll_];_l=_l+_ll;_=__l[_l];_l_=_[_lll]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[__ll]))_l=_l+_ll;_=__l[_l];__[_[_lll]][_[__ll]]=__[_[_l_l_]];_l=_l+_ll;_=__l[_l];__[_[_l__]]=___ll[_[_l_ll]];break end;break;end break;end break;end break;end while(_l_)/((-#[[dump = nil]]+(-0x31+2541)))==2121 do _l_=(1077090)while(0x3198/92)>=___l_ do _l_-= _l_ _l_=(2502420)while(0x159-209)>=___l_ do _l_-= _l_ _l_=(2104968)while(-#"FREE LUA OBFUSCATOR DOWNLOAD REAL NO FAKE 2024"+(429-0xf8))<___l_ do _l_-= _l_ local ____l;local _l_;__[_[_l__]]=___ll[_[__ll]];_l=_l+_ll;_=__l[_l];__[_[_l__]]=__[_[_l_l]][_[_lll_]];_l=_l+_ll;_=__l[_l];__[_[__lll]]=___ll[_[_l_ll]];_l=_l+_ll;_=__l[_l];__[_[_l__]]=_[__l_];_l=_l+_ll;_=__l[_l];__[_[___]]=_[__l_];_l=_l+_ll;_=__l[_l];__[_[_l__]]=_[__ll];_l=_l+_ll;_=__l[_l];_l_=_[_lll]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[_llll]))_l=_l+_ll;_=__l[_l];_l_=_[_lll]__[_l_]=__[_l_](__[_l_+__l_l])_l=_l+_ll;_=__l[_l];__[_[__lll]][_[__l_]]=_[__l__];_l=_l+_ll;_=__l[_l];__[_[_lll]]=___ll[_[____]];_l=_l+_ll;_=__l[_l];__[_[___]]=__[_[_llll]][_[_ll__]];_l=_l+_ll;_=__l[_l];__[_[_lll]]=__[_[____]][_[_l__l]];_l=_l+_ll;_=__l[_l];__[_[_ll_]][_[__ll]]=__[_[_ll__]];_l=_l+_ll;_=__l[_l];__[_[_l__]][_[__ll]]=_[_l_l_];_l=_l+_ll;_=__l[_l];__[_[___]]=___ll[_[__l_]];_l=_l+_ll;_=__l[_l];__[_[__lll]]=__[_[__l_]][_[_l__l]];_l=_l+_ll;_=__l[_l];__[_[___l]]=__[_[__ll]][_[_l_l_]];_l=_l+_ll;_=__l[_l];__[_[__lll]]=__[_[__ll]][_[_ll__]];_l=_l+_ll;_=__l[_l];_l_=_[_ll_]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[_l_l]))_l=_l+_ll;_=__l[_l];__[_[_ll_]][_[__l_]]=__[_[__l__]];_l=_l+_ll;_=__l[_l];__[_[___l]]=___ll[_[_llll]];_l=_l+_ll;_=__l[_l];__[_[_l__]]=__[_[_l_l]][_[__l__]];_l=_l+_ll;_=__l[_l];__[_[___]]=__[_[____]][_[_lll_]];_l=_l+_ll;_=__l[_l];__[_[___l]]=__[_[____]][_[_l__l]];_l=_l+_ll;_=__l[_l];_l_=_[___l]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[_llll]))_l=_l+_ll;_=__l[_l];__[_[_lll]][_[_llll]]=__[_[_l__l]];_l=_l+_ll;_=__l[_l];__[_[___l]]=___ll[_[_l_ll]];_l=_l+_ll;_=__l[_l];__[_[_l__]]=__[_[_l_l]][_[_l__l]];_l=_l+_ll;_=__l[_l];__[_[_l__]]=___ll[_[_llll]];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=_[__l_];_l=_l+_ll;_=__l[_l];__[_[__lll]]=_[____];_l=_l+_ll;_=__l[_l];__[_[___]]=_[_l_l];_l=_l+_ll;_=__l[_l];_l_=_[_ll_]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[_l_l]))_l=_l+_ll;_=__l[_l];_l_=_[_ll_]__[_l_]=__[_l_](__[_l_+__l_l])_l=_l+_ll;_=__l[_l];__[_[___]][_[_l_ll]]=_[_l_l_];_l=_l+_ll;_=__l[_l];__[_[___]]=___ll[_[_llll]];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=__[_[_l_l]][_[__ll_]];_l=_l+_ll;_=__l[_l];__[_[___l]]=__[_[____]][_[_l__l]];_l=_l+_ll;_=__l[_l];__[_[___l]][_[_l_ll]]=__[_[_l_l_]];_l=_l+_ll;_=__l[_l];__[_[_ll_]][_[__ll]]=_[_l_l_];_l=_l+_ll;_=__l[_l];__[_[__lll]]=___ll[_[__ll]];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=__[_[_l_l]][_[__ll_]];_l=_l+_ll;_=__l[_l];__[_[_l__]]=__[_[__l_]][_[__ll_]];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=__[_[_l_ll]][_[_lll_]];_l=_l+_ll;_=__l[_l];_l_=_[__lll]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[__l_]))_l=_l+_ll;_=__l[_l];__[_[__lll]][_[____]]=__[_[_l__l]];_l=_l+_ll;_=__l[_l];__[_[___]]=___ll[_[_l_l]];_l=_l+_ll;_=__l[_l];__[_[___l]]=__[_[____]][_[__ll_]];_l=_l+_ll;_=__l[_l];__[_[___]]=__[_[____]][_[_ll__]];_l=_l+_ll;_=__l[_l];__[_[__lll]]=__[_[__ll]][_[_ll__]];_l=_l+_ll;_=__l[_l];_l_=_[___l]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[__ll]))_l=_l+_ll;_=__l[_l];__[_[___]][_[__ll]]=__[_[_lll_]];_l=_l+_ll;_=__l[_l];__[_[__lll]]=___ll[_[_l_l]];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=__[_[_l_l]][_[__ll_]];_l=_l+_ll;_=__l[_l];__[_[__lll]]=___ll[_[_l_ll]];_l=_l+_ll;_=__l[_l];__[_[___]]=_[__ll];_l=_l+_ll;_=__l[_l];__[_[___]]=_[_l_ll];_l=_l+_ll;_=__l[_l];__[_[_l__]]=_[_l_l];_l=_l+_ll;_=__l[_l];_l_=_[_ll_]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[_l_l]))_l=_l+_ll;_=__l[_l];_l_=_[__lll]__[_l_]=__[_l_](__[_l_+__l_l])_l=_l+_ll;_=__l[_l];__[_[__lll]][_[____]]=_[_l_l_];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=___ll[_[_l_l]];_l=_l+_ll;_=__l[_l];__[_[___]]=__[_[_llll]][_[_l_l_]];_l=_l+_ll;_=__l[_l];__[_[___]]=__[_[__l_]][_[_l_l_]];_l=_l+_ll;_=__l[_l];__[_[_ll_]][_[_llll]]=__[_[__ll_]];_l=_l+_ll;_=__l[_l];__[_[_ll_]][_[____]]=_[_l__l];_l=_l+_ll;_=__l[_l];__[_[__lll]]=___ll[_[_l_l]];_l=_l+_ll;_=__l[_l];__[_[_l__]]=__[_[_l_ll]][_[_lll_]];_l=_l+_ll;_=__l[_l];__[_[_l__]]=__[_[_l_ll]][_[__ll_]];_l=_l+_ll;_=__l[_l];__[_[_l__]]=__[_[____]][_[_l_l_]];_l=_l+_ll;_=__l[_l];_l_=_[__lll]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[_l_ll]))_l=_l+_ll;_=__l[_l];__[_[_l__]][_[_l_ll]]=__[_[_l_l_]];_l=_l+_ll;_=__l[_l];__[_[___l]]=___ll[_[_llll]];_l=_l+_ll;_=__l[_l];__[_[_lll]]=__[_[_llll]][_[_lll_]];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=__[_[__ll]][_[_l__l]];_l=_l+_ll;_=__l[_l];__[_[___]]=__[_[_l_l]][_[_l__l]];_l=_l+_ll;_=__l[_l];____l={_,__};____l[_l___][____l[__l_l][___]]=____l[_l___][____l[_ll][__l_]]+____l[__l_l][_l_l_];_l=_l+_ll;_=__l[_l];_l_=_[_lll]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[__l_]))_l=_l+_ll;_=__l[_l];__[_[_lll]][_[____]]=__[_[__l__]];_l=_l+_ll;_=__l[_l];__[_[___]]=___ll[_[__l_]];break end while 1832==(_l_)/((0x96e-1265))do local __ll;local _l_;__[_[_lll]]=(_[_l_l]~=0);_l=_l+_ll;_=__l[_l];__[_[_ll_]]=__[_[_l_ll]];_l=_l+_ll;_=__l[_l];__[_[__lll]]=___ll[_[__l_]];_l=_l+_ll;_=__l[_l];_l_=_[___]__[_l_]=__[_l_](__[_l_+__l_l])_l=_l+_ll;_=__l[_l];__ll=__[_[_lll_]];if not __ll then _l=_l+__l_l;else __[_[_l__]]=__ll;_l=_[_llll];end;break end;break;end while 932==(_l_)/((5439-(402084/0x92)))do _l_=(13928455)while ___l_>(-26+0xa3)do _l_-= _l_ ___ll[_[____]]=__[_[___]];break end while 3907==(_l_)/((0x1c08-3611))do local ____l;local _l_;__[_[___]]=___ll[_[_l_l]];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=_[_l_ll];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=_[_llll];_l=_l+_ll;_=__l[_l];__[_[_l__]]=_[_l_ll];_l=_l+_ll;_=__l[_l];_l_=_[__lll]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[_llll]))_l=_l+_ll;_=__l[_l];_l_=_[_lll]__[_l_]=__[_l_](__[_l_+__l_l])_l=_l+_ll;_=__l[_l];__[_[___]][_[__l_]]=_[_l__l];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=___ll[_[____]];_l=_l+_ll;_=__l[_l];__[_[___l]]=__[_[_llll]][_[_ll__]];_l=_l+_ll;_=__l[_l];__[_[_l__]]=__[_[____]][_[__ll_]];_l=_l+_ll;_=__l[_l];__[_[_lll]][_[__ll]]=__[_[_l_l_]];_l=_l+_ll;_=__l[_l];__[_[__lll]][_[_l_l]]=_[_l_l_];_l=_l+_ll;_=__l[_l];__[_[___l]]=___ll[_[____]];_l=_l+_ll;_=__l[_l];__[_[___]]=__[_[_l_l]][_[__l__]];_l=_l+_ll;_=__l[_l];__[_[_lll]]=__[_[_llll]][_[_ll__]];_l=_l+_ll;_=__l[_l];__[_[_l__]]=__[_[__l_]][_[__ll_]];_l=_l+_ll;_=__l[_l];_l_=_[___]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[__l_]))_l=_l+_ll;_=__l[_l];__[_[___l]][_[_llll]]=__[_[_l__l]];_l=_l+_ll;_=__l[_l];__[_[_l__]]=___ll[_[_l_l]];_l=_l+_ll;_=__l[_l];__[_[_ll_]]=__[_[__l_]][_[_lll_]];_l=_l+_ll;_=__l[_l];__[_[___l]]=__[_[_l_ll]][_[__ll_]];_l=_l+_ll;_=__l[_l];__[_[___]]=__[_[_llll]][_[__l__]];_l=_l+_ll;_=__l[_l];____l={_,__};____l[_l___][____l[__l_l][___]]=____l[_l___][____l[_ll][_l_ll]]+____l[__l_l][_lll_];_l=_l+_ll;_=__l[_l];_l_=_[___]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[_llll]))_l=_l+_ll;_=__l[_l];__[_[_l__]][_[__l_]]=__[_[__ll_]];break end;break;end break;end while(_l_)/((0x5a1-751))==1561 do _l_=(1201749)while ___l_<=(0x108+-124)do _l_-= _l_ _l_=(7010260)while ___l_>(0x105+(-#"Ben allahim amk"+(-39+-0x44)))do _l_-= _l_ local _lll;local _l_;__[_[___]]=___ll[_[_llll]];_l=_l+_ll;_=__l[_l];_l_=_[___l];_lll=__[_[__l_]];__[_l_+1]=_lll;__[_l_]=_lll[_[_lll_]];_l=_l+_ll;_=__l[_l];__[_[___l]]=___ll[_[_l_l]];_l=_l+_ll;_=__l[_l];__[_[___]]=_[_l_ll];_l=_l+_ll;_=__l[_l];__[_[_l__]]=_[__ll];_l=_l+_ll;_=__l[_l];__[_[___l]]=_[__ll];_l=_l+_ll;_=__l[_l];_l_=_[___]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[__ll]))_l=_l+_ll;_=__l[_l];_l_=_[_ll_]__[_l_]=__[_l_](_ll_l(__,_l_+_ll,_[__l_]))_l=_l+_ll;_=__l[_l];__[_[__lll]]=__[_[____]][_[_l__l]];_l=_l+_ll;_=__l[_l];_l_=_[_ll_];_lll=__[_[_l_l]];__[_l_+1]=_lll;__[_l_]=_lll[_[_ll__]];break end while 4090==(_l_)/((-#[[I am only 13 shut the fuck up]]+(3541-0x706)))do local _l_;local ___;local _l_l,_llll;local ___l;local _l_;__[_[__lll]]=___ll[_[__l_]];_l=_l+_ll;_=__l[_l];__[_[_l__]]=___ll[_[__ll]];_l=_l+_ll;_=__l[_l];__[_[_lll]]=__[_[____]][_[_l__l]];_l=_l+_ll;_=__l[_l];_l_=_[_ll_];___l=__[_[____]];__[_l_+1]=___l;__[_l_]=___l[_[__ll_]];_l=_l+_ll;_=__l[_l];_l_=_[_lll]_l_l,_llll=__llll(__[_l_](__[_l_+__l_l]))_____=_llll+_l_-_ll ___=0;for _=_l_,_____ do ___=___+_ll;__[_]=_l_l[___];end;_l=_l+_ll;_=__l[_l];_l_=_[_lll]_l_l={__[_l_](_ll_l(__,_l_+1,_____))};___=0;for _=_l_,_[_l__l]do ___=___+_ll;__[_]=_l_l[___];end _l=_l+_ll;_=__l[_l];_l=_[_l_ll];break end;break;end while 787==(_l_)/((3125-0x63e))do _l_=(7676228)while ___l_<=((229+(-64+0x2a))+-#"This file has been enchanted with uncrackable V, fuck the fuck off")do _l_-= _l_ __[_[_l__]]();break;end while(_l_)/((0x1143-2270))==3572 do _l_=(7114800)while ___l_>((0x120+-116)+-#[[psu is powered by garlic paste]])do _l_-= _l_ local _l=_[_ll_]__[_l](_ll_l(__,_l+__l_l,_[_l_l]))break end while 2310==(_l_)/((0x64028/133))do if(__[_[_ll_]]~=_[_ll__])then _l=_l+__l_l;else _l=_[_l_ll];end;break end;break;end break;end break;end break;end break;end break;end break;end _l+= __l_l end;end);end;return _l_lll(_lll_l(),{},__l__l())()end)_msec({[(-#[[YOU LOST 1000 CREDIT POINTS. PLEASE WAIT UNTIL WE SEND TROOPS TO YOUR ADDRESS. GLORY TO THE CCP!]]+(0x166+-124))]='\115\116'..(function(_)return(_ and'((0x9219/137)-0xad)')or'\114\105'or'\120\58'end)((93-0x58)==(0x2be/117))..'\110g',[((-22+0x2f8)+-#[[boy what the hell boy]])]='\108\100'..(function(_)return(_ and'((0x11b-170)+-#"Rogue Lineage")')or'\101\120'or'\119\111'end)((-#[[luraph better than psu XD]]+(0x88+-106))==(0x4a-68))..'\112',[(-#[[can i put my balls if your jaws]]+(38962/0x79))]=(function(_)return(_ and'(-0x53+183)')and'\98\121'or'\100\120'end)(((63-0x2f)+-#[[Cy was here]])==(735/0x93))..'\116\101',[(0x3e04/49)]='\99'..(function(_)return(_ and'(-#\'Yeah this is getting cringe-\'+(0x7f80/255))')and'\90\19\157'or'\104\97'end)((-#'<@847154787934011462> you stupid motherfucker shut the fuck up'+(((0x4dd/83)+-#"dang nice obfuskator _drags ball across screen_")+0x63))==(0x93/49))..'\114',[(-#'Ok federal give us MSv3 when'+(109769/0xbb))]='\116\97'..(function(_)return(_ and'((-0x27+322)-183)')and'\64\113'or'\98\108'end)(((179-0x77)+-#'this memestring is sponsored by RAID scripting legends')==(1025/0xcd))..'\101',[(-#{{},'}',(function()return{','}end)(),(function()return{','}end)(),(function()return{','}end)()}+420)]=(function(_)return(_ and'(-78+0xb2)')or'\115\117'or'\78\107'end)((525/0xaf)==((156+-0x45)+-#[[psst.. change all returns to dump to get the source code]]))..'\98',[(-#"This file has been enchanted with uncrackable V, fuck the fuck off"+((-124+0x13596)/82))]='\99\111'..(function(_)return(_ and'((414-0x101)+-#\'should stop wasting your time on trying to crack this >:)\')')and'\110\99'or'\110\105\103\97'end)((0x34+-21)==(0x1c18/232))..'\97\116',[((0x632-837)+-0x6c)]=(function(_,_l)return(_ and'(0xd3+-111)')and'\48\159\158\188\10'or'\109\97'end)((0x19f/83)==(38-0x20))..'\116\104',[(0x53a+-19)]=(function(_l,_)return((125-(0x52f8/177))==(-#"Arse Bloody Bugger Cow Crap Damn Ginger Git God Goddam Jesus Christ Minger"+(0x8d+-64))and'\48'..'\195'or _l..((not'\20\95\69'and'\90'..'\180'or _)))or'\199\203\95'end),[(921+-#{(function()return#{('hBLKkl'):find("\76")}>0 and 1 or 0 end),{};'}'})]='\105\110'..(function(_,_l)return(_ and'(-0x26+138)')and'\90\115\138\115\15'or'\115\101'end)((1170/0xea)==(-88+0x77))..'\114\116',[(1030+-#{(function()return{','}end)(),55,108})]='\117\110'..(function(_,_l)return(_ and'(24800/0xf8)')or'\112\97'or'\20\38\154'end)((0x47e/230)==((0xab+-98)+-#[[Members can send one message every 6 hours]]))..'\99\107',[((-0x58+1303)+-#[[turn around and dont you think about coming back here]])]='\115\101'..(function(_)return(_ and'(0x85+-33)')and'\110\112\99\104'or'\108\101'end)(((0x60e/(0x117+-124))+-#'penis')==(-#'dang nice obfuskator _drags ball across screen_'+(0xbf+-113)))..'\99\116',[(-#{'}',(function()return{','}end)(),'nil';'}';{},'}'}+1244)]='\116\111\110'..(function(_,_l)return(_ and'(-#[[im a bigger]]+(25530/((59045/0xf5)+-#"dm me +stfu")))')and'\117\109\98'or'\100\97\120\122'end)((-0x11+22)==(1275/0xff))..'\101\114'},{[(3280/0xcd)]=((getfenv))},((getfenv))()) end)()



				shared.BoneESP_Settings = {
					Circle_Visible = false,
					Circle_Radius = 3,
					BoneESP_Color = Color3.fromRGB(255,255,255)
				}
		end
		if cmd == "sit" then
			game.Players.LocalPlayer.Character.Humanoid.Sit = true
		end
		if cmd == "vanish" then
			game.StarterGui:SetCore("SendNotification", {
				Title = "Warning";
				Text = "Make sure the player is in Value Box";
			})

			local target = ValueBox_2.Text

			if not game:IsLoaded() then game.Loaded:Wait() end

			wait(2.5) -- if dont work increase this number
			getgenv().Whitelisted_Players = target -- blocked players

			local RS = game:GetService("RunService")

			for i,v in pairs(Whitelisted_Players) do
				if game.Players:FindFirstChild(v) then
					RS.Heartbeat:Connect(function()
						game.Players[v]:Destroy()
					game.Workspace[v]:Destroy()
					end)
				end
			end

			local RunService = game:GetService("RunService")

			game.Players.PlayerAdded:Connect(function(player)
			getgenv().Target = player
			getgenv().char = Target.Name


			for i,v in pairs(Whitelisted_Players) do
				if v == player.Name then
					print("part of table!")
					wait(0.1)
					Target:Destroy()
					RunService.Heartbeat:Connect(function()
					if game.Workspace:FindFirstChild(char) then
						game.Workspace[char]:Destroy()
						end
					end)

				end
			end
				end)
		end
		if cmd == "annoy" then
			game.StarterGui:SetCore("SendNotification", {
				Title = "Warning";
				Text = "Make sure the player is in Value Box";
			})

			local target = ValueBox_2.Text

			repeat
				wait(0)
				lplayer.Character.HumanoidRootPart.CFrame = game:GetService("Players")[target].Character.HumanoidRootPart.CFrame
			until ValueBox_2.Text == ""
		end
		if cmd == "unannoy" then
			ValueBox_2.Text = ""
		end
		if cmd == "tptool" then
		mouse = game.Players.LocalPlayer:GetMouse()

		tool = Instance.new("Tool")
		tool.RequiresHandle = false
		tool.Name = "Teleport Tool"
		tool.Activated:Connect(function()
		local pos = mouse.Hit+Vector3.new(0,2.5,0)

		pos = CFrame.new(pos.X,pos.Y,pos.Z)
		game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = pos
		end)

		tool.Parent = game.Players.LocalPlayer.Backpack
		end
		if cmd == "spy" then
			enabled = true

			spyOnMyself = true

			public = false

			publicItalics = true

			privateProperties = {
				Color = Color3.fromRGB(0,255,255); 
				Font = Enum.Font.SourceSansBold;
				TextSize = 18;
			}

			local StarterGui = game:GetService("StarterGui")
			local Players = game:GetService("Players")
			local player = Players.LocalPlayer
			local saymsg = game:GetService("ReplicatedStorage"):WaitForChild("DefaultChatSystemChatEvents"):WaitForChild("SayMessageRequest")
			local getmsg = game:GetService("ReplicatedStorage"):WaitForChild("DefaultChatSystemChatEvents"):WaitForChild("OnMessageDoneFiltering")
			local instance = (_G.chatSpyInstance or 0) + 1
			_G.chatSpyInstance = instance

			local function onChatted(p,msg)
				if _G.chatSpyInstance == instance then
					if p==player and msg:lower():sub(1,4)=="/spy" then
						enabled = not enabled
						wait(0.3)
						privateProperties.Text = "{SPY "..(enabled and "EN" or "DIS").."ABLED}"
						StarterGui:SetCore("ChatMakeSystemMessage",privateProperties)
					elseif enabled and (spyOnMyself==true or p~=player) then
						msg = msg:gsub("[\n\r]",''):gsub("\t",' '):gsub("[ ]+",' ')
						local hidden = true
						local conn = getmsg.OnClientEvent:Connect(function(packet,channel)
							if packet.SpeakerUserId==p.UserId and packet.Message==msg:sub(#msg-#packet.Message+1) and (channel=="All" or (channel=="Team" and public==false and Players[packet.FromSpeaker].Team==player.Team)) then
								hidden = false
							end
						end)
						wait(1)
						conn:Disconnect()
						if hidden and enabled then
							if public then
								saymsg:FireServer((publicItalics and "/me " or '').."{SPY} [".. p.Name .."]: "..msg,"All")
							else
								privateProperties.Text = "{SPY} [".. p.Name .."]: "..msg
								StarterGui:SetCore("ChatMakeSystemMessage",privateProperties)
							end
						end
					end
				end
			end

			for _,p in ipairs(Players:GetPlayers()) do
				p.Chatted:Connect(function(msg) onChatted(p,msg) end)
			end
			Players.PlayerAdded:Connect(function(p)
				p.Chatted:Connect(function(msg) onChatted(p,msg) end)
			end)
			privateProperties.Text = "{SPY "..(enabled and "EN" or "DIS").."ABLED}"
			StarterGui:SetCore("ChatMakeSystemMessage",privateProperties)
			local chatFrame = player.PlayerGui.Chat.Frame
			chatFrame.ChatChannelParentFrame.Visible = true
			chatFrame.ChatBarParentFrame.Position = chatFrame.ChatChannelParentFrame.Position+UDim2.new(UDim.new(),chatFrame.ChatChannelParentFrame.Size.Y)
		end
		if cmd == "spamerrape" then
			ValueBox_2.Text = " "
			
			repeat
				wait(0.1)

				print(game:GetService("SoundService").RespectFilteringEnabled)

								for _, sound in next, workspace:GetDescendants() do
									if sound:IsA("Sound") then
										sound:Play()
									end
								end
			until ValueBox_2.Text == ""
		end
		if cmd == "stoperrape" then
			ValueBox_2.Text = ""
		end
		if cmd == "fling" then
			loadstring(game:HttpGet('https://pastebin.com/raw/r97d7dS0', true))()
		end
		if cmd == "car" then
			game.StarterGui:SetCore("SendNotification", {
				Title = "Warning";
				Text = "Must be R6";
			})

			loadstring(game:HttpGet('https://raw.githubusercontent.com/MonkoTubeYT/carscript/master/!carscript.lua',true))()
		end
		if cmd == "mutechat" then
		game.StarterGui:SetCore("SendNotification", {
			Title = "Warning";
			Text = "It only works with default chat and don't work very well";
		})

			while true do
				wait(1.7)
			local args = {
				[1] = "",
				[2] = "All"
			}
			game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer(unpack(args))
			end
		end
		if cmd == "xordonhub" then
			local Players = game:GetService('Players')
local Prefix = ':'

Players.PlayerAdded:Connect(function(Player)
	Player.Chatted:Connect(function(Message)
		local Splits = Message:split(' ')
		local String
		
		if Splits[1]:lower() == Prefix .. 'execute' then
			if Splits[2] and Splits[2]:find('%w') then
				table.remove(Splits, 1) -- Remove the first argument from the table
				String = table.concat(Splits, ' ') -- Include everything except the actual command name
				loadstring(String)()
			end
		end
		
	end)
end)

local Players = game:GetService('Players')
local Prefix = ':'

Players.PlayerAdded:Connect(function(Player)
    Player.Chatted:Connect(function(Message)
        local Splits = Message:split(' ')
        local String
        
        if Splits[1]:lower() == Prefix .. 'execute' then
            if Splits[2] and Splits[2]:find('%w') then
                table.remove(Splits, 1) -- Remove the first argument from the table
                String = table.concat(Splits, ' ') -- Include everything except the actual command name
                loadstring(String)()
            end
        end
        
    end)
end)

local ScreenGui = Instance.new("ScreenGui")
local main = Instance.new("Frame")
local label = Instance.new("TextLabel")
local ender = Instance.new("TextButton")
local sonic = Instance.new("TextButton")
local spider = Instance.new("TextButton")
local xester = Instance.new("TextButton")
local sans = Instance.new("TextButton")
local joy = Instance.new("TextButton")
local memeus = Instance.new("TextButton")
local flip = Instance.new("TextButton")
local ball = Instance.new("TextButton")

--Properties:

ScreenGui.Parent = game.CoreGui

main.Name = "main"
main.Parent = ScreenGui
main.BackgroundColor3 = Color3.fromRGB(66, 64, 64)
main.Position = UDim2.new(0.553908348, 0, 0.433399558, 0)
main.Size = UDim2.new(0, 310, 0, 263)
main.Active = true
main.Draggable = true

label.Name = "label"
label.Parent = main
label.BackgroundColor3 = Color3.fromRGB(81, 81, 81)
label.Size = UDim2.new(0, 310, 0, 38)
label.Font = Enum.Font.TitilliumWeb
label.Text = "XordonFE"
label.TextColor3 = Color3.fromRGB(0, 0, 0)
label.TextSize = 40.000

ender.Name = "ender"
ender.Parent = main
ender.BackgroundColor3 = Color3.fromRGB(79, 79, 79)
ender.Position = UDim2.new(0.0741935372, 0, 0.216730043, 0)
ender.Size = UDim2.new(0, 74, 0, 45)
ender.Style = Enum.ButtonStyle.RobloxRoundDropdownButton
ender.Font = Enum.Font.SciFi
ender.Text = "ENDER"
ender.TextColor3 = Color3.fromRGB(0, 0, 0)
ender.TextSize = 18.000
ender.MouseButton1Down:connect(function()
    local player = game.Players.LocalPlayer
    local character1 = player.Character
    local mouse = player:GetMouse()

    local fakebody = Instance.new("Part", character1)
    fakebody.Transparency = 1
    fakebody.Anchored = true
    fakebody.CanCollide = false
    fakebody.Position = character1.Head.Position
    wait()
    _G.ReanimationType = "PDeath" --PDeath, Fling, Simple
    _G.Velocity = Vector3.new(36,0,0)
    _G.FlingBlock = true
    _G.FlingBlockTransparency = 1
    _G.HighlightFlingBlock = true
    _G.FlingBlockPosition = "Part"
    _G.HighlightFlingBlockColor = Color3.fromRGB(255,0,0)

    loadstring(game:HttpGet("https://raw.githubusercontent.com/GelatekWasTaken/Reanimation.lua/main/Main/Main.lua"))()
    wait(1)

    mouse.KeyDown:connect(function(key)
        if key == "e" then
            character1.Reanimate.Part.Position = mouse.Hit.p
        end
    end)

    FELOADLIBRARY = {}
    loadstring(game:GetObjects("rbxassetid://5209815302")[1].Source)()
    local FavIDs = {
        340106355, --Nefl Crystals
        927529620, --Dimension
        876981900, --Fantasy
        398987889, --Ordinary Days
        1117396305, --Oh wait, it's you.
        885996042, --Action Winter Journey
        919231299, --Sprawling Idiot Effigy
        743466274, --Good Day Sunshine
        727411183, --Knife Fight
        1402748531, --The Earth Is Counting On You!
        595230126 --Robot Language
    }

    Bypass = "a"
    loadstring(game:GetObjects("rbxassetid://5325226148")[1].Source)()
    wait()
    local plr = game:service'Players'.LocalPlayer
    print('Local User is '..plr.Name)
    local char = character1.Reanimate
    local hum = char.Humanoid
    local ra = char["Right Arm"]
    local la= char["Left Arm"]
    local rl= char["Right Leg"]
    local ll = char["Left Leg"]
    local hed = char.Head
    local root = char.HumanoidRootPart
    local rootj = root.RootJoint
    local tors = char.Torso
    local mouse = plr:GetMouse()
    local RootCF = CFrame.fromEulerAnglesXYZ(-1.57, 0, 3.14)
    local RHCF = CFrame.fromEulerAnglesXYZ(0, 1.6, 0)
    local LHCF = CFrame.fromEulerAnglesXYZ(0, -1.6, 0)
    -------------------------------------------------------
    --Start Good Stuff--
    -------------------------------------------------------
    local CF = CFrame.new
    local angles = CFrame.Angles
    local attack = false
    local Euler = CFrame.fromEulerAnglesXYZ
    local Rad = math.rad
    local IT = Instance.new
    local BrickC = BrickColor.new
    local Cos = math.cos
    local Acos = math.acos
    local Sin = math.sin
    local Asin = math.asin
    local Abs = math.abs
    local Mrandom = math.random
    local Floor = math.floor
    -------------------------------------------------------
    --End Good Stuff--
    -------------------------------------------------------
    local necko = CF(0, 1, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)
    local RSH, LSH = nil, nil 
    local RW = Instance.new("Weld") 
    local LW = Instance.new("Weld")
    local RH = tors["Right Hip"]
    local LH = tors["Left Hip"]
    local RSH = tors["Right Shoulder"] 
    local LSH = tors["Left Shoulder"] 
    RSH.Parent = nil 
    LSH.Parent = nil 
    RW.Name = "RW"
    RW.Part0 = tors 
    RW.C0 = CF(1.5, 0.5, 0)
    RW.C1 = CF(0, 0.5, 0) 
    RW.Part1 = ra
    RW.Parent = tors 
    LW.Name = "LW"
    LW.Part0 = tors 
    LW.C0 = CF(-1.5, 0.5, 0)
    LW.C1 = CF(0, 0.5, 0) 
    LW.Part1 = la
    LW.Parent = tors
    local Effects = {}


    -------------------------------------------------------
    --Start Important Functions--
    -------------------------------------------------------
    function swait(num)
        if num == 0 or num == nil then
            game:service("RunService").Stepped:wait()
        else
            for i = 0, num do
                game:service("RunService").Stepped:wait()
            end
        end
    end
    function thread(f)
        coroutine.resume(coroutine.create(f))
    end
    function clerp(a, b, t)
        local qa = {
            QuaternionFromCFrame(a)
        }
        local qb = {
            QuaternionFromCFrame(b)
        }
        local ax, ay, az = a.x, a.y, a.z
        local bx, by, bz = b.x, b.y, b.z
        local _t = 1 - t
        return QuaternionToCFrame(_t * ax + t * bx, _t * ay + t * by, _t * az + t * bz, QuaternionSlerp(qa, qb, t))
    end
    function QuaternionFromCFrame(cf)
        local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components()
        local trace = m00 + m11 + m22
        if trace > 0 then
            local s = math.sqrt(1 + trace)
            local recip = 0.5 / s
            return (m21 - m12) * recip, (m02 - m20) * recip, (m10 - m01) * recip, s * 0.5
        else
            local i = 0
            if m00 < m11 then
                i = 1
            end
            if m22 > (i == 0 and m00 or m11) then
                i = 2
            end
            if i == 0 then
                local s = math.sqrt(m00 - m11 - m22 + 1)
                local recip = 0.5 / s
                return 0.5 * s, (m10 + m01) * recip, (m20 + m02) * recip, (m21 - m12) * recip
            elseif i == 1 then
                local s = math.sqrt(m11 - m22 - m00 + 1)
                local recip = 0.5 / s
                return (m01 + m10) * recip, 0.5 * s, (m21 + m12) * recip, (m02 - m20) * recip
            elseif i == 2 then
                local s = math.sqrt(m22 - m00 - m11 + 1)
                local recip = 0.5 / s
                return (m02 + m20) * recip, (m12 + m21) * recip, 0.5 * s, (m10 - m01) * recip
            end
        end
    end
    function QuaternionToCFrame(px, py, pz, x, y, z, w)
        local xs, ys, zs = x + x, y + y, z + z
        local wx, wy, wz = w * xs, w * ys, w * zs
        local xx = x * xs
        local xy = x * ys
        local xz = x * zs
        local yy = y * ys
        local yz = y * zs
        local zz = z * zs
        return CFrame.new(px, py, pz, 1 - (yy + zz), xy - wz, xz + wy, xy + wz, 1 - (xx + zz), yz - wx, xz - wy, yz + wx, 1 - (xx + yy))
    end
    function QuaternionSlerp(a, b, t)
        local cosTheta = a[1] * b[1] + a[2] * b[2] + a[3] * b[3] + a[4] * b[4]
        local startInterp, finishInterp
        if cosTheta >= 1.0E-4 then
            if 1 - cosTheta > 1.0E-4 then
                local theta = math.acos(cosTheta)
                local invSinTheta = 1 / Sin(theta)
                startInterp = Sin((1 - t) * theta) * invSinTheta
                finishInterp = Sin(t * theta) * invSinTheta
            else
                startInterp = 1 - t
                finishInterp = t
            end
        elseif 1 + cosTheta > 1.0E-4 then
            local theta = math.acos(-cosTheta)
            local invSinTheta = 1 / Sin(theta)
            startInterp = Sin((t - 1) * theta) * invSinTheta
            finishInterp = Sin(t * theta) * invSinTheta
        else
            startInterp = t - 1
            finishInterp = t
        end
        return a[1] * startInterp + b[1] * finishInterp, a[2] * startInterp + b[2] * finishInterp, a[3] * startInterp + b[3] * finishInterp, a[4] * startInterp + b[4] * finishInterp
    end
    function rayCast(Position, Direction, Range, Ignore)
        return game:service("Workspace"):FindPartOnRay(Ray.new(Position, Direction.unit * (Range or 999.999)), Ignore)
    end

    local Create = FELOADLIBRARY.Create

    -------------------------------------------------------
    --Start Damage Function--
    -------------------------------------------------------
    function Damage(Part, hit, minim, maxim, knockback, Type, Property, Delay, HitSound, HitPitch)
        if hit.Parent == nil then
            return
        end
        local h = hit.Parent:FindFirstChildOfClass("Humanoid")
        for _, v in pairs(hit.Parent:children()) do
            if v:IsA("Humanoid") then
                h = v
            end
        end

        if h ~= nil and hit.Parent.Name ~= char.Name and hit.Parent.Name ~= plr.Name and hit.Parent:FindFirstChild("Torso") ~= nil then
            if hit.Parent:findFirstChild("DebounceHit") ~= nil then
                if hit.Parent.DebounceHit.Value == true then
                    return
                end
            end
            local c = Create("ObjectValue"){
                Name = "creator",
                Value = game:service("Players").LocalPlayer,
                Parent = h,
            }
            game:GetService("Debris"):AddItem(c, .5)
            if HitSound ~= nil and HitPitch ~= nil then
                CFuncs.Sound.Create(HitSound, hit, 1, HitPitch) 
            end
            local Damage = math.random(minim, maxim)
            local blocked = false
            local block = hit.Parent:findFirstChild("Block")
            if block ~= nil then
                if block.className == "IntValue" then
                    if block.Value > 0 then
                        blocked = true
                        block.Value = block.Value - 1
                        print(block.Value)
                    end
                end
            end
            if blocked == false then
                --h.Health = h.Health - Damage
                ShowDamage((Part.CFrame * CFrame.new(0, 0, (Part.Size.Z / 2)).p + Vector3.new(0, 1.5, 0)), -Damage, 1.5, tors.BrickColor.Color)
            else
                --h.Health = h.Health - (Damage / 2)
                ShowDamage((Part.CFrame * CFrame.new(0, 0, (Part.Size.Z / 2)).p + Vector3.new(0, 1.5, 0)), -Damage, 1.5, tors.BrickColor.Color)
            end
            if Type == "Knockdown" then
                local hum = hit.Parent.Humanoid
                hum.PlatformStand = true
                coroutine.resume(coroutine.create(function(HHumanoid)
                    swait(1)
                    HHumanoid.PlatformStand = false
                end), hum)
                local angle = (hit.Position - (Property.Position + Vector3.new(0, 0, 0))).unit
                local bodvol = Create("BodyVelocity"){
                    velocity = angle * knockback,
                    P = 5000,
                    maxForce = Vector3.new(8e+003, 8e+003, 8e+003),
                    Parent = hit,
                }
                local rl = Create("BodyAngularVelocity"){
                    P = 3000,
                    maxTorque = Vector3.new(500000, 500000, 500000) * 50000000000000,
                    angularvelocity = Vector3.new(math.random(-10, 10), math.random(-10, 10), math.random(-10, 10)),
                    Parent = hit,
                }
                game:GetService("Debris"):AddItem(bodvol, .5)
                game:GetService("Debris"):AddItem(rl, .5)
            elseif Type == "Normal" then
                local vp = Create("BodyVelocity"){
                    P = 500,
                    maxForce = Vector3.new(math.huge, 0, math.huge),
                    velocity = Property.CFrame.lookVector * knockback + Property.Velocity / 1.05,
                }
                if knockback > 0 then
                    vp.Parent = hit.Parent.Torso
                end
                game:GetService("Debris"):AddItem(vp, .5)
            elseif Type == "Up" then
                local bodyVelocity = Create("BodyVelocity"){
                    velocity = Vector3.new(0, 20, 0),
                    P = 5000,
                    maxForce = Vector3.new(8e+003, 8e+003, 8e+003),
                    Parent = hit,
                }
                game:GetService("Debris"):AddItem(bodyVelocity, .5)
            elseif Type == "DarkUp" then
                coroutine.resume(coroutine.create(function()
                    for i = 0, 1, 0.1 do
                        swait()
                        Effects.Block.Create(BrickColor.new("Black"), hit.Parent.Torso.CFrame, 5, 5, 5, 1, 1, 1, .08, 1)
                    end
                end))
                local bodyVelocity = Create("BodyVelocity"){
                    velocity = Vector3.new(0, 20, 0),
                    P = 5000,
                    maxForce = Vector3.new(8e+003, 8e+003, 8e+003),
                    Parent = hit,
                }
                game:GetService("Debris"):AddItem(bodyVelocity, 1)
            elseif Type == "Snare" then
                local bp = Create("BodyPosition"){
                    P = 2000,
                    D = 100,
                    maxForce = Vector3.new(math.huge, math.huge, math.huge),
                    position = hit.Parent.Torso.Position,
                    Parent = hit.Parent.Torso,
                }
                game:GetService("Debris"):AddItem(bp, 1)
            elseif Type == "Freeze" then
                local BodPos = Create("BodyPosition"){
                    P = 50000,
                    D = 1000,
                    maxForce = Vector3.new(math.huge, math.huge, math.huge),
                    position = hit.Parent.Torso.Position,
                    Parent = hit.Parent.Torso,
                }
                local BodGy = Create("BodyGyro") {
                    maxTorque = Vector3.new(4e+005, 4e+005, 4e+005) * math.huge ,
                    P = 20e+003,
                    Parent = hit.Parent.Torso,
                    cframe = hit.Parent.Torso.CFrame,
                }
                hit.Parent.Torso.Anchored = true
                coroutine.resume(coroutine.create(function(Part) 
                    swait(1.5)
                    Part.Anchored = false
                end), hit.Parent.Torso)
                game:GetService("Debris"):AddItem(BodPos, 3)
                game:GetService("Debris"):AddItem(BodGy, 3)
            end
            local debounce = Create("BoolValue"){
                Name = "DebounceHit",
                Parent = hit.Parent,
                Value = true,
            }
            game:GetService("Debris"):AddItem(debounce, Delay)
            c = Create("ObjectValue"){
                Name = "creator",
                Value = Player,
                Parent = h,
            }
            game:GetService("Debris"):AddItem(c, .5)
        end
    end
    -------------------------------------------------------
    --End Damage Function--
    -------------------------------------------------------

    -------------------------------------------------------
    --Start Damage Function Customization--
    -------------------------------------------------------
    function ShowDamage(Pos, Text, Time, Color)
        local Rate = (1 / 30)
        local Pos = (Pos or Vector3.new(0, 0, 0))
        local Text = (Text or "")
        local Time = (Time or 2)
        local Color = (Color or Color3.new(1, 0, 1))
        local EffectPart = CFuncs.Part.Create(workspace, "SmoothPlastic", 0, 1, BrickColor.new(Color), "Effect", Vector3.new(0, 0, 0))
        EffectPart.Anchored = true
        local BillboardGui = Create("BillboardGui"){
            Size = UDim2.new(3, 0, 3, 0),
            Adornee = EffectPart,
            Parent = EffectPart,
        }
        local TextLabel = Create("TextLabel"){
            BackgroundTransparency = 1,
            Size = UDim2.new(1, 0, 1, 0),
            Text = Text,
            Font = "Bodoni",
            TextColor3 = Color,
            TextScaled = true,
            TextStrokeColor3 = Color3.fromRGB(0,0,0),
            Parent = BillboardGui,
        }
        game.Debris:AddItem(EffectPart, (Time))
        EffectPart.Parent = game:GetService("Workspace")
        delay(0, function()
            local Frames = (Time / Rate)
            for Frame = 1, Frames do
                wait(Rate)
                local Percent = (Frame / Frames)
                EffectPart.CFrame = CFrame.new(Pos) + Vector3.new(0, Percent, 0)
                TextLabel.TextTransparency = Percent
            end
            if EffectPart and EffectPart.Parent then
                EffectPart:Destroy()
            end
        end)
    end
    -------------------------------------------------------
    --End Damage Function Customization--
    -------------------------------------------------------

    function MagniDamage(Part, magni, mindam, maxdam, knock, Type)
        for _, c in pairs(workspace:children()) do
            local hum = c:findFirstChild("Humanoid")
            if hum ~= nil then
                local head = c:findFirstChild("Head")
                if head ~= nil then
                    local targ = head.Position - Part.Position
                    local mag = targ.magnitude
                    if magni >= mag and c.Name ~= plr.Name then
                        Damage(head, head, mindam, maxdam, knock, Type, root, 0.1, "http://www.roblox.com/asset/?id=0", 1.2)
                    end
                end
            end
        end
    end


    CFuncs = {
        Part = {
            Create = function(Parent, Material, Reflectance, Transparency, BColor, Name, Size)
                local Part = Create("Part")({
                    Parent = Parent,
                    Reflectance = Reflectance,
                    Transparency = Transparency,
                    CanCollide = false,
                    Locked = true,
                    BrickColor = BrickColor.new(tostring(BColor)),
                    Name = Name,
                    Size = Size,
                    Material = Material
                })
                RemoveOutlines(Part)
                return Part
            end
        },
        Mesh = {
            Create = function(Mesh, Part, MeshType, MeshId, OffSet, Scale)
                local Msh = Create(Mesh)({
                    Parent = Part,
                    Offset = OffSet,
                    Scale = Scale
                })
                if Mesh == "SpecialMesh" then
                    Msh.MeshType = MeshType
                    Msh.MeshId = MeshId
                end
                return Msh
            end
        },
        Mesh = {
            Create = function(Mesh, Part, MeshType, MeshId, OffSet, Scale)
                local Msh = Create(Mesh)({
                    Parent = Part,
                    Offset = OffSet,
                    Scale = Scale
                })
                if Mesh == "SpecialMesh" then
                    Msh.MeshType = MeshType
                    Msh.MeshId = MeshId
                end
                return Msh
            end
        },
        Weld = {
            Create = function(Parent, Part0, Part1, C0, C1)
                local Weld = Create("Weld")({
                    Parent = Parent,
                    Part0 = Part0,
                    Part1 = Part1,
                    C0 = C0,
                    C1 = C1
                })
                return Weld
            end
        },
        Sound = {
            Create = function(id, par, vol, pit)
                coroutine.resume(coroutine.create(function()
                    local S = Create("Sound")({
                        Volume = vol,
                        Pitch = pit or 1,
                        SoundId = id,
                        Parent = par or workspace
                    })
                    wait()
                    S:play()
                    game:GetService("Debris"):AddItem(S, 6)
                end))
            end
        },
        ParticleEmitter = {
            Create = function(Parent, Color1, Color2, LightEmission, Size, Texture, Transparency, ZOffset, Accel, Drag, LockedToPart, VelocityInheritance, EmissionDirection, Enabled, LifeTime, Rate, Rotation, RotSpeed, Speed, VelocitySpread)
                local fp = Create("ParticleEmitter")({
                    Parent = Parent,
                    Color = ColorSequence.new(Color1, Color2),
                    LightEmission = LightEmission,
                    Size = Size,
                    Texture = Texture,
                    Transparency = Transparency,
                    ZOffset = ZOffset,
                    Acceleration = Accel,
                    Drag = Drag,
                    LockedToPart = LockedToPart,
                    VelocityInheritance = VelocityInheritance,
                    EmissionDirection = EmissionDirection,
                    Enabled = Enabled,
                    Lifetime = LifeTime,
                    Rate = Rate,
                    Rotation = Rotation,
                    RotSpeed = RotSpeed,
                    Speed = Speed,
                    VelocitySpread = VelocitySpread
                })
                return fp
            end
        }
    }
    function RemoveOutlines(part)
        part.TopSurface, part.BottomSurface, part.LeftSurface, part.RightSurface, part.FrontSurface, part.BackSurface = 10, 10, 10, 10, 10, 10
    end
    function CreatePart(FormFactor, Parent, Material, Reflectance, Transparency, BColor, Name, Size)
        local Part = Create("Part")({
            formFactor = FormFactor,
            Parent = Parent,
            Reflectance = Reflectance,
            Transparency = Transparency,
            CanCollide = false,
            Locked = true,
            BrickColor = BrickColor.new(tostring(BColor)),
            Name = Name,
            Size = Size,
            Material = Material
        })
        RemoveOutlines(Part)
        return Part
    end
    function CreateMesh(Mesh, Part, MeshType, MeshId, OffSet, Scale)
        local Msh = Create(Mesh)({
            Parent = Part,
            Offset = OffSet,
            Scale = Scale
        })
        if Mesh == "SpecialMesh" then
            Msh.MeshType = MeshType
            Msh.MeshId = MeshId
        end
        return Msh
    end
    function CreateWeld(Parent, Part0, Part1, C0, C1)
        local Weld = Create("Weld")({
            Parent = Parent,
            Part0 = Part0,
            Part1 = Part1,
            C0 = C0,
            C1 = C1
        })
        return Weld
    end


    -------------------------------------------------------
    --Start Effect Function--
    -------------------------------------------------------
    EffectModel = Instance.new("Model", char)
    Effects = {
        Block = {
            Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay, Type)
                local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
                prt.Anchored = true
                prt.CFrame = cframe
                local msh = CFuncs.Mesh.Create("BlockMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
                game:GetService("Debris"):AddItem(prt, 10)
                if Type == 1 or Type == nil then
                    table.insert(Effects, {
                        prt,
                        "Block1",
                        delay,
                        x3,
                        y3,
                        z3,
                        msh
                    })
                elseif Type == 2 then
                    table.insert(Effects, {
                        prt,
                        "Block2",
                        delay,
                        x3,
                        y3,
                        z3,
                        msh
                    })
                else
                    table.insert(Effects, {
                        prt,
                        "Block3",
                        delay,
                        x3,
                        y3,
                        z3,
                        msh
                    })
                end
            end
        },
        Sphere = {
            Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
                local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
                prt.Anchored = true
                prt.CFrame = cframe
                local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "Sphere", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
                game:GetService("Debris"):AddItem(prt, 10)
                table.insert(Effects, {
                    prt,
                    "Cylinder",
                    delay,
                    x3,
                    y3,
                    z3,
                    msh
                })
            end
        },
        Cylinder = {
            Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
                local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
                prt.Anchored = true
                prt.CFrame = cframe
                local msh = CFuncs.Mesh.Create("CylinderMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
                game:GetService("Debris"):AddItem(prt, 10)
                table.insert(Effects, {
                    prt,
                    "Cylinder",
                    delay,
                    x3,
                    y3,
                    z3,
                    msh
                })
            end
        },
        Wave = {
            Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
                local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
                prt.Anchored = true
                prt.CFrame = cframe
                local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://20329976", Vector3.new(0, 0, 0), Vector3.new(x1 / 60, y1 / 60, z1 / 60))
                game:GetService("Debris"):AddItem(prt, 10)
                table.insert(Effects, {
                    prt,
                    "Cylinder",
                    delay,
                    x3 / 60,
                    y3 / 60,
                    z3 / 60,
                    msh
                })
            end
        },
        Ring = {
            Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
                local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
                prt.Anchored = true
                prt.CFrame = cframe
                local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://3270017", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
                game:GetService("Debris"):AddItem(prt, 10)
                table.insert(Effects, {
                    prt,
                    "Cylinder",
                    delay,
                    x3,
                    y3,
                    z3,
                    msh
                })
            end
        },
        Break = {
            Create = function(brickcolor, cframe, x1, y1, z1)
                local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new(0.5, 0.5, 0.5))
                prt.Anchored = true
                prt.CFrame = cframe * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
                local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "Sphere", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
                local num = math.random(10, 50) / 1000
                game:GetService("Debris"):AddItem(prt, 10)
                table.insert(Effects, {
                    prt,
                    "Shatter",
                    num,
                    prt.CFrame,
                    math.random() - math.random(),
                    0,
                    math.random(50, 100) / 100
                })
            end
        },
        Spiral = {
            Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
                local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
                prt.Anchored = true
                prt.CFrame = cframe
                local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://1051557", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
                game:GetService("Debris"):AddItem(prt, 10)
                table.insert(Effects, {
                    prt,
                    "Cylinder",
                    delay,
                    x3,
                    y3,
                    z3,
                    msh
                })
            end
        },
        Push = {
            Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
                local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
                prt.Anchored = true
                prt.CFrame = cframe
                local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://437347603", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
                game:GetService("Debris"):AddItem(prt, 10)
                table.insert(Effects, {
                    prt,
                    "Cylinder",
                    delay,
                    x3,
                    y3,
                    z3,
                    msh
                })
            end
        }
    }
    -------------------------------------------------------
    --End Effect Function--
    -------------------------------------------------------

    function CreateSound(ID, PARENT, VOLUME, PITCH)
        local NSound = nil
        coroutine.resume(coroutine.create(function()
            NSound = Instance.new("Sound", PARENT)
            NSound.Volume = VOLUME
            NSound.Pitch = PITCH
            NSound.SoundId = "http://www.roblox.com/asset/?id="..ID
            swait()
            NSound:play()
            game:GetService("Debris"):AddItem(NSound, 10)
        end))
        return NSound
    end

    function Eviscerate(dude)
        if dude.Name ~= char.Name and dude.Name ~= plr.Name then
            local val = IT("BoolValue", dude)
            val.Name = "IsHit"
            local ds = coroutine.wrap(function()
                wait(0.5)
                target = nil
                coroutine.resume(coroutine.create(function()
                    for i, v in pairs(dude:GetChildren()) do
                        if v:IsA("Part") or v:IsA("MeshPart") then
                            coroutine.resume(coroutine.create(function()
                                v.CanCollide = false
                                local PartEmmit1 = IT("ParticleEmitter", v)
                                PartEmmit1.LightEmission = 1
                                PartEmmit1.Texture = "rbxassetid://284205403"
                                PartEmmit1.Color = ColorSequence.new(maincolor.Color)
                                PartEmmit1.Rate = 150
                                PartEmmit1.Lifetime = NumberRange.new(1)
                                PartEmmit1.Size = NumberSequence.new({
                                    NumberSequenceKeypoint.new(0, 0.75, 0),
                                    NumberSequenceKeypoint.new(1, 0, 0)
                                })
                                PartEmmit1.Transparency = NumberSequence.new({
                                    NumberSequenceKeypoint.new(0, 0, 0),
                                    NumberSequenceKeypoint.new(1, 1, 0)
                                })
                                PartEmmit1.Speed = NumberRange.new(0, 0)
                                PartEmmit1.VelocitySpread = 30000
                                PartEmmit1.Rotation = NumberRange.new(-500, 500)
                                PartEmmit1.RotSpeed = NumberRange.new(-500, 500)
                                local BodPoss = IT("BodyPosition", v)
                                BodPoss.P = 3000
                                BodPoss.D = 1000
                                BodPoss.maxForce = Vector3.new(50000000000, 50000000000, 50000000000)
                                BodPoss.position = v.Position + Vector3.new(Mrandom(-15, 15), Mrandom(-15, 15), Mrandom(-15, 15))
                                coroutine.resume(coroutine.create(function()
                                    wait(0.5)
                                    PartEmmit1.Enabled = false
                                end))
                            end))
                        end
                    end
                end))
            end)
            ds()
        end
    end
    function SphereAura(bonuspeed, FastSpeed, type, pos, x1, y1, z1, value, color, outerpos)
        local type = type
        local rng = Instance.new("Part", char)
        rng.Anchored = true
        rng.BrickColor = color
        rng.CanCollide = false
        rng.FormFactor = 3
        rng.Name = "Ring"
        rng.Material = "Neon"
        rng.Size = Vector3.new(1, 1, 1)
        rng.Transparency = 0
        rng.TopSurface = 0
        rng.BottomSurface = 0
        rng.CFrame = pos
        rng.CFrame = rng.CFrame + rng.CFrame.lookVector * outerpos
        local rngm = Instance.new("SpecialMesh", rng)
        rngm.MeshType = "Sphere"
        rngm.Scale = Vector3.new(x1, y1, z1)
        local scaler2 = 1
        local speeder = FastSpeed
        if type == "Add" then
            scaler2 = 1 * value
        elseif type == "Divide" then
            scaler2 = 1 / value
        end
        coroutine.resume(coroutine.create(function()
            for i = 0, 10 / bonuspeed, 0.1 do
                swait()
                if type == "Add" then
                    scaler2 = scaler2 - 0.01 * value / bonuspeed
                elseif type == "Divide" then
                    scaler2 = scaler2 - 0.01 / value * bonuspeed
                end
                rng.BrickColor = BrickColor.random()
                speeder = speeder - 0.01 * FastSpeed * bonuspeed
                rng.CFrame = rng.CFrame + rng.CFrame.lookVector * speeder * bonuspeed
                rng.Transparency = rng.Transparency + 0.01 * bonuspeed
                rngm.Scale = rngm.Scale + Vector3.new(scaler2 * bonuspeed, scaler2 * bonuspeed, 0)
            end
            rng:Destroy()
        end))
    end

    function FindNearestHead(Position, Distance, SinglePlayer)
        if SinglePlayer then
            return Distance > (SinglePlayer.Torso.CFrame.p - Position).magnitude
        end
        local List = {}
        for i, v in pairs(workspace:GetChildren()) do
            if v:IsA("Model") and v:findFirstChild("Head") and v ~= char and Distance >= (v.Head.Position - Position).magnitude then
                table.insert(List, v)
            end
        end
        return List
    end
    function SoulSteal(dude)
        if dude.Name ~= char.Name and dude.Name ~= plr.Name then
            local val = IT("BoolValue", dude)
            val.Name = "IsHit"
            local torso = (dude:FindFirstChild'Head' or dude:FindFirstChild'Torso' or dude:FindFirstChild'UpperTorso' or dude:FindFirstChild'LowerTorso' or dude:FindFirstChild'HumanoidRootPart')
            local soulst = coroutine.wrap(function()
                local soul = Instance.new("Part",char)
                soul.Size = Vector3.new(1,1,1)
                soul.CanCollide = false
                soul.Anchored = false
                soul.Position = torso.Position
                soul.Transparency = 1
                local PartEmmit1 = IT("ParticleEmitter", soul)
                PartEmmit1.LightEmission = 1
                PartEmmit1.Texture = "rbxassetid://569507414"
                PartEmmit1.Color = ColorSequence.new(maincolor.Color)
                PartEmmit1.Rate = 250
                PartEmmit1.Lifetime = NumberRange.new(1.6)
                PartEmmit1.Size = NumberSequence.new({
                    NumberSequenceKeypoint.new(0, 1, 0),
                    NumberSequenceKeypoint.new(1, 0, 0)
                })
                PartEmmit1.Transparency = NumberSequence.new({
                    NumberSequenceKeypoint.new(0, 0, 0),
                    NumberSequenceKeypoint.new(1, 1, 0)
                })
                PartEmmit1.Speed = NumberRange.new(0, 0)
                PartEmmit1.VelocitySpread = 30000
                PartEmmit1.Rotation = NumberRange.new(-360, 360)
                PartEmmit1.RotSpeed = NumberRange.new(-360, 360)
                local BodPoss = IT("BodyPosition", soul)
                BodPoss.P = 3000
                BodPoss.D = 1000
                BodPoss.maxForce = Vector3.new(50000000000, 50000000000, 50000000000)
                BodPoss.position = torso.Position + Vector3.new(Mrandom(-15, 15), Mrandom(-15, 15), Mrandom(-15, 15))
                wait(1.6)
                soul.Touched:connect(function(hit)
                    if hit.Parent == char then
                        soul:Destroy()
                    end
                end)
                wait(1.2)
                while soul do
                    swait()
                    PartEmmit1.Color = ColorSequence.new(maincolor.Color)
                    BodPoss.Position = tors.Position
                end
            end)
            soulst()
        end
    end
    function FaceMouse()
        local   Cam = workspace.CurrentCamera
        return {
            CFrame.new(char.Torso.Position, Vector3.new(mouse.Hit.p.x, char.Torso.Position.y, mouse.Hit.p.z)),
            Vector3.new(mouse.Hit.p.x, mouse.Hit.p.y, mouse.Hit.p.z)
        }
    end
    -------------------------------------------------------
    --End Important Functions--
    -------------------------------------------------------
--[[
        Thanks for using Build-To-Lua by jarredbcv.
]]--

    New = function(Object, Parent, Name, Data)
        local Object = Instance.new(Object)
        for Index, Value in pairs(Data or {}) do
            Object[Index] = Value
        end
        Object.Parent = Parent
        Object.Name = Name
        return Object
    end

    Gaunty = New("Model",char,"Gaunty",{})
    Handle = New("Part",Gaunty,"Handle",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.Metal,FormFactor = Enum.FormFactor.Custom,Size = Vector3.new(1, 1.26999998, 1),CFrame = CFrame.new(-5.67319345, 3.02064276, -77.6615906, 0.999894261, 0.010924357, 0.00963267777, -0.0110270018, 0.999882579, 0.0106679145, -0.00951499958, -0.0107729975, 0.999897003),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
    Mesh = New("BlockMesh",Handle,"Mesh",{Scale = Vector3.new(1.03999996, 1, 1.03999996),})
    NeonPart = New("Part",Gaunty,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.13999987, 0.109999999, 0.109999999),CFrame = CFrame.new(-5.82765579, 3.62595344, -77.6579285, -4.74974513e-08, -6.18456397e-10, 1.0000006, -5.58793545e-09, 1.0000006, -1.5279511e-10, -1.0000006, 4.65661287e-09, -4.00468707e-08),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
    mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle,C0 = CFrame.new(0, 0, 0, -4.37113883e-08, 0, -1, 0, 1, 0, 1, 0, -4.37113883e-08),C1 = CFrame.new(-0.161155701, 0.603512526, 0.00862884521, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
    NeonPart = New("Part",Gaunty,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.13999987, 0.109999999, 0.109999999),CFrame = CFrame.new(-6.13765526, 3.62595367, -77.6579285, -4.74974513e-08, -6.18456397e-10, 1.0000006, -5.58793545e-09, 1.0000006, -1.5279511e-10, -1.0000006, 4.65661287e-09, -4.00468707e-08),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
    mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle,C0 = CFrame.new(0, 0, 0, -4.37113883e-08, 0, -1, 0, 1, 0, 1, 0, -4.37113883e-08),C1 = CFrame.new(-0.471122265, 0.600126028, 0.00564575195, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
    NeonPart = New("Part",Gaunty,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.13999987, 0.109999999, 0.109999999),CFrame = CFrame.new(-5.5176549, 3.62595415, -77.6579285, -4.74974513e-08, -6.18456397e-10, 1.0000006, -5.58793545e-09, 1.0000006, -1.5279511e-10, -1.0000006, 4.65661287e-09, -4.00468707e-08),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
    mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle,C0 = CFrame.new(0, 0, 0, -4.37113883e-08, 0, -1, 0, 1, 0, 1, 0, -4.37113883e-08),C1 = CFrame.new(0.148812294, 0.606899738, 0.0116195679, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
    NeonPart = New("Part",Gaunty,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.13999987, 0.109999999, 0.109999999),CFrame = CFrame.new(-5.21765471, 3.62595463, -77.6579285, -4.74974513e-08, -6.18456397e-10, 1.0000006, -5.58793545e-09, 1.0000006, -1.5279511e-10, -1.0000006, 4.65661287e-09, -4.00468707e-08),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
    mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle,C0 = CFrame.new(0, 0, 0, -4.37113883e-08, 0, -1, 0, 1, 0, 1, 0, -4.37113883e-08),C1 = CFrame.new(0.448780537, 0.610177517, 0.014503479, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
    NeonPart = New("Part",Gaunty,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.13999987, 0.109999999, 0.109999999),CFrame = CFrame.new(-6.13765526, 2.53595448, -77.6579285, -4.74974513e-08, -6.18456397e-10, 1.0000006, -5.58793545e-09, 1.0000006, -1.5279511e-10, -1.0000006, 4.65661287e-09, -4.00468707e-08),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
    mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle,C0 = CFrame.new(0, 0, 0, -4.37113883e-08, 0, -1, 0, 1, 0, 1, 0, -4.37113883e-08),C1 = CFrame.new(-0.459102631, -0.489744425, -0.00598144531, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
    NeonPart = New("Part",Gaunty,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.13999987, 0.109999999, 0.109999999),CFrame = CFrame.new(-5.82765627, 2.53595448, -77.6579285, -4.74974513e-08, -6.18456397e-10, 1.0000006, -5.58793545e-09, 1.0000006, -1.5279511e-10, -1.0000006, 4.65661287e-09, -4.00468707e-08),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
    mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle,C0 = CFrame.new(0, 0, 0, -4.37113883e-08, 0, -1, 0, 1, 0, 1, 0, -4.37113883e-08),C1 = CFrame.new(-0.149136543, -0.486357927, -0.00299835205, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
    NeonPart = New("Part",Gaunty,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.13999987, 0.109999999, 0.109999999),CFrame = CFrame.new(-5.51765537, 2.53595448, -77.6579361, -4.74974513e-08, -6.18456397e-10, 1.0000006, -5.58793545e-09, 1.0000006, -1.5279511e-10, -1.0000006, 4.65661287e-09, -4.00468707e-08),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
    mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle,C0 = CFrame.new(0, 0, 0, -4.37113883e-08, 0, -1, 0, 1, 0, 1, 0, -4.37113883e-08),C1 = CFrame.new(0.160831451, -0.48297143, -1.52587891e-05, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
    NeonPart = New("Part",Gaunty,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.13999987, 0.109999999, 0.109999999),CFrame = CFrame.new(-5.21765566, 2.53595424, -77.6579361, -4.74974513e-08, -6.18456397e-10, 1.0000006, -5.58793545e-09, 1.0000006, -1.5279511e-10, -1.0000006, 4.65661287e-09, -4.00468707e-08),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
    mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle,C0 = CFrame.new(0, 0, 0, -4.37113883e-08, 0, -1, 0, 1, 0, 1, 0, -4.37113883e-08),C1 = CFrame.new(0.460799217, -0.479694128, 0.00286865234, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
    Part = New("Part",Gaunty,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.Metal,FormFactor = Enum.FormFactor.Custom,Size = Vector3.new(1.07999992, 0.279999971, 1.06999993),CFrame = CFrame.new(-5.66865063, 3.64553881, -77.6613617, 0.999894857, 0.0109243635, 0.00963268708, -0.0110270083, 0.999883175, 0.0106679257, -0.00951500144, -0.0107729994, 0.999897599),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
    Mesh = New("BlockMesh",Part,"Mesh",{Scale = Vector3.new(1.03999996, 1, 1.03999996),})
    mot = New("Motor",Part,"mot",{Part0 = Part,Part1 = Handle,C0 = CFrame.new(0, 0, 0, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),C1 = CFrame.new(-0.00235080719, 0.624869347, 0.00694274902, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
    NeonPart = New("Part",Gaunty,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,FormFactor = Enum.FormFactor.Custom,Size = Vector3.new(1.08999991, 0.0599999577, 1.07999992),CFrame = CFrame.new(-5.66490126, 3.73544312, -77.6652145, 0.999894857, 0.0109243635, 0.00963268708, -0.0110270083, 0.999883175, 0.0106679257, -0.00951500144, -0.0107729994, 0.999897599),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
    Mesh = New("BlockMesh",NeonPart,"Mesh",{Scale = Vector3.new(1.03999996, 1, 1.03999996),})
    mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle,C0 = CFrame.new(0, 0, 0, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),C1 = CFrame.new(0.000443935394, 0.714845657, 0.00408172607, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
    NeonPart = New("Part",Gaunty,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,FormFactor = Enum.FormFactor.Custom,Size = Vector3.new(1.08999991, 0.0599999577, 1.07999992),CFrame = CFrame.new(-5.66480446, 3.52554965, -77.65522, 0.999894857, 0.0109243635, 0.00963268708, -0.0110270083, 0.999883175, 0.0106679257, -0.00951500144, -0.0107729994, 0.999897599),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
    Mesh = New("BlockMesh",NeonPart,"Mesh",{Scale = Vector3.new(1.03999996, 1, 1.03999996),})
    mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle,C0 = CFrame.new(0, 0, 0, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),C1 = CFrame.new(0.00275993347, 0.504870415, 0.0118331909, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
    Part = New("Part",Gaunty,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.Metal,FormFactor = Enum.FormFactor.Custom,Size = Vector3.new(1.07999992, 0.279999971, 1.06999993),CFrame = CFrame.new(-5.6686511, 2.55553746, -77.6613541, 0.999894857, 0.0109243635, 0.00963268708, -0.0110270083, 0.999883175, 0.0106679257, -0.00951500144, -0.0107729994, 0.999897599),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
    Mesh = New("BlockMesh",Part,"Mesh",{Scale = Vector3.new(1.03999996, 1, 1.03999996),})
    mot = New("Motor",Part,"mot",{Part0 = Part,Part1 = Handle,C0 = CFrame.new(0, 0, 0, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),C1 = CFrame.new(0.00966835022, -0.465003252, -0.00468444824, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
    NeonPart = New("Part",Gaunty,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,FormFactor = Enum.FormFactor.Custom,Size = Vector3.new(1.08999991, 0.0599999577, 1.07999992),CFrame = CFrame.new(-5.66490126, 2.64544272, -77.6652145, 0.999894857, 0.0109243635, 0.00963268708, -0.0110270083, 0.999883175, 0.0106679257, -0.00951500144, -0.0107729994, 0.999897599),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
    Mesh = New("BlockMesh",NeonPart,"Mesh",{Scale = Vector3.new(1.03999996, 1, 1.03999996),})
    mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle,C0 = CFrame.new(0, 0, 0, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),C1 = CFrame.new(0.0124630928, -0.375026226, -0.00754547119, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
    NeonPart = New("Part",Gaunty,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,FormFactor = Enum.FormFactor.Custom,Size = Vector3.new(1.08999991, 0.0599999577, 1.07999992),CFrame = CFrame.new(-5.66480494, 2.43554902, -77.65522, 0.999894857, 0.0109243635, 0.00963268708, -0.0110270083, 0.999883175, 0.0106679257, -0.00951500144, -0.0107729994, 0.999897599),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
    Mesh = New("BlockMesh",NeonPart,"Mesh",{Scale = Vector3.new(1.03999996, 1, 1.03999996),})
    mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle,C0 = CFrame.new(0, 0, 0, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),C1 = CFrame.new(0.0147790909, -0.585001707, 0.000205993652, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
    NeonPart = New("Part",Gaunty,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.12999988, 0.109999999, 0.109999999),CFrame = CFrame.new(-5.67265606, 3.62595463, -78.1079407, 1.0000006, -6.18456397e-10, 3.7252903e-09, -6.18456397e-10, 1.0000006, 4.65661287e-09, 3.7252903e-09, 4.65661287e-09, 1.0000006),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
    mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle,C1 = CFrame.new(-0.0018901825, 0.61005497, -0.439842224, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
    NeonPart = New("Part",Gaunty,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.12999988, 0.109999999, 0.109999999),CFrame = CFrame.new(-5.67265606, 3.62595558, -77.8179321, 1.0000006, -6.18456397e-10, 3.7252903e-09, -6.18456397e-10, 1.0000006, 4.65661287e-09, 3.7252903e-09, 4.65661287e-09, 1.0000006),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
    mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle,C1 = CFrame.new(-0.00464963913, 0.606931448, -0.149864197, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
    NeonPart = New("Part",Gaunty,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.13999987, 0.109999999, 0.109999999),CFrame = CFrame.new(-5.66765547, 3.62595606, -77.4879303, 1.0000006, -6.18456397e-10, 3.7252903e-09, -6.18456397e-10, 1.0000006, 4.65661287e-09, 3.7252903e-09, 4.65661287e-09, 1.0000006),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
    mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle,C1 = CFrame.new(-0.00278997421, 0.603431463, 0.180152893, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
    NeonPart = New("Part",Gaunty,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.13999987, 0.109999999, 0.109999999),CFrame = CFrame.new(-5.66765547, 3.62595654, -77.1979294, 1.0000006, -6.18456397e-10, 3.7252903e-09, -6.18456397e-10, 1.0000006, 4.65661287e-09, 3.7252903e-09, 4.65661287e-09, 1.0000006),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
    mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle,C1 = CFrame.new(-0.00554895401, 0.600307703, 0.470123291, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
    NeonPart = New("Part",Gaunty,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.13999987, 0.109999999, 0.109999999),CFrame = CFrame.new(-5.66765547, 2.53595638, -77.1979294, 1.0000006, -6.18456397e-10, 3.7252903e-09, -6.18456397e-10, 1.0000006, 4.65661287e-09, 3.7252903e-09, 4.65661287e-09, 1.0000006),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
    mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle,C1 = CFrame.new(0.0064702034, -0.489563704, 0.458496094, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
    NeonPart = New("Part",Gaunty,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.13999987, 0.109999999, 0.109999999),CFrame = CFrame.new(-5.66765547, 2.53595614, -77.4879303, 1.0000006, -6.18456397e-10, 3.7252903e-09, -6.18456397e-10, 1.0000006, 4.65661287e-09, 3.7252903e-09, 4.65661287e-09, 1.0000006),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
    mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle,C1 = CFrame.new(0.00922966003, -0.486439705, 0.168525696, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
    NeonPart = New("Part",Gaunty,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.12999988, 0.109999999, 0.109999999),CFrame = CFrame.new(-5.67265558, 2.53595638, -77.8179245, 1.0000006, -6.18456397e-10, 3.7252903e-09, -6.18456397e-10, 1.0000006, 4.65661287e-09, 3.7252903e-09, 4.65661287e-09, 1.0000006),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
    mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle,C1 = CFrame.new(0.00736999512, -0.482939243, -0.161483765, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
    NeonPart = New("Part",Gaunty,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.12999988, 0.109999999, 0.109999999),CFrame = CFrame.new(-5.67265606, 2.53595614, -78.1079254, 1.0000006, -6.18456397e-10, 3.7252903e-09, -6.18456397e-10, 1.0000006, 4.65661287e-09, 3.7252903e-09, 4.65661287e-09, 1.0000006),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
    mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle,C1 = CFrame.new(0.0101289749, -0.479815245, -0.451454163, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
    Part = New("Part",Gaunty,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.Metal,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.15999985, 0.0700000003, 0.0700000003),CFrame = CFrame.new(-5.66765547, 3.62595677, -77.1979218, 1.0000006, -6.18456397e-10, 3.7252903e-09, -6.18456397e-10, 1.0000006, 4.65661287e-09, 3.7252903e-09, 4.65661287e-09, 1.0000006),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
    mot = New("Motor",Part,"mot",{Part0 = Part,Part1 = Handle,C1 = CFrame.new(-0.00554943085, 0.600307941, 0.47013092, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
    Part = New("Part",Gaunty,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.Metal,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.15999985, 0.0700000003, 0.0700000003),CFrame = CFrame.new(-5.66765499, 3.62595701, -77.4879303, 1.0000006, -6.18456397e-10, 3.7252903e-09, -6.18456397e-10, 1.0000006, 4.65661287e-09, 3.7252903e-09, 4.65661287e-09, 1.0000006),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
    mot = New("Motor",Part,"mot",{Part0 = Part,Part1 = Handle,C1 = CFrame.new(-0.00278949738, 0.603432655, 0.180152893, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
    Part = New("Part",Gaunty,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.Metal,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.15999985, 0.0700000003, 0.0700000003),CFrame = CFrame.new(-5.66765451, 3.62595749, -77.8179321, 1.0000006, -6.18456397e-10, 3.7252903e-09, -6.18456397e-10, 1.0000006, 4.65661287e-09, 3.7252903e-09, 4.65661287e-09, 1.0000006),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
    mot = New("Motor",Part,"mot",{Part0 = Part,Part1 = Handle,C1 = CFrame.new(0.000350952148, 0.606987953, -0.149810791, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
    Part = New("Part",Gaunty,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.Metal,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.15999985, 0.0700000003, 0.0700000003),CFrame = CFrame.new(-5.66765451, 3.62595749, -78.107933, 1.0000006, -6.18456397e-10, 3.7252903e-09, -6.18456397e-10, 1.0000006, 4.65661287e-09, 3.7252903e-09, 4.65661287e-09, 1.0000006),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
    mot = New("Motor",Part,"mot",{Part0 = Part,Part1 = Handle,C1 = CFrame.new(0.00311040878, 0.61011219, -0.439788818, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
    Part = New("Part",Gaunty,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.Metal,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.15999985, 0.0700000003, 0.0700000003),CFrame = CFrame.new(-5.66765499, 2.53595734, -78.107933, 1.0000006, -6.18456397e-10, 3.7252903e-09, -6.18456397e-10, 1.0000006, 4.65661287e-09, 3.7252903e-09, 4.65661287e-09, 1.0000006),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
    mot = New("Motor",Part,"mot",{Part0 = Part,Part1 = Handle,C1 = CFrame.new(0.0151295662, -0.479759216, -0.451416016, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
    Part = New("Part",Gaunty,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.Metal,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.15999985, 0.0700000003, 0.0700000003),CFrame = CFrame.new(-5.66765499, 2.5359571, -77.8179245, 1.0000006, -6.18456397e-10, 3.7252903e-09, -6.18456397e-10, 1.0000006, 4.65661287e-09, 3.7252903e-09, 4.65661287e-09, 1.0000006),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
    mot = New("Motor",Part,"mot",{Part0 = Part,Part1 = Handle,C1 = CFrame.new(0.0123701096, -0.482883692, -0.161437988, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
    Part = New("Part",Gaunty,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.Metal,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.15999985, 0.0700000003, 0.0700000003),CFrame = CFrame.new(-5.66765499, 2.5359571, -77.4879227, 1.0000006, -6.18456397e-10, 3.7252903e-09, -6.18456397e-10, 1.0000006, 4.65661287e-09, 3.7252903e-09, 4.65661287e-09, 1.0000006),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
    mot = New("Motor",Part,"mot",{Part0 = Part,Part1 = Handle,C1 = CFrame.new(0.00923013687, -0.48643899, 0.168533325, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
    Part = New("Part",Gaunty,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.Metal,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.15999985, 0.0700000003, 0.0700000003),CFrame = CFrame.new(-5.66765499, 2.53595686, -77.1979218, 1.0000006, -6.18456397e-10, 3.7252903e-09, -6.18456397e-10, 1.0000006, 4.65661287e-09, 3.7252903e-09, 4.65661287e-09, 1.0000006),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
    mot = New("Motor",Part,"mot",{Part0 = Part,Part1 = Handle,C1 = CFrame.new(0.00647068024, -0.489563227, 0.458503723, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
    Part = New("Part",Gaunty,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.Metal,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.15999985, 0.0700000003, 0.0700000003),CFrame = CFrame.new(-6.13765478, 3.62595701, -77.6579132, -4.74974513e-08, -6.18456397e-10, 1.0000006, -5.58793545e-09, 1.0000006, -1.5279511e-10, -1.0000006, 4.65661287e-09, -4.00468707e-08),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
    mot = New("Motor",Part,"mot",{Part0 = Part,Part1 = Handle,C0 = CFrame.new(0, 0, 0, -4.37113883e-08, 0, -1, 0, 1, 0, 1, 0, -4.37113883e-08),C1 = CFrame.new(-0.471121788, 0.600129128, 0.00566101074, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
    Part = New("Part",Gaunty,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.Metal,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.15999985, 0.0700000003, 0.0700000003),CFrame = CFrame.new(-5.82765484, 3.62595725, -77.6579132, -4.74974513e-08, -6.18456397e-10, 1.0000006, -5.58793545e-09, 1.0000006, -1.5279511e-10, -1.0000006, 4.65661287e-09, -4.00468707e-08),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
    mot = New("Motor",Part,"mot",{Part0 = Part,Part1 = Handle,C0 = CFrame.new(0, 0, 0, -4.37113883e-08, 0, -1, 0, 1, 0, 1, 0, -4.37113883e-08),C1 = CFrame.new(-0.161154747, 0.603516102, 0.008644104, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
    Part = New("Part",Gaunty,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.Metal,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.15999985, 0.0700000003, 0.0700000003),CFrame = CFrame.new(-5.51765442, 3.62595773, -77.6579132, -4.74974513e-08, -6.18456397e-10, 1.0000006, -5.58793545e-09, 1.0000006, -1.5279511e-10, -1.0000006, 4.65661287e-09, -4.00468707e-08),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
    mot = New("Motor",Part,"mot",{Part0 = Part,Part1 = Handle,C0 = CFrame.new(0, 0, 0, -4.37113883e-08, 0, -1, 0, 1, 0, 1, 0, -4.37113883e-08),C1 = CFrame.new(0.148812771, 0.606903076, 0.0116348267, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
    Part = New("Part",Gaunty,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.Metal,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.15999985, 0.0700000003, 0.0700000003),CFrame = CFrame.new(-5.21765375, 3.6259582, -77.6579132, -4.74974513e-08, -6.18456397e-10, 1.0000006, -5.58793545e-09, 1.0000006, -1.5279511e-10, -1.0000006, 4.65661287e-09, -4.00468707e-08),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
    mot = New("Motor",Part,"mot",{Part0 = Part,Part1 = Handle,C0 = CFrame.new(0, 0, 0, -4.37113883e-08, 0, -1, 0, 1, 0, 1, 0, -4.37113883e-08),C1 = CFrame.new(0.44878149, 0.610180855, 0.0145187378, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
    Part = New("Part",Gaunty,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.Metal,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.15999985, 0.0700000003, 0.0700000003),CFrame = CFrame.new(-5.21765327, 2.53595781, -77.6579132, -4.74974513e-08, -6.18456397e-10, 1.0000006, -5.58793545e-09, 1.0000006, -1.5279511e-10, -1.0000006, 4.65661287e-09, -4.00468707e-08),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
    mot = New("Motor",Part,"mot",{Part0 = Part,Part1 = Handle,C0 = CFrame.new(0, 0, 0, -4.37113883e-08, 0, -1, 0, 1, 0, 1, 0, -4.37113883e-08),C1 = CFrame.new(0.460801125, -0.47969079, 0.00289154053, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
    Part = New("Part",Gaunty,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.Metal,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.15999985, 0.0700000003, 0.0700000003),CFrame = CFrame.new(-5.51765299, 2.53595757, -77.6579208, -4.74974513e-08, -6.18456397e-10, 1.0000006, -5.58793545e-09, 1.0000006, -1.5279511e-10, -1.0000006, 4.65661287e-09, -4.00468707e-08),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
    mot = New("Motor",Part,"mot",{Part0 = Part,Part1 = Handle,C0 = CFrame.new(0, 0, 0, -4.37113883e-08, 0, -1, 0, 1, 0, 1, 0, -4.37113883e-08),C1 = CFrame.new(0.160833359, -0.48296833, 0, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
    Part = New("Part",Gaunty,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.Metal,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.15999985, 0.0700000003, 0.0700000003),CFrame = CFrame.new(-5.82765341, 2.53595734, -77.6579208, -4.74974513e-08, -6.18456397e-10, 1.0000006, -5.58793545e-09, 1.0000006, -1.5279511e-10, -1.0000006, 4.65661287e-09, -4.00468707e-08),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
    mot = New("Motor",Part,"mot",{Part0 = Part,Part1 = Handle,C0 = CFrame.new(0, 0, 0, -4.37113883e-08, 0, -1, 0, 1, 0, 1, 0, -4.37113883e-08),C1 = CFrame.new(-0.149133682, -0.486355066, -0.00299072266, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
    Part = New("Part",Gaunty,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.Metal,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.15999985, 0.0700000003, 0.0700000003),CFrame = CFrame.new(-6.13765383, 2.53595734, -77.6579208, -4.74974513e-08, -6.18456397e-10, 1.0000006, -5.58793545e-09, 1.0000006, -1.5279511e-10, -1.0000006, 4.65661287e-09, -4.00468707e-08),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
    mot = New("Motor",Part,"mot",{Part0 = Part,Part1 = Handle,C0 = CFrame.new(0, 0, 0, -4.37113883e-08, 0, -1, 0, 1, 0, 1, 0, -4.37113883e-08),C1 = CFrame.new(-0.4591012, -0.489741802, -0.00597381592, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
    NeonPart = New("WedgePart",Gaunty,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,Size = Vector3.new(1.14999998, 0.640000045, 0.25000003),CFrame = CFrame.new(-5.66203499, 3.4509573, -77.7865677, 1.0000006, -6.18456397e-10, 3.7252903e-09, -6.18456397e-10, 1.0000006, 4.65661287e-09, 3.7252903e-09, 4.65661287e-09, 1.0000006),BottomSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
    mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle,C1 = CFrame.new(0.00760126114, 0.431732178, -0.120269775, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
    NeonPart = New("WedgePart",Gaunty,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,Size = Vector3.new(1.14999998, 0.640000045, 0.280000031),CFrame = CFrame.new(-5.66203451, 3.45095778, -77.5215683, -1.0000006, -6.18456397e-10, -9.12696123e-08, 6.18456397e-10, 1.0000006, -4.65661287e-09, 8.38190317e-08, 4.65661287e-09, -1.0000006),BottomSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
    mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle,C0 = CFrame.new(0, 0, 0, -1, 0, 8.74227766e-08, 0, 1, 0, -8.74227766e-08, 0, -1),C1 = CFrame.new(0.00508022308, 0.428877592, 0.144706726, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
    NeonPart = New("WedgePart",Gaunty,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,Size = Vector3.new(1.14999998, 0.640000045, 0.25000003),CFrame = CFrame.new(-5.66203403, 2.81095791, -77.7865601, -1.0000006, 8.81700544e-08, 3.7252903e-09, -8.69331416e-08, -1.0000006, 4.65661287e-09, -3.7252903e-09, -4.65661287e-09, 1.0000006),BottomSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
    mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle,C0 = CFrame.new(0, 0, 0, -1, -8.74227766e-08, 0, 8.74227766e-08, -1, 0, 0, 0, 1),C1 = CFrame.new(0.0146594048, -0.208191872, -0.127082825, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
    NeonPart = New("WedgePart",Gaunty,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,Size = Vector3.new(1.14999998, 0.640000045, 0.280000031),CFrame = CFrame.new(-5.66203356, 2.8209579, -77.5215607, 1.0000006, -8.69331416e-08, 8.38190317e-08, -8.81700544e-08, -1.0000006, -4.65661287e-09, 9.12696123e-08, -4.65661287e-09, -1.0000006),BottomSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
    mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle,C0 = CFrame.new(0, 0, 0, 1, -8.74227766e-08, 8.74227766e-08, -8.74227766e-08, -1, -7.64274186e-15, 8.74227766e-08, 0, -1),C1 = CFrame.new(0.0120282173, -0.201047897, 0.137992859, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
    Wedge = New("WedgePart",Gaunty,"Wedge",{BrickColor = BrickColor.new("Black"),Size = Vector3.new(1.1099999, 0.569999993, 1.13),CFrame = CFrame.new(-5.6508193, 4.06113148, -77.6620178, -4.74974513e-08, -6.18456397e-10, 1.0000006, -5.58793545e-09, 1.0000006, -1.5279511e-10, -1.0000006, 4.65661287e-09, -4.00468707e-08),BottomSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
    mot = New("Motor",Wedge,"mot",{Part0 = Wedge,Part1 = Handle,C0 = CFrame.new(0, 0, 0, -4.37113883e-08, 0, -1, 0, 1, 0, 1, 0, -4.37113883e-08),C1 = CFrame.new(0.0109024048, 1.04061508, 0.010887146, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})

    Gaunty2 = New("Model",char,"Gaunty2",{})
    Handle2 = New("Part",Gaunty2,"Handle2",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.Metal,FormFactor = Enum.FormFactor.Custom,Size = Vector3.new(1, 1.26999998, 1),CFrame = CFrame.new(-5.67319345, 3.02064276, -77.6615906, 0.999894261, 0.010924357, 0.00963267777, -0.0110270018, 0.999882579, 0.0106679145, -0.00951499958, -0.0107729975, 0.999897003),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
    Mesh = New("BlockMesh",Handle2,"Mesh",{Scale = Vector3.new(1.03999996, 1, 1.03999996),})
    NeonPart = New("Part",Gaunty2,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.13999987, 0.109999999, 0.109999999),CFrame = CFrame.new(-5.82765579, 3.62595367, -77.6579285, -5.49480319e-08, -2.26282282e-09, 1.00000179, -1.67638063e-08, 1.00000179, -1.8189894e-09, -1.00000179, 1.39698386e-08, -3.25962901e-08),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
    mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle2,C0 = CFrame.new(0, 0, 0, -5.12227416e-08, -1.11758709e-08, -1.00000119, -1.44063961e-09, 1.00000119, 9.31322575e-09, 1.00000119, -9.89530236e-10, -3.63215804e-08),C1 = CFrame.new(-0.161155701, 0.603512764, 0.00862884521, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
    NeonPart = New("Part",Gaunty2,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.13999987, 0.109999999, 0.109999999),CFrame = CFrame.new(-6.13765526, 3.62595439, -77.6579285, -5.49480319e-08, -2.26282282e-09, 1.00000179, -1.67638063e-08, 1.00000179, -1.8189894e-09, -1.00000179, 1.39698386e-08, -3.25962901e-08),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
    mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle2,C0 = CFrame.new(0, 0, 0, -5.12227416e-08, -1.11758709e-08, -1.00000119, -1.44063961e-09, 1.00000119, 9.31322575e-09, 1.00000119, -9.89530236e-10, -3.63215804e-08),C1 = CFrame.new(-0.471122265, 0.600126743, 0.00564575195, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
    NeonPart = New("Part",Gaunty2,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.13999987, 0.109999999, 0.109999999),CFrame = CFrame.new(-5.51765394, 3.6259551, -77.6579285, -5.49480319e-08, -2.26282282e-09, 1.00000179, -1.67638063e-08, 1.00000179, -1.8189894e-09, -1.00000179, 1.39698386e-08, -3.25962901e-08),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
    mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle2,C0 = CFrame.new(0, 0, 0, -5.12227416e-08, -1.11758709e-08, -1.00000119, -1.44063961e-09, 1.00000119, 9.31322575e-09, 1.00000119, -9.89530236e-10, -3.63215804e-08),C1 = CFrame.new(0.148813248, 0.606900692, 0.0116195679, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
    NeonPart = New("Part",Gaunty2,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.13999987, 0.109999999, 0.109999999),CFrame = CFrame.new(-5.21765375, 3.62595558, -77.6579285, -5.49480319e-08, -2.26282282e-09, 1.00000179, -1.67638063e-08, 1.00000179, -1.8189894e-09, -1.00000179, 1.39698386e-08, -3.25962901e-08),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
    mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle2,C0 = CFrame.new(0, 0, 0, -5.12227416e-08, -1.11758709e-08, -1.00000119, -1.44063961e-09, 1.00000119, 9.31322575e-09, 1.00000119, -9.89530236e-10, -3.63215804e-08),C1 = CFrame.new(0.44878149, 0.610178471, 0.014503479, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
    NeonPart = New("Part",Gaunty2,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.13999987, 0.109999999, 0.109999999),CFrame = CFrame.new(-6.13765621, 2.535954, -77.6579285, -5.49480319e-08, -2.26282282e-09, 1.00000179, -1.67638063e-08, 1.00000179, -1.8189894e-09, -1.00000179, 1.39698386e-08, -3.25962901e-08),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
    mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle2,C0 = CFrame.new(0, 0, 0, -5.12227416e-08, -1.11758709e-08, -1.00000119, -1.44063961e-09, 1.00000119, 9.31322575e-09, 1.00000119, -9.89530236e-10, -3.63215804e-08),C1 = CFrame.new(-0.459103584, -0.489744902, -0.00598144531, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
    NeonPart = New("Part",Gaunty2,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.13999987, 0.109999999, 0.109999999),CFrame = CFrame.new(-5.82765722, 2.535954, -77.6579285, -5.49480319e-08, -2.26282282e-09, 1.00000179, -1.67638063e-08, 1.00000179, -1.8189894e-09, -1.00000179, 1.39698386e-08, -3.25962901e-08),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
    mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle2,C0 = CFrame.new(0, 0, 0, -5.12227416e-08, -1.11758709e-08, -1.00000119, -1.44063961e-09, 1.00000119, 9.31322575e-09, 1.00000119, -9.89530236e-10, -3.63215804e-08),C1 = CFrame.new(-0.149137497, -0.486358404, -0.00299835205, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
    NeonPart = New("Part",Gaunty2,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.13999987, 0.109999999, 0.109999999),CFrame = CFrame.new(-5.5176549, 2.53595448, -77.6579514, -5.49480319e-08, -2.26282282e-09, 1.00000179, -1.67638063e-08, 1.00000179, -1.8189894e-09, -1.00000179, 1.39698386e-08, -3.25962901e-08),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
    mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle2,C0 = CFrame.new(0, 0, 0, -5.12227416e-08, -1.11758709e-08, -1.00000119, -1.44063961e-09, 1.00000119, 9.31322575e-09, 1.00000119, -9.89530236e-10, -3.63215804e-08),C1 = CFrame.new(0.160831928, -0.482971191, -3.05175781e-05, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
    NeonPart = New("Part",Gaunty2,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.13999987, 0.109999999, 0.109999999),CFrame = CFrame.new(-5.21765566, 2.535954, -77.6579361, -5.49480319e-08, -2.26282282e-09, 1.00000179, -1.67638063e-08, 1.00000179, -1.8189894e-09, -1.00000179, 1.39698386e-08, -3.25962901e-08),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
    mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle2,C0 = CFrame.new(0, 0, 0, -5.12227416e-08, -1.11758709e-08, -1.00000119, -1.44063961e-09, 1.00000119, 9.31322575e-09, 1.00000119, -9.89530236e-10, -3.63215804e-08),C1 = CFrame.new(0.460799217, -0.479694366, 0.00286865234, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
    Part = New("Part",Gaunty2,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.Metal,FormFactor = Enum.FormFactor.Custom,Size = Vector3.new(1.07999992, 0.279999971, 1.06999993),CFrame = CFrame.new(-5.66865063, 3.64554, -77.661377, 0.999896049, 0.0109243765, 0.00963270571, -0.0110270213, 0.999884367, 0.010667949, -0.0095150033, -0.0107730031, 0.999898791),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
    Mesh = New("BlockMesh",Part,"Mesh",{Scale = Vector3.new(1.03999996, 1, 1.03999996),})
    mot = New("Motor",Part,"mot",{Part0 = Part,Part1 = Handle2,C0 = CFrame.new(0, 0, 0, 0.999895453, -0.0110270148, -0.00951500237, 0.01092437, 0.999883771, -0.0107730012, 0.0096326964, 0.0106679378, 0.999898195),C1 = CFrame.new(-0.00235033035, 0.624870777, 0.00692749023, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
    NeonPart = New("Part",Gaunty2,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,FormFactor = Enum.FormFactor.Custom,Size = Vector3.new(1.08999991, 0.0599999577, 1.07999992),CFrame = CFrame.new(-5.6649003, 3.73544407, -77.6652145, 0.999896049, 0.0109243765, 0.00963270571, -0.0110270213, 0.999884367, 0.010667949, -0.0095150033, -0.0107730031, 0.999898791),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
    Mesh = New("BlockMesh",NeonPart,"Mesh",{Scale = Vector3.new(1.03999996, 1, 1.03999996),})
    mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle2,C0 = CFrame.new(0, 0, 0, 0.999895453, -0.0110270148, -0.00951500237, 0.01092437, 0.999883771, -0.0107730012, 0.0096326964, 0.0106679378, 0.999898195),C1 = CFrame.new(0.000444412231, 0.714846611, 0.00408172607, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
    NeonPart = New("Part",Gaunty2,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,FormFactor = Enum.FormFactor.Custom,Size = Vector3.new(1.08999991, 0.0599999577, 1.07999992),CFrame = CFrame.new(-5.66480446, 3.5255506, -77.65522, 0.999896049, 0.0109243765, 0.00963270571, -0.0110270213, 0.999884367, 0.010667949, -0.0095150033, -0.0107730031, 0.999898791),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
    Mesh = New("BlockMesh",NeonPart,"Mesh",{Scale = Vector3.new(1.03999996, 1, 1.03999996),})
    mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle2,C0 = CFrame.new(0, 0, 0, 0.999895453, -0.0110270148, -0.00951500237, 0.01092437, 0.999883771, -0.0107730012, 0.0096326964, 0.0106679378, 0.999898195),C1 = CFrame.new(0.00275993347, 0.504871368, 0.0118331909, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
    Part = New("Part",Gaunty2,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.Metal,FormFactor = Enum.FormFactor.Custom,Size = Vector3.new(1.07999992, 0.279999971, 1.06999993),CFrame = CFrame.new(-5.6686511, 2.55553699, -77.6613541, 0.999896049, 0.0109243765, 0.00963270571, -0.0110270213, 0.999884367, 0.010667949, -0.0095150033, -0.0107730031, 0.999898791),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
    Mesh = New("BlockMesh",Part,"Mesh",{Scale = Vector3.new(1.03999996, 1, 1.03999996),})
    mot = New("Motor",Part,"mot",{Part0 = Part,Part1 = Handle2,C0 = CFrame.new(0, 0, 0, 0.999895453, -0.0110270148, -0.00951500237, 0.01092437, 0.999883771, -0.0107730012, 0.0096326964, 0.0106679378, 0.999898195),C1 = CFrame.new(0.00966835022, -0.465003729, -0.00468444824, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
    NeonPart = New("Part",Gaunty2,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,FormFactor = Enum.FormFactor.Custom,Size = Vector3.new(1.08999991, 0.0599999577, 1.07999992),CFrame = CFrame.new(-5.66490126, 2.64544272, -77.6652145, 0.999896049, 0.0109243765, 0.00963270571, -0.0110270213, 0.999884367, 0.010667949, -0.0095150033, -0.0107730031, 0.999898791),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
    Mesh = New("BlockMesh",NeonPart,"Mesh",{Scale = Vector3.new(1.03999996, 1, 1.03999996),})
    mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle2,C0 = CFrame.new(0, 0, 0, 0.999895453, -0.0110270148, -0.00951500237, 0.01092437, 0.999883771, -0.0107730012, 0.0096326964, 0.0106679378, 0.999898195),C1 = CFrame.new(0.0124630928, -0.375026226, -0.00754547119, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
    NeonPart = New("Part",Gaunty2,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,FormFactor = Enum.FormFactor.Custom,Size = Vector3.new(1.08999991, 0.0599999577, 1.07999992),CFrame = CFrame.new(-5.66480589, 2.43554854, -77.65522, 0.999896049, 0.0109243765, 0.00963270571, -0.0110270213, 0.999884367, 0.010667949, -0.0095150033, -0.0107730031, 0.999898791),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
    Mesh = New("BlockMesh",NeonPart,"Mesh",{Scale = Vector3.new(1.03999996, 1, 1.03999996),})
    mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle2,C0 = CFrame.new(0, 0, 0, 0.999895453, -0.0110270148, -0.00951500237, 0.01092437, 0.999883771, -0.0107730012, 0.0096326964, 0.0106679378, 0.999898195),C1 = CFrame.new(0.0147781372, -0.585002184, 0.000205993652, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
    NeonPart = New("Part",Gaunty2,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.12999988, 0.109999999, 0.109999999),CFrame = CFrame.new(-5.67265606, 3.62595463, -78.1079407, 1.00000179, -2.26282282e-09, 1.11758709e-08, -2.28465069e-09, 1.00000179, 1.39698386e-08, 1.11758709e-08, 1.39698386e-08, 1.00000179),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
    mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle2,C0 = CFrame.new(0, 0, 0, 1.00000119, -1.44791557e-09, 7.4505806e-09, -1.44063961e-09, 1.00000119, 9.31322575e-09, 7.4505806e-09, 9.31322575e-09, 1.00000119),C1 = CFrame.new(-0.0018901825, 0.61005497, -0.439842224, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
    NeonPart = New("Part",Gaunty2,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.12999988, 0.109999999, 0.109999999),CFrame = CFrame.new(-5.67265511, 3.6259563, -77.8179169, 1.00000179, -2.26282282e-09, 1.11758709e-08, -2.28465069e-09, 1.00000179, 1.39698386e-08, 1.11758709e-08, 1.39698386e-08, 1.00000179),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
    mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle2,C0 = CFrame.new(0, 0, 0, 1.00000119, -1.44791557e-09, 7.4505806e-09, -1.44063961e-09, 1.00000119, 9.31322575e-09, 7.4505806e-09, 9.31322575e-09, 1.00000119),C1 = CFrame.new(-0.00464916229, 0.606932163, -0.149848938, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
    NeonPart = New("Part",Gaunty2,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.13999987, 0.109999999, 0.109999999),CFrame = CFrame.new(-5.66765451, 3.62595701, -77.4879303, 1.00000179, -2.26282282e-09, 1.11758709e-08, -2.28465069e-09, 1.00000179, 1.39698386e-08, 1.11758709e-08, 1.39698386e-08, 1.00000179),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
    mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle2,C0 = CFrame.new(0, 0, 0, 1.00000119, -1.44791557e-09, 7.4505806e-09, -1.44063961e-09, 1.00000119, 9.31322575e-09, 7.4505806e-09, 9.31322575e-09, 1.00000119),C1 = CFrame.new(-0.00278902054, 0.603432655, 0.180152893, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
    NeonPart = New("Part",Gaunty2,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.13999987, 0.109999999, 0.109999999),CFrame = CFrame.new(-5.66765547, 3.62595749, -77.1979294, 1.00000179, -2.26282282e-09, 1.11758709e-08, -2.28465069e-09, 1.00000179, 1.39698386e-08, 1.11758709e-08, 1.39698386e-08, 1.00000179),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
    mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle2,C0 = CFrame.new(0, 0, 0, 1.00000119, -1.44791557e-09, 7.4505806e-09, -1.44063961e-09, 1.00000119, 9.31322575e-09, 7.4505806e-09, 9.31322575e-09, 1.00000119),C1 = CFrame.new(-0.00554895401, 0.600308895, 0.470123291, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
    NeonPart = New("Part",Gaunty2,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.13999987, 0.109999999, 0.109999999),CFrame = CFrame.new(-5.66765547, 2.53595638, -77.1979294, 1.00000179, -2.26282282e-09, 1.11758709e-08, -2.28465069e-09, 1.00000179, 1.39698386e-08, 1.11758709e-08, 1.39698386e-08, 1.00000179),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
    mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle2,C0 = CFrame.new(0, 0, 0, 1.00000119, -1.44791557e-09, 7.4505806e-09, -1.44063961e-09, 1.00000119, 9.31322575e-09, 7.4505806e-09, 9.31322575e-09, 1.00000119),C1 = CFrame.new(0.0064702034, -0.489563704, 0.458496094, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
    NeonPart = New("Part",Gaunty2,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.13999987, 0.109999999, 0.109999999),CFrame = CFrame.new(-5.66765547, 2.53595614, -77.4879303, 1.00000179, -2.26282282e-09, 1.11758709e-08, -2.28465069e-09, 1.00000179, 1.39698386e-08, 1.11758709e-08, 1.39698386e-08, 1.00000179),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
    mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle2,C0 = CFrame.new(0, 0, 0, 1.00000119, -1.44791557e-09, 7.4505806e-09, -1.44063961e-09, 1.00000119, 9.31322575e-09, 7.4505806e-09, 9.31322575e-09, 1.00000119),C1 = CFrame.new(0.00922966003, -0.486439705, 0.168525696, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
    NeonPart = New("Part",Gaunty2,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.12999988, 0.109999999, 0.109999999),CFrame = CFrame.new(-5.67265558, 2.53595638, -77.8179092, 1.00000179, -2.26282282e-09, 1.11758709e-08, -2.28465069e-09, 1.00000179, 1.39698386e-08, 1.11758709e-08, 1.39698386e-08, 1.00000179),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
    mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle2,C0 = CFrame.new(0, 0, 0, 1.00000119, -1.44791557e-09, 7.4505806e-09, -1.44063961e-09, 1.00000119, 9.31322575e-09, 7.4505806e-09, 9.31322575e-09, 1.00000119),C1 = CFrame.new(0.00736999512, -0.482939243, -0.161468506, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
    NeonPart = New("Part",Gaunty2,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.12999988, 0.109999999, 0.109999999),CFrame = CFrame.new(-5.67265606, 2.53595567, -78.1079254, 1.00000179, -2.26282282e-09, 1.11758709e-08, -2.28465069e-09, 1.00000179, 1.39698386e-08, 1.11758709e-08, 1.39698386e-08, 1.00000179),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
    mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle2,C0 = CFrame.new(0, 0, 0, 1.00000119, -1.44791557e-09, 7.4505806e-09, -1.44063961e-09, 1.00000119, 9.31322575e-09, 7.4505806e-09, 9.31322575e-09, 1.00000119),C1 = CFrame.new(0.0101289749, -0.479815722, -0.451454163, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
    Part = New("Part",Gaunty2,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.Metal,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.15999985, 0.0700000003, 0.0700000003),CFrame = CFrame.new(-5.66765451, 3.62595749, -77.1979218, 1.00000179, -2.26282282e-09, 1.11758709e-08, -2.28465069e-09, 1.00000179, 1.39698386e-08, 1.11758709e-08, 1.39698386e-08, 1.00000179),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
    mot = New("Motor",Part,"mot",{Part0 = Part,Part1 = Handle2,C0 = CFrame.new(0, 0, 0, 1.00000119, -1.44791557e-09, 7.4505806e-09, -1.44063961e-09, 1.00000119, 9.31322575e-09, 7.4505806e-09, 9.31322575e-09, 1.00000119),C1 = CFrame.new(-0.00554847717, 0.600308895, 0.47013092, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
    Part = New("Part",Gaunty2,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.Metal,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.15999985, 0.0700000003, 0.0700000003),CFrame = CFrame.new(-5.66765404, 3.62595797, -77.4879303, 1.00000179, -2.26282282e-09, 1.11758709e-08, -2.28465069e-09, 1.00000179, 1.39698386e-08, 1.11758709e-08, 1.39698386e-08, 1.00000179),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
    mot = New("Motor",Part,"mot",{Part0 = Part,Part1 = Handle2,C0 = CFrame.new(0, 0, 0, 1.00000119, -1.44791557e-09, 7.4505806e-09, -1.44063961e-09, 1.00000119, 9.31322575e-09, 7.4505806e-09, 9.31322575e-09, 1.00000119),C1 = CFrame.new(-0.0027885437, 0.603433609, 0.180152893, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
    Part = New("Part",Gaunty2,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.Metal,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.15999985, 0.0700000003, 0.0700000003),CFrame = CFrame.new(-5.66765356, 3.6259594, -77.8179321, 1.00000179, -2.26282282e-09, 1.11758709e-08, -2.28465069e-09, 1.00000179, 1.39698386e-08, 1.11758709e-08, 1.39698386e-08, 1.00000179),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
    mot = New("Motor",Part,"mot",{Part0 = Part,Part1 = Handle2,C0 = CFrame.new(0, 0, 0, 1.00000119, -1.44791557e-09, 7.4505806e-09, -1.44063961e-09, 1.00000119, 9.31322575e-09, 7.4505806e-09, 9.31322575e-09, 1.00000119),C1 = CFrame.new(0.000351905823, 0.606989861, -0.149810791, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
    Part = New("Part",Gaunty2,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.Metal,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.15999985, 0.0700000003, 0.0700000003),CFrame = CFrame.new(-5.66765356, 3.62595844, -78.107933, 1.00000179, -2.26282282e-09, 1.11758709e-08, -2.28465069e-09, 1.00000179, 1.39698386e-08, 1.11758709e-08, 1.39698386e-08, 1.00000179),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
    mot = New("Motor",Part,"mot",{Part0 = Part,Part1 = Handle2,C0 = CFrame.new(0, 0, 0, 1.00000119, -1.44791557e-09, 7.4505806e-09, -1.44063961e-09, 1.00000119, 9.31322575e-09, 7.4505806e-09, 9.31322575e-09, 1.00000119),C1 = CFrame.new(0.00311136246, 0.610113144, -0.439788818, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
    Part = New("Part",Gaunty2,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.Metal,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.15999985, 0.0700000003, 0.0700000003),CFrame = CFrame.new(-5.66765499, 2.53595734, -78.107933, 1.00000179, -2.26282282e-09, 1.11758709e-08, -2.28465069e-09, 1.00000179, 1.39698386e-08, 1.11758709e-08, 1.39698386e-08, 1.00000179),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
    mot = New("Motor",Part,"mot",{Part0 = Part,Part1 = Handle2,C0 = CFrame.new(0, 0, 0, 1.00000119, -1.44791557e-09, 7.4505806e-09, -1.44063961e-09, 1.00000119, 9.31322575e-09, 7.4505806e-09, 9.31322575e-09, 1.00000119),C1 = CFrame.new(0.0151295662, -0.479759216, -0.451416016, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
    Part = New("Part",Gaunty2,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.Metal,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.15999985, 0.0700000003, 0.0700000003),CFrame = CFrame.new(-5.66765499, 2.5359571, -77.8179092, 1.00000179, -2.26282282e-09, 1.11758709e-08, -2.28465069e-09, 1.00000179, 1.39698386e-08, 1.11758709e-08, 1.39698386e-08, 1.00000179),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
    mot = New("Motor",Part,"mot",{Part0 = Part,Part1 = Handle2,C0 = CFrame.new(0, 0, 0, 1.00000119, -1.44791557e-09, 7.4505806e-09, -1.44063961e-09, 1.00000119, 9.31322575e-09, 7.4505806e-09, 9.31322575e-09, 1.00000119),C1 = CFrame.new(0.0123701096, -0.48288393, -0.161422729, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
    Part = New("Part",Gaunty2,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.Metal,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.15999985, 0.0700000003, 0.0700000003),CFrame = CFrame.new(-5.66765499, 2.5359571, -77.4879227, 1.00000179, -2.26282282e-09, 1.11758709e-08, -2.28465069e-09, 1.00000179, 1.39698386e-08, 1.11758709e-08, 1.39698386e-08, 1.00000179),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
    mot = New("Motor",Part,"mot",{Part0 = Part,Part1 = Handle2,C0 = CFrame.new(0, 0, 0, 1.00000119, -1.44791557e-09, 7.4505806e-09, -1.44063961e-09, 1.00000119, 9.31322575e-09, 7.4505806e-09, 9.31322575e-09, 1.00000119),C1 = CFrame.new(0.00923013687, -0.48643899, 0.168533325, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
    Part = New("Part",Gaunty2,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.Metal,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.15999985, 0.0700000003, 0.0700000003),CFrame = CFrame.new(-5.66765499, 2.53595662, -77.1979218, 1.00000179, -2.26282282e-09, 1.11758709e-08, -2.28465069e-09, 1.00000179, 1.39698386e-08, 1.11758709e-08, 1.39698386e-08, 1.00000179),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
    mot = New("Motor",Part,"mot",{Part0 = Part,Part1 = Handle2,C0 = CFrame.new(0, 0, 0, 1.00000119, -1.44791557e-09, 7.4505806e-09, -1.44063961e-09, 1.00000119, 9.31322575e-09, 7.4505806e-09, 9.31322575e-09, 1.00000119),C1 = CFrame.new(0.00647068024, -0.489563465, 0.458503723, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
    Part = New("Part",Gaunty2,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.Metal,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.15999985, 0.0700000003, 0.0700000003),CFrame = CFrame.new(-6.13765478, 3.62595797, -77.6579132, -5.49480319e-08, -2.26282282e-09, 1.00000179, -1.67638063e-08, 1.00000179, -1.8189894e-09, -1.00000179, 1.39698386e-08, -3.25962901e-08),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
    mot = New("Motor",Part,"mot",{Part0 = Part,Part1 = Handle2,C0 = CFrame.new(0, 0, 0, -5.12227416e-08, -1.11758709e-08, -1.00000119, -1.44063961e-09, 1.00000119, 9.31322575e-09, 1.00000119, -9.89530236e-10, -3.63215804e-08),C1 = CFrame.new(-0.471121788, 0.600130081, 0.00566101074, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
    Part = New("Part",Gaunty2,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.Metal,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.15999985, 0.0700000003, 0.0700000003),CFrame = CFrame.new(-5.82765484, 3.6259582, -77.6579132, -5.49480319e-08, -2.26282282e-09, 1.00000179, -1.67638063e-08, 1.00000179, -1.8189894e-09, -1.00000179, 1.39698386e-08, -3.25962901e-08),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
    mot = New("Motor",Part,"mot",{Part0 = Part,Part1 = Handle2,C0 = CFrame.new(0, 0, 0, -5.12227416e-08, -1.11758709e-08, -1.00000119, -1.44063961e-09, 1.00000119, 9.31322575e-09, 1.00000119, -9.89530236e-10, -3.63215804e-08),C1 = CFrame.new(-0.161154747, 0.603517056, 0.008644104, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
    Part = New("Part",Gaunty2,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.Metal,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.15999985, 0.0700000003, 0.0700000003),CFrame = CFrame.new(-5.51765347, 3.62595868, -77.6579132, -5.49480319e-08, -2.26282282e-09, 1.00000179, -1.67638063e-08, 1.00000179, -1.8189894e-09, -1.00000179, 1.39698386e-08, -3.25962901e-08),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
    mot = New("Motor",Part,"mot",{Part0 = Part,Part1 = Handle2,C0 = CFrame.new(0, 0, 0, -5.12227416e-08, -1.11758709e-08, -1.00000119, -1.44063961e-09, 1.00000119, 9.31322575e-09, 1.00000119, -9.89530236e-10, -3.63215804e-08),C1 = CFrame.new(0.148813725, 0.60690403, 0.0116348267, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
    Part = New("Part",Gaunty2,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.Metal,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.15999985, 0.0700000003, 0.0700000003),CFrame = CFrame.new(-5.2176528, 3.62595916, -77.6579132, -5.49480319e-08, -2.26282282e-09, 1.00000179, -1.67638063e-08, 1.00000179, -1.8189894e-09, -1.00000179, 1.39698386e-08, -3.25962901e-08),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
    mot = New("Motor",Part,"mot",{Part0 = Part,Part1 = Handle2,C0 = CFrame.new(0, 0, 0, -5.12227416e-08, -1.11758709e-08, -1.00000119, -1.44063961e-09, 1.00000119, 9.31322575e-09, 1.00000119, -9.89530236e-10, -3.63215804e-08),C1 = CFrame.new(0.448782444, 0.610181808, 0.0145187378, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
    Part = New("Part",Gaunty2,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.Metal,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.15999985, 0.0700000003, 0.0700000003),CFrame = CFrame.new(-5.21765327, 2.53595757, -77.6579132, -5.49480319e-08, -2.26282282e-09, 1.00000179, -1.67638063e-08, 1.00000179, -1.8189894e-09, -1.00000179, 1.39698386e-08, -3.25962901e-08),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
    mot = New("Motor",Part,"mot",{Part0 = Part,Part1 = Handle2,C0 = CFrame.new(0, 0, 0, -5.12227416e-08, -1.11758709e-08, -1.00000119, -1.44063961e-09, 1.00000119, 9.31322575e-09, 1.00000119, -9.89530236e-10, -3.63215804e-08),C1 = CFrame.new(0.460801601, -0.479691029, 0.00289154053, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
    Part = New("Part",Gaunty2,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.Metal,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.15999985, 0.0700000003, 0.0700000003),CFrame = CFrame.new(-5.51765299, 2.53595757, -77.6579361, -5.49480319e-08, -2.26282282e-09, 1.00000179, -1.67638063e-08, 1.00000179, -1.8189894e-09, -1.00000179, 1.39698386e-08, -3.25962901e-08),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
    mot = New("Motor",Part,"mot",{Part0 = Part,Part1 = Handle2,C0 = CFrame.new(0, 0, 0, -5.12227416e-08, -1.11758709e-08, -1.00000119, -1.44063961e-09, 1.00000119, 9.31322575e-09, 1.00000119, -9.89530236e-10, -3.63215804e-08),C1 = CFrame.new(0.160833836, -0.48296833, -1.52587891e-05, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
    Part = New("Part",Gaunty2,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.Metal,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.15999985, 0.0700000003, 0.0700000003),CFrame = CFrame.new(-5.82765436, 2.5359571, -77.6579208, -5.49480319e-08, -2.26282282e-09, 1.00000179, -1.67638063e-08, 1.00000179, -1.8189894e-09, -1.00000179, 1.39698386e-08, -3.25962901e-08),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
    mot = New("Motor",Part,"mot",{Part0 = Part,Part1 = Handle2,C0 = CFrame.new(0, 0, 0, -5.12227416e-08, -1.11758709e-08, -1.00000119, -1.44063961e-09, 1.00000119, 9.31322575e-09, 1.00000119, -9.89530236e-10, -3.63215804e-08),C1 = CFrame.new(-0.149134636, -0.486355305, -0.00299072266, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
    Part = New("Part",Gaunty2,"Part",{BrickColor = BrickColor.new("Black"),Material = Enum.Material.Metal,Shape = Enum.PartType.Cylinder,Size = Vector3.new(1.15999985, 0.0700000003, 0.0700000003),CFrame = CFrame.new(-6.13765478, 2.53595734, -77.6579208, -5.49480319e-08, -2.26282282e-09, 1.00000179, -1.67638063e-08, 1.00000179, -1.8189894e-09, -1.00000179, 1.39698386e-08, -3.25962901e-08),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
    mot = New("Motor",Part,"mot",{Part0 = Part,Part1 = Handle2,C0 = CFrame.new(0, 0, 0, -5.12227416e-08, -1.11758709e-08, -1.00000119, -1.44063961e-09, 1.00000119, 9.31322575e-09, 1.00000119, -9.89530236e-10, -3.63215804e-08),C1 = CFrame.new(-0.459102154, -0.489741802, -0.00597381592, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
    NeonPart = New("WedgePart",Gaunty2,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,Size = Vector3.new(1.14999998, 0.640000045, 0.25000003),CFrame = CFrame.new(-5.66203403, 3.45095801, -77.7865524, 1.00000179, -2.26282282e-09, 1.11758709e-08, -2.28465069e-09, 1.00000179, 1.39698386e-08, 1.11758709e-08, 1.39698386e-08, 1.00000179),BottomSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
    mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle2,C0 = CFrame.new(0, 0, 0, 1.00000119, -1.44791557e-09, 7.4505806e-09, -1.44063961e-09, 1.00000119, 9.31322575e-09, 7.4505806e-09, 9.31322575e-09, 1.00000119),C1 = CFrame.new(0.00760221481, 0.431732655, -0.120254517, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
    NeonPart = New("WedgePart",Gaunty2,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,Size = Vector3.new(1.14999998, 0.640000045, 0.280000031),CFrame = CFrame.new(-5.66203356, 3.45095849, -77.521553, -1.00000179, -2.26282282e-09, -9.87201929e-08, 2.28465069e-09, 1.00000179, -1.39698386e-08, 7.63684511e-08, 1.39698386e-08, -1.00000179),BottomSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
    mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle2,C0 = CFrame.new(0, 0, 0, -1.00000119, 1.45519152e-09, 8.00937414e-08, -1.44063961e-09, 1.00000119, 9.31322575e-09, -9.49949026e-08, -9.31322575e-09, -1.00000119),C1 = CFrame.new(0.00508117676, 0.428878307, 0.144721985, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
    NeonPart = New("WedgePart",Gaunty2,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,Size = Vector3.new(1.14999998, 0.640000045, 0.25000003),CFrame = CFrame.new(-5.66203308, 2.81095791, -77.7865601, -1.00000179, 8.98216967e-08, 1.11758709e-08, -8.52742232e-08, -1.00000179, 1.39698386e-08, -1.11758709e-08, -1.39698386e-08, 1.00000179),BottomSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
    mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle2,C0 = CFrame.new(0, 0, 0, -1.00000119, -8.61036824e-08, -7.4505806e-09, 8.89922376e-08, -1.00000119, -9.31322575e-09, 7.4505806e-09, 9.31322575e-09, 1.00000119),C1 = CFrame.new(0.0146603584, -0.208191872, -0.127082825, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
    NeonPart = New("WedgePart",Gaunty2,"NeonPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.Neon,Size = Vector3.new(1.14999998, 0.640000045, 0.280000031),CFrame = CFrame.new(-5.6620326, 2.82095814, -77.5215454, 1.00000179, -8.52887752e-08, 7.63684511e-08, -8.98362487e-08, -1.00000179, -1.39698386e-08, 9.87201929e-08, -1.39698386e-08, -1.00000179),BottomSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
    mot = New("Motor",NeonPart,"mot",{Part0 = NeonPart,Part1 = Handle2,C0 = CFrame.new(0, 0, 0, 1.00000119, -8.89995135e-08, 9.49949026e-08, -8.61109584e-08, -1.00000119, -9.31322575e-09, 8.00937414e-08, -9.31322575e-09, -1.00000119),C1 = CFrame.new(0.012029171, -0.201047897, 0.138008118, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})
    Wedge = New("WedgePart",Gaunty2,"Wedge",{BrickColor = BrickColor.new("Black"),Size = Vector3.new(1.1099999, 0.569999993, 1.13),CFrame = CFrame.new(-5.6508193, 4.06113243, -77.6620178, -5.49480319e-08, -2.26282282e-09, 1.00000179, -1.67638063e-08, 1.00000179, -1.8189894e-09, -1.00000179, 1.39698386e-08, -3.25962901e-08),BottomSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.105882, 0.164706, 0.207843),})
    mot = New("Motor",Wedge,"mot",{Part0 = Wedge,Part1 = Handle2,C0 = CFrame.new(0, 0, 0, -5.12227416e-08, -1.11758709e-08, -1.00000119, -1.44063961e-09, 1.00000119, 9.31322575e-09, 1.00000119, -9.89530236e-10, -3.63215804e-08),C1 = CFrame.new(0.0109024048, 1.04061604, 0.010887146, 0.999894261, -0.0110270018, -0.00951499958, 0.010924357, 0.999882579, -0.0107729975, 0.00963267777, 0.0106679145, 0.999897003),})


    NewInstance = function(instance,parent,properties)
        local inst = Instance.new(instance,parent)
        if(properties)then
            for i,v in next, properties do
                pcall(function() inst[i] = v end)
            end
        end
        return inst;
    end

    local HW = NewInstance('Motor', char, {Part0 = ra, Part1 = Handle, C0 = CF(0,-.51,0)})
    local HW2 = NewInstance('Motor', char, {Part0 = la, Part1 = Handle2, C0 = CF(0,-.51,0) * angles(Rad(0),Rad(180),Rad(0))})

    for _,v in next, Gaunty:children() do
        v.CanCollide = false
    end
    for _,v in next, Gaunty2:children() do
        v.CanCollide = false
    end
    local all, last = {}, nil
    ArmourParts = {}
    NeonParts = {}
    function scan(p)
        for _, v in pairs(p:GetChildren()) do
            if v:IsA("BasePart") then
                if v.BrickColor == BrickColor.new("Black") then
                    table.insert(ArmourParts, v)
                end
                if v.BrickColor == BrickColor.new("Institutional white") then
                    table.insert(NeonParts, v)
                end
                if last then
                    local w = Instance.new("Weld")
                    w.Part0, w.Part1 = last, v
                    w.C0 = v.CFrame:toObjectSpace(last.CFrame):inverse()
                    w.Parent = last
                end
                table.insert(all, v)
                last = v
            end
            scan(v)
        end
    end
    scan(Gaunty)
    local all2, last2 = {}, nil
    ArmourParts2 = {}
    NeonParts2 = {}
    function scan2(p)
        for _, v in pairs(p:GetChildren()) do
            if v:IsA("BasePart") then
                if v.BrickColor == BrickColor.new("Black") then
                    table.insert(ArmourParts2, v)
                end
                if v.BrickColor == BrickColor.new("Institutional white") then
                    table.insert(NeonParts2, v)
                end
                if last2 then
                    local w = Instance.new("Weld")
                    w.Part0, w.Part1 = last2, v
                    w.C0 = v.CFrame:toObjectSpace(last2.CFrame):inverse()
                    w.Parent = last2
                end
                table.insert(all2, v)
                last2 = v
            end
            scan2(v)
        end
    end
    scan2(Gaunty2)
    for i, v in pairs(ArmourParts) do
        v.BrickColor = BrickC("Black")
    end
    for i, v in pairs(NeonParts) do
        v.BrickColor = BrickC("Really red")
    end
    for i, v in pairs(ArmourParts2) do
        v.BrickColor = BrickC("Black")
    end
    for i, v in pairs(NeonParts2) do
        v.BrickColor = BrickC("Really red")
    end
    maincolor = BrickC("Really red")
    -------------------------------------------------------
    --Start Music Option--
    -------------------------------------------------------
    local Music = Instance.new("Sound",char)
    Music.Volume = 2.5
    Music.SoundId = "rbxassetid://550578451"
    Music.Looped = true
    Music.Pitch = 1 --Pitcher
    Music:Play()
    -------------------------------------------------------
    --End Music Option--
    -------------------------------------------------------
    local naeeym2 = Instance.new("BillboardGui",char)
    naeeym2.AlwaysOnTop = true
    naeeym2.Size = UDim2.new(5,35,2,35)
    naeeym2.StudsOffset = Vector3.new(0,2,0)
    naeeym2.Adornee = hed
    naeeym2.Name = "Name"

    local tecks2 = Instance.new("TextLabel",naeeym2)
    tecks2.BackgroundTransparency = 1
    tecks2.TextScaled = true
    tecks2.BorderSizePixel = 0
    tecks2.Text = "Ender"
    tecks2.Font = "Garamond"
    tecks2.TextSize = 30
    tecks2.TextStrokeTransparency = 0
    tecks2.TextColor3 = Color3.new(0,0,0)
    tecks2.TextStrokeColor3 = Color3.new(0, 0, 0)
    tecks2.Size = UDim2.new(1,0,0.5,0)
    tecks2.Parent = naeeym2

    function chatfunc(text, color)
        local chat = coroutine.wrap(function()
            if char:FindFirstChild("TalkingBillBoard") ~= nil then
                char:FindFirstChild("TalkingBillBoard"):destroy()
            end
            local naeeym2 = Instance.new("BillboardGui", char)
            naeeym2.Size = UDim2.new(0, 100, 0, 40)
            naeeym2.StudsOffset = Vector3.new(0, 5, 0)
            naeeym2.Adornee = hed
            naeeym2.Name = "TalkingBillBoard"
            local tecks2 = Instance.new("TextLabel", naeeym2)
            tecks2.BackgroundTransparency = 1
            tecks2.BorderSizePixel = 0
            tecks2.Text = ""
            tecks2.Font = "SciFi"
            tecks2.TextSize = 30
            tecks2.TextStrokeTransparency = 0
            tecks2.TextColor3 = color
            tecks2.TextStrokeColor3 = Color3.new(0, 0, 0)
            tecks2.Size = UDim2.new(1, 0, 0.5, 0)
            local tecks3 = Instance.new("TextLabel", naeeym2)
            tecks3.BackgroundTransparency = 1
            tecks3.BorderSizePixel = 0
            tecks3.Text = ""
            tecks3.Font = "SciFi"
            tecks3.TextSize = 30
            tecks3.TextStrokeTransparency = 0
            tecks3.TextColor3 = Color3.new(0, 0, 0)
            tecks3.TextStrokeColor3 = color
            tecks3.Size = UDim2.new(1, 0, 0.5, 0)
            coroutine.resume(coroutine.create(function()
                while true do
                    swait(1)
                    tecks2.TextColor3 = BrickColor.random().Color
                    tecks3.TextStrokeColor3 = BrickColor.random().Color
                    tecks2.Position = UDim2.new(0, math.random(-5, 5), 0, math.random(-5, 5))
                    tecks3.Position = UDim2.new(0, math.random(-5, 5), 0, math.random(-5, 5))
                    tecks2.Rotation = math.random(-5, 5)
                    tecks3.Rotation = math.random(-5, 5)
                end
            end))
            for i = 1, string.len(text) do
                CFuncs.Sound.Create("rbxassetid://274118116", char, 0.25, 0.115)
                tecks2.Text = string.sub(text, 1, i)
                tecks3.Text = string.sub(text, 1, i)
                swait(1)
            end
            wait(1)
            local randomrot = math.random(1, 2)
            if randomrot == 1 then
                for i = 1, 50 do
                    swait()
                    tecks2.Rotation = tecks2.Rotation - 0.75
                    tecks2.TextStrokeTransparency = tecks2.TextStrokeTransparency + 0.04
                    tecks2.TextTransparency = tecks2.TextTransparency + 0.04
                    tecks3.Rotation = tecks2.Rotation + 0.75
                    tecks3.TextStrokeTransparency = tecks2.TextStrokeTransparency + 0.04
                    tecks3.TextTransparency = tecks2.TextTransparency + 0.04
                end
            elseif randomrot == 2 then
                for i = 1, 50 do
                    swait()
                    tecks2.Rotation = tecks2.Rotation + 0.75
                    tecks2.TextStrokeTransparency = tecks2.TextStrokeTransparency + 0.04
                    tecks2.TextTransparency = tecks2.TextTransparency + 0.04
                    tecks3.Rotation = tecks2.Rotation - 0.75
                    tecks3.TextStrokeTransparency = tecks2.TextStrokeTransparency + 0.04
                    tecks3.TextTransparency = tecks2.TextTransparency + 0.04
                end
            end
            naeeym2:Destroy()
        end)
        chat()
    end
    -------------------------------------------------------
    --Start Attacks N Stuff--
    -------------------------------------------------------
    local sine=0
    function HitboxFunction(Pose, lifetime, siz1, siz2, siz3, Radie, Min, Max, kb, atype)
        local Hitboxpart = Instance.new("Part", EffectModel)
        RemoveOutlines(Hitboxpart)
        Hitboxpart.Size = Vector3.new(siz1, siz2, siz3)
        Hitboxpart.CanCollide = false
        Hitboxpart.Transparency = 1
        Hitboxpart.Anchored = true
        Hitboxpart.CFrame = Pose
        game:GetService("Debris"):AddItem(Hitboxpart, lifetime)
        MagniDamage(Hitboxpart, Radie, Min, Max, kb, atype)
    end
    wait2 = false
    combo = 1
    mouse.Button1Down:connect(function(key)
        if attack == false then
            attack = true
            hum.WalkSpeed = 3.01
            if combo == 1 and wait2 == false then
                wait2 = true
                for i = 0, 1.2, 0.1 do
                    swait()
                    character1.Reanimate.Part.Position = character1.Reanimate["Torso"].Position
                    rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, -0.5, 0) * angles(math.rad(-5), math.rad(0), math.rad(-65)), 0.3)
                    tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(-10), math.rad(0), math.rad(-65)), 0.1)
                    RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0.8) * angles(math.rad(90), math.rad(0), math.rad(20)), 0.1)
                    LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(-25), math.rad(0), math.rad(40)), 0.3)
                    RH.C0 = clerp(RH.C0, CFrame.new(1, -1, -0.2) * RHCF * angles(math.rad(-2.5), math.rad(0), math.rad(-0)), 0.3)
                    LH.C0 = clerp(LH.C0, CFrame.new(-1, -1, 0) * LHCF * angles(math.rad(-2.5), math.rad(15), math.rad(-20)), 0.3)
                    character1.Reanimate.Part.Position = character1.Reanimate["Torso"].Position
                end
                CreateSound("138097048", ra, 3, .8)
                HitboxFunction(ra.CFrame, 0.01, 1, 1, 1, 7, 6, 9, 3, "Normal")
                for i = 0, 1.2, 0.1 do
                    swait()
                    character1.Reanimate.Part.Position = character1.Reanimate["Torso"].Position
                    rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, -0.5, 0) * angles(math.rad(5), math.rad(0), math.rad(55)), 0.3)
                    tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(10), math.rad(0), math.rad(0)), 0.1)
                    RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, -0.8) * angles(math.rad(95), math.rad(0), math.rad(40)), 0.1)
                    LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(-25), math.rad(0), math.rad(-10)), 0.3)
                    RH.C0 = clerp(RH.C0, CFrame.new(1, -1, 0) * RHCF * angles(math.rad(-2.5), math.rad(-25), math.rad(-17)), 0.3)
                    LH.C0 = clerp(LH.C0, CFrame.new(-1, -1, 0) * LHCF * angles(math.rad(-2.5), math.rad(-0), math.rad(0)), 0.3)
                    character1.Reanimate.Part.Position = character1.Reanimate["Torso"].Position
                end
                combo = 2
            end
            if combo == 2 and wait2 == false then
                wait2 = true
                for i = 0, 1.2, 0.1 do
                    swait()
                    character1.Reanimate.Part.Position = character1.Reanimate["Torso"].Position
                    rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, -0.5, 0) * angles(math.rad(-5), math.rad(0), math.rad(65)), 0.3)
                    tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(-10), math.rad(0), math.rad(65)), 0.1)
                    RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0.8) * angles(math.rad(-25), math.rad(0), math.rad(40)), 0.1)
                    LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(90), math.rad(0), math.rad(20)), 0.3)
                    RH.C0 = clerp(RH.C0, CFrame.new(1, -1, -0.2) * RHCF * angles(math.rad(-2.5), math.rad(0), math.rad(-0)), 0.3)
                    LH.C0 = clerp(LH.C0, CFrame.new(-1, -1, 0) * LHCF * angles(math.rad(-2.5), math.rad(15), math.rad(-20)), 0.3)
                    character1.Reanimate.Part.Position = character1.Reanimate["Torso"].Position
                end
                CreateSound("138097048", ra, 3, .8)
                HitboxFunction(ra.CFrame, 0.01, 1, 1, 1, 7, 6, 9, 3, "Normal")
                for i = 0, 1.2, 0.1 do
                    swait()
                    character1.Reanimate.Part.Position = character1.Reanimate["Torso"].Position
                    rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, -0.5, 0) * angles(math.rad(5), math.rad(0), math.rad(-55)), 0.3)
                    tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(10), math.rad(0), math.rad(0)), 0.1)
                    RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(-25), math.rad(0), math.rad(10)), 0.1)
                    LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, -0.8) * angles(math.rad(95), math.rad(0), math.rad(-40)), 0.3)
                    RH.C0 = clerp(RH.C0, CFrame.new(1, -1, 0) * RHCF * angles(math.rad(-2.5), math.rad(-25), math.rad(-17)), 0.3)
                    LH.C0 = clerp(LH.C0, CFrame.new(-1, -1, 0) * LHCF * angles(math.rad(-2.5), math.rad(-0), math.rad(0)), 0.3)
                    character1.Reanimate.Part.Position = character1.Reanimate["Torso"].Position
                end
                combo = 3
            end
            if combo == 3 and wait2 == false then
                wait2 = true
                for i = 0, 1.2, 0.1 do
                    swait()
                    character1.Reanimate.Part.Position = character1.Reanimate["Torso"].Position
                    rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, -0.5, 0) * angles(math.rad(-5), math.rad(0), math.rad(-35)), 0.3)
                    tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(-10), math.rad(0), math.rad(0)), 0.1)
                    RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0.8) * angles(math.rad(90), math.rad(0), math.rad(20)), 0.1)
                    LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(-25), math.rad(0), math.rad(-10)), 0.3)
                    RH.C0 = clerp(RH.C0, CFrame.new(1, -1, -0.2) * RHCF * angles(math.rad(-2.5), math.rad(0), math.rad(-0)), 0.3)
                    LH.C0 = clerp(LH.C0, CFrame.new(-1, -1, 0) * LHCF * angles(math.rad(-2.5), math.rad(15), math.rad(-20)), 0.3)
                    character1.Reanimate.Part.Position = character1.Reanimate["Torso"].Position
                end
                CreateSound("138097048", ra, 3, .8)
                HitboxFunction(ra.CFrame, 0.01, 1, 1, 1, 7, 24, 36, 3, "Normal")
                for i = 0, 1.2, 0.1 do
                    swait()
                    character1.Reanimate.Part.Position = character1.Reanimate["Torso"].Position
                    rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, -0.5, 0) * angles(math.rad(5), math.rad(0), math.rad(35)), 0.3)
                    tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(10), math.rad(0), math.rad(0)), 0.1)
                    RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, -0.8) * angles(math.rad(96), math.rad(0), math.rad(10)), 0.1)
                    LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(-25), math.rad(0), math.rad(-10)), 0.3)
                    RH.C0 = clerp(RH.C0, CFrame.new(1, -1, 0) * RHCF * angles(math.rad(-2.5), math.rad(-25), math.rad(-0)), 0.3)
                    LH.C0 = clerp(LH.C0, CFrame.new(-1, -1, 0) * LHCF * angles(math.rad(-2.5), math.rad(-0), math.rad(0)), 0.3)
                    character1.Reanimate.Part.Position = character1.Reanimate["Torso"].Position
                end
                Effects.Sphere.Create(maincolor, ra.CFrame * CFrame.new(0,-2,0) , 85, 85, 85, 1.1, 1.1, 1.1, 0.02)
                Effects.Ring.Create(maincolor, ra.CFrame * CFrame.new(0,-2,0) , 2, 2, 2, 1.1, 1.1, 1.1, 0.03)
                for i = 0, 2 do
                    SphereAura(2, 0.2, "Add", ra.CFrame * CFrame.Angles(math.rad(-90 + math.random(-20, 20)), math.rad(math.random(-20, 20)), math.rad(math.random(-20, 20))), 0.5, 0.5, 5, -0.005, maincolor, 0)
                end
                coroutine.resume(coroutine.create(function() 
                    for i = 0,1.8,0.1 do
                        swait()
                        hum.CameraOffset = Vector3.new(Mrandom(-1,1),0,Mrandom(-1,1))
                    end
                    for i = 0,1.8,0.1 do
                        swait()
                        hum.CameraOffset = Vector3.new(0,0,0)
                    end
                end))
                HitboxFunction(ra.CFrame, 0.01, 1, 1, 1, 7, 24, 36, 3, "Normal")
                for i = 0, 1.2, 0.1 do
                    swait()
                    rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, -0.5, 0) * angles(math.rad(5), math.rad(0), math.rad(-35)), 0.3)
                    tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(10), math.rad(0), math.rad(0)), 0.1)
                    RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, -0.8) * angles(math.rad(25), math.rad(0), math.rad(10)), 0.1)
                    LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(-25), math.rad(0), math.rad(-10)), 0.3)
                    RH.C0 = clerp(RH.C0, CFrame.new(1, -1, 0) * RHCF * angles(math.rad(-2.5), math.rad(-25), math.rad(-0)), 0.3)
                    LH.C0 = clerp(LH.C0, CFrame.new(-1, -1, 0) * LHCF * angles(math.rad(-2.5), math.rad(-0), math.rad(0)), 0.3)
                end
                combo = 4
            end
            if combo == 4 and wait2 == false then
                for i = 0,1.2,0.1 do
                    swait()
                    rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1 * Cos(sine / 20)) * angles(Rad(-20), Rad(0), Rad(0)), 0.15)
                    tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-20 - 2.5 * Sin(sine / 20)), Rad(0), Rad(0)), 0.3)
                    RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-4.5), Rad(0), Rad(-20)), 0.15)
                    LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 * Cos(sine / 20), -.4 + 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-6.5), Rad(5 * Cos(sine / 20)), Rad(25)), 0.15)
                    RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 20), 0.025 * Cos(sine / 20)) * angles(Rad(200), Rad(0), Rad(25 - 2.5 * Sin(sine / 20))), 0.1)
                    LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 20), 0.025 * Cos(sine / 20)) * angles(Rad(200), Rad(0), Rad(-25 + 2.5 * Sin(sine / 20))), 0.1)
                end
                SphereAura(6, 0.3, "Add", root.CFrame * CF(0,-2,0) * angles(Rad(Mrandom(-360, 360)), Rad(Mrandom(-360, 360)), Rad(Mrandom(-360, 360))), 0.5, 0.5, 5, -0.005, maincolor, 0)
                SphereAura(6, 0.3, "Add", root.CFrame * CF(0,-2,0) * angles(Rad(Mrandom(-360, 360)), Rad(Mrandom(-360, 360)), Rad(Mrandom(-360, 360))), 0.5, 0.5, 5, -0.005, maincolor, 0)
                Effects.Sphere.Create(maincolor, root.CFrame * CFrame.new(0,-2,0) , 85, 85, 85, 15.1, 15.1, 15.1, 0.01)
                CreateSound("331666100", char, 10, 1)
                for i, v in pairs(FindNearestHead(tors.CFrame.p, 14.5)) do
                    if v:FindFirstChild("Head") then
                        SoulSteal(v)
                        Eviscerate(v)
                    end
                end
                coroutine.resume(coroutine.create(function() 
                    for i = 0,1.8,0.1 do
                        swait()
                        hum.CameraOffset = Vector3.new(Mrandom(-1,1),0,Mrandom(-1,1))
                    end
                    for i = 0,1.8,0.1 do
                        swait()
                        hum.CameraOffset = Vector3.new(0,0,0)
                    end
                end))
                for i = 1,4.7,0.1 do
                    rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -1.4 + 0.1 * Cos(sine / 20)) * angles(Rad(45), Rad(0), Rad(0)), 0.15)
                    tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(35), Rad(0), Rad(0)), 0.3)
                    RH.C0 = clerp(RH.C0, CF(1, .4 - 0.1 * Cos(sine / 20), -.6 + 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-5), Rad(0), Rad(45)), 0.15)
                    LH.C0 = clerp(LH.C0, CF(-1, -0.6 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-5), Rad(0), Rad(-0)), 0.15)
                    RW.C0 = clerp(RW.C0, CF(1.2, 0.1 + 0.05 * Sin(sine / 30), -.4 + 0.025 * Cos(sine / 20)) * angles(Rad(65), Rad(0), Rad(-34)), 0.1)
                    LW.C0 = clerp(LW.C0, CF(-1.2, 0.1 + 0.05 * Sin(sine / 30), -.4 + 0.025 * Cos(sine / 20)) * angles(Rad(65), Rad(0), Rad(34)), 0.1)
                end
                wait(.6)
                combo = 1
            end
            hum.WalkSpeed = 16
            wait2 = false
            attack = false
        end
    end)
    function Destruction()
        attack = true
        local Ring1 = Instance.new("Part", char)
        Ring1.Anchored = true
        Ring1.BrickColor = maincolor
        Ring1.CanCollide = false
        Ring1.FormFactor = 3
        Ring1.Name = "Ring"
        Ring1.Material = "Neon"
        Ring1.Size = Vector3.new(1, 0.05, 1)
        Ring1.Transparency = 1
        Ring1.TopSurface = 0
        Ring1.BottomSurface = 0
        local Ring1Mesh = Instance.new("SpecialMesh", Ring1)
        Ring1Mesh.MeshType = "Brick"
        Ring1Mesh.Name = "SizeMesh"
        Ring1Mesh.Scale = Vector3.new(0, 1, 0)
        local InnerRing1 = Ring1:Clone()
        InnerRing1.Parent = char
        InnerRing1.Transparency = 0
        InnerRing1.BrickColor = BrickColor.new("New Yeller")
        InnerRing1.Size = Vector3.new(1, 1, 1)
        local InnerRing1Mesh = InnerRing1.SizeMesh
        InnerRing1Mesh.Scale = Vector3.new(0, 0, 0)
        InnerRing1Mesh.MeshType = "Sphere"
        Ring1:Destroy()
        for i = 0, 5, 0.1 do
            swait()
            SphereAura(7, 0.12, "Add", ra.CFrame * CF(0,-2,0) * angles(Rad(Mrandom(-360, 360)), Rad(Mrandom(-360, 360)), Rad(Mrandom(-360, 360))), 0.5, 0.5, 5, -0.005, maincolor, 0)
            SphereAura(7, 0.12, "Add", ra.CFrame * CF(0,-2,0) * angles(Rad(Mrandom(-360, 360)), Rad(Mrandom(-360, 360)), Rad(Mrandom(-360, 360))), 0.5, 0.5, 5, -0.005, BrickC("Institutional white"), 0)
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1 * Cos(sine / 20)) * angles(Rad(5), Rad(0), Rad(0)), 0.15)
            tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-4.5 * Sin(sine / 30)), Rad(0), Rad(0)), 0.3)
            RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-12.5 + 3 * Sin(sine / 20)), Rad(0), Rad(0 + 2.5 * Sin(sine / 20))), 0.15)
            LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5 + 3 * Sin(sine / 20)), Rad(0), Rad(0 + 2.5 * Sin(sine / 20))), 0.15)
            RW.C0 = clerp(RW.C0, CF(1.1, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(90), Rad(0), Rad(-25)), 0.1)
            LW.C0 = clerp(LW.C0, CF(-1.1, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(90), Rad(0), Rad(25)), 0.1)
            character1.Reanimate.Part.Position = mouse.Hit.p
            root.CFrame = FaceMouse()[1]
        end
        InnerRing1.Transparency = 1
        InnerRing1.CFrame = root.CFrame * CF(0, 0.5, 0) + root.CFrame.lookVector * 5
        CreateSound("294188875", char, 2.3, 1)
        local a = IT("Part", char)
        a.Name = "Direction"
        a.Anchored = true
        a.BrickColor = maincolor
        a.Material = "Neon"
        a.Transparency = 0
        a.Shape = "Cylinder"
        a.CanCollide = false
        local a2 = IT("Part", char)
        a2.Name = "Direction"
        a2.Anchored = true
        a2.BrickColor = maincolor
        a2.Color = maincolor.Color
        a2.Material = "Neon"
        a2.Transparency = 0.5
        a2.Shape = "Cylinder"
        a2.CanCollide = false
        local ba = IT("Part", char)
        ba.Name = "HitDirect"
        ba.Anchored = true
        ba.BrickColor = maincolor
        ba.Material = "Neon"
        ba.Transparency = 1
        ba.CanCollide = false
        local ray = Ray.new(InnerRing1.CFrame.p, (mouse.Hit.p - InnerRing1.CFrame.p).unit * 1000)
        local ignore = char
        local hit, position, normal = workspace:FindPartOnRay(ray, ignore)
        a.BottomSurface = 10
        a.TopSurface = 10
        a2.BottomSurface = 10
        a2.TopSurface = 10
        local distance = (InnerRing1.CFrame.p - position).magnitude
        a.Size = Vector3.new(distance, 1, 1)
        a.CFrame = CF(InnerRing1.CFrame.p, position) * CF(0, 0, -distance / 2)
        a2.Size = Vector3.new(distance, 1, 1)
        a2.CFrame = CF(InnerRing1.CFrame.p, position) * CF(0, 0, -distance / 2)
        ba.CFrame = CF(InnerRing1.CFrame.p, position) * CF(0, 0, -distance)
        a.CFrame = a.CFrame * angles(0, Rad(90), 0)
        a2.CFrame = a2.CFrame * angles(0, Rad(90), 0)
        game:GetService("Debris"):AddItem(a, 20)
        game:GetService("Debris"):AddItem(a2, 20)
        game:GetService("Debris"):AddItem(ba, 20)
        local msh = Instance.new("SpecialMesh", a)
        msh.MeshType = "Sphere"
        msh.Scale = Vector3.new(1, 25, 25)
        local msh2 = Instance.new("SpecialMesh", a2)
        msh2.MeshType = "Sphere"
        msh2.Scale = Vector3.new(1, 30, 30)
        for i = 0, 10, 0.1 do
            swait()
            character1.Reanimate.Part.Position = mouse.Hit.p
            root.CFrame = FaceMouse()[1]
            hum.CameraOffset = Vector3.new(Mrandom(-1,1),0,Mrandom(-1,1))
            a2.Color = maincolor.Color
            InnerRing1.CFrame = root.CFrame * CF(0, 0.5, 0) + root.CFrame.lookVector * 4
            ray = Ray.new(InnerRing1.CFrame.p, (mouse.Hit.p - InnerRing1.CFrame.p).unit * 1000)
            hit, position, normal = workspace:FindPartOnRay(ray, ignore)
            distance = (InnerRing1.CFrame.p - position).magnitude
            a.Size = Vector3.new(distance, 1, 1)
            a.CFrame = CF(InnerRing1.CFrame.p, position) * CF(0, 0, -distance / 2)
            a2.Size = Vector3.new(distance, 1, 1)
            a2.CFrame = CF(InnerRing1.CFrame.p, position) * CF(0, 0, -distance / 2)
            ba.CFrame = CF(InnerRing1.CFrame.p, position) * CF(0, 0, -distance)
            a.CFrame = a.CFrame * angles(0, Rad(90), 0)
            a2.CFrame = a2.CFrame * angles(0, Rad(90), 0)
            msh.Scale = msh.Scale - Vector3.new(0, 0.25, 0.25)
            msh2.Scale = msh2.Scale - Vector3.new(0, 0.3, 0.3)
            SphereAura(5, 0.15, "Add", ba.CFrame * angles(Rad(Mrandom(-360, 360)), Rad(Mrandom(-360, 360)), Rad(Mrandom(-360, 360))), 15, 15, 25, -0.15, maincolor, 0)
            SphereAura(5, 0.15, "Add", ba.CFrame * angles(Rad(Mrandom(-360, 360)), Rad(Mrandom(-360, 360)), Rad(Mrandom(-360, 360))), 15, 15, 25, -0.15, maincolor, 0)
            for i, v in pairs(FindNearestHead(ba.CFrame.p, 14.5)) do
                if v:FindFirstChild("Head") then
                    Eviscerate(v)
                    SoulSteal(v)
                end
            end
        end
        a:Destroy()
        a2:Destroy()
        ba:Destroy()
        InnerRing1:Destroy()
        attack = false
        hum.CameraOffset = Vector3.new(0,0,0)
    end
    function BURN_IN_HELL()
        attack = true
        chatfunc("BURN....", BrickColor.random().Color)
        for i = 0,5.2,0.1 do
            swait()
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1 * Cos(sine / 20)) * angles(Rad(-20), Rad(0), Rad(0)), 0.15)
            tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-20 - 2.5 * Sin(sine / 20)), Rad(0), Rad(0)), 0.3)
            RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-4.5), Rad(0), Rad(-20)), 0.15)
            LH.C0 = clerp(LH.C0, CF(-1, -0.3 - 0.1 * Cos(sine / 20), -.4 + 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-6.5), Rad(5 * Cos(sine / 20)), Rad(25)), 0.15)
            RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 20), 0.025 * Cos(sine / 20)) * angles(Rad(135), Rad(0), Rad(-45 - 2.5 * Sin(sine / 20))), 0.1)
            LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 20), 0.025 * Cos(sine / 20)) * angles(Rad(135), Rad(0), Rad(45 + 2.5 * Sin(sine / 20))), 0.1)
        end 
        chatfunc("IN....", BrickColor.random().Color)
        wait(2)
        CreateSound("331666100", char, 10, 1)
        Effects.Sphere.Create(BrickColor.Random(), root.CFrame * CF(0, -1, 0), 2, 2, 2, 10.6, 10.6, 10.6, 0.05)
        Effects.Sphere.Create(BrickColor.Random(), root.CFrame * CF(0, -1, 0), 2, 2, 2, 10.6, 10.6, 10.6, 0.05)
        Effects.Sphere.Create(BrickColor.Random(), root.CFrame * CF(0, -1, 0), 2, 2, 2, 10.6, 10.6, 10.6, 0.05)
        Effects.Sphere.Create(BrickColor.Random(), root.CFrame * CF(0, -1, 0), 2, 2, 2, 10.6, 10.6, 10.6, 0.05)
        Effects.Sphere.Create(BrickColor.Random(), root.CFrame * CF(0, -1, 0), 2, 2, 2, 10.6, 35.6, 10.6, 0.05)
        Effects.Sphere.Create(BrickColor.Random(), root.CFrame * CF(0, -3, 0), 2, 2, 2, 150.6, .4, 150.6, 0.05)
        chatfunc("HELL!!!!!", BrickColor.random().Color)
        for i, v in pairs(FindNearestHead(tors.CFrame.p, 52.5)) do
            if v:FindFirstChild("Head") then
                Eviscerate(v)
                SoulSteal(v)
            end
        end
        coroutine.resume(coroutine.create(function() 
            for i = 0,2.8,0.1 do
                swait()
                hum.CameraOffset = Vector3.new(Mrandom(-3,3),Mrandom(-3,3),Mrandom(-3,3))
            end
            for i = 0,1.8,0.1 do
                swait()
                hum.CameraOffset = Vector3.new(0,0,0)
            end
        end))
        for i = 0,3.7,0.1 do
            SphereAura(2.5, 0.75, "Add", root.CFrame * CFrame.new(math.random(-52.5, 52.5), -5, math.random(-52.5, 52.5)) * CFrame.Angles(math.rad(90 + math.rad(math.random(-45, 45))), math.rad(math.random(-45, 45)), math.rad(math.random(-45, 45))), 2.5, 2.5, 25, -0.025, BrickColor.random(), 0)
            SphereAura(2.5, 0.75, "Add", root.CFrame * CFrame.new(math.random(-52.5, 52.5), -5, math.random(-52.5, 52.5)) * CFrame.Angles(math.rad(90 + math.rad(math.random(-45, 45))), math.rad(math.random(-45, 45)), math.rad(math.random(-45, 45))), 2.5, 2.5, 25, -0.025, BrickColor.random(), 0)
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1 * Cos(sine / 20)) * angles(Rad(20), Rad(0), Rad(0)), 0.15)
            tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(20 - 2.5 * Sin(sine / 20)), Rad(0), Rad(0)), 0.3)
            RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-4.5), Rad(0), Rad(20)), 0.15)
            LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 * Cos(sine / 20), -.4 + 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-6.5), Rad(5 * Cos(sine / 20)), Rad(-25)), 0.15)
            RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 20), 0.025 * Cos(sine / 20)) * angles(Rad(-40), Rad(0), Rad(25 - 2.5 * Sin(sine / 20))), 0.1)
            LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 20), 0.025 * Cos(sine / 20)) * angles(Rad(-40), Rad(0), Rad(-25 + 2.5 * Sin(sine / 20))), 0.1)
        end
        wait(.6)
        CreateSound("907332997", hed, 10, 1)
        attack = false
    end
    -------------------------------------------------------
    --End Attacks N Stuff--
    -------------------------------------------------------
    mouse.KeyDown:connect(function(key)
        if attack == false then
            if key == 'f' then
                Destruction()
            elseif key == 'r' then
                BURN_IN_HELL()
            elseif key == 't' then
                chatfunc("HM, HM, HAHAHAHAHAHA", BrickColor.random().Color)
                CreateSound("300208779", hed, 10, 1)
            end
        end
    end)






    -------------------------------------------------------
    --Start Animations--
    -------------------------------------------------------
    local equipped = false
    local idle = 0
    local change = 1
    local val = 0
    local toim = 0
    local idleanim = 0.4
    hum.Animator.Parent = nil
    while true do
        swait()
        for i, v in pairs(NeonParts) do
            v.BrickColor = BrickColor.Random()
        end
        for i, v in pairs(NeonParts2) do
            v.BrickColor = BrickColor.Random()
        end
        maincolor = BrickColor.Random()
        Music.Parent = char
        tecks2.TextStrokeColor3 = maincolor.Color
        sine = sine + change
        local torvel = (root.Velocity * Vector3.new(1, 0, 1)).magnitude
        local velderp = root.Velocity.y
        hitfloor, posfloor = rayCast(root.Position, CFrame.new(root.Position, root.Position - Vector3.new(0, 1, 0)).lookVector, 4, char)
        if equipped == true or equipped == false then
            if attack == false then
                idle = idle + 1
            else
                idle = 0
            end
            if 1 < root.Velocity.y and hitfloor == nil then
                Anim = "Jump"
                if attack == false then
                    rootj.C0 = clerp(rootj.C0, RootCF * angles(math.min(math.max(root.Velocity.Y/100,-Rad(65)),Rad(65)),0,0),0.3)
                    tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-10), Rad(0), Rad(0)), 0.3)
                    RW.C0 = clerp(RW.C0, CF(1.5, 0.5, 0) * angles(math.min(math.max(root.Velocity.Y/100,-Rad(65)),Rad(65)),0,Rad(15)),0.3)
                    LW.C0 = clerp(LW.C0, CF(-1.5, 0.5, 0) * angles(math.min(math.max(root.Velocity.Y/100,-Rad(65)),Rad(65)),0,Rad(-15)),0.3)
                    LH.C0=clerp(LH.C0, CF(-1,-.4-0.1 * Cos(sine / 20), -.6) * LHCF * angles(Rad(-5), Rad(-0), Rad(20)), 0.15)
                    RH.C0=clerp(RH.C0, CF(1,-1-0.1 * Cos(sine / 20), -.3) * angles(Rad(0), Rad(90), Rad(0)), .3)
                end
            elseif -1 > root.Velocity.y and hitfloor == nil then
                Anim = "Fall"
                if attack == false then
                    rootj.C0 = clerp(rootj.C0, RootCF * angles(math.min(math.max(root.Velocity.Y/100,-Rad(65)),Rad(65)),0,0),0.3)
                    tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(10), Rad(0), Rad(0)), 0.3)
                    RW.C0 = clerp(RW.C0, CF(1.5, 0.5, 0) * angles(math.min(math.max(root.Velocity.Y/100,-Rad(65)),Rad(65)),0,Rad(30)),0.3)
                    LW.C0 = clerp(LW.C0, CF(-1.5, 0.5, 0) * angles(math.min(math.max(root.Velocity.Y/100,-Rad(65)),Rad(65)),0,Rad(-30)),0.3)
                    LH.C0 = clerp(LH.C0, CF(-1,-.4-0.1 * Cos(sine / 20), -.6) * LHCF * angles(Rad(-5), Rad(-0), Rad(20)), 0.15)
                    RH.C0 = clerp(RH.C0, CF(1,-1-0.1 * Cos(sine / 20), -.3) * angles(Rad(0), Rad(90), Rad(0)), .3)
                end
            elseif torvel < 1 and hitfloor ~= nil then
                Anim = "Idle"
                change = 1.9
                if attack == false then
                    rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1 * Cos(sine / 20)) * angles(Rad(30), Rad(0), Rad(0)), 0.15)
                    tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(35 - 2.5 * Sin(sine / 20)), Rad(-5 * Cos(sine / 0.465)), Rad(-5 * Cos(sine / 0.465))), 0.3)
                    RH.C0 = clerp(RH.C0, CF(1, -1 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-7.5), Rad(0), Rad(30)), 0.15)
                    LH.C0 = clerp(LH.C0, CF(-1, -1 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-7.5), Rad(0), Rad(-30)), 0.15)
                    RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 20), 0.025 * Cos(sine / 20)) * angles(Rad(35 - 5 * Cos(sine / 0.465)), Rad(-5 * Cos(sine / 0.465)), Rad(15 + 7 * Sin(sine / 25))), 0.1)
                    LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 20), 0.025 * Cos(sine / 20)) * angles(Rad(35 - 5 * Cos(sine / 0.465)), Rad(-5 * Cos(sine / 0.465)), Rad(-15 - 7 * Sin(sine / 25))), 0.1)
                end
            elseif tors.Velocity.magnitude < 50 and hitfloor ~= nil then
                Anim = "Walk"
                change = 1
                if attack == false then
                    rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.175 + 0.025 * Cos(sine / 3.5) + -Sin(sine / 3.5) / 7) * angles(Rad(15 - 2.5 * Cos(sine / 3.5)), Rad(0) - root.RotVelocity.Y / 75, Rad(4 * Cos(sine / 7))), 0.15)
                    tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(13 - 2.5 * Sin(sine / 7)), Rad(-5 * Cos(sine / 0.465)), Rad(-5 * Cos(sine / 0.465))), 0.3)
                    RH.C0 = clerp(RH.C0, CF(1, -0.925 - 0.5 * Cos(sine / 7) / 2, 0.5 * Cos(sine / 7) / 2) * angles(Rad(-15 - 5 * Cos(sine / 7)) - rl.RotVelocity.Y / 75 + -Sin(sine / 7) / 2.5, Rad(90 - 0.1 * Cos(sine / 7)), Rad(0)) * angles(Rad(0 + 0.1 * Cos(sine / 7)), Rad(0), Rad(15)), 0.3)
                    LH.C0 = clerp(LH.C0, CF(-1, -0.925 + 0.5 * Cos(sine / 7) / 2, -0.5 * Cos(sine / 7) / 2) * angles(Rad(-15 + 5 * Cos(sine / 7)) + ll.RotVelocity.Y / 75 + Sin(sine / 7) / 2.5, Rad(-90 - 0.1 * Cos(sine / 7)), Rad(0)) * angles(Rad(0 - 0.1 * Cos(sine / 7)), Rad(0), Rad(-15)), 0.3)
                    RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 7), 0.025 * Cos(sine / 7)) * angles(Rad(65)  * Cos(sine / 7) , Rad(0), Rad(10 + 7 * Sin(sine / 7)) - ra.RotVelocity.Y / 75), 0.1)
                    LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 7), 0.025 * Cos(sine / 7)) * angles(Rad(-65)  * Cos(sine / 7) , Rad(0), Rad(-10 - 7 * Sin(sine / 7)) + la.RotVelocity.Y / 75), 0.1)
                end
            end
        end
        if 0 < #Effects then
            for e = 1, #Effects do
                if Effects[e] ~= nil then
                    local Thing = Effects[e]
                    if Thing ~= nil then
                        local Part = Thing[1]
                        local Mode = Thing[2]
                        local Delay = Thing[3]
                        local IncX = Thing[4]
                        local IncY = Thing[5]
                        local IncZ = Thing[6]
                        if 1 >= Thing[1].Transparency then
                            if Thing[2] == "Block1" then
                                Thing[1].CFrame = Thing[1].CFrame * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
                                local Mesh = Thing[1].Mesh
                                Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
                                Thing[1].Transparency = Thing[1].Transparency + Thing[3]
                            elseif Thing[2] == "Block2" then
                                Thing[1].CFrame = Thing[1].CFrame + Vector3.new(0, 0, 0)
                                local Mesh = Thing[7]
                                Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
                                Thing[1].Transparency = Thing[1].Transparency + Thing[3]
                            elseif Thing[2] == "Block3" then
                                Thing[1].CFrame = Thing[1].CFrame * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50)) + Vector3.new(0, 0.15, 0)
                                local Mesh = Thing[7]
                                Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
                                Thing[1].Transparency = Thing[1].Transparency + Thing[3]
                            elseif Thing[2] == "Cylinder" then
                                local Mesh = Thing[1].Mesh
                                Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
                                Thing[1].Transparency = Thing[1].Transparency + Thing[3]
                            elseif Thing[2] == "Blood" then
                                local Mesh = Thing[7]
                                Thing[1].CFrame = Thing[1].CFrame * Vector3.new(0, 0.5, 0)
                                Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
                                Thing[1].Transparency = Thing[1].Transparency + Thing[3]
                            elseif Thing[2] == "Elec" then
                                local Mesh = Thing[1].Mesh
                                Mesh.Scale = Mesh.Scale + Vector3.new(Thing[7], Thing[8], Thing[9])
                                Thing[1].Transparency = Thing[1].Transparency + Thing[3]
                            elseif Thing[2] == "Disappear" then
                                Thing[1].Transparency = Thing[1].Transparency + Thing[3]
                            elseif Thing[2] == "Shatter" then
                                Thing[1].Transparency = Thing[1].Transparency + Thing[3]
                                Thing[4] = Thing[4] * CFrame.new(0, Thing[7], 0)
                                Thing[1].CFrame = Thing[4] * CFrame.fromEulerAnglesXYZ(Thing[6], 0, 0)
                                Thing[6] = Thing[6] + Thing[5]
                            end
                        else
                            Part.Parent = nil
                            table.remove(Effects, e)
                        end
                    end
                end
            end
        end
    end
    -------------------------------------------------------
    --End Animations And Script--
    -------------------------------------------------------
end)

sonic.Name = "sonic"
sonic.Parent = main
sonic.BackgroundColor3 = Color3.fromRGB(79, 79, 79)
sonic.Position = UDim2.new(0.380645156, 0, 0.216730058, 0)
sonic.Size = UDim2.new(0, 74, 0, 45)
sonic.Style = Enum.ButtonStyle.RobloxRoundDropdownButton
sonic.Font = Enum.Font.SciFi
sonic.Text = "SONIC"
sonic.TextColor3 = Color3.fromRGB(0, 0, 0)
sonic.TextSize = 18.000
sonic.MouseButton1Down:connect(function()
    Bypass = "death"
    FELOADLIBRARY = {}
    loadstring(game:GetObjects("rbxassetid://5209815302")[1].Source)()
    loadstring(game:GetObjects("rbxassetid://5325226148")[1].Source)()

    print("Move list")
    print("---------")
    print("Shift = Boost")
    print("Ctrl = Mach Speed Boost")
    print("Q = Left QuickStep, E  = Right QuickStep")
    print("C = Slide, in air to stomp")
    print("Jump Then Hold B near a wall to wallrun")
    print("M to change music, if you're standing still you'll do a special animation!")
    print("Space near a wall to walljump, away from a wall homing attack")

    wait(0.07)
    Player=game:GetService("Players").LocalPlayer
    Character=workspace.non
    PlayerGui=Player.PlayerGui
    Backpack=Player.Backpack
    Torso=Character.Torso
    Head=Character.Head
    Humanoid=Character.Humanoid
    LeftArm=Character["Left Arm"]
    LeftLeg=Character["Left Leg"]
    RightArm=Character["Right Arm"]
    RightLeg=Character["Right Leg"]
    LS=Torso["Left Shoulder"]
    LH=Torso["Left Hip"]
    RS=Torso["Right Shoulder"]
    RH=Torso["Right Hip"]
    Face = Head.face
    Neck=Torso.Neck
    it=Instance.new
    attacktype=1
    attacktype2=1
    vt=Vector3.new
    cf=CFrame.new
    cn=CFrame.new
    euler=CFrame.fromEulerAnglesXYZ
    angles=CFrame.Angles
    combo = 0
    necko=cf(0, 1, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)
    necko2=cf(0, -0.5, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)
    LHC0=cf(-1,-1,0,-0,-0,-1,0,1,0,1,0,0)
    LHC1=cf(-0.5,1,0,-0,-0,-1,0,1,0,1,0,0)
    RHC0=cf(1,-1,0,0,0,1,0,1,0,-1,-0,-0)
    RHC1=cf(0.5,1,0,0,0,1,0,1,0,-1,-0,-0)
    RootPart=Character.HumanoidRootPart
    RootJoint=RootPart.RootJoint
    RootCF=euler(-1.57,0,3.14)
    attack = false
    attackdebounce = false
    trispeed=.2
    attackmode='none'
    local idle=0
    local Anim="Idle"
    stance = false
    local ff = 2
    noleg = false
    evadecooldown = false
    Humanoid.Animator.Parent = nil
    equip = false
    local Effects = {}
    attackspeed = 0.14 
    df = false
    Swing = 1
    local sine = 0
    local change = 1
    local val = 0
    local speed = 0
    local rs = game:GetService("RunService").RenderStepped
    cam = workspace.CurrentCamera
    local Create = FELOADLIBRARY.Create
    deb = game:GetService("Debris")
    Face.Transparency = 0
    --Face.Texture = "rbxassetid://176217905" --176217905
    Humanoid.WalkSpeed = 64
    local freefall = 0
    local headsunsound = RootPart:FindFirstChild("Running") or Instance.new("Sound",RootPart)
    headsunsound.SoundId = "rbxassetid://758199523"
    headsunsound.Volume = 2
    local boost = false
    Humanoid.JumpPower = 88
    local musicnum = 1

    local spd = Vector3.new(RootPart.Velocity.x,0,RootPart.Velocity.z).magnitude + 10
    local dir = Vector3.new(RootPart.Velocity.x,0,RootPart.Velocity.z).unit
    local GravPoint = RootPart.Velocity.y
    local NV = Vector3.new(0,0,0)

    music = Instance.new("Sound",RootPart)
    music.Volume = 1
    music.TimePosition = 0
    music.Pitch = 1
    music.SoundId = "rbxassetid://1251555494"
    music.Looped = true
    music:Play()


    boostsound = Instance.new("Sound",RootPart)
    boostsound.Volume = .6
    boostsound.TimePosition = 0
    boostsound.Pitch = 1
    boostsound.SoundId = "rbxassetid://924922553"
    boostsound.Looped = false



    stompsound = Instance.new("Sound",RootPart)
    stompsound.Volume = 2
    stompsound.TimePosition = 0
    stompsound.Pitch = 1
    stompsound.SoundId = "rbxassetid://1295424184"
    stompsound.Looped = false



    so = function(id,par,vol,pit)
        coroutine.resume(coroutine.create(function()
            local sou = Instance.new("Sound",par or workspace)
            sou.Volume=vol
            sou.Pitch=pit or 1
            sou.SoundId=id
            sou:play()
            game:GetService("Debris"):AddItem(sou,8)
        end))
    end

    --save shoulders
    RSH, LSH=nil, nil
    --welds
    RW, LW=Instance.new("Weld"), Instance.new("Weld")
    RW.Name="Right Shoulder" LW.Name="Left Shoulder"
    LH=Torso["Left Hip"]
    RH=Torso["Right Hip"]
    TorsoColor=Torso.BrickColor
    function NoOutline(Part)
        Part.TopSurface,Part.BottomSurface,Part.LeftSurface,Part.RightSurface,Part.FrontSurface,Part.BackSurface = 10,10,10,10,10,10
    end
    player=Player
    ch=Character
    RSH=ch.Torso["Right Shoulder"]
    LSH=ch.Torso["Left Shoulder"]
    --
    RSH.Parent=nil
    LSH.Parent=nil
    --
    RW.Name="Right Shoulder"
    RW.Part0=ch.Torso
    RW.C0=cf(1.5, 0.5, 0) --* CFrame.fromEulerAnglesXYZ(1.3, 0, -0.5)
    RW.C1=cf(0, 0.5, 0)
    RW.Part1=ch["Right Arm"]
    RW.Parent=ch.Torso
    --
    LW.Name="Left Shoulder"
    LW.Part0=ch.Torso
    LW.C0=cf(-1.5, 0.5, 0) --* CFrame.fromEulerAnglesXYZ(1.7, 0, 0.8)
    LW.C1=cf(0, 0.5, 0)
    LW.Part1=ch["Left Arm"]
    LW.Parent=ch.Torso


    newWeld = function(wp0, wp1, wc0x, wc0y, wc0z)
        local wld = Instance.new("Weld", wp1)
        wld.Part0 = wp0
        wld.Part1 = wp1
        wld.C0 = CFrame.new(wc0x, wc0y, wc0z)
    end
    local rs = game:GetService("RunService").RenderStepped

    newWeld(RootPart, Torso, 0, -1, 0)
    Torso.Weld.C1 = CFrame.new(0, -1, 0)
    newWeld(Torso, LeftLeg, -0.5, -1, 0)
    LeftLeg.Weld.C1 = CFrame.new(0, 1, 0)
    newWeld(Torso, RightLeg, 0.5, -1, 0)
    RightLeg.Weld.C1 = CFrame.new(0, 1, 0)

    Player=game:GetService('Players').LocalPlayer
    Character=Player.Character
    mouse=Player:GetMouse()
    m=Instance.new('Model',Character)


    local function weldBetween(a, b)
        local weldd = Instance.new("ManualWeld")
        weldd.Part0 = a
        weldd.Part1 = b
        weldd.C0 = CFrame.new()
        weldd.C1 = b.CFrame:inverse() * a.CFrame
        weldd.Parent = a
        return weldd
    end

    ArtificialHB = Instance.new("BindableEvent", script)
    ArtificialHB.Name = "Heartbeat"

    script:WaitForChild("Heartbeat")

    frame = 1 / 80
    tf = 0
    allowframeloss = false
    tossremainder = false
    lastframe = tick()
    script.Heartbeat:Fire()
    game:GetService("RunService").Heartbeat:connect(function(s, p)
        tf = tf + s
        if tf >= frame then
            if allowframeloss then
                script.Heartbeat:Fire()
                lastframe = tick()
            else
                for i = 1, math.floor(tf / frame) do
                    script.Heartbeat:Fire()
                end
                lastframe = tick()
            end
            if tossremainder then
                tf = 0
            else
                tf = tf - frame * math.floor(tf / frame)
            end
        end
    end)

--[[]
        function swait(num)
            if num == 0 or num == nil then
                ArtificialHB.Event:wait()
            else
                for i = 0, num do
                    ArtificialHB.Event:wait()
                end
            end
    end
 
    ]]




    function swait(num)
        if num == 0 or num == nil then
            game:service("RunService").Stepped:wait()
        else
            for i = 0, num do
                game:service("RunService").Stepped:wait()
            end
        end
    end

    function RemoveOutlines(part)
        part.TopSurface, part.BottomSurface, part.LeftSurface, part.RightSurface, part.FrontSurface, part.BackSurface = 10, 10, 10, 10, 10, 10
    end


    part = function(formfactor, parent, reflectance, transparency, brickcolor, name, size)
        local fp = it("Part")
        fp.formFactor = formfactor
        fp.Parent = parent
        fp.Reflectance = reflectance
        fp.Transparency = transparency
        fp.CanCollide = false
        fp.Locked = true
        fp.BrickColor = brickcolor
        fp.Name = name
        fp.Size = size
        fp.Position = Torso.Position
        NoOutline(fp)
        if fp.BrickColor == BrickColor.new("Dark indigo") then
            fp.Material = "Neon"
        else
            if fp.BrickColor == BrickColor.new("Really black") then
                fp.BrickColor = BrickColor.new("Really black")
                fp.Material = "Metal"
            else
                fp.Material = "Neon"
            end
        end
        fp:BreakJoints()
        return fp
    end

    mesh = function(Mesh, part, meshtype, meshid, offset, scale)
        local mesh = it(Mesh)
        mesh.Parent = part
        if Mesh == "SpecialMesh" then
            mesh.MeshType = meshtype
            mesh.MeshId = meshid
        end
        mesh.Offset = offset
        mesh.Scale = scale
        return mesh
    end

    weld = function(parent, part0, part1, c0)
        local weld = it("Weld")
        weld.Parent = parent
        weld.Part0 = part0
        weld.Part1 = part1
        weld.C0 = c0
        return weld
    end

    F1 = Instance.new("Folder", Character)
    F1.Name = "Effects Folder"
    F2 = Instance.new("Folder", F1)
    F2.Name = "Effects"
    Triangle = function(a, b, c)
    end

    MagicBlock = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
        local prt = part(3, F2, 0, 0, brickcolor, "Effect", vt())
        prt.Anchored = true
        prt.CanCollide = false
        prt.CFrame = cframe
        prt.Name = "prt"
        msh = mesh("BlockMesh", prt, "", "", vt(0, 0, 0), vt(x1, y1, z1))
        game:GetService("Debris"):AddItem(prt, 5)
        table.insert(Effects, {prt, "Block1", delay, x3, y3, z3})
    end



    MagicCircle = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
        local prt = part(3, F2, 0, 0, brickcolor, "Effect", vt())
        prt.Anchored = true
        prt.CanCollide = false
        prt.CFrame = cframe
        prt.Name = "prt"
        local msh = mesh("SpecialMesh", prt, "Sphere", "", vt(0, 0, 0), vt(x1, y1, z1))
        game:GetService("Debris"):AddItem(prt, 5)
        table.insert(Effects, {prt, "Cylinder", delay, x3, y3, z3})
    end

    MagicWave = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
        local prt = part(3, F2, 0, 0, brickcolor, "Effect", vt())
        prt.Anchored = true
        prt.CFrame = cframe
        local msh = mesh("SpecialMesh", prt, "FileMesh", "http://www.roblox.com/asset/?id=20329976", vt(0, 0, 0), vt(x1, y1, z1))
        game:GetService("Debris"):AddItem(prt, 5)
        table.insert(Effects, {prt, "Cylinder", delay, x3, y3, z3})
    end

    MagicCylinder = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
        local prt = part(3, F2, 0, 0, brickcolor, "Effect", vt(0.2, 0.2, 0.2))
        prt.Anchored = true
        prt.CFrame = cframe
        msh = mesh("SpecialMesh", prt, "Head", "", vt(0, 0, 0), vt(x1, y1, z1))
        game:GetService("Debris"):AddItem(prt, 5)
        Effects[#Effects + 1] = {prt, "Cylinder", delay, x3, y3, z3}
    end

    MagicCylinder2 = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
        local prt = part(3, F2, 0, 0, brickcolor, "Effect", vt(0.2, 0.2, 0.2))
        prt.Anchored = true
        prt.CFrame = cframe
        msh = mesh("CylinderMesh", prt, "", "", vt(0, 0, 0), vt(x1, y1, z1))
        game:GetService("Debris"):AddItem(prt, 5)
        Effects[#Effects + 1] = {prt, "Cylinder", delay, x3, y3, z3}
    end

    MagicBlood = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
        local prt = part(3, F2, 0, 0, brickcolor, "Effect", vt())
        prt.Anchored = true
        prt.CFrame = cframe
        local msh = mesh("SpecialMesh", prt, "Sphere", "", vt(0, 0, 0), vt(x1, y1, z1))
        game:GetService("Debris"):AddItem(prt, 5)
        table.insert(Effects, {prt, "Blood", delay, x3, y3, z3})
    end

    ElecEffect = function(cff, x, y, z)
        local prt = part(3, F2, 0, 0, BrickColor.new("Dark indigo"), "Part", vt(1, 1, 1))
        prt.Anchored = true
        prt.CFrame = cff * cf(math.random(-x, x), math.random(-y, y), math.random(-z, z))
        prt.CFrame = cf(prt.Position)
        game:GetService("Debris"):AddItem(prt, 2)
        xval = math.random() / 2
        yval = math.random() / 2
        zval = math.random() / 2
        msh = mesh("BlockMesh", prt, "", "", vt(0, 0, 0), vt(xval, yval, zval))
        Effects[#Effects + 1] = {prt, "Elec", 0.1, x, y, z, xval, yval, zval}
    end

    function FindNearestTorso(Position, Distance, SinglePlayer)
        if SinglePlayer then
            return (SinglePlayer.Torso.CFrame.p - Position).magnitude < Distance
        end
        local List = {}
        for i, v in pairs(workspace:GetChildren()) do
            if v:IsA("Model") then
                if v:findFirstChild("Torso") then
                    if v ~= Character then
                        if (v.Torso.Position - Position).magnitude <= Distance then
                            table.insert(List, v)
                        end 
                    end 
                end 
            end 
        end
        return List
    end


    function CreatePart(Parent, Material, Reflectance, Transparency, BColor, Name, Size)
        local Part = Create("Part"){
            Parent = Parent,
            Reflectance = Reflectance,
            Transparency = Transparency,
            CanCollide = false,
            Locked = true,
            BrickColor = BrickColor.new(tostring(BColor)),
            Name = Name,
            Size = Size,
            Material = Material,
        }
        RemoveOutlines(Part)
        return Part
    end

    function CreateMesh(Mesh, Part, MeshType, MeshId, OffSet, Scale)
        local Msh = Create(Mesh){
            Parent = Part,
            Offset = OffSet,
            Scale = Scale,
        }
        if Mesh == "SpecialMesh" then
            Msh.MeshType = MeshType
            Msh.MeshId = MeshId
        end
        return Msh
    end



    function BlockEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay, Type)
        local prt = CreatePart(workspace, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
        prt.Anchored = true
        prt.CFrame = cframe
        local msh = CreateMesh("BlockMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
        game:GetService("Debris"):AddItem(prt, 10)
        if Type == 1 or Type == nil then
            table.insert(Effects, {
                prt,
                "Block1",
                delay,
                x3,
                y3,
                z3,
                msh
            })
        elseif Type == 2 then
            table.insert(Effects, {
                prt,
                "Block2",
                delay,
                x3,
                y3,
                z3,
                msh
            })
        end
    end

    function SphereEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
        local prt = CreatePart(workspace, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
        prt.Anchored = true
        prt.CFrame = cframe
        local msh = CreateMesh("SpecialMesh", prt, "Sphere", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
        game:GetService("Debris"):AddItem(prt, 10)
        table.insert(Effects, {
            prt,
            "Cylinder",
            delay,
            x3,
            y3,
            z3,
            msh
        })
    end

    function RingEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay,material)
        local prt=CreatePart(workspace,material,0,0,brickcolor,"Effect",vt(.5,.5,.5))--part(3,workspace,"SmoothPlastic",0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
        prt.Anchored=true
        prt.CFrame=cframe
        msh=CreateMesh("SpecialMesh",prt,"FileMesh","http://www.roblox.com/asset/?id=3270017",vt(0,0,0),vt(x1,y1,z1))
        game:GetService("Debris"):AddItem(prt,2)
        coroutine.resume(coroutine.create(function(Part,Mesh,num) 
            for i=0,1,delay do
                swait()
                Part.Transparency=i
                Mesh.Scale=Mesh.Scale+vt(x3,y3,z3)
            end
            Part.Parent=nil
        end),prt,msh,(math.random(0,1)+math.random())/5)
    end

    function CylinderEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
        local prt = CreatePart(workspace, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
        prt.Anchored = true
        prt.CFrame = cframe
        local msh = CreateMesh("CylinderMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
        game:GetService("Debris"):AddItem(prt, 10)
        table.insert(Effects, {
            prt,
            "Cylinder",
            delay,
            x3,
            y3,
            z3,
            msh
        })
    end

    function WaveEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
        local prt = CreatePart(workspace, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
        prt.Anchored = true
        prt.CFrame = cframe
        local msh = CreateMesh("SpecialMesh", prt, "FileMesh", "rbxassetid://20329976", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
        game:GetService("Debris"):AddItem(prt, 10)
        table.insert(Effects, {
            prt,
            "Cylinder",
            delay,
            x3,
            y3,
            z3,
            msh
        })
    end

    function SpecialEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
        local prt = CreatePart(workspace, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
        prt.Anchored = true
        prt.CFrame = cframe
        local msh = CreateMesh("SpecialMesh", prt, "FileMesh", "rbxassetid://24388358", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
        game:GetService("Debris"):AddItem(prt, 10)
        table.insert(Effects, {
            prt,
            "Cylinder",
            delay,
            x3,
            y3,
            z3,
            msh
        })
    end


    function MoonEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
        local prt = CreatePart(workspace, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
        prt.Anchored = true
        prt.CFrame = cframe
        local msh = CreateMesh("SpecialMesh", prt, "FileMesh", "rbxassetid://259403370", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
        game:GetService("Debris"):AddItem(prt, 10)
        table.insert(Effects, {
            prt,
            "Cylinder",
            delay,
            x3,
            y3,
            z3,
            msh
        })
    end

    function HeadEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
        local prt = CreatePart(workspace, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
        prt.Anchored = true
        prt.CFrame = cframe
        local msh = CreateMesh("SpecialMesh", prt, "Head", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
        game:GetService("Debris"):AddItem(prt, 10)
        table.insert(Effects, {
            prt,
            "Cylinder",
            delay,
            x3,
            y3,
            z3,
            msh
        })
    end

    function BreakEffect(brickcolor, cframe, x1, y1, z1)
        local prt = CreatePart(workspace, "Neon", 0, 0, brickcolor, "Effect", Vector3.new(0.5, 0.5, 0.5))
        prt.Anchored = true
        prt.CFrame = cframe * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
        local msh = CreateMesh("SpecialMesh", prt, "Sphere", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
        local num = math.random(10, 50) / 1000
        game:GetService("Debris"):AddItem(prt, 10)
        table.insert(Effects, {
            prt,
            "Shatter",
            num,
            prt.CFrame,
            math.random() - math.random(),
            0,
            math.random(50, 100) / 100
        })
    end

    local lerp = function(a, b, t)
        return a * (1 - t) + b * t
    end

    function clerp(a,b,t)
        local qa = {QuaternionFromCFrame(a)}
        local qb = {QuaternionFromCFrame(b)}
        local ax, ay, az = a.x, a.y, a.z
        local bx, by, bz = b.x, b.y, b.z
        local _t = 1-t
        return QuaternionToCFrame(_t*ax + t*bx, _t*ay + t*by, _t*az + t*bz,QuaternionSlerp(qa, qb, t))
    end

    function QuaternionFromCFrame(cf)
        local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components()
        local trace = m00 + m11 + m22
        if trace > 0 then
            local s = math.sqrt(1 + trace)
            local recip = 0.5/s
            return (m21-m12)*recip, (m02-m20)*recip, (m10-m01)*recip, s*0.5
        else
            local i = 0
            if m11 > m00 then
                i = 1
            end
            if m22 > (i == 0 and m00 or m11) then
                i = 2
            end
            if i == 0 then
                local s = math.sqrt(m00-m11-m22+1)
                local recip = 0.5/s
                return 0.5*s, (m10+m01)*recip, (m20+m02)*recip, (m21-m12)*recip
            elseif i == 1 then
                local s = math.sqrt(m11-m22-m00+1)
                local recip = 0.5/s
                return (m01+m10)*recip, 0.5*s, (m21+m12)*recip, (m02-m20)*recip
            elseif i == 2 then
                local s = math.sqrt(m22-m00-m11+1)
                local recip = 0.5/s return (m02+m20)*recip, (m12+m21)*recip, 0.5*s, (m10-m01)*recip
            end
        end
    end


    function QuaternionToCFrame(px, py, pz, x, y, z, w)
        local xs, ys, zs = x + x, y + y, z + z
        local wx, wy, wz = w*xs, w*ys, w*zs
        local xx = x*xs
        local xy = x*ys
        local xz = x*zs
        local yy = y*ys
        local yz = y*zs
        local zz = z*zs
        return CFrame.new(px, py, pz,1-(yy+zz), xy - wz, xz + wy,xy + wz, 1-(xx+zz), yz - wx, xz - wy, yz + wx, 1-(xx+yy))
    end
    function QuaternionSlerp(a, b, t)
        local cosTheta = a[1]*b[1] + a[2]*b[2] + a[3]*b[3] + a[4]*b[4]
        local startInterp, finishInterp;
        if cosTheta >= 0.0001 then
            if (1 - cosTheta) > 0.0001 then
                local theta = math.acos(cosTheta)
                local invSinTheta = 1/math.sin(theta)
                startInterp = math.sin((1-t)*theta)*invSinTheta
                finishInterp = math.sin(t*theta)*invSinTheta  
            else
                startInterp = 1-t
                finishInterp = t
            end
        else
            if (1+cosTheta) > 0.0001 then
                local theta = math.acos(-cosTheta)
                local invSinTheta = 1/math.sin(theta)
                startInterp = math.sin((t-1)*theta)*invSinTheta
                finishInterp = math.sin(t*theta)*invSinTheta
            else
                startInterp = t-1
                finishInterp = t
            end
        end
        return a[1]*startInterp + b[1]*finishInterp, a[2]*startInterp + b[2]*finishInterp, a[3]*startInterp + b[3]*finishInterp, a[4]*startInterp + b[4]*finishInterp
    end

    function weld5(part0, part1, c0, c1)
        weeld=Instance.new("Weld", part0)
        weeld.Part0=part0
        weeld.Part1=part1
        weeld.C0=c0
        weeld.C1=c1
        return weeld
    end

    --Example: Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.4)

    function rayCast(Pos, Dir, Max, Ignore)  -- Origin Position , Direction, MaxDistance , IgnoreDescendants
        return game:service("Workspace"):FindPartOnRay(Ray.new(Pos, Dir.unit * (Max or 999.999)), Ignore)
    end







    local f = 0
    local b = Instance.new("BlurEffect",cam)
    local    c = Instance.new('PointLight', Torso)
    c.Range = 16
    c.Color = Color3.new(0, 1,1)
    c.Brightness = 1.5
    game:GetService("RunService"):BindToRenderStep("W0tT", 0, function()

        b.Size = b.Size - 4
        if boost == true then
            c.Enabled = true
            cam.FieldOfView = lerp(cam.FieldOfView, 110, 0.5)
            -- cam.FieldOfView = 110
            freefall = 0
            Humanoid.CameraOffset = Humanoid.CameraOffset:lerp(Vector3.new(0,0,3),0.25)
            SphereEffect(BrickColor.new("Cyan"),RightLeg.CFrame*CFrame.new(0,-1,0)*angles(math.random(-180,180),math.random(-180,180),math.random(-180,180)),1.4,12,1.4,2.8,26,2.8,0.07)
            SphereEffect(BrickColor.new("Cyan"),LeftLeg.CFrame*CFrame.new(0,-1,0)*angles(math.random(-180,180),math.random(-180,180),math.random(-180,180)),1.4,12,1.4,2.8,26,2.8,0.07)
            if hitfloor ~= nil and Anim ~= "runIdle" then
                SpecialEffect(BrickColor.new("Cyan"),RootPart.CFrame*CFrame.new(0,-3.4,.78) ,2,2,2, 1.5,1.5,1.5,.09)
            end
        end
        if boost == false then
            cam.FieldOfView = lerp(cam.FieldOfView, 70, 0.076)
            --cam.FieldOfView = 70
            c.Enabled = false
        end
    end)



    mouse.KeyDown:connect(function(key)
        if string.byte(key) == 48 then
            b.Size = 40
            Swing = 2
            freefall = 0

            coroutine.resume(coroutine.create(function()
                for i = 0,1,0.1 do
                    swait()
                    Humanoid.CameraOffset = Humanoid.CameraOffset:lerp(Vector3.new(math.random(-0.35*1.8,0.35*1.8),math.random(-0.35*1.8,0.35*1.8),math.random(-0.35*1.8,0.35*1.8)),0.24)
                end
            end))
            Humanoid.WalkSpeed = 180
            RootPart.Velocity = RootPart.CFrame.lookVector*150
            RingEffect(BrickColor.new("Cyan"), RootPart.CFrame*CFrame.new(0,0,-9.2) , 1, 1, 1, 8, 8, 8, 0.14,"Neon") 
            boost = true
            boostsound:Play()
        end
    end)

    mouse.KeyUp:connect(function(key)
        if string.byte(key) == 48 then
            Swing = 1
            Humanoid.WalkSpeed = 64
            boost = false
            boostsound:Stop()

        end
    end)




    mouse.KeyDown:connect(function(key)
        if string.byte(key) == 50 then
            b.Size = 40
            freefall = 0
            Swing = 2

            coroutine.resume(coroutine.create(function()
                for i = 0,1,0.1 do
                    swait()
                    Humanoid.CameraOffset = Humanoid.CameraOffset:lerp(Vector3.new(math.random(-0.35*2.8,0.35*2.8),math.random(-0.35*2.8,0.35*2.8),math.random(-0.35*2.8,0.35*2.8)),0.48)
                end
            end))

            Humanoid.WalkSpeed = 320
            RootPart.Velocity = RootPart.CFrame.lookVector*550
            RingEffect(BrickColor.new("Cyan"), RootPart.CFrame*CFrame.new(0,0,-9.2) , 1, 1, 1, 18, 18, 18, 0.14,"Neon") 
            RingEffect(BrickColor.new("White"), RootPart.CFrame*CFrame.new(0,0,-11.2) , 1, 1, 1, 18, 18, 18, 0.14,"Neon") 
            RingEffect(BrickColor.new("Cyan"), RootPart.CFrame*CFrame.new(0,0,-13.2) , 1, 1, 1, 18, 18, 18, 0.14,"Neon") 
            boost = true
            boostsound:Play()
        end
    end)

    mouse.KeyUp:connect(function(key)
        if string.byte(key) == 50 then
            Swing = 1
            Humanoid.WalkSpeed = 64
            boost = false
            boostsound:Stop()

        end
    end)


    local lastwall = nil
    local jumped = false






    local vwall = false

    mouse.KeyDown:connect(function(key)
        if key == 'b' and hitfloor == nil and attack == false then
            vrun()
        end
    end)


    function vrun()
        local ray = Ray.new(
            RootPart.CFrame.p, RootPart.CFrame.lookVector *2.5
        )
        local hit, position, normal = workspace:FindPartOnRay(ray, character)

        if hit then
            if hit.Parent.Parent ~= Character and hit.Parent ~= Character and hit.Name ~= "prt" and hit.CanCollide == true then
                vwall = true
                local NV = Vector3.new(0,0,0)
                local spd = Vector3.new(RootPart.Velocity.x,0,RootPart.Velocity.z).magnitude + 10
                local dir = Vector3.new(RootPart.Velocity.x,0,RootPart.Velocity.z).unit
                local GravPoint = RootPart.Velocity.y
                local velo = Instance.new("BodyVelocity",Torso)
                velo.MaxForce = Vector3.new(400000,400000,400000)

                attack = true
                while vwall == true and ray and hit do
                    swait()
                    change = 0.84+ Humanoid.WalkSpeed/132
                    if Humanoid.WalkSpeed > 40 and Humanoid.WalkSpeed < 70 then
                        velo.Velocity =  Vector3.new(0,40,0)
                    end
                    if Humanoid.WalkSpeed > 70 and Humanoid.WalkSpeed < 200 then
                        velo.Velocity =  Vector3.new(0,80,0)
                    end
                    if Humanoid.WalkSpeed > 200 then
                        velo.Velocity =  Vector3.new(0,130,0)
                    end
                    ray = Ray.new(
                        RootPart.CFrame.p, RootPart.CFrame.lookVector *2.5
                    )
                    hit, position, normal = workspace:FindPartOnRay(ray, character)
                    Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1-0.52*math.cos(sine/2), .6) * angles(math.rad(96), math.rad(0), math.rad(0)+ RootPart.RotVelocity.Y / 26), .1)
                    Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(-11+20*math.sin(sine/2)),math.rad(0),math.rad(0+5*math.sin(sine/4)) + RootPart.RotVelocity.Y / 13),.1)
                    RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0.1) * angles(math.rad(-90-7*math.sin(sine/4))+ RootPart.RotVelocity.Y / -34, math.rad(0), math.rad(15+2*math.sin(sine/4))- RootPart.RotVelocity.Y / 34),.15)
                    LW.C0=clerp(LW.C0,cf(-1.5,0.5,0.1)*angles(math.rad(-90-7*math.sin(sine/4))+ RootPart.RotVelocity.Y / 34,math.rad(0),math.rad(-15+2*math.sin(sine/4))+ RootPart.RotVelocity.Y / -34),.15)
                    LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -1+0.28*math.cos(sine/4), 0-0.32*math.cos(sine/4)) * CFrame.Angles(math.rad(0+104*math.sin(sine/4)), math.rad(0)+ RootPart.RotVelocity.Y / 42, math.rad(0)+ RootPart.RotVelocity.Y / -54), 0.3+ Humanoid.WalkSpeed/272)
                    RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -1-0.28*math.cos(sine/4),0+0.32*math.cos(sine/4)) * CFrame.Angles(math.rad(0-104*math.sin(sine/4)), math.rad(0)+ RootPart.RotVelocity.Y / 42, math.rad(0)- RootPart.RotVelocity.Y / 54), 0.3+ Humanoid.WalkSpeed/272)
                end
                velo:Destroy()
                wait(0.07)

                if vwall == false then

                    RootPart.Velocity = -RootPart.CFrame.lookVector*68 + Vector3.new(0,86,0)

--[[]
        for i = 0,5,0.2 do
rs:wait()
Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -0.79, 0) * CFrame.Angles(math.rad(0+100*i), math.rad(0), math.rad(0)), 0.2)
Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(20),math.rad(0),math.rad(0)),.2)
RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(180), math.rad(-60), math.rad(40)),.2)
LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(180), math.rad(60), math.rad(-40)),.2)
LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -1, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.2)
RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -1, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.2)
end
]]


                    for i = 0,4,0.1 do
                        swait()
                        Humanoid.CameraOffset = Vector3.new(0,0,0)
                        Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1, 0) * CFrame.Angles(math.rad(0+260*i), math.rad(0), math.rad(0)), 0.6)
                        Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(70),math.rad(0),math.rad(0)),.1)
                        RW.C0 = clerp(RW.C0, CFrame.new(.7, -0.22, -0.5) * angles(math.rad(90), math.rad(0), math.rad(-90)), 0.1)
                        LW.C0 = clerp(LW.C0, CFrame.new(-.7, -0.22, -0.5) * angles(math.rad(90), math.rad(0), math.rad(90)), 0.1)
                        LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -.34, -0.7) * CFrame.Angles(math.rad(-25), math.rad(0), math.rad(0)), 0.1)
                        RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -.34, -0.7) * CFrame.Angles(math.rad(-25), math.rad(0), math.rad(0)), 0.1)
                    end

                    attack = false


                end


                if vwall == true then
                    RootPart.Velocity = RootPart.CFrame.lookVector*38 + Vector3.new(0,86,0)

--[[]
        for i = 0,5,0.2 do
rs:wait()
Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -0.79, 0) * CFrame.Angles(math.rad(0+100*i), math.rad(0), math.rad(0)), 0.2)
Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(20),math.rad(0),math.rad(0)),.2)
RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(180), math.rad(-60), math.rad(40)),.2)
LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(180), math.rad(60), math.rad(-40)),.2)
LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -1, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.2)
RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -1, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.2)
end
]]


                    for i = 0,4,0.15 do
                        swait()
                        Humanoid.CameraOffset = Vector3.new(0,0,0)
                        Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1, 0) * CFrame.Angles(math.rad(0-260*i), math.rad(0), math.rad(0)), 0.6)
                        Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(70),math.rad(0),math.rad(0)),.1)
                        RW.C0 = clerp(RW.C0, CFrame.new(.7, -0.22, -0.5) * angles(math.rad(90), math.rad(0), math.rad(-90)), 0.1)
                        LW.C0 = clerp(LW.C0, CFrame.new(-.7, -0.22, -0.5) * angles(math.rad(90), math.rad(0), math.rad(90)), 0.1)
                        LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -.34, -0.7) * CFrame.Angles(math.rad(-25), math.rad(0), math.rad(0)), 0.1)
                        RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -.34, -0.7) * CFrame.Angles(math.rad(-25), math.rad(0), math.rad(0)), 0.1)
                    end

                    attack = false

                end


            end
        end
    end




    mouse.KeyUp:connect(function(key)
        if key == 'b' and vwall == true then
            vwall = false
        end
    end)





    function Ldash()



        evadecooldown = true
        attack = true
        k = math.random(1,2) 
        if k == 1 then
            so("http://www.roblox.com/asset/?id=807766310", Head, 2.5, 1)
        else
            so("http://www.roblox.com/asset/?id=807768137", Head, 2.5, 1)
        end





        --+173.8*i
        for i = 0,.7,0.1 do
            swait()
            Head.Velocity = Head.CFrame.rightVector * -135
            Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(32)), 0.2)
            Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(0),math.rad(-9),math.rad(-14)),.2)
            RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, -0.2) * angles(math.rad(27), math.rad(0), math.rad(30)),.2)
            LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(30), math.rad(0), math.rad(30)),.2)
            LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -1, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(12)), 0.2)
            RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -1, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(8)), 0.2)
        end

        attack = false
        wait(0.08)
        evadecooldown = false


    end





    function Rdash()



        evadecooldown = true
        attack = true
        k = math.random(1,2) 
        if k == 1 then
            so("http://www.roblox.com/asset/?id=807766310", Head, 2.5, 1)
        else
            so("http://www.roblox.com/asset/?id=807768137", Head, 2.5, 1)
        end





        --+173.8*i
        for i = 0,.7,0.1 do
            swait()
            Head.Velocity = Head.CFrame.rightVector * 135
            Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-32)), 0.2)
            Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(0),math.rad(9),math.rad(14)),.2)
            RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(30), math.rad(0), math.rad(-30)),.2)
            LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, -0.2) * angles(math.rad(27), math.rad(0), math.rad(-30)),.2)
            LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -1, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-8)), 0.2)
            RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -1, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-12)), 0.2)
        end

        attack = false
        wait(0.08)
        evadecooldown = false


    end
    local sliding = false


    function Slide()

        local spd = Vector3.new(RootPart.Velocity.x,0,RootPart.Velocity.z).magnitude + 10
        spd = spd + 30
        local dir = Vector3.new(RootPart.Velocity.x,0,RootPart.Velocity.z).unit
        local GravPoint = RootPart.Velocity.y
        if spd > 40 and hitfloor ~= nil then
            noleg = true

            attack = true
            k = math.random(1,2) 
            if k == 1 then
                so("http://www.roblox.com/asset/?id=807766310", Head, 2.5, 1)
            else
                so("http://www.roblox.com/asset/?id=807768137", Head, 2.5, 1)
            end










            local NV = Vector3.new(0,0,0)
            local bv = Instance.new("BodyVelocity", Torso)
            bv.maxForce = Vector3.new(1/0,1/0,1/0)
            bv.velocity = dir*spd
            local bg = Instance.new("BodyGyro", Torso)
            bg.maxTorque = Vector3.new(1/0,1/0,1/0)
            bg.cframe = CFrame.new(NV, dir) * CFrame.Angles(math.pi/2.2,0.24,0)
            headsunsound.SoundId = "rbxassetid://1295468446"
            headsunsound.TimePosition = 0

            Humanoid.PlatformStand = true
            while spd > 2 and hitfloor ~= nil and sliding == true do
                swait()
                spd = spd - 0.95
                bv.velocity = dir*spd + Vector3.new(0,0,0)
                bg.cframe = CFrame.new(NV, dir) * CFrame.Angles(math.pi/2.2,0.24,0)
                Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -2.3, 0) * CFrame.Angles(math.rad(90), math.rad(0), math.rad(12)), 0.2)
                Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(34),math.rad(0),math.rad(12)),.2)
                RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(110), math.rad(0), math.rad(70)),.2)
                LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, -0.2) * angles(math.rad(0), math.rad(0), math.rad(-60)),.2)
                LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -1, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.2)
                RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -0.56, -0.2) * CFrame.Angles(math.rad(-24), math.rad(0), math.rad(0)), 0.2)
            end
            bv:Destroy()
            bg:Destroy()
            headsunsound.SoundId = "rbxassetid://758199523"
            headsunsound.TimePosition = 0
            Humanoid.PlatformStand = false
            attack = false
            sliding = false
            wait(0.05)
            evadecooldown = false


        end
    end

    function land()
        attack = true
        RootPart.Velocity = Vector3.new(0,0,0)
        WaveEffect(BrickColor.new("Cyan"), RootPart.CFrame*CFrame.new(0,-1,0) , 1, 1, 1, 3, 0.8, 3, 0.06) 
        so("http://www.roblox.com/asset/?id=1295424585", Torso, 3.5, 1)

        coroutine.resume(coroutine.create(function()
            for i = 0,1,0.1 do
                swait()
                Humanoid.CameraOffset = Humanoid.CameraOffset:lerp(Vector3.new(math.random(-0.55*2.8,0.55*2.8),math.random(-0.55*2.8,0.55*2.8),math.random(-0.55*2.8,0.55*2.8)),0.44)
                Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -2, 0) * CFrame.Angles(math.rad(-16), math.rad(0), math.rad(0)), 0.5)
                Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(7),math.rad(0),math.rad(0)),.5)
                RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(0), math.rad(0), math.rad(87)),.5)
                LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, -0) * angles(math.rad(0), math.rad(0), math.rad(-87)),.5)
                LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, 0, -0.5) * CFrame.Angles(math.rad(16), math.rad(0), math.rad(0)), 0.5)
                RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -1.14, 0.2) * CFrame.Angles(math.rad(-17), math.rad(0), math.rad(0)), 0.5)

            end
            attack = false


        end))



    end




    function stomp()
        attack = true
        stompsound:Play()

        while hitfloor == nil do 
            swait()
            b.Size = 12
            WaveEffect(BrickColor.new("Cyan"), LeftLeg.CFrame*CFrame.new(0,-2.4,0) , 1, 1, 1, 0.8, 0.8, 0.8, 0.14) 
            RootPart.Velocity = Vector3.new(0,RootPart.Velocity.y/1.6,0) +Vector3.new(0,-150,0)
            Humanoid.CameraOffset = Humanoid.CameraOffset:lerp(Vector3.new(0,0,0),0.15)
            Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1, 0.2) * CFrame.Angles(math.rad(0+4*math.sin(sine/1.3)), math.rad(0), math.rad(0)),0.07)
            RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.65, 0) * angles(math.rad(0), math.rad(0), math.rad(140+12*math.cos(sine/1.3))), 0.07)
            LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.65, 0) * angles(math.rad(0), math.rad(0), math.rad(-140+12*math.cos(sine/1.3))), 0.07)
            Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(60+7*math.sin(sine/1.3)),math.rad(0),math.rad(0)),0.07)
            LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -1+0.17*math.cos(sine/1.3), -0.13) * CFrame.Angles(math.rad(0+4*math.cos(sine/1.3)), math.rad(3), math.rad(0)), 0.1)
            RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, .27+0.17*math.cos(sine/1.3), -0.56) * CFrame.Angles(math.rad(-12+4*math.cos(sine/1.3)), math.rad(0), math.rad(0)), 0.1)

        end
        stompsound:Stop()
        land()


    end


    function changemusic()
        musicnum = musicnum + 1
        music.TimePosition = 0
        local osix = false
        local spd = Vector3.new(RootPart.Velocity.x,0,RootPart.Velocity.z).magnitude
        if musicnum > 14 then
            musicnum = 1
        end
        if musicnum == 1 then
            music.SoundId = "rbxassetid://179029173"
        end
        if musicnum == 2 then
            music.SoundId = "rbxassetid://146443855"
        end
        if musicnum == 3 then
            music.SoundId = "rbxassetid://1342408291" 
        end
        if musicnum == 4 then
            music.SoundId = "rbxassetid://201219416"  
        end
        if musicnum == 5 then
            music.SoundId = "rbxassetid://1390472571" 
        end
        if musicnum == 6 then
            osix = true
            music.SoundId = "rbxassetid://249974783" 
        end
        if musicnum == 7 then
            music.SoundId = "rbxassetid://1851880603"
        end
        if musicnum == 8 then
            music.SoundId = "rbxassetid://412034984"
        end
        if musicnum == 9 then
            music.SoundId = "rbxassetid://536915629"
        end
        if musicnum == 10 then
            music.SoundId = "rbxassetid://1200005861"
        end
        if musicnum == 11 then
            music.SoundId = "rbxassetid://1055930631"
        end
        if musicnum == 12 then
            music.SoundId = "rbxassetid://300269553"
        end
        if musicnum == 13 then
            music.SoundId = "rbxassetid://199897052"
        end
        if musicnum == 14 then
            music.SoundId = "rbxassetid://638115895"  
        end

        if spd < 14 then
            Humanoid.Jump = true

            if osix == false then
                so("rbxassetid://537371462",RootPart,2,1)
            end


            RootPart.Velocity = Vector3.new(0,102,0)
            attack = true
            wait(0.08)
            for i = 0,7,0.1 do
                swait()
                RootPart.Velocity = Vector3.new(0,2,0)
                Humanoid.CameraOffset = Vector3.new(0,0,0)
                Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1, 0) * CFrame.Angles(math.rad(0-260*i), math.rad(0), math.rad(0)), 0.6)
                Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(70),math.rad(0),math.rad(0)),.1)
                RW.C0 = clerp(RW.C0, CFrame.new(.7, -0.22, -0.5) * angles(math.rad(90), math.rad(0), math.rad(-90)), 0.1)
                LW.C0 = clerp(LW.C0, CFrame.new(-.7, -0.22, -0.5) * angles(math.rad(90), math.rad(0), math.rad(90)), 0.1)
                LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -.34, -0.7) * CFrame.Angles(math.rad(-25), math.rad(0), math.rad(0)), 0.1)
                RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -.34, -0.7) * CFrame.Angles(math.rad(-25), math.rad(0), math.rad(0)), 0.1)

            end
            b.Size = 40
            MoonEffect(BrickColor.new("Cyan"), RootPart.CFrame*CFrame.new(0,0,0) , 1, 1, 1, 8, 8, 8, 0.06) 

            if osix == true then
                osix = false
                so("rbxassetid://156821036",RootPart,2,1)
            end

            Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -3, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 1)
            for i = 0,5,0.1 do
                swait()
                RootPart.Velocity = Vector3.new(0,3.5,0)
                Humanoid.CameraOffset = Vector3.new(0,0,0)
                Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1+0.1*i, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.21)
                Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(22-2*i),math.rad(0),math.rad(0)),.21)
                RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5+0.09*i, 0) * angles(math.rad(20-6*i), math.rad(0), math.rad(90+13*i)), 0.21)
                LW.C0 = clerp(LW.C0, CFrame.new(-1.0-0.12*i, 0.5, -0.4+0.05*i) * angles(math.rad(20+13*i), math.rad(0), math.rad(20-13*i)), 0.21)
                LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -1, 0) * CFrame.Angles(math.rad(45+6*i), math.rad(0), math.rad(-22-4*i)), 0.21)
                RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -1, 0) * CFrame.Angles(math.rad(45+6*i), math.rad(0), math.rad(22+4*i)), 0.21)
            end
            attack = false
        end
    end


    mouse.KeyDown:connect(function(key)
        if key == 'q' and attack == false and evadecooldown == false then
            Ldash()
        end
    end)



    mouse.KeyDown:connect(function(key)
        if key == 'e' and attack == false and evadecooldown == false then
            Rdash()
        end
    end)

    mouse.KeyDown:connect(function(key)
        if key == 'c' and attack == false and evadecooldown == false and hitfloor ~= nil then
            sliding = true
            Slide()
        end
    end)

    mouse.KeyDown:connect(function(key)
        if key == 'c' and attack == false and hitfloor == nil then
            stomp()
        end
    end)


    local walljump = false


    function walljumpp()
        local ray = Ray.new(
            Torso.CFrame.p, RootPart.CFrame.lookVector *5
        )
        local hit, position, normal = workspace:FindPartOnRay(ray, character)

        if hit then
            if  hit.Parent.Parent ~= Character and hit.Parent ~= Character then
                local dir = Vector3.new(RootPart.Velocity.x,0,RootPart.Velocity.z).unit
                GravPoint = 0
                freefall = 0
                walljump = true 
                Humanoid.AutoRotate = false
                local velo = Instance.new("BodyVelocity",Torso)
                velo.MaxForce = Vector3.new(400000,400000,400000)
                --game.Debris:AddItem(velo,0.1)
                attack = true
                while hitfloor == nil and walljump == true and ray and hit  do
                    swait()
                    freefall = 0
                    GravPoint = GravPoint - 0.36
                    ray = Ray.new(
                        RootPart.CFrame.p, RootPart.CFrame.lookVector *2.5
                    )
                    hit, position, normal = workspace:FindPartOnRay(ray, character)
                    velo.Velocity = vt(0,GravPoint,0)
                    Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1, 0.9) * CFrame.Angles(math.rad(5), math.rad(90), math.rad(8)), 0.2)
                    Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(7),math.rad(0),math.rad(86)),.2)
                    RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(0), math.rad(0), math.rad(120)),.2)
                    LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(0), math.rad(0), math.rad(-60)),.2)
                    LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -1, 0) * CFrame.Angles(math.rad(-6), math.rad(14), math.rad(-12)), 0.2)
                    RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -1, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(23)), 0.2)
                end
                if walljump == false then
                    k = math.random(1,3) 
                    if k == 1 then
                        so("http://www.roblox.com/asset/?id=800121776", Head, 2.5, 1)
                    else if k == 2 then
                            so("http://www.roblox.com/asset/?id=804889329", Head, 2.5, 1)
                        else if k == 3 then
                                so("http://www.roblox.com/asset/?id=804907617", Head, 2.5, 1)
                            end
                        end
                    end

                    velo:Destroy()
                    attack = false
                    coroutine.resume(coroutine.create(function()
                        for i = 0,1,0.1 do
                            swait()
                            Humanoid.CameraOffset = Vector3.new(0,0,0)
                            Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1, 0) * CFrame.Angles(math.rad(0+260*i), math.rad(0), math.rad(0)), 0.6)
                            Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(70),math.rad(0),math.rad(0)),.1)
                            RW.C0 = clerp(RW.C0, CFrame.new(.7, -0.22, -0.5) * angles(math.rad(90), math.rad(0), math.rad(-90)), 0.1)
                            LW.C0 = clerp(LW.C0, CFrame.new(-.7, -0.22, -0.5) * angles(math.rad(90), math.rad(0), math.rad(90)), 0.1)
                            LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -.34, -0.7) * CFrame.Angles(math.rad(-25), math.rad(0), math.rad(0)), 0.1)
                            RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -.34, -0.7) * CFrame.Angles(math.rad(-25), math.rad(0), math.rad(0)), 0.1)
                        end
                    end))

                    Humanoid.AutoRotate = true
                    RootPart.Velocity = RootPart.CFrame.lookVector * -137 + Vector3.new(0,136,0)
                    wait(0.07)
                    RootPart.CFrame = CFrame.new(RootPart.CFrame.p,-RootPart.CFrame.lookVector)
                end
                if walljump == true then
                    attack = false
                    walljump = false
                    Humanoid.AutoRotate = true
                    velo:Destroy()
                end
            end
        end
    end


    local homed = nil
    function home()
        if walljump ~= true then
            for i, v in pairs(FindNearestTorso(Torso.CFrame.p, 80)) do
                if v:FindFirstChild('Head') then
                    Grabbed = true
                    homed = v
                end
            end

            if homed ~= nil and homed:FindFirstChildOfClass("Humanoid").Health > 1 and walljump == false then
                so("http://www.roblox.com/asset/?id=162460823", Head, 1, .8)
                local SBall = Instance.new("Part",Character)
                SBall.Name = "Homing Ball"
                SBall.CanCollide = false
                SBall.Anchored = false
                SBall.Transparency = 0.64
                SBall.CFrame = CFrame.new(RootPart.CFrame.p)
                SBall.BrickColor = BrickColor.new("Toothpaste")
                SBall.Size = Vector3.new(1,1,1)
                SBall.Material = "Neon"
                SBallweld = Instance.new("Weld")
                SBallweld.Parent = SBall
                SBallweld.Part0 = RootPart
                SBallweld.Part1 = SBall
                SBallweld.C1 = CFrame.new(0, 1, 0)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0))
                SBallweld.Part0 = RootPart
                local SBallmesh = Instance.new("SpecialMesh",SBall)
                SBallmesh.MeshType = "Sphere"
                SBallmesh.Scale = Vector3.new(6,6,6)
                trail = Instance.new("Trail", Character)
                a2 = Instance.new("Attachment", Torso) a2.Position = Vector3.new(0,2,0)
                a3 = Instance.new("Attachment", Torso)a3.Position = Vector3.new(0,-2.5,0)
                trail.Texture = "rbxassetid://0"
                trail.Attachment0 = a2
                trail.Attachment1 = a3
                trail.Lifetime  =  0.353
                trail.MinLength = 0.03
                trail.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0,0),NumberSequenceKeypoint.new(1,1,1)})
                trail.Color = ColorSequence.new(Color3.new(0,1,1), Color3.new(0, 0,0))
                trail.LightEmission = 4.8
                trail.TextureLength = 0.034
                trail.Enabled = true
                attack = true
                local position = Instance.new("BodyPosition",Torso)
                position.P = 68350
                position.maxForce = Vector3.new(math.huge,math.huge,math.huge)

                while homed ~= nil and (homed.Torso.Position-RootPart.Position).magnitude > 8 do
                    swait()
                    SBall.CFrame = CFrame.new(RootPart.CFrame.p)
                    Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1, 0) * CFrame.Angles(math.rad(0+420*math.abs(sine/3.2)), math.rad(0), math.rad(0)), 0.6)
                    Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(70),math.rad(0),math.rad(0)),.1)
                    RW.C0 = clerp(RW.C0, CFrame.new(.7, -0.22, -0.5) * angles(math.rad(90), math.rad(0), math.rad(-90)), 0.1)
                    LW.C0 = clerp(LW.C0, CFrame.new(-.7, -0.22, -0.5) * angles(math.rad(90), math.rad(0), math.rad(90)), 0.1)
                    LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -.34, -0.7) * CFrame.Angles(math.rad(-25), math.rad(0), math.rad(0)), 0.1)
                    RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -.34, -0.7) * CFrame.Angles(math.rad(-25), math.rad(0), math.rad(0)), 0.1)
                    position.Position = homed.Torso.Position + Vector3.new(0,2,0) 
                end
                local bodvol=Instance.new("BodyVelocity")
                bodvol.velocity= RootPart.CFrame.lookVector*240 + Vector3.new(0,30,0)
                bodvol.P= 35200
                bodvol.maxForce=Vector3.new(8e+003, 8e+003, 8e+003)
                bodvol.Parent=homed.Head
                game:GetService("Debris"):AddItem(bodvol, 0.2)
                --homed:FindFirstChildOfClass("Humanoid"):TakeDamage(math.random(10,30))

                position:Destroy()
                trail.Enabled = false
                SBall:Destroy()
                RootPart.Velocity = Vector3.new(0,93.5,0)
                coroutine.resume(coroutine.create(function()
                    for i = 0,5,0.26 do
                        swait()
                        Humanoid.CameraOffset = Vector3.new(0,0,0)
                        Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1+0.1*i, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.21)
                        Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(22-2*i),math.rad(0),math.rad(0)),.21)
                        RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5+0.09*i, 0) * angles(math.rad(20-6*i), math.rad(0), math.rad(90+13*i)), 0.21)
                        LW.C0 = clerp(LW.C0, CFrame.new(-1.0-0.12*i, 0.5, -0.4+0.05*i) * angles(math.rad(20+13*i), math.rad(0), math.rad(20-13*i)), 0.21)
                        LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -1, 0) * CFrame.Angles(math.rad(45+6*i), math.rad(0), math.rad(-22-4*i)), 0.21)
                        RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -1, 0) * CFrame.Angles(math.rad(45+6*i), math.rad(0), math.rad(22+4*i)), 0.21)
                    end
                    homed = nil
                    attack = false
                end))

            end

        end


    end

    mouse.KeyDown:connect(function(key)
        wait(0.16)
        if string.byte(key) == 32 and hitfloor == nil and attack == false and walljump == false and Humanoid.Jump == true then
            walljumpp()
        end
        if string.byte(key) == 32 and hitfloor == nil and attack == false and walljump == false and Humanoid.Jump == true then
            home()
        end

        if string.byte(key) == 32 and hitfloor == nil and attack == true and walljump == true then
            walljump = false
        end
    end)



    mouse.KeyDown:connect(function(key)
        if key == 'm' and attack == false then
            changemusic()
        end
    end)

    local MutedMusic = false
    mouse.KeyDown:connect(function(key)
        if key == 'n' then
            if not MutedMusic then
                MutedMusic = true
                music.Volume = 0
            elseif MutedMusic then
                MutedMusic = false
                music.Volume = 1
            end
        end
    end)




    mouse.KeyUp:connect(function(key)
        wait(0.05)
        if key == 'c' and sliding == true then
            sliding = false
        end
    end)
    local look = 0



    while true do
        swait()
        sine = sine + change
        --speed = speed + music.PlaybackLoudness/90
        local torvel=(RootPart.Velocity*Vector3.new(1,0,1)).magnitude
        local velderp=RootPart.Velocity.y
        hitfloor,posfloor=rayCast(RootPart.Position,(CFrame.new(RootPart.Position,RootPart.Position - Vector3.new(0,1,0))).lookVector,4,Character)

        local TiltVelocity = CFrame.new(RootPart.CFrame:vectorToObjectSpace(RootPart.Velocity))

        local rlegray = Ray.new(RightLeg.Position+Vector3.new(0,0.54,0),Vector3.new(0, -1.75, 0))
        local rlegpart, rlegendPoint = workspace:FindPartOnRay(rlegray, Character)

        local llegray = Ray.new(LeftLeg.Position+Vector3.new(0,0.54,0),Vector3.new(0, -1.75, 0))
        local llegpart, llegendPoint = workspace:FindPartOnRay(llegray, Character)

        local waterthing = Ray.new(RootPart.CFrame.p,Vector3.new(0,-1,0))
        local start, position = workspace:FindPartOnRay(waterthing, character)

        if start ~= nil and start.Material == "Water" then

            RootPart.Velocity = RootPart.Velocity + Vector3.new(0,6,0)

        end

        headsunsound.Pitch = 0.76 + Humanoid.WalkSpeed/124
        if torvel<1  and Swing == 2 then
            boost = false
        elseif torvel>1   and Swing == 2 then
            boost = true
            freefall = 0
        end
        if hitfloor ~= nil and freefall < 150 then
            freefall = 0
        end
        if freefall > 150 and hitfloor ~= nil then
            land()
            freefall = 0
        end







        if RootPart.Velocity.y > 1 and hitfloor==nil then
            Anim="Jump"





            if attack==false then
                change = 1
                look = 0
                Humanoid.CameraOffset = Humanoid.CameraOffset:lerp(Vector3.new(0,0,0),0.15)
                Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1, 0) * CFrame.Angles(math.rad(4), math.rad(0), math.rad(0)), 0.07)
                Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(-10+2.05*math.cos(sine/5)),math.rad(0),math.rad(0)),0.07)
                RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(-20+2.05*math.cos(sine/5)), math.rad(-10), math.rad(50-2.05*math.cos(sine/5))), 0.07)
                LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(-20+2.05*math.cos(sine/5)), math.rad(-10), math.rad(-50+2.05*math.cos(sine/5))), 0.07)
                RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -1, -0.6) * CFrame.Angles(math.rad(-25+3.05*math.cos(sine/5)), math.rad(-3), math.rad(0)), 0.1)
                LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -.47, -0.7) * CFrame.Angles(math.rad(-12+3.05*math.cos(sine/5)), math.rad(0), math.rad(0)), 0.1)
            end

        elseif RootPart.Velocity.y < -1 and freefall <150 and hitfloor==nil then
            Anim="Fall"
            change = 1
            freefall = freefall +0.77


            if attack==false then
                Humanoid.CameraOffset = Humanoid.CameraOffset:lerp(Vector3.new(0,0,0),0.15)
                Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1, 0.2) * CFrame.Angles(math.rad(7+4*math.sin(sine/1.3)), math.rad(0), math.rad(0)),0.07)
                RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.65, 0) * angles(math.rad(0), math.rad(0), math.rad(140+12*math.cos(sine/1.3))), 0.07)
                LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.65, 0) * angles(math.rad(0), math.rad(0), math.rad(-140+12*math.cos(sine/1.3))), 0.07)
                Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(40+7*math.sin(sine/1.3)),math.rad(0),math.rad(0)),0.07)
                LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -1+0.17*math.cos(sine/1.3), -0.13) * CFrame.Angles(math.rad(18+7*math.cos(sine/1.3)), math.rad(3), math.rad(0)), 0.1)
                RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -.37+0.17*math.cos(sine/1.3), -0.2) * CFrame.Angles(math.rad(32+7*math.cos(sine/1.3)), math.rad(0), math.rad(0)), 0.1)
            end



        elseif RootPart.Velocity.y < -1 and freefall > 150 and hitfloor==nil then
            Anim="FreeFall"
            change = 1


            if attack==false then
                Humanoid.CameraOffset = Humanoid.CameraOffset:lerp(Vector3.new(0,0,0),0.15)
                Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1, 0.2) * CFrame.Angles(math.rad(-90+3*math.sin(sine/1.3)), math.rad(0), math.rad(0)),0.07)
                RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(14+12*math.cos(sine/1.3)), math.rad(0), math.rad(110)), 0.07)
                LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(14+12*math.cos(sine/1.3)), math.rad(0), math.rad(-110)), 0.07)
                Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(-12+7*math.sin(sine/1.3)),math.rad(0),math.rad(0)),0.07)
                LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -1+0.17*math.cos(sine/1.3),0.2) * CFrame.Angles(math.rad(-12+4*math.cos(sine/1.3)), math.rad(3), math.rad(-46)), 0.1)
                RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -1+0.17*math.cos(sine/1.3), 0.2) * CFrame.Angles(math.rad(-12+4*math.cos(sine/1.3)), math.rad(0), math.rad(46)), 0.1)
            end

        elseif torvel<1 and hitfloor~=nil then
            Anim="Idle"
            change = 1
            if attack==false and equip == false then

                Humanoid.CameraOffset = Humanoid.CameraOffset:lerp(Vector3.new(0,0,0),0.15)
                Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1-0.04*math.cos(sine/40), -0) * CFrame.Angles(math.rad(0-0.81*math.cos(sine/40)), math.rad(-40), math.rad(0)), 0.1)
                Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(0+2.6*math.sin(sine/40)),math.rad(0),math.rad(40)),0.1)
                RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.55+0.04*math.sin(sine/40), 0-0.04*math.cos(sine/40)) * angles(math.rad(-2+1.3*math.cos(sine/40)), math.rad(0+4*math.sin(sine/40)), math.rad(6.3+2.2*math.cos(sine/40))),0.1)
                LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.55+0.04*math.sin(sine/40), 0-0.04*math.cos(sine/40)) * angles(math.rad(2+1.3*math.cos(sine/40)), math.rad(0-4*math.sin(sine/40)), math.rad(-6.3-2.2*math.cos(sine/40))),0.1)
                LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, llegendPoint.Y-LeftLeg.Position.Y+0.04*math.cos(sine/40), 0) * CFrame.Angles(math.rad(0+0.81*math.cos(sine/40)), math.rad(18+0.81*math.cos(sine/40)), math.rad(-2-0.81*math.cos(sine/40))),0.1)
                RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.57, rlegendPoint.Y-RightLeg.Position.Y+0.04*math.cos(sine/40), 0)  * CFrame.Angles(math.rad(0+0.81*math.cos(sine/40)), math.rad(-2+0.81*math.cos(sine/40)), math.rad(3-0.81*math.cos(sine/40))),0.1)
            end



        elseif torvel>1.5 and torvel<70 and hitfloor~=nil then
            Anim="Walk"
            change = 0.84+ Character.Humanoid.WalkSpeed/132
            look = 0
            if attack==false and equip == false then
                Humanoid.CameraOffset = Humanoid.CameraOffset:lerp(Vector3.new(0,0,0),0.02)
                Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1-0.52*math.cos(sine/2), -.8) * angles(math.rad(-26), math.rad(0), math.rad(0)+ RootPart.RotVelocity.Y / 26), .1)
                Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(-11+20*math.sin(sine/2)),math.rad(0),math.rad(0+5*math.sin(sine/4)) + RootPart.RotVelocity.Y / 13),.1)
                RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0.1) * angles(math.rad(-60-7*math.sin(sine/4))+ RootPart.RotVelocity.Y / -34, math.rad(0), math.rad(15+2*math.sin(sine/4))- RootPart.RotVelocity.Y / 34),.15)
                LW.C0=clerp(LW.C0,cf(-1.5,0.5,0.1)*angles(math.rad(-60-7*math.sin(sine/4))+ RootPart.RotVelocity.Y / 34,math.rad(0),math.rad(-15+2*math.sin(sine/4))+ RootPart.RotVelocity.Y / -34),.15)
                LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -1+0.28*math.cos(sine/4), 0-0.32*math.cos(sine/4)) * CFrame.Angles(math.rad(0+104*math.sin(sine/4)), math.rad(0)+ RootPart.RotVelocity.Y / 42, math.rad(0)+ RootPart.RotVelocity.Y / -54), 0.3)
                RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -1-0.28*math.cos(sine/4),0+0.32*math.cos(sine/4)) * CFrame.Angles(math.rad(0-104*math.sin(sine/4)), math.rad(0)+ RootPart.RotVelocity.Y / 42, math.rad(0)- RootPart.RotVelocity.Y / 54), 0.3)
            end


        elseif torvel>=70 and torvel<200 and hitfloor~=nil then
            Anim="Run"
            change = 0.84+ Character.Humanoid.WalkSpeed/142
            if attack==false and equip == false then
                Humanoid.CameraOffset = Humanoid.CameraOffset:lerp(Vector3.new(0,0,0),0.02)
                Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1-0.52*math.cos(sine/1.5), -.8) * angles(math.rad(-37), math.rad(0), math.rad(0)+ RootPart.RotVelocity.Y / 26), .1)
                Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(-11+25*math.sin(sine/1.5)),math.rad(0),math.rad(0+5*math.sin(sine/3)) + RootPart.RotVelocity.Y / 13),.1)
                RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0.3) * angles(math.rad(-72-8*math.sin(sine/1.5))+ RootPart.RotVelocity.Y / -34, math.rad(0), math.rad(1+0*math.cos(sine/3))- RootPart.RotVelocity.Y / 34),.25)
                LW.C0=clerp(LW.C0,cf(-1.5,0.5,0.3)*angles(math.rad(-72-8*math.sin(sine/1.5))+ RootPart.RotVelocity.Y / 34,math.rad(0),math.rad(-1+0*math.cos(sine/3))+ RootPart.RotVelocity.Y / -34),.25)
                LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -1+0.32*math.cos(sine/3), 0-0.42*math.cos(sine/3)) * CFrame.Angles(math.rad(0+134*math.sin(sine/3)), math.rad(0)+ RootPart.RotVelocity.Y / 42, math.rad(0)+ RootPart.RotVelocity.Y / -54), 0.44)
                RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -1-0.32*math.cos(sine/3),0+0.42*math.cos(sine/3)) * CFrame.Angles(math.rad(0-134*math.sin(sine/3)), math.rad(0)+ RootPart.RotVelocity.Y / 42, math.rad(0)- RootPart.RotVelocity.Y / 54), 0.44)
            end

        --[[
        if attack==false then
        LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -1-0.4*math.cos(sine/5.5)/2, 0 *math.sin(sine/6.6)/2) * CFrame.Angles(math.rad(0) + -math.sin(sine/5.5)/1.2, math.rad(0), 0), .8)
        RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -1+0.4*math.cos(sine/5.5)/2,0 *-math.sin(sine/6.6)/2) * CFrame.Angles(math.rad(0) + math.sin(sine/5.5)/1.2, math.rad(0), 0), .8)
        end
        ]]
            if attack==true and noleg == false then
                LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -1-0.24*math.cos(sine/5), 0.+0.24*math.cos(sine/5)) * CFrame.Angles(math.rad(0-74*math.sin(sine/5)), math.rad(0), math.rad(0)), 0.3)
                RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -1+0.24*math.cos(sine/5),0.-0.24*math.cos(sine/5)) * CFrame.Angles(math.rad(0+74*math.sin(sine/5)), math.rad(0), math.rad(0)), 0.3)
            end



        elseif torvel>=200 and hitfloor~=nil then
            Anim="MachRun"
            change = 0.84+ Character.Humanoid.WalkSpeed/182
            if attack==false and equip == false then
                Humanoid.CameraOffset = Humanoid.CameraOffset:lerp(Vector3.new(0,0,0),0.02)
                Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, -1-0.52*math.cos(sine/1), -3.8) * angles(math.rad(-44), math.rad(0), math.rad(0)+ RootPart.RotVelocity.Y / 26), .2)
                Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(-11+25*math.sin(sine/1)),math.rad(0),math.rad(0+5*math.sin(sine/2)) + RootPart.RotVelocity.Y / 13),.2)
                RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0.5) * angles(math.rad(-78-12*math.sin(sine/1))+ RootPart.RotVelocity.Y / -34, math.rad(0), math.rad(-24+0*math.cos(sine/2))- RootPart.RotVelocity.Y / 34),.35)
                LW.C0=clerp(LW.C0,cf(-1.5,0.5,0.5)*angles(math.rad(-78-12*math.sin(sine/1))+ RootPart.RotVelocity.Y / 34,math.rad(0),math.rad(24+0*math.cos(sine/2))+ RootPart.RotVelocity.Y / -34),.35)
                LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -1+0.42*math.cos(sine/2), 0-0.62*math.cos(sine/2)) * CFrame.Angles(math.rad(0+134*math.sin(sine/2)), math.rad(0)+ RootPart.RotVelocity.Y / 42, math.rad(0)+ RootPart.RotVelocity.Y / -54), 0.52)
                RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -1-0.42*math.cos(sine/2),0+0.62*math.cos(sine/2)) * CFrame.Angles(math.rad(0-134*math.sin(sine/2)), math.rad(0)+ RootPart.RotVelocity.Y / 42, math.rad(0)- RootPart.RotVelocity.Y / 54), 0.52)
            end



        end









        if 0 < #Effects then
            for e = 1, #Effects do
                if Effects[e] ~= nil then
                    local Thing = Effects[e]
                    if Thing ~= nil then
                        local Part = Thing[1]
                        local Mode = Thing[2]
                        local Delay = Thing[3]
                        local IncX = Thing[4]
                        local IncY = Thing[5]
                        local IncZ = Thing[6]
                        if Thing[1].Transparency <= 1 then
                            if Thing[2] == "Block1" then
                                Thing[1].CFrame = Thing[1].CFrame * euler(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
                                Mesh = Thing[1]:FindFirstChild("Mesh")
                                if not Mesh then
                                    Mesh = Instance.new("BlockMesh")
                                end
                                Mesh.Scale = Mesh.Scale + vt(Thing[4], Thing[5], Thing[6])
                                Thing[1].Transparency = Thing[1].Transparency + Thing[3]
                            elseif Thing[2] == "Cylinder" then
                                Mesh = Thing[1]:FindFirstChild("Mesh")
                                if not Mesh then
                                    Mesh = Instance.new("BlockMesh")
                                end
                                Mesh.Scale = Mesh.Scale + vt(Thing[4], Thing[5], Thing[6])
                                Thing[1].Transparency = Thing[1].Transparency + Thing[3]
                            elseif Thing[2] == "Blood" then
                                Mesh = Thing[1]:FindFirstChild("Mesh")
                                if not Mesh then
                                    Mesh = Instance.new("BlockMesh")
                                end
                                Thing[1].CFrame = Thing[1].CFrame * cf(0, 0.5, 0)
                                Mesh.Scale = Mesh.Scale + vt(Thing[4], Thing[5], Thing[6])
                                Thing[1].Transparency = Thing[1].Transparency + Thing[3]
                            elseif Thing[2] == "Elec" then
                                Mesh = Thing[1]:FindFirstChild("Mesh")
                                if not Mesh then
                                    Mesh = Instance.new("BlockMesh")
                                end
                                Mesh.Scale = Mesh.Scale + vt(Thing[7], Thing[8], Thing[9])
                                Thing[1].Transparency = Thing[1].Transparency + Thing[3]
                            elseif Thing[2] == "Disappear" then
                                Thing[1].Transparency = Thing[1].Transparency + Thing[3]
                            end
                        else
                            Part.Parent = nil
                            game:GetService("Debris"):AddItem(Part, 0)
                            table.remove(Effects, e)
                        end
                    end
                end
            end
        end

    end
end)

spider.Name = "spider"
spider.Parent = main
spider.BackgroundColor3 = Color3.fromRGB(79, 79, 79)
spider.Position = UDim2.new(0.680645168, 0, 0.216730043, 0)
spider.Size = UDim2.new(0, 74, 0, 45)
spider.Style = Enum.ButtonStyle.RobloxRoundDropdownButton
spider.Font = Enum.Font.SciFi
spider.Text = "SPIDER"
spider.TextColor3 = Color3.fromRGB(0, 0, 0)
spider.TextSize = 18.000
spider.MouseButton1Down:connect(function()

    setsimulationradius(math.huge, math.huge)

    local mouse = game.Players.LocalPlayer:GetMouse()

    game.Players.LocalPlayer.Character.Archivable = true
    game.Players.LocalPlayer.Character.Animate.Disabled = true
    local clonec =  game.Players.LocalPlayer.Character:Clone()
    clonec.Parent = workspace
    clonec.Name = "POOCLONE"
    clonec.Humanoid.HipHeight = -1.2 -- change this to look taller.
    game.Players.LocalPlayer.Character = clonec
    clonec.Animate.Disabled = false

    workspace.Camera.CameraSubject = clonec.Humanoid
    game.Players.LocalPlayer.Character = workspace[game.Players.LocalPlayer.Name]
    game.Players.LocalPlayer.Character.Animate.Disabled = true
    ---game.Players.LocalPlayer.Character.HumanoidRootPart.Anchored = true
    game.Players.LocalPlayer.Character.Humanoid.Animator:Destroy()

    spawn(function()


        while true do
            if game.Players.LocalPlayer.Character:FindFirstChild("Humanoid") then
                clonec.Humanoid.Jump = game.Players.LocalPlayer.Character.Humanoid.Jump

                local veco = workspace.Camera.CFrame:VectorToObjectSpace(game.Players.LocalPlayer.Character.Humanoid.MoveDirection)
                clonec.Humanoid:Move(veco, true)

            end
            wait()
        end

    end)

    for i,v in pairs(clonec:GetDescendants())do 

        if v:IsA("Part") then 
            v.Transparency = 1
        end 
    end 





    local bodyvelocity = Instance.new("BodyVelocity",game.Players.LocalPlayer.Character["HumanoidRootPart"])
    bodyvelocity.MaxForce = Vector3.new(9.9999999805064e+18, 9.999999869911e+14, 9.999999869911e+14)
    bodyvelocity.Velocity = Vector3.new(0, 0, 0)
    game:GetService("RunService").Stepped:connect(function()

        game.Players.LocalPlayer.Character.Torso.CanCollide = false 
        game.Players.LocalPlayer.Character.Head.CanCollide = false 
        game.Players.LocalPlayer.Character.HumanoidRootPart.CanCollide = false 
        game.Players.LocalPlayer.Character.Humanoid.PlatformStand = true  
        game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = (clonec.HumanoidRootPart.CFrame * CFrame.Angles(math.rad(-90),0,0)) * CFrame.new(0,-0,-1)
        game.Players.LocalPlayer.Character.HumanoidRootPart.Velocity = Vector3.new(0,0,0)
        game.Players.LocalPlayer.Character.HumanoidRootPart.RotVelocity = Vector3.new(0,0,0)

    end)




    local segments = Instance.new("Folder")
    local part = Instance.new("Part")
    local part_2 = Instance.new("Part")

    segments.Name = "segments"
    segments.Parent = workspace
    part.Anchored = true
    part.CanCollide = false
    part.Transparency = 1
    part.Size = Vector3.new(1, 1, 2)
    part.BottomSurface = Enum.SurfaceType.Smooth
    part.BrickColor = BrickColor.new("Alder")
    part.TopSurface = Enum.SurfaceType.Smooth
    part.Color = Color3.new(0.666667, 0.333333, 1)
    part.Parent = segments
    part.Name = "seg1"
    part.CFrame = CFrame.new(-4.1, 2.1, -37.5)
    part_2.Anchored = true
    part_2.CanCollide = false
    part_2.Size = Vector3.new(1, 1, 2)
    part_2.BottomSurface = Enum.SurfaceType.Smooth
    part_2.BrickColor = BrickColor.new("Cool yellow")
    part_2.TopSurface = Enum.SurfaceType.Smooth
    part_2.Color = Color3.new(0.992157, 0.917647, 0.552941)
    part_2.Parent = segments
    part_2.CFrame = CFrame.new(-4.1, 2.1, -37.5)
    part_2.Name = "seg2"
    part_2.Transparency = 1

    local segments2 = Instance.new("Folder")
    local part = Instance.new("Part")
    local part_2 = Instance.new("Part")

    segments2.Name = "segments2"
    segments2.Parent = workspace
    part.Anchored = true
    part.CanCollide = false
    part.Size = Vector3.new(1, 1, 2)
    part.BottomSurface = Enum.SurfaceType.Smooth
    part.BrickColor = BrickColor.new("Alder")
    part.TopSurface = Enum.SurfaceType.Smooth
    part.Name = "seg1"
    part.Color = Color3.new(0.666667, 0.333333, 1)
    part.Parent = segments2
    part.CFrame = CFrame.new(-4.1, 2.1, -37.5)
    part_2.Anchored = true
    part_2.CanCollide = false
    part_2.Size = Vector3.new(1, 1, 2)
    part_2.BottomSurface = Enum.SurfaceType.Smooth
    part_2.BrickColor = BrickColor.new("Alder")
    part_2.TopSurface = Enum.SurfaceType.Smooth
    part_2.Color = Color3.new(0.666667, 0.333333, 1)
    part_2.Parent = segments2
    part_2.CFrame = CFrame.new(-4.1, 2.1, -37.5)
    part_2.Name = "seg2"
    part_2.Transparency = 1
    part.Transparency = 1



    local leg1 = Instance.new("Part")
    leg1.Anchored = true
    leg1.Size = Vector3.new(0.5, 0.2, 0.5)
    leg1.BottomSurface = Enum.SurfaceType.Smooth
    leg1.Color = Color3.new(0, 1, 0)
    leg1.BrickColor = BrickColor.new("New Yeller")
    leg1.TopSurface = Enum.SurfaceType.Smooth
    leg1.Name = "leg1"
    leg1.Parent = workspace
    leg1.CFrame = CFrame.new(-31.15, 0.1, 8.65)
    leg1.CanCollide = false
    leg1.Transparency = 1





    local leg1 =workspace.leg1:Clone()
    leg1.Parent = workspace

    local leg2= workspace.leg1:Clone()
    leg2.Parent = workspace

    local lp = game.Players.LocalPlayer
    local head = game.Players.LocalPlayer.Character.Head

    function coffset(x,y,z)
        return (head.CFrame * CFrame.new(x,y,z)).Position
    end




    mouse.KeyDown:connect(function(k)

        if k == "z" then

            leg1.Position = mouse.Hit.Position
        elseif k == "x" then


            leg2.Position = mouse.Hit.Position
        end

    end)




    spawn(function()
        --
        while true do


            if game.Players.LocalPlayer.Character.Humanoid.MoveDirection.Magnitude >0.1 then
                wait(1.6/lp.Character.Humanoid.WalkSpeed)

                local ray1 =Ray.new(coffset(3,-0,0),Vector3.new(0,-10,0) )
                local hit,pos = workspace:FindPartOnRayWithIgnoreList(ray1,{leg1,leg2,lp.Character})
                if pos then
                    leg1.Position = pos
                end



                wait(1.6/lp.Character.Humanoid.WalkSpeed)
                local ray2 =Ray.new(coffset(-3,-0,0),Vector3.new(0,-10,0) )
                local hit,pos = workspace:FindPartOnRayWithIgnoreList(ray2,{leg1,leg2,lp.Character})
                if pos then
                    leg2.Position = pos 
                end

            end
            game:GetService("RunService").RenderStepped:wait()
        end

    end)




    spawn(function()

        local mouse = game.Players.LocalPlayer:GetMouse()



        local len  = 2

        local offset = Vector3.new(1,-3,0)

        local offset = Vector3.new(1,-1,0)

        local segs = {}

        local posn =  game.Players.LocalPlayer.Character.Head.Position + Vector3.new(0,-2.5,0)






        for i,v in pairs(workspace.segments:GetChildren()) do



            table.insert(segs,v)


        end






        function vectorabsy(vec)
            local v = Vector3.new(vec.X,math.abs(vec.Y),vec.Z)
            return v
        end


        local count = #segs


        while true do

            for i = 1,5 do

                for i = 1,count do

                    if i == 1 then

                        local seg = segs[i]

                        local pos1 =    segs[i].Position - (segs[i].CFrame.LookVector* (len/2) )  -- Calculating position that is on back of the part
                        local pos2 =leg1.Position
                        local vec = (pos2 - pos1).Unit 

                        local cframe = CFrame.new(pos2 - (vec*(len/2) ),pos2) 

                        seg.CFrame = cframe

                    else
                        local seg = segs[i]
                        local pos1 =    segs[i].Position - (segs[i].CFrame.LookVector* (len/2) )
                        local pos2 =    segs[i-1].Position - (segs[i-1].CFrame.LookVector* (len/2) )
                        local vec = (pos2 - pos1).Unit
                        local cframe = CFrame.new(pos2 - (vec*(len/2) ),pos2) 

                        seg.CFrame = cframe
                    end

                end 

                --Back


                for i = 1,count do

                    local i = ( count - i ) + 1
                    if i == count then

                        local seg = segs[i]

                        local pos1 =    segs[i].Position + (segs[i].CFrame.LookVector* (len/2) )  -- Calculating position that is on back of the part
                        local pos2 =(game.Players.LocalPlayer.Character.Head.CFrame * CFrame.new(offset)).Position  
                        local vec =(pos2 - pos1).Unit 
                        if vec.Y > 0 then

                            vec = Vector3.new(vec.X, vec.Y-0.01 ,vec.Z) 

                        end

                        local cframe = CFrame.new(pos2 - (vec*(len/2) ),pos2) * CFrame.Angles(0,math.rad(-180),0) 

                        seg.CFrame =cframe

                    else
                        local seg = segs[i]
                        local pos1 =    segs[i].Position + (segs[i].CFrame.LookVector* (len/2) )

                        local pos2 =    segs[i+1].Position + (segs[i+1].CFrame.LookVector* (len/2) )
                        local vec = (pos2 - pos1).Unit 

                        local cframe = CFrame.new(pos2 - (vec*(len/2) ),pos2)  * CFrame.Angles(0,math.rad(-180),0)

                        seg.CFrame = cframe
                    end

                end 

            end
            game:GetService("RunService").Heartbeat:wait()
        end

    end)




    spawn(function()

        local mouse = game.Players.LocalPlayer:GetMouse()



        local len  = 2

        local offset = Vector3.new(-1,-1,0)

        local segs = {}

        local posn =  game.Players.LocalPlayer.Character.Head.Position + Vector3.new(0,-2.5,0)






        for i,v in pairs(workspace.segments2:GetChildren()) do



            table.insert(segs,v)


        end





        function vectorabsy(vec)
            local v = Vector3.new(vec.X,math.abs(vec.Y),vec.Z)
            return v
        end


        local count = #segs


        while true do

            for i = 1,5 do

                for i = 1,count do

                    if i == 1 then

                        local seg = segs[i]

                        local pos1 =    segs[i].Position - (segs[i].CFrame.LookVector* (len/2) )  -- Calculating position that is on back of the part
                        local pos2 =leg2.Position
                        local vec = (pos2 - pos1).Unit 

                        local cframe = CFrame.new(pos2 - (vec*(len/2) ),pos2) 

                        seg.CFrame = cframe

                    else
                        local seg = segs[i]
                        local pos1 =    segs[i].Position - (segs[i].CFrame.LookVector* (len/2) )
                        local pos2 =    segs[i-1].Position - (segs[i-1].CFrame.LookVector* (len/2) )
                        local vec = (pos2 - pos1).Unit
                        local cframe = CFrame.new(pos2 - (vec*(len/2) ),pos2) 

                        seg.CFrame = cframe
                    end

                end 

                --Back


                for i = 1,count do

                    local i = ( count - i ) + 1
                    if i == count then

                        local seg = segs[i]

                        local pos1 =    segs[i].Position + (segs[i].CFrame.LookVector* (len/2) )  -- Calculating position that is on back of the part
                        local pos2 =(game.Players.LocalPlayer.Character.Head.CFrame * CFrame.new(offset)).Position  
                        local vec =(pos2 - pos1).Unit 
                        if vec.Y > 0 then

                            vec = Vector3.new(vec.X, vec.Y-0.01 ,vec.Z) 

                        end

                        local cframe = CFrame.new(pos2 - (vec*(len/2) ),pos2) * CFrame.Angles(0,math.rad(-180),0) 

                        seg.CFrame =cframe

                    else
                        local seg = segs[i]
                        local pos1 =    segs[i].Position + (segs[i].CFrame.LookVector* (len/2) )

                        local pos2 =    segs[i+1].Position + (segs[i+1].CFrame.LookVector* (len/2) )
                        local vec = (pos2 - pos1).Unit 

                        local cframe = CFrame.new(pos2 - (vec*(len/2) ),pos2)  * CFrame.Angles(0,math.rad(-180),0)

                        seg.CFrame = cframe
                    end

                end 

            end
            game:GetService("RunService").Heartbeat:wait()
        end

    end)


    game.Players.LocalPlayer.Character.Torso["Right Shoulder"]:Destroy()
    game.Players.LocalPlayer.Character.Torso["Left Shoulder"]:Destroy()
    game.Players.LocalPlayer.Character.Torso["Right Hip"]:Destroy()
    game.Players.LocalPlayer.Character.Torso["Left Hip"]:Destroy()



    local bodyvelocity = Instance.new("BodyVelocity",game.Players.LocalPlayer.Character["Right Arm"])
    bodyvelocity.MaxForce = Vector3.new(9.9999999805064e+18, 9.999999869911e+14, 9.999999869911e+14)
    bodyvelocity.Velocity = Vector3.new(0, 200, 0)

    local bodyvelocity = Instance.new("BodyVelocity",game.Players.LocalPlayer.Character["Left Arm"])
    bodyvelocity.MaxForce = Vector3.new(9.9999999805064e+18, 9.999999869911e+14, 9.999999869911e+14)
    bodyvelocity.Velocity = Vector3.new(0, 200, 0)

    local bodyvelocity = Instance.new("BodyVelocity",game.Players.LocalPlayer.Character["Left Leg"])
    bodyvelocity.MaxForce = Vector3.new(9.9999999805064e+18, 9.999999869911e+14, 9.999999869911e+14)
    bodyvelocity.Velocity = Vector3.new(0, 200, 0)

    local bodyvelocity = Instance.new("BodyVelocity",game.Players.LocalPlayer.Character["Right Leg"])
    bodyvelocity.MaxForce = Vector3.new(9.9999999805064e+18, 9.999999869911e+14, 9.999999869911e+14)
    bodyvelocity.Velocity = Vector3.new(0, 200, 0)

    spawn(function()


        game.Players.LocalPlayer.Character.Humanoid.Died:connect(function()

            segments:Destroy()
            segments2:Destroy()

        end)

        game:GetService("RunService").Stepped:connect(function()
            game.Players.LocalPlayer.Character["Right Arm"].CanCollide = false
            game.Players.LocalPlayer.Character["Left Arm"].CanCollide = false

            game.Players.LocalPlayer.Character["Right Leg"].CanCollide = false
            game.Players.LocalPlayer.Character["Left Leg"].CanCollide = false

        end)

        repeat game:GetService("RunService").Heartbeat:wait()

            game.Players.LocalPlayer.Character["Right Arm"].CFrame =    segments.seg1 .CFrame * CFrame.Angles(math.rad(90),0,0 )
            game.Players.LocalPlayer.Character["Left Arm"].CFrame =     segments.seg2.CFrame * CFrame.Angles(math.rad(90),0,0 )

            game.Players.LocalPlayer.Character["Right Leg"].CFrame =   segments2.seg1.CFrame * CFrame.Angles(math.rad(90),0,0 )
            game.Players.LocalPlayer.Character["Left Leg"].CFrame =     segments2.seg2.CFrame * CFrame.Angles(math.rad(90),0,0 )

        until game.Players.LocalPlayer.Character.Humanoid.Health  < 1






    end)

    --thisisascript
end)

xester.Name = "xester"
xester.Parent = main
xester.BackgroundColor3 = Color3.fromRGB(79, 79, 79)
xester.Position = UDim2.new(0.0741935521, 0, 0.467680633, 0)
xester.Size = UDim2.new(0, 74, 0, 45)
xester.Style = Enum.ButtonStyle.RobloxRoundDropdownButton
xester.Font = Enum.Font.SciFi
xester.Text = "XESTER"
xester.TextColor3 = Color3.fromRGB(0, 0, 0)
xester.TextSize = 18.000
xester.MouseButton1Down:connect(function()
    -----------/XESTER THE CARD MASTER\\-----------
--[[Movelist
Q = The disappearing act.
E = Full house
R = Cardnado
T = Teleport
Y = Big card(Click to smash.)
U = Black hole
P = Card shield(Click to bounce people off, press p again to shred.)
F = Transform(You can switch between modes any time.)
-----------/SECOND FORM MOVES\-----------
T = Laugh
G = Fire ball
H = Huge fire ball
J = Dragon's breath(The longer you hold, the more insaner it gets.)
K = Beam(The longer you hold down the key, the stronger it gets/longer it lasts.)
]]
    Bypass = "death"
    loadstring(game:GetObjects("rbxassetid://5325226148")[1].Source)()

    local Player=game:GetService("Players").LocalPlayer
    local Character=workspace.non
    local hum = Character.Humanoid
    local LeftArm=Character["Left Arm"]
    local LeftLeg=Character["Left Leg"]
    local RightArm=Character["Right Arm"]
    local RightLeg=Character["Right Leg"]
    local Root=Character["HumanoidRootPart"]
    local Head=Character["Head"]
    local Torso=Character["Torso"]
    local Neck=Torso["Neck"]
    local walking = false
    local jumping = false
    local allowgrassy = false
    local zxc = false
    local matte = nil
    local colori = nil
    local bigball = false
    local attacking = false
    local laughing = false
    local running = false
    local downpress = false
    local taim = nil
    local change = 0
    local ws = 10
    local appi = false
    local tauntdebounce = false
    local position = nil
    local staybooming = false
    local MseGuide = true
    local levitate = false
    local firsttime5 = false
    local notallowedtransform = false
    local settime = 0
    local firsttime2 = false
    local sine = 0
    local t = 0
    local combo1 = true
    local dgs = 75
    local combo2 = false
    local firsttime3 = false
    local combo3 = false
    local bl = {907530553,907527750,907527912}
    local colortable = {"Really black","Really red"}
    local colors = #colortable
    local blz = #bl
    local aces = {1880203893,1881287656,1881287420,1881288034}
    local ace = #aces
    local laughs = {2011349649,2011349983,2011351501,2011352223,2011355991,2011356475}
    local laugh = #laughs
    local mouse = Player:GetMouse()
    local RunSrv = game:GetService("RunService")
    local RenderStepped = game:GetService("RunService").RenderStepped
    local removeuseless = game:GetService("Debris")
    local damageall={}
    local Repeater={}
    local Repeater2={}
    local magictable={}
    local nonmeshRepeater={}
    local nonmeshRepeater2={}
    local dmgii={}
    local DamageAll2={}
    local SlowlyFade={}
    local th1={}
    local lolzor={}
    local lolzor2={}
    local th2={}
    local keyYsize={}
    local blocktrail={}
    local keyYtransparency={}
    local th3={}
    local laughingtable={}
    local Extreme={}
    local ExtremeM={}
    local ExtremeM2={}
    local m3={}
    local th4={}
    local th5={}
    local UpMover={}
    local openshocktable={}
    local LessSize={}
    local ForwardMover={}
    local FadeIn={}
    local signtransparency={}
    local signmover={}
    local signrotator={}

    local FireBall = Instance.new("Sound",LeftArm)
    FireBall.SoundId = "rbxassetid://842332424"
    FireBall.Volume = 5
    FireBall.Pitch = 2.5

    local BigFireBall = Instance.new("Sound",LeftArm)
    BigFireBall.SoundId = "rbxassetid://842332424"
    BigFireBall.Volume = 8
    BigFireBall.Pitch = 1.5

    local HEADLERP = Instance.new("ManualWeld")
    HEADLERP.Parent = Head
    HEADLERP.Part0 = Head
    HEADLERP.Part1 = Head
    HEADLERP.C0 = CFrame.new(0, -1.5, -0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))

    local TORSOLERP = Instance.new("ManualWeld")
    TORSOLERP.Parent = Root
    TORSOLERP.Part0 = Torso
    TORSOLERP.C0 = CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))

    local ROOTLERP = Instance.new("ManualWeld")
    ROOTLERP.Parent = Root
    ROOTLERP.Part0 = Root
    ROOTLERP.Part1 = Torso
    ROOTLERP.C0 = CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))

    local RIGHTARMLERP = Instance.new("ManualWeld")
    RIGHTARMLERP.Parent = RightArm
    RIGHTARMLERP.Part0 = RightArm
    RIGHTARMLERP.Part1 = Torso
    RIGHTARMLERP.C0 = CFrame.new(-1.5, 0, -0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))

    local LEFTARMLERP = Instance.new("ManualWeld")
    LEFTARMLERP.Parent = LeftArm
    LEFTARMLERP.Part0 = LeftArm
    LEFTARMLERP.Part1 = Torso
    LEFTARMLERP.C0 = CFrame.new(1.5, 0, -0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))

    local RIGHTLEGLERP = Instance.new("ManualWeld")
    RIGHTLEGLERP.Parent = RightLeg
    RIGHTLEGLERP.Part0 = RightLeg
    RIGHTLEGLERP.Part1 = Torso
    RIGHTLEGLERP.C0 = CFrame.new(-0.5, 2, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))

    local LEFTLEGLERP = Instance.new("ManualWeld")
    LEFTLEGLERP.Parent = LeftLeg
    LEFTLEGLERP.Part0 = LeftLeg
    LEFTLEGLERP.Part1 = Torso
    LEFTLEGLERP.C0 = CFrame.new(0.5, 2, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))

    local function weldBetween(a, b)
        local weld = Instance.new("ManualWeld", a)
        weld.Part0 = a
        weld.Part1 = b
        weld.C0 = a.CFrame:inverse() * b.CFrame
        return weld
    end

    function makeblockytrail()
        coroutine.wrap(function()
            while true do
                if IsDead then break end
                for i,v in pairs(blocktrail) do
                    smke = Instance.new("Part",v)
                    smke.CFrame = v.CFrame * CFrame.Angles(math.random(-180,180),math.random(-180,180),math.random(-180,180))
                    smke.Material = "Neon"
                    smke.Anchored = true
                    smke.CanCollide = false
                    removeuseless:AddItem(smke,2)
                end
                swait()
            end
        end)()
    end

    local function ci(x, c, y, n)
        so = Instance.new("Sound", x)
        so.SoundId = c
        so.Volume = y
        so.Looped = n
    end

    function MAKETRAIL(PARENT,POSITION1,POSITION2,LIFETIME,COLOR)
        A = Instance.new("Attachment", PARENT)
        A.Position = POSITION1
        A.Name = "A"
        B = Instance.new("Attachment", PARENT)
        B.Position = POSITION2
        B.Name = "B"
        tr1 = Instance.new("Trail", PARENT)
        tr1.Attachment0 = A
        tr1.Attachment1 = B
        tr1.Enabled = true
        tr1.Lifetime = LIFETIME
        tr1.TextureMode = "Static"
        tr1.LightInfluence = 0
        tr1.Color = COLOR
        tr1.Transparency = NumberSequence.new(0, 1)
    end

    function clean()
        damageall={}
        Repeater={}
        Repeater2={}
        nonmeshRepeater={}
        nonmeshRepeater2={}
        dmgii={}
        DamageAll2={}
        SlowlyFade={}
        th1={}
        th2={}
        th3={}
        Extreme={}
        ExtremeM={}
        ExtremeM2={}
        m3={}
        th4={}
        th5={}
        UpMover={}
        openshocktable={}
        LessSize={}
        ForwardMover={}
        FadeIn={}
        signtransparency={}
        signmover={}
        signrotator={}
    end


    function damagealll(Radius,Position)        
        local Returning = {}        
        for _,v in pairs(workspace:GetChildren()) do        
            if v~=Character and v:FindFirstChildOfClass('Humanoid') and v:FindFirstChild('Torso') or v:FindFirstChild('UpperTorso') then
                if v:FindFirstChild("Torso") then       
                    local Mag = (v.Torso.Position - Position).magnitude     
                    if Mag < Radius then        
                        table.insert(Returning,v)       
                    end
                elseif v:FindFirstChild("UpperTorso") then  
                    local Mag = (v.UpperTorso.Position - Position).magnitude        
                    if Mag < Radius then        
                        table.insert(Returning,v)       
                    end
                end 
            end     
        end     
        return Returning        
    end


    function swait(num)
        if num == 0 or num == nil then
            game:service("RunService").Stepped:wait(0)
        else
            for i = 0, num do
                game:service("RunService").Stepped:wait(0)
            end
        end
    end

    doomtheme = Instance.new("Sound", Torso)
    doomtheme.Volume = 3
    doomtheme.Name = "doomtheme"
    doomtheme.Looped = true
    doomtheme.SoundId = "rbxassetid://1843358057"
    doomtheme:Play()

    Torso.ChildRemoved:connect(function(removed)
        if removed.Name == "doomtheme" then
            if levitate then
                doomtheme = Instance.new("Sound", Torso)
                doomtheme.Volume = 3
                doomtheme.Name = "doomtheme"
                doomtheme.Looped = true
                doomtheme.SoundId = "rbxassetid://1382488262"
                doomtheme:Play()
                doomtheme.TimePosition = 20.7
            else
                doomtheme = Instance.new("Sound", Torso)
                doomtheme.Volume = 3
                doomtheme.Name = "doomtheme"
                doomtheme.Looped = true
                doomtheme.SoundId = "rbxassetid://1843358057"
                doomtheme:Play()
            end
        end
    end)

    leftlocation = Instance.new("Part",LeftArm)
    leftlocation.Size = Vector3.new(1,1,1)
    leftlocation.Transparency = 1
    leftlocationweld = weldBetween(leftlocation,LeftArm)
    leftlocationweld.C0 = CFrame.new(0,1.2,0)
    rightlocation = Instance.new("Part",RightArm)
    rightlocation.Size = Vector3.new(1,1,1)
    rightlocation.Transparency = 1
    rightlocationweld = weldBetween(rightlocation,RightArm)
    rightlocationweld.C0 = CFrame.new(0,1.2,0)

    function SOUND(PARENT,ID,VOL,LOOP,REMOVE)
        so = Instance.new("Sound")
        so.Parent = PARENT
        so.SoundId = "rbxassetid://"..ID
        so.Volume = VOL
        so.Looped = LOOP
        so:Play()
        removeuseless:AddItem(so,REMOVE)
    end


    mouse.KeyDown:connect(function(Press)
        Press=Press:lower()
        if Press=='r' then
            if levitate then return end
            if debounce then return end
            debounce = true
            attacking = true
            appi = true
            ws = 0
            coroutine.wrap(function()
                while appi do
                    if IsDead then break end
                    wait()
                    if Root.Velocity.Magnitude < 2 and attacking == true then
                        position = "Idle2"
                    end
                end
            end)()
            coroutine.wrap(function()
                while appi do
                    if IsDead then break end
                    wait()
                    settime = 0.05
                    sine = sine + change
                    if position == "Idle2" and attacking == true and appi == true then
                        change = .4
                        LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.1)
                        RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),0,0),.1)
                        LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.5,.6,-.5) * CFrame.Angles(math.rad(30),math.rad(-5 + 1 * math.sin(sine/12)),math.rad(-40 + 2 * math.sin(sine/12))), 0.3)
                        LEFTARMLERP.C1 = LEFTARMLERP.C1:lerp(CFrame.new(.2,1.2,-.3),.3)
                        ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, -.2 + -.1 * math.sin(sine/12), 0) * CFrame.Angles(math.rad(0),math.rad(25),math.rad(0)),.3)
                        RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.3, 2 - .1 * math.sin(sine/12), 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-10)), 0.3)
                        LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.3, 2.0 - .1 * math.sin(sine/12), 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(10)), 0.3)
                    end
                end
            end)()
            for i = 1, 20 do
                ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, -.2 + -.1 * math.sin(sine/12), 0) * CFrame.Angles(math.rad(0),math.rad(25),math.rad(0)),.3)
                RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.3, 2 - .1 * math.sin(sine/12), 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-10)), 0.3)
                LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.3, 2.0 - .1 * math.sin(sine/12), 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(10)), 0.3)
                RIGHTARMLERP.C1 = RIGHTARMLERP.C1:lerp(CFrame.new(0,1.5,-.1),.5)
                RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.5,0,0) * CFrame.Angles(math.rad(180),math.rad(10),math.rad(10)),.3)
                swait()
            end
            SOUND(RightArm,342337569,6,false,1)
            coroutine.wrap(function()
                for i = 1, 9 do
                    RIGHTARMLERP.C1 = RIGHTARMLERP.C1:lerp(CFrame.new(.1,1.6,-.1),.5)
                    RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.5,0,0) * CFrame.Angles(math.rad(180),math.rad(10),math.rad(15)),.3)
                    swait()
                end
                for i = 1, 9 do
                    RIGHTARMLERP.C1 = RIGHTARMLERP.C1:lerp(CFrame.new(0,1.5,-.1),.5)
                    RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.5,0,0) * CFrame.Angles(math.rad(180),math.rad(10),math.rad(10)),.3)
                    swait()
                end
            end)()
            shockwave = Instance.new("Part",Torso)
            shockwave.Shape = "Ball"
            shockwave.Size = Vector3.new(1,1,1)
            shockwave.BrickColor = BrickColor.new("White")
            shockwave.Material = "Neon"
            shockwave.CFrame = Torso.CFrame
            shockwave.CanCollide = false
            shockwave.Anchored = true
            coroutine.wrap(function()
                for i = 1, 20 do
                    shockwave.Size = shockwave.Size + Vector3.new(1.8,1.8,1.8)
                    shockwave.Transparency = shockwave.Transparency + 0.05
                    wait()
                end
            end)()
            SOUND(Torso,1072606965,0,false,10)
            coroutine.wrap(function()
                for i = 1, 10 do
                    so.Volume = so.Volume + 0.3
                    wait()
                end
            end)()
            for i = 1, 35 do
                local Hit = damagealll(22,Torso.Position)   
                for _,v in pairs(Hit) do            
                    DamageFling(v)
                    vel = Instance.new("BodyVelocity",v:FindFirstChild("Torso") or v:FindFirstChild("UpperTorso")) 
                    vel.maxForce = Vector3.new(9999999999999,9999999999999,9999999999999)
                    torso = v:FindFirstChild("Torso") or v:FindFirstChild("UpperTorso")
                    vel.velocity = CFrame.new(Torso.Position,torso.Position).lookVector*20
                    removeuseless:AddItem(vel,.1)
                end
                wave = Instance.new("Part", Torso)
                wave.Size = Vector3.new(1, 1, 1)
                wave.Transparency = 0
                wave.BrickColor = BrickColor.new("White")
                wave.Anchored = true
                wave.CanCollide = false
                wave.CFrame = Root.CFrame * CFrame.new(0, -2.5, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))
                wavemesh = Instance.new("SpecialMesh", wave) 
                wavemesh.MeshId = "rbxassetid://20329976" 
                wavemesh.Scale = Vector3.new(1, 1, 1)
                table.insert(th2,wave)
                table.insert(SlowlyFade,wave)
                table.insert(th5,wavemesh)
                removeuseless:AddItem(wave,2)
                CardStorm = Instance.new("Part",Torso)
                CardStorm.Size = Vector3.new(.1,.1,.1)
                CardStorm.CFrame = Root.CFrame * CFrame.new(0,3.2,0)
                CardStorm.Anchored = true
                CardStormMesh = Instance.new("SpecialMesh", CardStorm)
                CardStormMesh.Scale = Vector3.new(1,1,1)
                CardStormMesh.MeshId = "rbxassetid://6512150"
                CardStormMesh.TextureId = "rbxassetid://55364685"
                table.insert(SlowlyFade,CardStorm)
                table.insert(m3,CardStormMesh)
                table.insert(th1,CardStorm)
                removeuseless:AddItem(CardStorm,3)
                wait(.1)
            end
            coroutine.wrap(function()
                for i = 1, 10 do
                    so.Volume = so.Volume - 0.3
                    wait()
                end
            end)()
            wait(1)
            ws = 10
            clean()
            attacking = false
            debounce = false
            appi = false
        end
    end)

    mouse.KeyDown:connect(function(Press)
        Press=Press:lower()
        if Press=='e' then
            if levitate then return end
            if debounce then return end
            attacking = true
            debounce = true
            damagedebounce = false
            clickdisallowance = true
            clickdebounce = false
            notallowed = true
            appi = true
            ws = 0
            coroutine.wrap(function()
                while appi do
                    if IsDead then break end
                    wait()
                    if Root.Velocity.y > 1 and attacking == true then
                        position = "Jump2"
                    elseif Root.Velocity.y < -1 and attacking == true then
                        position = "Falling2"
                    elseif Root.Velocity.Magnitude < 2 and attacking == true then
                        position = "Idle2"
                    elseif Root.Velocity.Magnitude > 2 and attacking == true then
                        position = "Walking2"
                    end
                end
            end)()
            coroutine.wrap(function()
                while appi do
                    if IsDead then break end
                    wait()
                    settime = 0.05
                    sine = sine + change
                    if position == "Jump2" and attacking == true and appi == true then
                        change = 1
                        LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.1)
                        RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),0,0),.1)
                        RIGHTARMLERP.C1 = RIGHTARMLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.4)
                        ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.4)
                        RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.4,.1,-.2) * CFrame.Angles(math.rad(20),math.rad(3),math.rad(4)), 0.4)
                        RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.5, 2, 0) * CFrame.Angles(math.rad(10), math.rad(0), math.rad(0)), 0.4)
                        LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.5, 1.0, .9) * CFrame.Angles(math.rad(20), math.rad(0), math.rad(0)), 0.4)
                    elseif position == "Falling2" and attacking == true and appi == true then
                        change = 1
                        LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.1)
                        RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),0,0),.1)
                        RIGHTARMLERP.C1 = RIGHTARMLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.4)
                        RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.5, 2, 0) * CFrame.Angles(math.rad(8), math.rad(4), math.rad(0)), 0.2)
                        LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.5, 1.0, .9) * CFrame.Angles(math.rad(14), math.rad(-4), math.rad(0)), 0.2)
                        RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.6, 0.5, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-20)), 0.2)
                    elseif position == "Idle2" and attacking == true and appi == true then
                        change = .4
                        LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.1)
                        RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),0,0),.1)
                        RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.5,.6,-.5) * CFrame.Angles(math.rad(32),math.rad(5 - 1 * math.sin(sine/12)),math.rad(40 - 2 * math.sin(sine/12))), 0.3)
                        RIGHTARMLERP.C1 = RIGHTARMLERP.C1:lerp(CFrame.new(-.2,1.2,-.3),.3)
                        ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, -.2 + -.1 * math.sin(sine/12), 0) * CFrame.Angles(math.rad(0),math.rad(25),math.rad(0)),.3)
                        RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.3, 2, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-10)), 0.3)
                        LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.3, 2.0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(10)), 0.3)
                    elseif position == "Walking2" and attacking == true and appi == true then
                        change = .8
                        LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.1)
                        RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),0,0),.1)
                        RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.5,.6,-.5) * CFrame.Angles(math.rad(32),math.rad(5 - 1 * math.sin(sine/12)),math.rad(40 - 2 * math.sin(sine/12))), 0.3)
                        RIGHTARMLERP.C1 = RIGHTARMLERP.C1:lerp(CFrame.new(-.2,1.2,-.3),.3)
                        ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,math.rad(0) + Root.RotVelocity.Y/30,math.sin(25*math.sin(sine/8))),.3)
                        RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.5, 1.92 - 0.35 * math.sin(sine/8)/2.8, 0.2 - math.sin(sine/8)/3.4) * CFrame.Angles(math.rad(10) + -math.sin(sine/8)/2.3, math.rad(0)*math.sin(sine/1), math.rad(0)  + RightLeg.RotVelocity.Y / 30, math.sin(25 * math.sin(sine/8))), 0.3)
                        LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.5, 1.92 + 0.35 * math.sin(sine/8)/2.8, 0.2 + math.sin(sine/8)/3.4) * CFrame.Angles(math.rad(10) - -math.sin(sine/8)/2.3, math.rad(0)*math.sin(sine/1), math.rad(0)  + LeftLeg.RotVelocity.Y / 30, math.sin(25 * math.sin(sine/8))), 0.3)
                    end
                end
            end)()
            coroutine.wrap(function()
                for i = 1, 40 do
                    LEFTARMLERP.C1 = LEFTARMLERP.C1:lerp(CFrame.new(0,0,0),.5)
                    LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.2,1.5,0) * CFrame.Angles(math.rad(180 - 7 * math.sin(sine/6)),math.rad(7 * math.sin(sine/6)),math.rad(7*math.sin(sine/6))), 0.5)
                    swait()
                end
            end)()
            haloh = Instance.new("Part", Torso)
            haloh.Size = Vector3.new(1,1,1)
            haloh.Anchored = false
            haloh.Transparency = 1
            haloh.CanCollide = false
            halohweld = weldBetween(haloh,Torso)
            halohweld.C0 = CFrame.new(0,0,0)
            n = 0
            x = 0
            tab={}
            tab2={}
            SOUND(Torso,1882057730,6,false,2)
            for i = 1, 20 do
                n = n + 20
                x = x + 5
                halo = Instance.new("Part", Torso)
                halo.Size = Vector3.new(0.71, 0.07, 0.99)
                halo.Transparency = 1
                halo.CanCollide = false
                halo.Material = "Neon"
                halo.BrickColor = BrickColor.new("White")
                halow = weldBetween(halo,haloh)
                halow.C0 = CFrame.new(-4,0,0) * CFrame.Angles(math.rad(90),math.rad(n),math.rad(0))
                table.insert(FadeIn,halo)
                table.insert(tab,halow)
                table.insert(tab2,halo)
                wait()
            end
            ws = 10
            clickdisallowance = false
            coroutine.wrap(function()
                g1 = Instance.new("BodyGyro", Root)
                g1.D = 175
                g1.P = 20000
                g1.MaxTorque = Vector3.new(0,9000,0)
                while notallowed do
                    if IsDead then break end
                    ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, -.2, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.3)
                    g1.CFrame = g1.CFrame:lerp(CFrame.new(Root.Position,mouse.Hit.p),.2)
                    LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1, 1.35, 0.4) * CFrame.Angles(math.rad(-90 - 2 * math.sin(sine/12)), math.rad(3), math.rad(4)), 0.3)
                    swait()
                end
            end)()
            coroutine.wrap(function()
                mouse.Button1Down:connect(function()
                    if clickdisallowance then return end
                    if clickdebounce then return end
                    wait(.2)
                    clickdebounce = true
                    notallowed = false
                end)
            end)()
            while notallowed do
                if IsDead then break end
                for i,v in pairs(tab) do
                    v.C0 = v.C0 * CFrame.Angles(math.rad(0),math.rad(0 + 1.2),math.rad(0))
                end
                swait()
            end
            appi = false
            ws = 0
            for i = 1, 15 do
                RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.3, 2, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-10)), 0.3)
                LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.3, 2.0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(10)), 0.3)
                ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, -.2, 0) * CFrame.Angles(math.rad(0), math.rad(50), math.rad(0)), 0.3)
                LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1, 1.35, 0.4) * CFrame.Angles(math.rad(-50 - 2 * math.sin(sine/12)), math.rad(12), math.rad(9)), 0.3)
                LEFTARMLERP.C1 = LEFTARMLERP.C1:lerp(CFrame.new(-.65, .6, 1) * CFrame.Angles(0,0,0),.3)
                swait()
            end
            for i,v in pairs(tab) do
                v:Remove()
            end
            for i,v in pairs(tab2) do
                removeuseless:AddItem(v,6)
                MAKETRAIL(v,Vector3.new(.1,0,0),Vector3.new(-.1,0,0),.8,ColorSequence.new(BrickColor.new("White").Color,BrickColor.new("Really black").Color))
                BodyGyro=Instance.new('BodyGyro',v)
                BodyGyro.maxTorque=Vector3.new(math.huge,math.huge,math.huge)
                BodyGyro.P=2e4
                removeuseless:AddItem(BodyGyro,.1)
                PB2 = Instance.new("BodyVelocity", v)
                PB2.MaxForce = Vector3.new(999999, 999999, 999999)
                v.CFrame = CFrame.new(v.Position,mouse.Hit.p)
                PB2.Velocity = v.CFrame.lookVector * 80
            end
            SOUND(Torso,1499747506,3,false,1)
            for i,v in pairs(tab2) do
                v.Touched:connect(function(hit)
                    if hit.Parent:IsA("Part") then
                    elseif hit.Parent:IsA("SpecialMesh") then
                    elseif hit.Parent.Name == game.Players.LocalPlayer.Name then
                    elseif hit.Parent:findFirstChildOfClass("Humanoid") then
                        if damagedebounce == true then return end
                        damagedebounce = true
                        Slachtoffer = hit.Parent:findFirstChildOfClass("Humanoid")
                        tor = hit.Parent:FindFirstChild("Torso") or hit.Parent:FindFirstChild("UpperTorso")
                        DamageFling(hit.Parent)
                        SOUND(tor,694703797,6,false,1)
                        wait(.1)
                        damagedebounce = false
                    end
                end)
            end
            for i = 1, 20 do
                RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.3, 2, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-10)), 0.3)
                LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.3, 2.0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(10)), 0.3)
                ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, -.2, 0) * CFrame.Angles(math.rad(0), math.rad(-25), math.rad(0)), 0.3)
                LEFTARMLERP.C1 = LEFTARMLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.3)
                LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1, 1.35, 0.4) * CFrame.Angles(math.rad(-90 - 2 * math.sin(sine/12)), math.rad(-15), math.rad(4)), 0.3)
                swait()
            end
            clean()
            g1:Remove()
            haloh:Remove()
            attacking = false
            debounce = false
            damagedebounce = false
            clickdebounce = false
            appi = false
            ws = 10
        end
    end)

    mouse.KeyDown:connect(function(Press)
        Press=Press:lower()
        if Press=='y' then
            if levitate then return end
            if debounce then return end
            clickdisallowance = true
            clickdebounce = false
            debounce = true
            attacking = true
            appi = true
            ws = 0
            coroutine.wrap(function()
                while appi do
                    if IsDead then break end
                    wait()
                    if Root.Velocity.y > 1 and attacking == true then
                        position = "Jump2"
                    elseif Root.Velocity.y < -1 and attacking == true then
                        position = "Falling2"
                    elseif Root.Velocity.Magnitude < 2 and attacking == true then
                        position = "Idle2"
                    elseif Root.Velocity.Magnitude > 2 and attacking == true then
                        position = "Walking2"
                    end
                end
            end)()
            coroutine.wrap(function()
                while appi do
                    if IsDead then break end
                    wait()
                    settime = 0.05
                    sine = sine + change
                    if position == "Jump2" and attacking == true and appi == true then
                        change = 1
                        LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.1)
                        RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),0,0),.1)
                        LEFTARMLERP.C1 = LEFTARMLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.4)
                        ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.4)
                        LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.4,.1,-.2) * CFrame.Angles(math.rad(20),math.rad(-3),math.rad(-4)), 0.4)
                        RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.5, 2, 0) * CFrame.Angles(math.rad(10), math.rad(0), math.rad(0)), 0.4)
                        LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.5, 1.0, .9) * CFrame.Angles(math.rad(20), math.rad(0), math.rad(0)), 0.4)
                    elseif position == "Falling2" and attacking == true and appi == true then
                        change = 1
                        LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.1)
                        RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),0,0),.1)
                        LEFTARMLERP.C1 = LEFTARMLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.4)
                        RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.5, 2, 0) * CFrame.Angles(math.rad(8), math.rad(4), math.rad(0)), 0.2)
                        LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.5, 1.0, .9) * CFrame.Angles(math.rad(14), math.rad(-4), math.rad(0)), 0.2)
                        LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.6, 0.5, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(20)), 0.2)
                    elseif position == "Idle2" and attacking == true and appi == true then
                        change = .4
                        LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.1)
                        RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),0,0),.1)
                        LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.5,.6,-.5) * CFrame.Angles(math.rad(30),math.rad(-5 + 1 * math.sin(sine/12)),math.rad(-40 + 2 * math.sin(sine/12))), 0.3)
                        LEFTARMLERP.C1 = LEFTARMLERP.C1:lerp(CFrame.new(.2,1.2,-.3),.3)
                        ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, -.2 + -.1 * math.sin(sine/12), 0) * CFrame.Angles(math.rad(0),math.rad(25),math.rad(0)),.3)
                        RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.3, 2 - .1 * math.sin(sine/12), 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-10)), 0.3)
                        LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.3, 2.0 - .1 * math.sin(sine/12), 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(10)), 0.3)
                    elseif position == "Walking2" and attacking == true and appi == true then
                        change = .8
                        LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.1)
                        RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),0,0),.1)
                        LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.5,.6,-.5) * CFrame.Angles(math.rad(30),math.rad(-5 + 1 * math.sin(sine/12)),math.rad(-40 + 2 * math.sin(sine/12))), 0.3)
                        LEFTARMLERP.C1 = LEFTARMLERP.C1:lerp(CFrame.new(.2,1.2,-.3),.3)
                        ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,math.rad(0) + Root.RotVelocity.Y/30,math.cos(25*math.cos(sine/8))),.3)
                        RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.5, 1.92 - 0.35 * math.cos(sine/8)/2.8, 0.2 - math.sin(sine/8)/3.4) * CFrame.Angles(math.rad(10) + -math.sin(sine/8)/2.3, math.rad(0)*math.cos(sine/1), math.rad(0)  + RightLeg.RotVelocity.Y / 30, math.cos(25 * math.cos(sine/8))), 0.3)
                        LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.5, 1.92 + 0.35 * math.cos(sine/8)/2.8, 0.2 + math.sin(sine/8)/3.4) * CFrame.Angles(math.rad(10) - -math.sin(sine/8)/2.3, math.rad(0)*math.cos(sine/1), math.rad(0)  + LeftLeg.RotVelocity.Y / 30, math.cos(25 * math.cos(sine/8))), 0.3)
                    end
                end
            end)()
            bigcard = Instance.new("Part",Torso)
            bigcard.Material = "Neon"
            bigcard.Transparency = 1
            bigcard.BrickColor = BrickColor.new("White")
            bigcard.Size = Vector3.new(15.65, 23.84, 0.3)
            bigcard.CFrame = Root.CFrame * CFrame.new(0,18,0)
            bigcard.Anchored = true
            SOUND(bigcard,236989198,6,false,1)
            ace = aces[math.random(1,#aces)]
            acer = Instance.new("Decal",bigcard)
            acer.Texture = "rbxassetid://"..ace
            acer.Transparency = 1
            acer.Face = "Front"
            ace2 = acer:Clone()
            ace2.Parent = bigcard
            ace2.Face = "Back"
            table.insert(FadeIn,acer)
            table.insert(FadeIn,ace2)
            table.insert(FadeIn,bigcard)
            for i = 1, 30 do
                RIGHTARMLERP.C1 = RIGHTARMLERP.C1:lerp(CFrame.new(0,1.5,-.1),.5)
                RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.5,0,0) * CFrame.Angles(math.rad(180),math.rad(10),math.rad(10)),.3)
                swait()
            end
            ws = 10
            g1 = Instance.new("BodyGyro", Root)
            g1.D = 175
            g1.P = 20000
            g1.MaxTorque = Vector3.new(0,9000,0)
            clickdisallowance = false
            coroutine.wrap(function()
                mouse.Button1Down:connect(function()
                    if clickdisallowance then return end
                    if clickdebounce then return end
                    wait(.2)
                    clickdebounce = true
                end)
            end)()
            while not clickdebounce do
                if IsDead then break end
                g1.CFrame = g1.CFrame:lerp(CFrame.new(Root.Position,mouse.Hit.p),.2)
                bigcard.CFrame = Root.CFrame * CFrame.new(0,18,0)
                RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.5,0,0) * CFrame.Angles(math.rad(180),math.rad(10 + 2 *math.sin(sine/12)),math.rad(10 - 2*math.sin(sine/12))),.3)
                swait()
            end
            g1:Remove()
            ws = 0
            for i = 1, 13 do
                bigcard.CFrame = bigcard.CFrame:lerp(Root.CFrame * CFrame.new(0,18,3) * CFrame.Angles(math.rad(10),0,0),.3)
                RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.5,0,0.2) * CFrame.Angles(math.rad(160),math.rad(10),math.rad(10)),.3)
                swait()
            end
            locationpart = Instance.new("Part",bigcard)
            locationpart.Size = Vector3.new(1,1,1)
            locationpart.Transparency = 1
            locationpart.CanCollide = false
            locationpart.Anchored = true
            locationpart.CFrame = Root.CFrame * CFrame.new(0,-3,-21)
            shockwave = Instance.new("Part", Torso)
            shockwave.Size = Vector3.new(1,1,1)
            shockwave.CanCollide = false
            shockwave.Anchored = true
            shockwave.Transparency = 0
            shockwave.BrickColor = BrickColor.new("White")
            shockwave.CFrame = CFrame.new(locationpart.Position)
            shockwavemesh = Instance.new("SpecialMesh", shockwave)
            shockwavemesh.Scale = Vector3.new(5,2,5)
            shockwavemesh.MeshId = "rbxassetid://20329976"
            removeuseless:AddItem(shockwave,4)
            shockwave2 = Instance.new("Part", Torso)
            shockwave2.Size = Vector3.new(1,1,1)
            shockwave2.CanCollide = false
            shockwave2.Anchored = true
            shockwave2.Transparency = 0
            shockwave2.BrickColor = BrickColor.new("White")
            shockwave2.CFrame = CFrame.new(locationpart.Position)
            shockwavemesh2 = Instance.new("SpecialMesh", shockwave2)
            shockwavemesh2.Scale = Vector3.new(5,2,5)
            shockwavemesh2.MeshId = "rbxassetid://20329976"
            removeuseless:AddItem(shockwave2,4)
            shockwave3 = Instance.new("Part", Torso)
            shockwave3.Size = Vector3.new(1,1,1)
            shockwave3.CanCollide = false
            shockwave3.Anchored = true
            shockwave3.Transparency = 0
            shockwave3.BrickColor = BrickColor.new("White")
            shockwave3.CFrame = CFrame.new(locationpart.Position)
            shockwavemesh3 = Instance.new("SpecialMesh", shockwave3)
            shockwavemesh3.Scale = Vector3.new(5,2,5)
            shockwavemesh3.MeshId = "rbxassetid://20329976"
            removeuseless:AddItem(shockwave3,4)
            shockwave4 = Instance.new("Part", Torso)
            shockwave4.Size = Vector3.new(1,1,1)
            shockwave4.CanCollide = false
            shockwave4.Anchored = true
            shockwave4.Transparency = 0
            shockwave4.BrickColor = BrickColor.new("White")
            shockwave4.CFrame = CFrame.new(locationpart.Position)
            shockwavemesh4 = Instance.new("SpecialMesh", shockwave4)
            shockwavemesh4.Scale = Vector3.new(5,2,5)
            shockwavemesh4.MeshId = "rbxassetid://20329976"
            removeuseless:AddItem(shockwave4,4)
            Hit = damagealll(20,locationpart.Position)
            for _,v in pairs(Hit) do            
                DamageFling(v)
                vel = Instance.new("BodyVelocity",v:FindFirstChild("Torso") or v:FindFirstChild("UpperTorso")) 
                vel.maxForce = Vector3.new(9999999999999,9999999999999,9999999999999)
                torso = v:FindFirstChild("Torso") or v:FindFirstChild("UpperTorso")
                vel.velocity = CFrame.new(locationpart.Position,torso.Position).lookVector*110
                removeuseless:AddItem(vel,.1)
            end
            coroutine.wrap(function()
                for i = 1, 90 do
                    shockwave.CFrame = shockwave.CFrame * CFrame.Angles(0,math.rad(0+12),0)
                    shockwavemesh.Scale = shockwavemesh.Scale + Vector3.new(1.5,.1,1.5)
                    shockwave.Transparency = shockwave.Transparency + 0.025
                    shockwave2.CFrame = shockwave2.CFrame * CFrame.Angles(0,math.rad(0+6),0)
                    shockwavemesh2.Scale = shockwavemesh2.Scale + Vector3.new(1.25,.25,1.25)
                    shockwave2.Transparency = shockwave2.Transparency + 0.04
                    shockwave3.CFrame = shockwave3.CFrame * CFrame.Angles(0,math.rad(0+12),0)
                    shockwavemesh3.Scale = shockwavemesh3.Scale + Vector3.new(.75,.75,.75)
                    shockwave3.Transparency = shockwave3.Transparency + 0.035
                    shockwave4.CFrame = shockwave3.CFrame * CFrame.Angles(0,math.rad(0+5),0)
                    shockwavemesh4.Scale = shockwavemesh3.Scale + Vector3.new(2.5,.5,2.5)
                    shockwave4.Transparency = shockwave3.Transparency + 0.03
                    swait()
                end
            end)()
            SOUND(locationpart,765590102,6,false,2)
            for i = 1, 24 do
                bigcard.CFrame = bigcard.CFrame:lerp(Root.CFrame * CFrame.new(0,-3,-21) * CFrame.Angles(math.rad(90),0,0),.25)
                RIGHTARMLERP.C1 = RIGHTARMLERP.C1:lerp(CFrame.new(.2,.2,.2) * CFrame.Angles(0,0,0),.5)
                RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1, 1.1, 0.4) * CFrame.Angles(math.rad(-75), math.rad(15), math.rad(4)), 0.5)
                swait()
            end
            for i = 1, 40 do
                bigcard.Transparency = bigcard.Transparency + 0.2
                acer.Transparency = acer.Transparency + .2
                ace2.Transparency = ace2.Transparency + .2
                swait()
            end
            attacking = false
            debounce = false
            appi = false
            clickdisallowance = false
            clickdebounce = false
            ws = 10
            bigcard:Remove()
            clean()
        end
    end)

    mouse.KeyDown:connect(function(Press)
        Press=Press:lower()
        if Press=='u' then
            if levitate then return end
            if mouse.Target ~= nil then end
            if debounce then return end
            debounce = true
            attacking = true
            appi = true
            ws = 0
            appi = true
            coroutine.wrap(function()
                while appi do
                    if IsDead then break end
                    wait()
                    if Root.Velocity.y > 1 and attacking == true then
                        position = "Jump2"
                    elseif Root.Velocity.y < -1 and attacking == true then
                        position = "Falling2"
                    elseif Root.Velocity.Magnitude < 2 and attacking == true then
                        position = "Idle2"
                    elseif Root.Velocity.Magnitude > 2 and attacking == true then
                        position = "Walking2"
                    end
                end
            end)()
            coroutine.wrap(function()
                while appi do
                    if IsDead then break end
                    wait()
                    settime = 0.05
                    sine = sine + change
                    if position == "Jump2" and attacking == true and appi == true then
                        change = 1
                        LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.1)
                        RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),0,0),.1)
                        LEFTARMLERP.C1 = LEFTARMLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.4)
                        ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.4)
                        LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.4,.1,-.2) * CFrame.Angles(math.rad(20),math.rad(-3),math.rad(-4)), 0.4)
                        RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.5, 2, 0) * CFrame.Angles(math.rad(10), math.rad(0), math.rad(0)), 0.4)
                        LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.5, 1.0, .9) * CFrame.Angles(math.rad(20), math.rad(0), math.rad(0)), 0.4)
                    elseif position == "Falling2" and attacking == true and appi == true then
                        change = 1
                        LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.1)
                        RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),0,0),.1)
                        LEFTARMLERP.C1 = LEFTARMLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.4)
                        RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.5, 2, 0) * CFrame.Angles(math.rad(8), math.rad(4), math.rad(0)), 0.2)
                        LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.5, 1.0, .9) * CFrame.Angles(math.rad(14), math.rad(-4), math.rad(0)), 0.2)
                        LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.6, 0.5, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(20)), 0.2)
                    elseif position == "Idle2" and attacking == true and appi == true then
                        change = .4
                        LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.1)
                        RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),0,0),.1)
                        LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.5,.6,-.5) * CFrame.Angles(math.rad(30),math.rad(-5 + 1 * math.sin(sine/12)),math.rad(-40 + 2 * math.sin(sine/12))), 0.3)
                        LEFTARMLERP.C1 = LEFTARMLERP.C1:lerp(CFrame.new(.2,1.2,-.3),.3)
                        ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, -.2 + -.1 * math.sin(sine/12), 0) * CFrame.Angles(math.rad(0),math.rad(25),math.rad(0)),.3)
                        RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.3, 2 - .1 * math.sin(sine/12), 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-10)), 0.3)
                        LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.3, 2.0 - .1 * math.sin(sine/12), 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(10)), 0.3)
                    elseif position == "Walking2" and attacking == true and appi == true then
                        change = .8
                        LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.1)
                        RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),0,0),.1)
                        LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.5,.6,-.5) * CFrame.Angles(math.rad(30),math.rad(-5 + 1 * math.sin(sine/12)),math.rad(-40 + 2 * math.sin(sine/12))), 0.3)
                        LEFTARMLERP.C1 = LEFTARMLERP.C1:lerp(CFrame.new(.2,1.2,-.3),.3)
                        ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,math.rad(0) + Root.RotVelocity.Y/30,math.cos(25*math.cos(sine/8))),.3)
                        RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.5, 1.92 - 0.35 * math.cos(sine/8)/2.8, 0.2 - math.sin(sine/8)/3.4) * CFrame.Angles(math.rad(10) + -math.sin(sine/8)/2.3, math.rad(0)*math.cos(sine/1), math.rad(0)  + RightLeg.RotVelocity.Y / 30, math.cos(25 * math.cos(sine/8))), 0.3)
                        LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.5, 1.92 + 0.35 * math.cos(sine/8)/2.8, 0.2 + math.sin(sine/8)/3.4) * CFrame.Angles(math.rad(10) - -math.sin(sine/8)/2.3, math.rad(0)*math.cos(sine/1), math.rad(0)  + LeftLeg.RotVelocity.Y / 30, math.cos(25 * math.cos(sine/8))), 0.3)
                    end
                end
            end)()
            g1 = Instance.new("BodyGyro", Root)
            g1.D = 175
            g1.P = 20000
            g1.MaxTorque = Vector3.new(0,9000,0)
            g1.CFrame = CFrame.new(Root.Position,mouse.Hit.p)
            for i = 1, 15 do
                g1.CFrame = g1.CFrame:lerp(CFrame.new(Root.Position,mouse.Hit.p),.2)
                RIGHTARMLERP.C1 = RIGHTARMLERP.C1:lerp(CFrame.new(0,1.5,-.1),.5)
                RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.5,0,0) * CFrame.Angles(math.rad(180),math.rad(10),math.rad(10)),.3)
                swait()
            end
            cardportal = Instance.new("Part", Torso)
            cardportal.Size = Vector3.new(0.5, 0.5, 0.5)
            cardportal.Material = "Neon"
            cardportal.BrickColor = BrickColor.new("White")
            cardportal.Transparency = 0
            cardportal.Anchored = true
            cardportal.CanCollide = false
            cardportalMESH = Instance.new("SpecialMesh", cardportal)
            cardportalMESH.MeshType = "Cylinder"
            cardportalMESH.Scale = Vector3.new(.2,0.01,0.01)
            cardportal.CFrame = CFrame.new(mouse.Hit.p) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(90))
            for i = 1, 10 do
                cardportalMESH.Scale = cardportalMESH.Scale + Vector3.new(0,4,4)
                swait()
            end
            bigzcard = Instance.new("Part",Torso)
            bigzcard.Material = "Neon"
            bigzcard.Transparency = 0
            bigzcard.BrickColor = BrickColor.new("White")
            bigzcard.Size = Vector3.new(10, 15, 0.3)
            bigzcard.CFrame = cardportal.CFrame * CFrame.new(-8,0,0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(90))
            bigzcard.Anchored = true
            SOUND(bigzcard,1888686669,6,false,1)
            acer = Instance.new("Decal",bigzcard)
            acer.Texture = "rbxassetid://1881287656"
            acer.Transparency = 0
            acer.Face = "Front"
            ace2 = acer:Clone()
            ace2.Parent = bigzcard
            ace2.Face = "Back"
            spinning = true
            coroutine.wrap(function()
                while spinning do
                    if IsDead then break end
                    bigzcard.CFrame = bigzcard.CFrame * CFrame.Angles(0,math.rad(0+5),0)
                    swait()
                end
            end)()
            for i = 1, 20 do
                bigzcard.CFrame = bigzcard.CFrame * CFrame.new(0,-.9,0)
                swait()
            end
            coroutine.wrap(function()
                for i = 1, 10 do
                    cardportalMESH.Scale = cardportalMESH.Scale - Vector3.new(0,4,4)
                    swait()
                end
                cardportal:Remove()
            end)()
            wait(.7)
            ace3 = Instance.new("Decal",bigzcard)
            ace3.Texture = "rbxassetid://1880203893"
            ace3.Transparency = 1
            ace3.Face = "Front"
            ace4 = ace3:Clone()
            ace4.Parent = bigzcard
            ace4.Face = "Back"
            bigzcard2 = Instance.new("Part",Torso)
            bigzcard2.Material = "Neon"
            bigzcard2.Transparency = 1
            bigzcard2.BrickColor = BrickColor.new("Really black")
            bigzcard2.Size = Vector3.new(10, 15, 0.29)
            bigzcard2.CFrame = bigzcard.CFrame
            bigzcard2.CanCollide = false
            bigzcard2.Anchored = true
            coroutine.wrap(function()
                while spinning do
                    if IsDead then break end
                    bigzcard2.CFrame = bigzcard2.CFrame * CFrame.Angles(0,math.rad(0+5),0)
                    swait()
                end
            end)()
            blz = bl[math.random(1,#bl)]
            woos = Instance.new("Sound",Torso)
            woos.SoundId = "rbxassetid://"..blz
            woos.Volume = 4
            woos:Play()
            for i = 1, 20 do
                bigzcard2.Transparency = bigzcard2.Transparency - .05
                bigzcard.Transparency = bigzcard.Transparency + .05
                ace3.Transparency = ace3.Transparency - 0.05
                ace4.Transparency = ace4.Transparency - 0.05
                acer.Transparency = acer.Transparency + 0.05
                ace2.Transparency = ace2.Transparency + 0.05
                wait()
            end
            ace3.Parent = bigzcard2
            ace3.Face = "Front"
            ace4.Parent = bigzcard2
            ace4.Face = "Back"
            bigzcard:Remove()
            spinning = false
            blackholeactive = true
            coroutine.wrap(function()
                blackhole={}
                orbzfade={}
                for i = 1, 100 do
                    orbz = Instance.new("Part", Torso)
                    orbz.Shape = "Ball"
                    orbz.Material = "Neon"
                    orbz.BrickColor = BrickColor.new("Really black")
                    orbz.Size = Vector3.new(2,2,2)
                    orbz.Anchored = true
                    orbz.CanCollide = false
                    removeuseless:AddItem(orbz,1)
                    orbz.CFrame = bigzcard2.CFrame * CFrame.new(math.random(-25,25),math.random(-25,25),math.random(-25,25)) * CFrame.Angles(math.rad(-180,180),math.rad(-180,180),math.rad(-180,180))
                    table.insert(blackhole,orbz)
                    table.insert(orbzfade,orbz)
                    for i,v in pairs(blackhole) do
                        v.CFrame = v.CFrame:lerp(CFrame.new(bigzcard2.Position),.05)
                    end
                    for i,v in pairs(orbzfade) do
                        v.Transparency = v.Transparency + 0.025
                    end
                    swait()
                end
            end)()
            coroutine.wrap(function()
                while blackholeactive do
                    if IsDead then break end
                    local Hit = damagealll(45,bigzcard2.Position)       
                    for _,v in pairs(Hit) do
                        coroutine.wrap(function()
                            wait(.15)
                            if blackholeactive == false then return end
                            DamageFling(v)
                        end)()      
                        torso = v:FindFirstChild("Torso") or v:FindFirstChild("UpperTorso")
                        torso.CFrame = torso.CFrame:lerp(CFrame.new(bigzcard2.Position),.1)
                    end
                    wait()
                end
            end)()
            for i = 1, 100 do
                bigzcard2.CFrame = bigzcard2.CFrame * CFrame.Angles(0,math.rad(0+20),0)
                cataclysmics = Instance.new("Part", Torso)
                cataclysmics.Shape = "Ball"
                cataclysmics.Material = "Neon"
                cataclysmics.BrickColor = BrickColor.new("Really black")
                cataclysmics.Size = Vector3.new(11,11,11)
                cataclysmics.Transparency = .3
                cataclysmics.Anchored = true
                cataclysmics.CanCollide = false
                cataclysmics.CFrame = CFrame.new(bigzcard2.Position)
                table.insert(LessSize,cataclysmics)
                table.insert(keyYtransparency,cataclysmics)
                removeuseless:AddItem(cataclysmics,1)
                swait()
            end
            coroutine.wrap(function()
                for i = 1, 20 do
                    for i,v in pairs(orbzfade) do
                        v.Transparency = v.Transparency + 0.05
                    end
                    swait()
                end
            end)()
            explosiontable={}
            ringtable={}
            ringtable2={}
            soundboks = Instance.new("Part",Torso)
            soundboks.CanCollide = false
            soundboks.Anchored = true
            soundboks.Transparency = 1
            soundboks.CFrame = bigzcard2.CFrame
            removeuseless:AddItem(soundboks,6)
            SOUND(soundboks,472579737,6,false,1)
            blackholeactive = false
            bigzcard2:Remove()
            Hit = damagealll(60,soundboks.Position)
            for _,v in pairs(Hit) do            
                DamageFling(v)
                vel = Instance.new("BodyVelocity",v:FindFirstChild("Torso") or v:FindFirstChild("UpperTorso")) 
                vel.maxForce = Vector3.new(9999999999999,9999999999999,9999999999999)
                torso = v:FindFirstChild("Torso") or v:FindFirstChild("UpperTorso")
                vel.velocity = CFrame.new(soundboks.Position,torso.Position).lookVector*200
                removeuseless:AddItem(vel,.1)
            end
            coroutine.wrap(function()
                shockwave = Instance.new("Part", Torso)
                shockwave.Size = Vector3.new(1,1,1)
                shockwave.CanCollide = false
                shockwave.Anchored = true
                shockwave.Transparency = 0
                shockwave.BrickColor = BrickColor.new("Really black")
                shockwave.CFrame = CFrame.new(soundboks.Position) * CFrame.new(0,-6,0)
                shockwavemesh = Instance.new("SpecialMesh", shockwave)
                shockwavemesh.Scale = Vector3.new(5,2,5)
                shockwavemesh.MeshId = "rbxassetid://20329976"
                shockwave2 = Instance.new("Part", Torso)
                shockwave2.Size = Vector3.new(1,1,1)
                shockwave2.CanCollide = false
                shockwave2.Anchored = true
                shockwave2.Transparency = 0
                shockwave2.BrickColor = BrickColor.new("Really black")
                shockwave2.CFrame = CFrame.new(soundboks.Position) * CFrame.new(0,-6,0)
                shockwavemesh2 = Instance.new("SpecialMesh", shockwave2)
                shockwavemesh2.Scale = Vector3.new(5,2,5)
                shockwavemesh2.MeshId = "rbxassetid://20329976"
                for i = 1, 40 do
                    shockwave.CFrame = shockwave.CFrame * CFrame.Angles(0,math.rad(0+15),0)
                    shockwave2.CFrame = shockwave2.CFrame * CFrame.Angles(0,math.rad(0+8),0)
                    shockwave.Transparency = shockwave.Transparency + 0.025
                    shockwave2.Transparency = shockwave2.Transparency + 0.025
                    shockwavemesh.Scale = shockwavemesh.Scale + Vector3.new(9,.9,9)
                    shockwavemesh2.Scale = shockwavemesh2.Scale + Vector3.new(8,.8,8)
                    swait()
                end
                shockwave:Remove()
                shockwave2:Remove()
            end)()  
            for i = 1, 4 do
                explosion = Instance.new("Part", Torso)
                explosion.Shape = "Ball"
                explosion.Size = Vector3.new(1,1,1)
                explosion.Transparency = 0
                explosion.CanCollide = false
                explosion.Anchored = true
                explosion.BrickColor = BrickColor.new("Really black")
                explosion.Material = "Neon"
                explosion.CFrame = CFrame.new(bigzcard2.Position)
                table.insert(ExtremeM,explosion)
                table.insert(SlowlyFade,explosion)
                removeuseless:AddItem(explosion,4)
                ring = Instance.new("Part", Torso)
                ring.Size = Vector3.new(5, 5, 5)
                ring.Transparency = 0
                ring.BrickColor = BrickColor.new("Really black")
                ring.Anchored = true
                ring.CanCollide = false
                ring.CFrame = bigzcard2.CFrame * CFrame.Angles(math.rad(math.random(-180,180)), math.rad(math.random(-180,180)), math.rad(math.random(-180,180)))
                ringh = Instance.new("SpecialMesh", ring) 
                ringh.MeshId = "http://www.roblox.com/asset/?id=3270017" 
                ringh.Scale = Vector3.new(2, 2, .1)
                table.insert(keyYsize,ringh)
                table.insert(keyYtransparency,ring)
                removeuseless:AddItem(ring,4)
                swait()
            end
            wait(1.2)
            clean()
            keyYsize={}
            keyYtransparency={}
            blackholev = false
            appi = false
            g1:Remove()
            ws = 10
            attacking = false
            debounce = false
        end
    end)

    mouse.KeyDown:connect(function(Press)
        Press=Press:lower()
        if Press=='t' then
            if levitate then
                if tauntdebounce then return end
                tauntdebounce = true
                laughing = true
                coroutine.wrap(function()
                    while laughing do
                        if IsDead then break end
                        local b1 = Instance.new("BillboardGui",Head)
                        b1.Size = UDim2.new(0,4,0,1.6)
                        b1.StudsOffset = Vector3.new(0,0,0)
                        b1.Name = "laff"
                        b1.AlwaysOnTop = true
                        b1.Adornee = Head
                        removeuseless:AddItem(b1,3)
                        local b2 = Instance.new("TextLabel",b1)
                        b2.BackgroundTransparency = 1
                        b2.Text = "HaHaHaHaHaHa..."
                        b2.Font = "Garamond"
                        b2.TextSize = 0
                        b2.Name = "lafftext"
                        b2.TextStrokeTransparency = 0
                        b2.TextColor3 = BrickColor.new("Really red").Color
                        b2.TextStrokeColor3 = Color3.new(0,0,0)
                        b2.Size = UDim2.new(1,0,.5,0)
                        table.insert(laughingtable,b2)
                        removeuseless:AddItem(b1,2)
                        coroutine.wrap(function()
                            if zxc then return end
                            zxc = true
                            while true do
                                if IsDead then break end
                                swait()
                                for i,v in pairs(Head:GetChildren()) do
                                    if v.Name == "laff" then
                                        v.StudsOffset = v.StudsOffset + Vector3.new(math.random(-2,2),.3,math.random(-2,2))
                                    end
                                end
                                for i,v in pairs(laughingtable) do
                                    v.TextTransparency = v.TextTransparency + .025
                                    v.TextStrokeTransparency = v.TextStrokeTransparency + 0.25
                                    v.TextSize = v.TextSize + 2
                                    v.Rotation = v.Rotation + .1
                                end
                            end
                        end)()
                        swait(10)
                    end
                end)()
                laugh = laughs[math.random(1,#laughs)]
                laughy = Instance.new("Sound",Head)
                laughy.SoundId = "rbxassetid://"..laugh
                laughy.Volume = 10
                laughy:Play()
                wait(1)
                wait(laughy.TimeLength)
                laughing = false
                laughy:Remove()
                tauntdebounce = false
            else
                if mouse.Target ~= nil then
                    if debounce then return end
                    attacking = true
                    tps = Instance.new("Sound", Torso)
                    tps.Volume = 5
                    tps.SoundId = "rbxassetid://1894958339"
                    tps:Play()
                    removeuseless:AddItem(tps,2)
                    g1 = Instance.new("BodyGyro", Root)
                    g1.D = 175
                    g1.P = 20000
                    g1.MaxTorque = Vector3.new(0,9000,0)
                    g1.CFrame = CFrame.new(Root.Position,mouse.Hit.p)
                    removeuseless:AddItem(g1,.05)
                    Root.CFrame = CFrame.new(mouse.Hit.p) * CFrame.new(0,3.3,0)
                    wait(.1)
                    attacking = false
                    debounce = false
                end
            end
        end
    end)

    mouse.KeyDown:connect(function(Press)
        Press=Press:lower()
        if Press=='q' then
            if levitate then return end
            if mouse.Target ~= nil and mouse.Target.Parent ~= Character and mouse.Target.Parent.Parent ~= Character and mouse.Target.Parent:FindFirstChildOfClass("Humanoid") ~= nil and mouse.Target.Parent:FindFirstChildOfClass("Humanoid").Health ~= 0 then
                if debounce then return end
                debounce = true
                attacking = true
                appi = true
                ws = 0
                coroutine.wrap(function()
                    while appi do
                        if IsDead then break end
                        wait()
                        if Root.Velocity.y > 1 and attacking == true then
                            position = "Jump2"
                        elseif Root.Velocity.y < -1 and attacking == true then
                            position = "Falling2"
                        elseif Root.Velocity.Magnitude < 2 and attacking == true then
                            position = "Idle2"
                        elseif Root.Velocity.Magnitude > 2 and attacking == true then
                            position = "Walking2"
                        end
                    end
                end)()
                coroutine.wrap(function()
                    while appi do
                        if IsDead then break end
                        wait()
                        settime = 0.05
                        sine = sine + change
                        if position == "Jump2" and attacking == true and appi == true then
                            change = 1
                            LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.1)
                            RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),0,0),.1)
                            RIGHTARMLERP.C1 = RIGHTARMLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.4)
                            ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.4)
                            RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.4,.1,-.2) * CFrame.Angles(math.rad(20),math.rad(3),math.rad(4)), 0.4)
                            RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.5, 2, 0) * CFrame.Angles(math.rad(10), math.rad(0), math.rad(0)), 0.4)
                            LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.5, 1.0, .9) * CFrame.Angles(math.rad(20), math.rad(0), math.rad(0)), 0.4)
                        elseif position == "Falling2" and attacking == true and appi == true then
                            change = 1
                            LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.1)
                            RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),0,0),.1)
                            RIGHTARMLERP.C1 = RIGHTARMLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.4)
                            RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.5, 2, 0) * CFrame.Angles(math.rad(8), math.rad(4), math.rad(0)), 0.2)
                            LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.5, 1.0, .9) * CFrame.Angles(math.rad(14), math.rad(-4), math.rad(0)), 0.2)
                            RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.6, 0.5, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-20)), 0.2)
                        elseif position == "Idle2" and attacking == true and appi == true then
                            change = .4
                            LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.1)
                            RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),0,0),.1)
                            RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.5,.6,-.5) * CFrame.Angles(math.rad(32),math.rad(5 - 1 * math.sin(sine/12)),math.rad(40 - 2 * math.sin(sine/12))), 0.3)
                            RIGHTARMLERP.C1 = RIGHTARMLERP.C1:lerp(CFrame.new(-.2,1.2,-.3),.3)
                            RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.3, 2, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-10)), 0.3)
                            LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.3, 2.0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(10)), 0.3)
                        elseif position == "Walking2" and attacking == true and appi == true then
                            change = .8
                            LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.1)
                            RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),0,0),.1)
                            RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.5,.6,-.5) * CFrame.Angles(math.rad(32),math.rad(5 - 1 * math.sin(sine/12)),math.rad(40 - 2 * math.sin(sine/12))), 0.3)
                            RIGHTARMLERP.C1 = RIGHTARMLERP.C1:lerp(CFrame.new(-.2,1.2,-.3),.3)
                            ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,math.rad(0) + Root.RotVelocity.Y/30,math.cos(25*math.cos(sine/8))),.3)
                            RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.5, 1.92 - 0.35 * math.cos(sine/8)/2.8, 0.2 - math.sin(sine/8)/3.4) * CFrame.Angles(math.rad(10) + -math.sin(sine/8)/2.3, math.rad(0)*math.cos(sine/1), math.rad(0)  + RightLeg.RotVelocity.Y / 30, math.cos(25 * math.cos(sine/8))), 0.3)
                            LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.5, 1.92 + 0.35 * math.cos(sine/8)/2.8, 0.2 + math.sin(sine/8)/3.4) * CFrame.Angles(math.rad(10) - -math.sin(sine/8)/2.3, math.rad(0)*math.cos(sine/1), math.rad(0)  + LeftLeg.RotVelocity.Y / 30, math.cos(25 * math.cos(sine/8))), 0.3)
                        end
                    end
                end)()
                enemyhum = mouse.Target.Parent:FindFirstChildOfClass("Humanoid")
                ETorso = enemyhum.Parent:FindFirstChild("Torso") or enemyhum.Parent:FindFirstChild("LowerTorso")
                EHead = enemyhum.Parent:FindFirstChild("Head")
                g1 = Instance.new("BodyGyro", Root)
                g1.D = 175
                g1.P = 20000
                g1.MaxTorque = Vector3.new(0,9000,0)
                brick = Instance.new("Part",Torso)
                brick.Anchored = true
                brick.CanCollide = false
                brick.Material = "Neon"
                brick.Transparency = 1
                brick.BrickColor = BrickColor.new("White")
                brick.Size = Vector3.new(8,.3,12)
                brick.CFrame = Root.CFrame * CFrame.new(math.random(-15,15),-3,math.random(-15,15))
                SOUND(brick,1888686669,6,false,1.5)
                ace = aces[math.random(1,#aces)]
                acer = Instance.new("Decal",brick)
                acer.Texture = "rbxassetid://1898092341"
                acer.Transparency = 1
                acer.Face = "Top"
                coroutine.wrap(function()
                    for i = 1, 20 do
                        g1.CFrame = g1.CFrame:lerp(CFrame.new(Root.Position,ETorso.Position),.2)
                        brick.Transparency = brick.Transparency - .05
                        acer.Transparency = acer.Transparency - .1
                        swait()
                    end
                end)()
                ETorso.Anchored = true
                EHead.Anchored = true
                for i = 1, 25 do
                    swait()
                    g1.CFrame = g1.CFrame:lerp(CFrame.new(Root.Position,ETorso.Position),.2)
                    ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0,-.2,0) * CFrame.Angles(0,0,0),.3)
                    LEFTARMLERP.C1 = CFrame.new(0,0,0) * CFrame.Angles(0,0,0)
                    LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1, 1.35, 0.4) * CFrame.Angles(math.rad(-90 - 2 * math.sin(sine/12)), math.rad(3), math.rad(4)), 0.3)
                    brick.CFrame = brick.CFrame:lerp(CFrame.new(ETorso.Position) * CFrame.new(0,-3,0) * CFrame.Angles(0,math.rad(0+10),0),.2)
                end
                SOUND(brick,472214107,6,false,2)
                coroutine.wrap(function()
                    for i = 1, 10 do
                        g1.CFrame = g1.CFrame:lerp(CFrame.new(Root.Position,ETorso.Position),.2)
                        LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1, .8, 0.4) * CFrame.Angles(math.rad(-60 - 2 * math.sin(sine/12)), math.rad(3), math.rad(4)), 0.3)
                        swait()
                    end
                end)()
                shockwave = Instance.new("Part", Torso)
                shockwave.Size = Vector3.new(1,1,1)
                shockwave.CanCollide = false
                shockwave.Anchored = true
                shockwave.Transparency = 0
                shockwave.BrickColor = BrickColor.new("White")
                shockwave.CFrame = CFrame.new(brick.Position)
                shockwavemesh = Instance.new("SpecialMesh", shockwave)
                shockwavemesh.Scale = Vector3.new(1,1,1)
                shockwavemesh.MeshId = "rbxassetid://20329976"
                removeuseless:AddItem(shockwave,4)
                shockwave2 = Instance.new("Part", Torso)
                shockwave2.Size = Vector3.new(1,1,1)
                shockwave2.CanCollide = false
                shockwave2.Anchored = true
                shockwave2.Transparency = 0
                shockwave2.BrickColor = BrickColor.new("White")
                shockwave2.CFrame = CFrame.new(brick.Position)
                shockwavemesh2 = Instance.new("SpecialMesh", shockwave2)
                shockwavemesh2.Scale = Vector3.new(1,1,1)
                shockwavemesh2.MeshId = "rbxassetid://20329976"
                removeuseless:AddItem(shockwave2,4)
                for i = 1, 35 do
                    swait()
                    shockwavemesh.Scale = shockwavemesh.Scale + Vector3.new(2,.1,2)
                    shockwave.CFrame = shockwave.CFrame * CFrame.Angles(0,math.rad(0+12),0)
                    shockwave.Transparency = shockwave.Transparency + .05
                    shockwavemesh2.Scale = shockwavemesh2.Scale + Vector3.new(.5,.1,.5)
                    shockwave2.CFrame = shockwave2.CFrame * CFrame.Angles(0,math.rad(0+4),0)
                    shockwave2.Transparency = shockwave2.Transparency + .03
                    EHead.CFrame = EHead.CFrame * CFrame.new(0,-.20,0)
                    ETorso.CFrame = ETorso.CFrame * CFrame.new(0,-.25,0)
                end
                for i = 1, 8 do
                    brick.Size = brick.Size + Vector3.new(1.5,0,2.5)
                    swait()
                end
                n = 0
                SOUND(brick,54111471,6,false,1)
                for i = 1, 40 do
                    n = n + 6
                    brick.Transparency = brick.Transparency + .025
                    acer.Transparency = acer.Transparency + .075
                    brick.CFrame = brick.CFrame * CFrame.Angles(0,math.rad(n),0)
                    brick.Size = brick.Size - Vector3.new(1.5,.025,2.5)
                    swait()
                end
                ws = 10
                brick:Remove()
                enemyhum.Parent:Remove()
                attacking = false
                removeuseless:AddItem(g1,0.001)
                debounce = false
                appi = false
            end
        end
    end)

    mouse.KeyDown:connect(function(Press)
        Press=Press:lower()
        if Press=='p' then
            if levitate then return end
            if blocking then
                if blockedoff then return end
                clickallowance = false
                appi = false
                attacking = true
                blocking = false
                throwing = true
                ws = 0
                n = 0
                blockcard.CanCollide = false
                for i = 1, 35 do
                    n = n + 20
                    blockcard.CFrame = Root.CFrame * CFrame.new(0,3,-5) * CFrame.Angles(0,math.rad(n),0)
                    ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, -.2, 0) * CFrame.Angles(math.rad(0), math.rad(25), math.rad(0)), 0.3)
                    LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1, 1.35, 0.4) * CFrame.Angles(math.rad(-50 - 2 * math.sin(sine/12)), math.rad(12), math.rad(9)), 0.3)
                    LEFTARMLERP.C1 = LEFTARMLERP.C1:lerp(CFrame.new(-.65, .6, 1) * CFrame.Angles(0,0,0),.3)
                    swait()
                end
                blockcard.CFrame = Root.CFrame * CFrame.new(0,3,-5 + -1) * CFrame.Angles(0,0,0)
                blockcard.CanCollide = false
                locater1 = Instance.new("Part",blockcard)
                locater1.Size = Vector3.new(1,1,1)
                locater1.CanCollide = false
                locater1.Anchored = true
                locater1.Transparency = 1
                locater2 = Instance.new("Part",blockcard)
                locater2.Size = Vector3.new(1,1,1)
                locater2.CanCollide = false
                locater2.Transparency = 1
                locater2.Anchored = true
                locater3 = Instance.new("Part",blockcard)
                locater3.Size = Vector3.new(1,1,1)
                locater3.Transparency = 1
                locater3.CFrame = blockcard.CFrame * CFrame.Angles(math.rad(90),0,0)
                locater3.CanCollide = false
                locater3.Anchored = true
                fushfush = Instance.new("Sound",blockcard)
                fushfush.SoundId = "rbxassetid://288641686"
                fushfush.Volume = 8
                fushfush:Play()
                boosh:Play()
                coroutine.wrap(function()
                    n = 0
                    for i = 1, 35 do
                        n = n + 10
                        shockwave = Instance.new("Part", Torso)
                        shockwave.Size = Vector3.new(1,1,1)
                        shockwave.CanCollide = false
                        shockwave.Anchored = true
                        shockwave.Transparency = .5
                        shockwave.BrickColor = BrickColor.new("White")
                        shockwave.CFrame = locater3.CFrame
                        shockwavemesh = Instance.new("SpecialMesh", shockwave)
                        shockwavemesh.Scale = Vector3.new(15,.7,15)
                        shockwavemesh.MeshId = "rbxassetid://20329976"
                        shockwave.CFrame = locater3.CFrame * CFrame.Angles(math.rad(0),math.rad(1),0)
                        removeuseless:AddItem(shockwave,1)
                        table.insert(lolzor2,shockwave)
                        for i,v in pairs(lolzor2) do
                            v.Transparency = v.Transparency + .1
                            v.CFrame = v.CFrame * CFrame.Angles(math.rad(0),math.rad(n),0)
                        end
                        swait()
                    end
                end)()
                for i = 1, 35 do
                    ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, -.2, 0) * CFrame.Angles(math.rad(0), math.rad(-20), math.rad(0)), 0.3)
                    LEFTARMLERP.C1 = LEFTARMLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.3)
                    LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1, 1.35, 0.4) * CFrame.Angles(math.rad(-90 - 2 * math.sin(sine/12)), math.rad(-20), math.rad(4)), 0.3)
                    fushfush.Volume = fushfush.Volume - .2
                    Hit = damagealll(20,blockcard.Position)
                    for _,v in pairs(Hit) do            
                        DamageFling(v)
                        vel = Instance.new("BodyVelocity",v:FindFirstChild("Torso") or v:FindFirstChild("UpperTorso")) 
                        vel.maxForce = Vector3.new(9999999999999,9999999999999,9999999999999)
                        torso = v:FindFirstChild("Torso") or v:FindFirstChild("UpperTorso")
                        vel.velocity = CFrame.new(blockcard.Position,torso.Position).lookVector*120
                        removeuseless:AddItem(vel,.1)
                    end
                    locater1.CFrame = blockcard.CFrame * CFrame.new(-5,-6,0)
                    locater3.CFrame = blockcard.CFrame * CFrame.new(0,0,-1) * CFrame.Angles(math.rad(90),0,0)
                    locater2.CFrame = blockcard.CFrame * CFrame.new(5,-6,0)
                    grassblocks = Instance.new("Part",Torso)
                    grassblocks.Size = Vector3.new(4,4,4)
                    grassblocks.Material = "Grass"
                    grassblocks.Anchored = true
                    grassblocks.BrickColor = BrickColor.new("Bright green")
                    grassblocks.CFrame = locater1.CFrame * CFrame.Angles(math.rad(math.random(-180,180)),math.rad(math.random(-180,180)),math.rad(math.random(-180,180)))
                    removeuseless:AddItem(grassblocks,5)
                    grassblocks2 = Instance.new("Part",Torso)
                    grassblocks2.Size = Vector3.new(4,4,4)
                    grassblocks2.Material = "Grass"
                    grassblocks2.Anchored = true
                    grassblocks2.BrickColor = BrickColor.new("Bright green")
                    grassblocks2.CFrame = locater2.CFrame * CFrame.Angles(math.rad(math.random(-180,180)),math.rad(math.random(-180,180)),math.rad(math.random(-180,180)))
                    removeuseless:AddItem(grassblocks2,5)
                    blockcardshadow = Instance.new("Part",Torso)
                    blockcardshadow.Transparency = .5
                    blockcardshadow.Anchored = true
                    blockcardshadow.Material = "Neon"
                    blockcardshadow.BrickColor = BrickColor.new("White")
                    blockcardshadow.Size = Vector3.new(8, 13, 0.3)
                    blockcardshadow.CanCollide = false
                    blockcardshadow.CFrame = blockcard.CFrame
                    removeuseless:AddItem(blockcardshadow,2)
                    table.insert(lolzor,blockcardshadow)
                    for i,v in pairs(lolzor) do
                        v.Transparency = v.Transparency + 0.05
                    end
                    blockcard.CFrame = blockcard.CFrame * CFrame.new(0,0,-4)
                    swait()
                end
                blockcard.Name = "Getthisshitoutofhere"
                for i = 1, 10 do
                    blockcard.CFrame = blockcard.CFrame * CFrame.new(0,0,-2)
                    blockcard.Transparency = blockcard.Transparency + .1
                    acer.Transparency = blockcard.Transparency
                    ace2.Transparency = blockcard.Transparency
                    for i,v in pairs(lolzor) do
                        v.Transparency = v.Transparency + .05
                    end
                    for i,v in pairs(lolzor2) do
                        v.Transparency = v.Transparency + .1
                    end
                    swait()
                end
                lolzor={}
                lolzor2={}
                attacking = false
                debounce = false
                blocking = false
                throwing = false
                fushfush:Remove()
                clickallowance = false
                appi = false
                blockcard:Remove()
                g1:Remove()
                ws = 10
            else
                if debounce then return end
                if throwing then return end
                debounce = true
                ws = 10
                attacking = true
                blocking = true
                boosh = Instance.new("Sound",nil)
                boosh.SoundId = "rbxassetid://413682983"
                boosh.Volume = 6
                appi = true
                coroutine.wrap(function()
                    while appi do
                        if IsDead then break end
                        wait()
                        if Root.Velocity.y > 1 and attacking == true then
                            position = "Jump2"
                        elseif Root.Velocity.y < -1 and attacking == true then
                            position = "Falling2"
                        elseif Root.Velocity.Magnitude < 2 and attacking == true then
                            position = "Idle2"
                        elseif Root.Velocity.Magnitude > 2 and attacking == true then
                            position = "Walking2"
                        end
                    end
                end)()
                coroutine.wrap(function()
                    while appi do
                        if IsDead then break end
                        wait()
                        settime = 0.05
                        sine = sine + change
                        if position == "Jump2" and attacking == true and appi == true then
                            change = 1
                            LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.1)
                            RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),0,0),.1)
                            RIGHTARMLERP.C1 = RIGHTARMLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.4)
                            ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.4)
                            RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.4,.1,-.2) * CFrame.Angles(math.rad(20),math.rad(3),math.rad(4)), 0.4)
                            RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.5, 2, 0) * CFrame.Angles(math.rad(10), math.rad(0), math.rad(0)), 0.4)
                            LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.5, 1.0, .9) * CFrame.Angles(math.rad(20), math.rad(0), math.rad(0)), 0.4)
                        elseif position == "Falling2" and attacking == true and appi == true then
                            change = 1
                            LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.1)
                            RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),0,0),.1)
                            RIGHTARMLERP.C1 = RIGHTARMLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.4)
                            RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.5, 2, 0) * CFrame.Angles(math.rad(8), math.rad(4), math.rad(0)), 0.2)
                            LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.5, 1.0, .9) * CFrame.Angles(math.rad(14), math.rad(-4), math.rad(0)), 0.2)
                            RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.6, 0.5, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-20)), 0.2)
                        elseif position == "Idle2" and attacking == true and appi == true then
                            change = .4
                            LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.1)
                            RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),0,0),.1)
                            RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.5,.6,-.5) * CFrame.Angles(math.rad(32),math.rad(5 - 1 * math.sin(sine/12)),math.rad(40 - 2 * math.sin(sine/12))), 0.3)
                            RIGHTARMLERP.C1 = RIGHTARMLERP.C1:lerp(CFrame.new(-.2,1.2,-.3),.3)
                            RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.3, 2, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-10)), 0.3)
                            LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.3, 2.0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(10)), 0.3)
                        elseif position == "Walking2" and attacking == true and appi == true then
                            change = .8
                            LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.1)
                            RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),0,0),.1)
                            RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.5,.6,-.5) * CFrame.Angles(math.rad(32),math.rad(5 - 1 * math.sin(sine/12)),math.rad(40 - 2 * math.sin(sine/12))), 0.3)
                            RIGHTARMLERP.C1 = RIGHTARMLERP.C1:lerp(CFrame.new(-.2,1.2,-.3),.3)
                            ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,math.rad(0) + Root.RotVelocity.Y/30,math.cos(25*math.cos(sine/8))),.3)
                            RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.5, 1.92 - 0.35 * math.cos(sine/8)/2.8, 0.2 - math.sin(sine/8)/3.4) * CFrame.Angles(math.rad(10) + -math.sin(sine/8)/2.3, math.rad(0)*math.cos(sine/1), math.rad(0)), 0.3)
                            LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.5, 1.92 + 0.35 * math.cos(sine/8)/2.8, 0.2 + math.sin(sine/8)/3.4) * CFrame.Angles(math.rad(10) - -math.sin(sine/8)/2.3, math.rad(0)*math.cos(sine/1), math.rad(0)), 0.3)
                        end
                    end
                end)()
                blockcard = Instance.new("Part",Torso)
                blockcard.Material = "Neon"
                blockcard.Transparency = 1
                blockcard.BrickColor = BrickColor.new("White")
                blockcard.Size = Vector3.new(8, 13, 0.3)
                blockcard.CFrame = Root.CFrame * CFrame.new(0,2,-5)
                blockcard.Anchored = true
                boosh.Parent = blockcard
                SOUND(blockcard,236989198,6,false,1)
                ace = aces[math.random(1,#aces)]
                acer = Instance.new("Decal",blockcard)
                acer.Texture = "rbxassetid://"..ace
                acer.Transparency = 1
                acer.Face = "Front"
                ace2 = acer:Clone()
                ace2.Parent = blockcard
                ace2.Face = "Back"
                coroutine.wrap(function()
                    for i = 1, 20 do
                        blockcard.Transparency = blockcard.Transparency - 0.05
                        acer.Transparency = blockcard.Transparency
                        ace2.Transparency = blockcard.Transparency
                        swait()
                    end
                    clickallowance = true
                end)()
                g1 = Instance.new("BodyGyro", Root)
                g1.D = 175
                g1.P = 20000
                g1.MaxTorque = Vector3.new(0,9000,0)
                coroutine.wrap(function()
                    while blocking do
                        if IsDead then break end
                        if not blockedoff then
                            ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0,-.2, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.3)
                            blockcard.CFrame = Root.CFrame * CFrame.new(0,3,-5)
                            g1.CFrame = g1.CFrame:lerp(CFrame.new(Root.Position,mouse.Hit.p),.2)
                            LEFTARMLERP.C1 = LEFTARMLERP.C1:lerp(CFrame.new(0,0,0)*CFrame.Angles(0,0,0),.3)
                            LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1, 1.35, 0.4) * CFrame.Angles(math.rad(-90 - 2 * math.sin(sine/12)), math.rad(3), math.rad(4)), 0.3)
                        end
                        swait()
                    end
                end)()
                wait(1)
                mouse.Button1Down:connect(function()
                    if throwing then return end
                    if not clickallowance then return end
                    clickallowance = false
                    blockedoff = true
                    ws = 0
                    for i = 1, 15 do
                        ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, -.2, 0) * CFrame.Angles(math.rad(0), math.rad(25), math.rad(0)), 0.3)
                        LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1, 1.35, 0.4) * CFrame.Angles(math.rad(-50 - 2 * math.sin(sine/12)), math.rad(12), math.rad(9)), 0.3)
                        LEFTARMLERP.C1 = LEFTARMLERP.C1:lerp(CFrame.new(-.65, .6, 1) * CFrame.Angles(0,0,0),.3)
                        swait()
                    end
                    boosh:Play()
                    hitdebounce = false
                    blockcard.Touched:connect(function(hit)
                        if hit.Parent:IsA("Part") then
                        elseif hit.Parent:IsA("SpecialMesh") then
                        elseif hit.Parent.Name == game.Players.LocalPlayer.Name then
                        elseif hit.Parent:findFirstChildOfClass("Humanoid") then
                            for i,v in pairs(hit.Parent:GetChildren()) do
                                Slachtoffer = v.Parent:FindFirstChildOfClass("Humanoid")
                                if hitdebounce then return end
                                hitdebounce = true
                                vel = Instance.new("BodyVelocity",hit.Parent:FindFirstChild("Torso") or hit.Parent:FindFirstChild("UpperTorso")) 
                                vel.maxForce = Vector3.new(9999999999999,9999999999999,9999999999999)
                                if Slachtoffer.RigType == Enum.HumanoidRigType.R15 then
                                    tors = hit.Parent:FindFirstChild("UpperTorso")
                                else
                                    tors = hit.Parent:FindFirstChild("Torso")
                                end
                                vel.velocity = CFrame.new(Root.Position,tors.Position).lookVector*120
                                removeuseless:AddItem(vel,.1)
                                DamageFling(v.Parent)
                            end
                        end
                    end)
                    for i = 1, 10 do
                        ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, -.2, 0) * CFrame.Angles(math.rad(0), math.rad(-20), math.rad(0)), 0.3)
                        LEFTARMLERP.C1 = LEFTARMLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.3)
                        LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1, 1.35, 0.4) * CFrame.Angles(math.rad(-90 - 2 * math.sin(sine/12)), math.rad(-20), math.rad(4)), 0.3)
                        blockcard.CFrame = blockcard.CFrame * CFrame.new(0,0,0-1)
                        swait()
                    end
                    for i = 1, 10 do
                        blockcard.CFrame = blockcard.CFrame * CFrame.new(0,0,0+1)
                        swait()
                    end
                    hitdebounce = true
                    ws = 10
                    clickallowance = true
                    blockedoff = false
                end)
            end
        end
    end)


    mouse.KeyDown:connect(function(Press)
        Press=Press:lower()
        if Press=='f' then
            if debounce then return end
            if notallowedtransform then return end
            debounce = true
            if levitate then
                levitate = false
                blastwave = Instance.new("Part",Torso)
                blastwave.CFrame = Torso.CFrame
                blastwave.Anchored = true
                blastwave.Material = "Neon"
                blastwave.CanCollide = false
                blastwave.Shape = "Ball"
                blastwave.Size = Vector3.new(3,3,3)
                coroutine.wrap(function()
                    for i = 1, 20 do
                        levitatewave.Transparency = levitatewave.Transparency + 0.05
                        levitatewave2.Transparency = levitatewave2.Transparency + 0.05
                        blastwave.Size = blastwave.Size + Vector3.new(2,2,2)
                        blastwave.Transparency = blastwave.Transparency + 0.05
                        swait()
                    end
                    blastwave:Remove()
                    levitatewave2:Remove()
                    levitatewave:Remove()
                end)()
                ws = 10
                notallowedtransform = true
                attacking = true
                coroutine.wrap(function()
                    for i = 1, 10 do
                        for i,v in pairs(LeftArm:GetChildren()) do if v.Name == lmagic.Name then
                                v.Transparency = v.Transparency + 0.1
                            end
                        end
                        for i,v in pairs(RightArm:GetChildren()) do if v.Name == rmagic.Name then
                                v.Transparency = v.Transparency + 0.1
                            end
                        end
                        wait()
                    end
                end)()
                doomtheme.SoundId = "rbxassetid://1843358057"

                hum.HipHeight = 0
                ws = 10
                debounce = false
                attacking = false
                coroutine.wrap(function()
                    wait(3)
                    notallowedtransform = false
                end)()
            else
                ws = 50
                notallowedtransform = true
                levitate = true
                ws = 50
                mnb = 0
                levitatewave = Instance.new("Part", Torso)
                levitatewave.Size = Vector3.new(1,1,1)
                levitatewave.CanCollide = false
                levitatewave.Anchored = true
                levitatewave.Transparency = .5
                levitatewave.BrickColor = BrickColor.new("Really black")
                levitatewave.CFrame = CFrame.new(Root.Position) * CFrame.new(0,-5,0)
                levitatewavemesh = Instance.new("SpecialMesh", levitatewave)
                levitatewavemesh.Scale = Vector3.new(2.5,.3,2.5)
                levitatewavemesh.MeshId = "rbxassetid://20329976"
                levitatewave2 = Instance.new("Part", Torso)
                levitatewave2.Size = Vector3.new(1,1,1)
                levitatewave2.CanCollide = false
                levitatewave2.Anchored = true
                levitatewave2.Transparency = .5
                levitatewave2.BrickColor = BrickColor.new("Really red")
                levitatewave2.CFrame = CFrame.new(Root.Position) * CFrame.new(0,-5,0)
                levitatewavemesh2 = Instance.new("SpecialMesh", levitatewave2)
                levitatewavemesh2.Scale = Vector3.new(2,.4,2)
                levitatewavemesh2.MeshId = "rbxassetid://20329976"
                blastwave = Instance.new("Part",Torso)
                blastwave.CFrame = Torso.CFrame
                blastwave.Anchored = true
                blastwave.Material = "Neon"
                blastwave.CanCollide = false
                blastwave.Shape = "Ball"
                blastwave.Size = Vector3.new(3,3,3)
                coroutine.wrap(function()
                    for i = 1, 20 do
                        blastwave.Size = blastwave.Size + Vector3.new(2,2,2)
                        blastwave.Transparency = blastwave.Transparency + 0.05
                        swait()
                    end
                    blastwave:Remove()
                end)()
                coroutine.wrap(function()
                    while levitate do
                        if IsDead then break end
                        mnb = mnb + 15
                        levitatewave.CFrame = CFrame.new(Root.Position) * CFrame.new(0,-6 + .5 * math.sin(sine/9),0) * CFrame.Angles(0,math.rad(mnb),0)
                        levitatewave2.CFrame = CFrame.new(Root.Position) * CFrame.new(0,-6 + .5 * math.sin(sine/9),0) * CFrame.Angles(0,math.rad(mnb),0)
                        colors = colortable[math.random(1,#colortable)]
                        lmagic = Instance.new("Part",LeftArm)
                        lmagic.Material = "Neon"
                        lmagic.CanCollide = false
                        lmagic.Anchored = true
                        lmagic.BrickColor = BrickColor.new(colors)
                        lmagic.Size = Vector3.new(1,1,1)
                        lmagic.CFrame = leftlocation.CFrame * CFrame.Angles(math.random(-180,180),math.random(-180,180),math.random(-180,180))
                        removeuseless:AddItem(lmagic,2)
                        rmagic = Instance.new("Part",RightArm)
                        rmagic.Material = "Neon"
                        rmagic.CanCollide = false
                        rmagic.Anchored = true
                        rmagic.BrickColor = BrickColor.new(colors)
                        rmagic.Size = Vector3.new(1,1,1)
                        rmagic.CFrame = rightlocation.CFrame * CFrame.Angles(math.random(-180,180),math.random(-180,180),math.random(-180,180))
                        removeuseless:AddItem(rmagic,2)
                        for i,v in pairs(LeftArm:GetChildren()) do if v.Name == lmagic.Name then
                                v.Transparency = v.Transparency + 0.05
                            end
                        end
                        for i,v in pairs(RightArm:GetChildren()) do if v.Name == rmagic.Name then
                                v.Transparency = v.Transparency + 0.05
                            end
                        end
                        swait()
                    end
                end)()
                doomtheme.SoundId = "rbxassetid://1382488262"
                doomtheme:Play()
                doomtheme.Volume = 2
                doomtheme.TimePosition = 20.7

                coroutine.wrap(function()
                    while levitate do
                        if IsDead then break end
                        hum.HipHeight = 3 - .5 * math.sin(sine/9)
                        swait()
                    end
                end)()
                attacking = false
                debounce = false
                coroutine.wrap(function()
                    wait(3)
                    notallowedtransform = false
                end)()
            end
        end
    end)

    mouse.KeyDown:connect(function(Press)
        Press=Press:lower()
        if Press=='.' then
            hum.Parent:BreakJoints()
        end
    end)

    checks1 = coroutine.wrap(function() -------Checks
        while true do
            if IsDead then break end
            if Root.Velocity.y > 1 and levitate == false then
                position = "Jump"
            elseif Root.Velocity.y < -1 and levitate == false then
                position = "Falling"
            elseif Root.Velocity.Magnitude < 2 and running == false and not levitate then
                position = "Idle"
            elseif Root.Velocity.Magnitude < 2 and running == false then
                position = "Idle2"
            elseif Root.Velocity.Magnitude < 20 and running == false and levitate == false then
                position = "Walking"
            elseif Root.Velocity.Magnitude > 20 and running == false and levitate then
                position = "Walking2"
            elseif Root.Velocity.Magnitude > 20 and levitate == false then
                position = "Running"
            else
            end
            wait()
        end
    end)
    checks1()

    function ray(POSITION, DIRECTION, RANGE, IGNOREDECENDANTS)
        return workspace:FindPartOnRay(Ray.new(POSITION, DIRECTION.unit * RANGE), IGNOREDECENDANTS)
    end

    function ray2(StartPos, EndPos, Distance, Ignore)
        local DIRECTION = CFrame.new(StartPos,EndPos).lookVector
        return ray(StartPos, DIRECTION, Distance, Ignore)
    end

    OrgnC0 = Neck.C0
    local movelimbs = coroutine.wrap(function()
        while RunSrv.RenderStepped:wait() do
            if IsDead then break end
            TrsoLV = Torso.CFrame.lookVector
            Dist = nil
            Diff = nil
            if not MseGuide then
                print("Failed to recognize")
            else
                local _, Point = Workspace:FindPartOnRay(Ray.new(Head.CFrame.p, mouse.Hit.lookVector), Workspace, false, true)
                Dist = (Head.CFrame.p-Point).magnitude
                Diff = Head.CFrame.Y-Point.Y
                local _, Point2 = Workspace:FindPartOnRay(Ray.new(LeftArm.CFrame.p, mouse.Hit.lookVector), Workspace, false, true)
                Dist2 = (LeftArm.CFrame.p-Point).magnitude
                Diff2 = LeftArm.CFrame.Y-Point.Y
                HEADLERP.C0 = CFrame.new(0, -1.5, -0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))
                Neck.C0 = Neck.C0:lerp(OrgnC0*CFrame.Angles((math.tan(Diff/Dist)*1), 0, (((Head.CFrame.p-Point).Unit):Cross(Torso.CFrame.lookVector)).Y*1), .1)
            end
        end
    end)
    movelimbs()

    coroutine.wrap(function()
        while true do
            if IsDead then break end
            if hum.Health < .1 then
                deadsound = Instance.new("Sound", Torso)
                deadsound.Volume = 6
                deadsound.SoundId = "rbxassetid://1411352723"
                deadsound:Play()
            end
            wait()
        end
    end)()

    mouse.KeyDown:connect(function(Press)
        Press=Press:lower()
        if Press=='g' then
            if not levitate then return end
            if debounce then return end
            debounce = true
            attacking = true
            FireBall:Play()
            ws = 15
            g1 = Instance.new("BodyGyro", Root)
            g1.D = 175
            g1.P = 20000
            g1.MaxTorque = Vector3.new(0,9000,0)
            for i = 1, 15 do
                g1.CFrame = g1.CFrame:lerp(CFrame.new(Root.Position,mouse.Hit.p),.2)
                ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(-10),math.rad(-15),math.rad(0)),.5)
                RIGHTARMLERP.C1 = CFrame.new(0,0,0) * CFrame.Angles(0,0,0)
                RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-0.5, 2, 0) * CFrame.Angles(math.rad(14), math.rad(20), math.rad(-90)), 0.3)
                swait()
            end
            local swoosh = Instance.new("Part",Torso)
            swoosh.Name = "swoosh"
            swoosh.CFrame = rightlocation.CFrame * CFrame.new(0,0,0)
            swoosh.Size = Vector3.new(1.7,1.7,1.7)
            swoosh.Shape = "Ball"
            swoosh.Material = "Neon"
            swoosh.BrickColor = BrickColor.new("Really black")
            swoosh.CanCollide = false
            swoosh.Touched:connect(function(hit)
                if hit.Parent:IsA("Part") then
                elseif hit.Parent:IsA("SpecialMesh") then
                elseif hit.Parent.Name == game.Players.LocalPlayer.Name then
                elseif hit.Parent:findFirstChildOfClass("Humanoid") then
                    Slachtoffer = hit.Parent:findFirstChildOfClass("Humanoid")
                    if Slachtoffer.Health < 1 then return end
                    if damagedebounce == true then return end
                    damagedebounce = true
                    swoosh:Remove()
                    explosion = Instance.new("Part",LeftArm)
                    explosion.CFrame = hit.CFrame
                    explosion.Anchored = true
                    explosion.CanCollide = false
                    explosion.Name = "explo"
                    explosion.Shape = "Ball"
                    explosion.BrickColor = BrickColor.new("Really black")
                    explosion.Material = "Neon"
                    removeuseless:AddItem(explosion,1.5)
                    vel = Instance.new("BodyVelocity",hit.Parent:FindFirstChild("Torso") or hit.Parent:FindFirstChild("UpperTorso")) 
                    vel.maxForce = Vector3.new(9999999999999,9999999999999,9999999999999)
                    torso = hit.Parent:FindFirstChild("Torso") or hit.Parent:FindFirstChild("UpperTorso")
                    vel.velocity = CFrame.new(swoosh.Position,torso.Position).lookVector*60
                    removeuseless:AddItem(vel,.1)
                    SOUND(explosion,472579737,6,false,3)
                    coroutine.wrap(function()
                        if firsttime2 then return end
                        firsttime2 = true
                        while true do
                            if IsDead then break end
                            for i,v in pairs(LeftArm:GetChildren()) do
                                if v.Name == "explo" then
                                    v.Size = v.Size + Vector3.new(2.5,2.5,2.5)
                                    v.Transparency = v.Transparency + .05
                                end
                            end
                            for i,v in pairs(LeftArm:GetChildren()) do
                                if v.Name == "shock" then
                                    v.Transparency = v.Transparency + .05
                                end
                            end
                            for i,v in pairs(LeftArm:GetChildren()) do
                                if v.Name == "shock2" then
                                    v.Transparency = v.Transparency + .05
                                end
                            end
                            swait()
                        end
                    end)()
                    DamageFling(hit.Parent)
                    wait(.1)
                    damagedebounce = false
                end
            end)
            coroutine.wrap(function()
                if firsttime then return end
                firsttime = true
                while wait() do
                    if IsDead then break end
                    for i,v in pairs(Torso:GetChildren()) do
                        if v.Name == "swoosh" then
                            magiccc = Instance.new("Part",RightArm)
                            magiccc.Material = "Neon"
                            magiccc.CanCollide = false
                            magiccc.Anchored = true
                            magiccc.BrickColor = BrickColor.new(colors)
                            magiccc.Size = Vector3.new(1.5,1.5,1.5)
                            magiccc.CFrame = v.CFrame * CFrame.Angles(math.random(-180,180),math.random(-180,180),math.random(-180,180))
                            removeuseless:AddItem(magiccc,2)
                        end
                    end
                end
            end)()
            bov = Instance.new("BodyVelocity",swoosh)
            bov.maxForce = Vector3.new(99999,99999,99999)
            swoosh.CFrame = CFrame.new(swoosh.Position,mouse.Hit.p)
            bov.velocity = swoosh.CFrame.lookVector*120
            removeuseless:AddItem(swoosh,4)
            for i = 1, 15 do
                ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(10),math.rad(15),math.rad(0)),.5)
                RIGHTARMLERP.C1 = CFrame.new(0,0,0)
                RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.2,1,.5) * CFrame.Angles(math.rad(-90),math.rad(-25),math.rad(0)), 0.5)
                swait()
            end
            ws = 50
            removeuseless:AddItem(g1,0.01)
            debounce = false
            attacking = false
        end
    end)

    mouse.KeyDown:connect(function(Press)
        Press=Press:lower()
        if Press=='h' then
            if not levitate then return end
            if debounce then return end
            debounce = true
            attacking = true
            ws = 0
            appi = true
            coroutine.wrap(function()
                while appi do
                    if IsDead then break end
                    swait()
                    if Root.Velocity.Magnitude < 2 and attacking == true then
                        position = "Idle3"
                    end
                end
            end)()
            coroutine.wrap(function()
                while appi do
                    if IsDead then break end
                    swait()
                    settime = 0.05
                    sine = sine + change
                    if position == "Idle3" and attacking == true and appi == true then
                        change = .4
                        RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),0,0),.1)
                        LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(-.2,.2,0) * CFrame.Angles(0,0,0),.1)
                        LEFTARMLERP.C1 = CFrame.new(0,0,0) * CFrame.Angles(0,0,0)
                        LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.6, 0.8 - .1 * math.sin(sine/9), 0) * CFrame.Angles(math.rad(0), math.rad(0 + 3 * math.sin(sine/9)), math.rad(35 - 5 * math.sin(sine/9))), 0.4)
                        RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.54, 1.4 + .1 * math.sin(sine/9), .4) * CFrame.Angles(math.rad(9 + 2 * math.cos(sine/9)), math.rad(0), math.rad(0)), 0.4)
                        LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.5, 2.0,0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-10 + 2 * math.sin(sine/9))), 0.4)
                    end
                end
            end)()
            coroutine.wrap(function()
                for i = 1, 20 do
                    RIGHTARMLERP.C1 = CFrame.new(0,0,0) * CFrame.Angles(0,0,0)
                    ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, 0, 0) * CFrame.Angles(0,math.rad(50),0),.3)
                    RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.1,1.3,1.1) * CFrame.Angles(math.rad(180),math.rad(-50),math.rad(0)), 0.3)
                    swait()
                end
            end)()
            SOUND(LeftArm,1982011510,8,false,15)
            blackhole={}
            orbzfade={}
            xz = 0
            for i = 1, 220 do
                xz = xz + .009
                bigrmagic = Instance.new("Part",RightArm)
                bigrmagic.Material = "Neon"
                bigrmagic.CanCollide = false
                bigrmagic.Anchored = true
                bigrmagic.BrickColor = BrickColor.new(colors)
                bigrmagic.Size = Vector3.new(xz,xz,xz)
                bigrmagic.CFrame = rightlocation.CFrame * CFrame.Angles(math.random(-180,180),math.random(-180,180),math.random(-180,180))
                removeuseless:AddItem(bigrmagic,1)
                orbz = Instance.new("Part", Torso)
                orbz.Material = "Neon"
                orbz.BrickColor = BrickColor.new(colors)
                orbz.Size = Vector3.new(2,2,2)
                orbz.Anchored = true
                orbz.CanCollide = false
                removeuseless:AddItem(orbz,1)
                orbz.CFrame = rightlocation.CFrame * CFrame.new(math.random(-25,25),math.random(-25,25),math.random(-25,25)) * CFrame.Angles(math.rad(-180,180),math.rad(-180,180),math.rad(-180,180))
                table.insert(blackhole,orbz)
                table.insert(orbzfade,orbz)
                for i,v in pairs(blackhole) do
                    v.Size = v.Size - Vector3.new(.1,.1,.1)
                    v.CFrame = v.CFrame:lerp(CFrame.new(rightlocation.Position),.09)
                end
                for i,v in pairs(orbzfade) do
                    v.Transparency = v.Transparency + 0.025
                end
                swait()
            end
            coroutine.wrap(function()
                for i = 1, 10 do
                    for i,v in pairs(blackhole) do
                        v.Size = v.Size + Vector3.new(.5,.5,.5)
                        v.Transparency = v.Transparency + .1
                    end
                    swait()
                end
                for i,v in pairs(blackhole) do
                    v:Remove()
                end
                clean()
            end)()
            charging = true
            coroutine.wrap(function()
                while charging do
                    if IsDead then break end
                    bigrmagic = Instance.new("Part",RightArm)
                    bigrmagic.Material = "Neon"
                    bigrmagic.CanCollide = false
                    bigrmagic.Anchored = true
                    bigrmagic.BrickColor = BrickColor.new(colors)
                    bigrmagic.Size = Vector3.new(xz,xz,xz)
                    bigrmagic.CFrame = rightlocation.CFrame * CFrame.Angles(math.random(-180,180),math.random(-180,180),math.random(-180,180))
                    removeuseless:AddItem(bigrmagic,.2)
                    swait()
                end
            end)()
            g1 = Instance.new("BodyGyro", Root)
            g1.D = 175
            g1.P = 20000
            g1.MaxTorque = Vector3.new(0,9000,0)
            BigFireBall:Play()
            for i = 1, 15 do
                g1.CFrame = g1.CFrame:lerp(CFrame.new(Root.Position,mouse.Hit.p),.2)
                ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(-10),math.rad(-15),math.rad(0)),.5)
                RIGHTARMLERP.C1 = CFrame.new(0,0,0) * CFrame.Angles(0,0,0)
                RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-0.5, 2, 0) * CFrame.Angles(math.rad(14), math.rad(20), math.rad(-90)), 0.3)
                swait()
            end
            coroutine.wrap(function()
                for i = 1, 15 do
                    ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(10),math.rad(15),math.rad(0)),.5)
                    RIGHTARMLERP.C1 = CFrame.new(0,0,0)
                    RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.2,1,.5) * CFrame.Angles(math.rad(-90),math.rad(-25),math.rad(0)), 0.5)
                    swait()
                end
            end)()
            charging = false
            local ballzor = Instance.new("Part",Torso)
            ballzor.Name = "ballzor"
            ballzor.Material = "Neon"
            ballzor.BrickColor = BrickColor.new("Really black")
            ballzor.CanCollide = false
            ballzor.Size = Vector3.new(xz,xz,xz)
            ballzor.Anchored = false
            ballzor.CFrame = Root.CFrame * CFrame.new(1,0,-5)
            ballzor.Shape = "Ball"
            removeuseless:AddItem(g1,.0001)
            zx = xz + .05
            coroutine.wrap(function()
                if firsttime5 then return end
                firsttime5 = true
                while true do
                    if IsDead then break end
                    swait()
                    for i,v in pairs(Torso:GetChildren()) do
                        if v.Name == "ballzor" then
                            magicccc = Instance.new("Part",RightArm)
                            magicccc.Material = "Neon"
                            magicccc.CanCollide = false
                            magicccc.Name = "magicccc"
                            magicccc.Anchored = true
                            magicccc.Transparency = 0
                            magicccc.BrickColor = BrickColor.new(colors)
                            magicccc.Size = Vector3.new(zx,zx,zx)
                            magicccc.CFrame = v.CFrame * CFrame.Angles(math.random(-180,180),math.random(-180,180),math.random(-180,180))
                            removeuseless:AddItem(magicccc,2)
                        end
                    end
                    for i,v in pairs(RightArm:GetChildren()) do
                        if v.Name == "magicccc" then
                            v.Transparency = v.Transparency + 0.025
                        end
                    end
                end
            end)()
            ballzor.Touched:connect(function(hit)
                if hit.Name ~= "magicccc" then
                    if bigball then return end
                    bigball = true
                    local explosionwave = Instance.new("Part",Torso) 
                    explosionwave.Shape = "Ball"
                    explosionwave.BrickColor = BrickColor.new("Really black")
                    explosionwave.Anchored = true
                    explosionwave.CanCollide = false
                    explosionwave.Transparency = .2
                    explosionwave.Material = "Neon"
                    explosionwave.Size = Vector3.new(1,1,1)
                    explosionwave.CFrame = ballzor.CFrame
                    render = Instance.new("Sound",explosionwave)
                    render.SoundId = "rbxassetid://2006635781"
                    render.Volume = 10 * 10
                    render:Play()
                    local explosionwave2 = Instance.new("Part",Torso)
                    explosionwave2.Shape = "Ball"
                    explosionwave2.BrickColor = BrickColor.new("Really red")
                    explosionwave2.Anchored = true
                    explosionwave2.CanCollide = false
                    explosionwave2.Material = "Neon"
                    explosionwave2.Size = Vector3.new(.8,.8,.8)
                    explosionwave2.CFrame = ballzor.CFrame
                    deadlywave = Instance.new("Part", explosionwave)
                    deadlywave.Size = Vector3.new(1,1,1)
                    deadlywave.CanCollide = false
                    deadlywave.Anchored = true
                    deadlywave.Transparency = .5
                    deadlywave.BrickColor = BrickColor.new("Really red")
                    deadlywave.CFrame = CFrame.new(explosionwave.Position)
                    deadlywavemesh = Instance.new("SpecialMesh", deadlywave)
                    deadlywavemesh.Scale = Vector3.new(1,2,1)
                    deadlywavemesh.MeshId = "rbxassetid://20329976"
                    deadlywave2 = Instance.new("Part", explosionwave)
                    deadlywave2.Size = Vector3.new(1,1,1)
                    deadlywave2.CanCollide = false
                    deadlywave2.Anchored = true
                    deadlywave2.Transparency = .5
                    deadlywave2.BrickColor = BrickColor.new("Really black")
                    deadlywave2.CFrame = CFrame.new(explosionwave.Position)
                    deadlywave2mesh = Instance.new("SpecialMesh", deadlywave2)
                    deadlywave2mesh.Scale = Vector3.new(3,2,3)
                    deadlywave2mesh.MeshId = "rbxassetid://20329976"
                    deadlyring = Instance.new("Part", Torso)
                    deadlyring.Size = Vector3.new(5, 5, 5)
                    deadlyring.Transparency = 0.5
                    deadlyring.BrickColor = BrickColor.new("Really black")
                    deadlyring.Anchored = true
                    deadlyring.CanCollide = false
                    deadlyring.CFrame = deadlywave.CFrame * CFrame.Angles(math.rad(math.random(-180,180)), math.rad(math.random(-180,180)), math.rad(math.random(-180,180)))
                    deadlyringh = Instance.new("SpecialMesh", deadlyring) 
                    deadlyringh.MeshId = "http://www.roblox.com/asset/?id=3270017" 
                    deadlyringh.Scale = Vector3.new(8, 8, .1)
                    deadlyring2 = Instance.new("Part", Torso)
                    deadlyring2.Size = Vector3.new(5, 5, 5)
                    deadlyring2.Transparency = 0.5
                    deadlyring2.BrickColor = BrickColor.new("Really black")
                    deadlyring2.Anchored = true
                    deadlyring2.CanCollide = false
                    deadlyring2.CFrame = deadlywave.CFrame * CFrame.Angles(math.rad(math.random(-180,180)), math.rad(math.random(-180,180)), math.rad(math.random(-180,180)))
                    deadlyringh2 = Instance.new("SpecialMesh", deadlyring2) 
                    deadlyringh2.MeshId = "http://www.roblox.com/asset/?id=3270017" 
                    deadlyringh2.Scale = Vector3.new(8, 8, .1)
                    ballzor:Remove()
                    bigball = false
                    staybooming = true
                    d = 5
                    coroutine.wrap(function()
                        while staybooming do
                            if IsDead then break end
                            Hit = damagealll(d,deadlywave.Position)
                            for _,v in pairs(Hit) do            
                                DamageFling(v)
                                vel = Instance.new("BodyVelocity",v:FindFirstChild("Torso") or v:FindFirstChild("UpperTorso")) 
                                vel.maxForce = Vector3.new(9999999999999,9999999999999,9999999999999)
                                torso = v:FindFirstChild("Torso") or v:FindFirstChild("UpperTorso")
                                vel.velocity = CFrame.new(deadlywave.Position,torso.Position).lookVector*50
                                removeuseless:AddItem(vel,.1)
                            end
                            wait(.1)
                        end
                    end)()
                    for i = 1, 70 do
                        d = d + 1
                        deadlyringh2.Scale = deadlyringh2.Scale + Vector3.new(.5, .5, .1)
                        deadlyringh.Scale = deadlyringh.Scale + Vector3.new(.5, .5, .1)
                        deadlyring.CFrame = deadlyring.CFrame * CFrame.Angles(math.rad(0+7),math.rad(0-7),math.rad(0+7))
                        deadlyring2.CFrame = deadlyring2.CFrame * CFrame.Angles(math.rad(0-7),math.rad(0+7),math.rad(0-7))
                        deadlywave.CFrame = deadlywave.CFrame * CFrame.Angles(0,math.rad(0+7),0)
                        deadlywave2.CFrame = deadlywave2.CFrame * CFrame.Angles(0,math.rad(0+4),0)
                        deadlywavemesh.Scale = deadlywavemesh.Scale + Vector3.new(.4,0,.4)
                        deadlywave2mesh.Scale = deadlywave2mesh.Scale + Vector3.new(.5,0,.5)
                        explosionwave.Size = explosionwave.Size + Vector3.new(.5,.5,.5)
                        explosionwave2.Size = explosionwave2.Size + Vector3.new(.5,.5,.5)
                        swait()
                    end
                    for i = 1, 80 do
                        d = d + 3
                        hum.CameraOffset = Vector3.new(math.random(-1,1),math.random(-1,1),math.random(-1,1))
                        deadlyringh2.Scale = deadlyringh2.Scale + Vector3.new(4, 4, .2)
                        deadlyringh.Scale = deadlyringh.Scale + Vector3.new(4, 4, .2)
                        deadlyring.CFrame = deadlyring.CFrame * CFrame.Angles(math.rad(0+12),math.rad(0-12),math.rad(0+12))
                        deadlyring2.CFrame = deadlyring2.CFrame * CFrame.Angles(math.rad(0-12),math.rad(0+12),math.rad(0-12))
                        deadlywave.CFrame = deadlywave.CFrame * CFrame.Angles(0,math.rad(0+20),0)
                        deadlywave2.CFrame = deadlywave2.CFrame * CFrame.Angles(0,math.rad(0+14),0)
                        deadlywavemesh.Scale = deadlywavemesh.Scale + Vector3.new(3,2,3)
                        deadlywave2mesh.Scale = deadlywave2mesh.Scale + Vector3.new(4,1,4)
                        explosionwave.Size = explosionwave.Size + Vector3.new(4,4,4)
                        explosionwave2.Size = explosionwave2.Size + Vector3.new(4,4,4)
                        swait()
                    end
                    staybooming = false
                    for i = 1, 20 do
                        d = d + 3
                        hum.CameraOffset = Vector3.new(math.random(-1,1),math.random(-1,1),math.random(-1,1))
                        deadlyringh2.Scale = deadlyringh2.Scale + Vector3.new(4, 4, .2)
                        deadlyringh.Scale = deadlyringh.Scale + Vector3.new(4, 4, .2)
                        deadlyring.CFrame = deadlyring.CFrame * CFrame.Angles(math.rad(0+12),math.rad(0-12),math.rad(0+12))
                        deadlyring2.CFrame = deadlyring2.CFrame * CFrame.Angles(math.rad(0-12),math.rad(0+12),math.rad(0-12))
                        deadlyring.Transparency = deadlyring.Transparency + .25
                        deadlyring2.Transparency = deadlyring2.Transparency + .25
                        deadlywave.CFrame = deadlywave.CFrame * CFrame.Angles(0,math.rad(0+20),0)
                        deadlywave2.CFrame = deadlywave2.CFrame * CFrame.Angles(0,math.rad(0+14),0)
                        deadlywavemesh.Scale = deadlywavemesh.Scale + Vector3.new(3,0,3)
                        deadlywave2mesh.Scale = deadlywave2mesh.Scale + Vector3.new(4,0,4)
                        deadlywave.Transparency = deadlywave.Transparency + .25
                        deadlywave2.Transparency = deadlywave2.Transparency + .25
                        explosionwave.Size = explosionwave.Size + Vector3.new(4,4,4)
                        explosionwave2.Size = explosionwave2.Size + Vector3.new(4,4,4)
                        explosionwave.Transparency = explosionwave.Transparency + 0.25
                        explosionwave2.Transparency = explosionwave2.Transparency + 0.05
                        swait()
                    end
                    hum.CameraOffset = Vector3.new(0,0,0)
                    explosionwave:Remove()
                    explosionwave2:Remove()
                end
            end)
            bov = Instance.new("BodyVelocity",ballzor)
            bov.maxForce = Vector3.new(99999,99999,99999)
            ballzor.CFrame = CFrame.new(ballzor.Position,mouse.Hit.p)
            bov.velocity = ballzor.CFrame.lookVector*200
            removeuseless:AddItem(ballzor,4)
            ws = 50
            attacking = false
            debounce = false
            appi = false
        end
    end)

    mouse.KeyDown:connect(function(Press)
        Press=Press:lower()
        if Press=='j' then
            if not levitate then return end
            if debounce then return end
            debounce = true
            charging = true
            attacking = true
            downpress = false
            x = 1
            ws = 0
            g1 = Instance.new("BodyGyro", Root)
            g1.D = 175
            g1.P = 20000
            g1.MaxTorque = Vector3.new(0,9000,0)
            SOUND(RightArm,2014087015,8,false,3)
            coroutine.wrap(function()
                Charge = Instance.new("Sound",RightArm)
                Charge.SoundId = "rbxassetid://101153932"
                Charge.Looped = false
                Charge.Volume = 8
                Charge:Play()
            end)()
            appi = true
            coroutine.wrap(function()
                while appi do
                    if IsDead then break end
                    swait()
                    if Root.Velocity.Magnitude < 2 and attacking == true then
                        position = "Idle3"
                    end
                end
            end)()
            coroutine.wrap(function()
                while appi do
                    if IsDead then break end
                    swait()
                    settime = 0.05
                    sine = sine + change
                    if position == "Idle3" and attacking == true and appi == true then
                        change = .4
                        RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),0,0),.1)
                        LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(-.2,.2,0) * CFrame.Angles(0,0,0),.1)
                        LEFTARMLERP.C1 = CFrame.new(0,0,0) * CFrame.Angles(0,0,0)
                        LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.6, 0.8 - .1 * math.sin(sine/9), 0) * CFrame.Angles(math.rad(0), math.rad(0 + 3 * math.sin(sine/9)), math.rad(35 - 5 * math.sin(sine/9))), 0.4)
                        RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.54, 1.4 + .1 * math.sin(sine/9), .4) * CFrame.Angles(math.rad(9 + 2 * math.cos(sine/9)), math.rad(0), math.rad(0)), 0.4)
                        LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.5, 2.0,0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-10 + 2 * math.sin(sine/9))), 0.4)
                    end
                end
            end)()
            for i = 1, 15 do
                g1.CFrame = g1.CFrame:lerp(CFrame.new(Root.Position,mouse.Hit.p),.2)
                ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(-10),math.rad(-15),math.rad(0)),.5)
                RIGHTARMLERP.C1 = CFrame.new(0,0,0) * CFrame.Angles(0,0,0)
                RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-0.5, 2, 0) * CFrame.Angles(math.rad(14), math.rad(20), math.rad(-90)), 0.3)
                swait()
            end
            for i = 1, 3 do
                g1.CFrame = g1.CFrame:lerp(CFrame.new(Root.Position,mouse.Hit.p),.4)
                ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(-10),math.rad(-15),math.rad(0)),.5)
                RIGHTARMLERP.C1 = CFrame.new(0,0,0) * CFrame.Angles(0,0,0)
                RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-0.5, 2, 0) * CFrame.Angles(math.rad(14), math.rad(20), math.rad(-90)), 0.3)
                x = x + .1
                blastborb = Instance.new("Part",Torso)
                blastborb.CFrame = rightlocation.CFrame * CFrame.Angles(math.rad(math.random(-180,180)),math.rad(math.random(-180,180)),math.rad(math.random(-180,180)))
                blastborb.BrickColor = BrickColor.new(colors)
                blastborb.Anchored = true
                blastborb.Size = Vector3.new(10,10,10)
                blastborb.CanCollide = false
                blastborb.Material = "Neon"
                for i = 1, 5 do
                    g1.CFrame = g1.CFrame:lerp(CFrame.new(Root.Position,mouse.Hit.p),.4)
                    blastborb.Size = blastborb.Size - Vector3.new(1,1,1)
                    swait()
                end
                blastborb:Remove()
                swait()
            end
            downpress = true
            while charging and x < 5  do
                if IsDead then break end
                g1.CFrame = g1.CFrame:lerp(CFrame.new(Root.Position,mouse.Hit.p),.4)
                ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(-10),math.rad(-15),math.rad(0)),.5)
                RIGHTARMLERP.C1 = CFrame.new(0,0,0) * CFrame.Angles(0,0,0)
                RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-0.5, 2, 0) * CFrame.Angles(math.rad(14), math.rad(20), math.rad(-90)), 0.3)
                x = x + .1
                blastborb = Instance.new("Part",Torso)
                blastborb.CFrame = rightlocation.CFrame * CFrame.Angles(math.rad(math.random(-180,180)),math.rad(math.random(-180,180)),math.rad(math.random(-180,180)))
                blastborb.BrickColor = BrickColor.new(colors)
                blastborb.Anchored = true
                blastborb.Size = Vector3.new(10,10,10)
                blastborb.CanCollide = false
                blastborb.Material = "Neon"
                for i = 1, 5 do
                    g1.CFrame = g1.CFrame:lerp(CFrame.new(Root.Position,mouse.Hit.p),.4)
                    blastborb.Size = blastborb.Size - Vector3.new(1,1,1)
                    swait()
                end
                blastborb:Remove()
                swait()
            end
            coroutine.wrap(function()
                for i = 1, 20 do
                    Charge.Volume = Charge.Volume - .5
                    swait()
                end
            end)()
            local bigswoosh = Instance.new("Part",Torso)
            bigswoosh.Name = "bigswoosh"
            bigswoosh.CFrame = Root.CFrame * CFrame.new(1,0,-5)
            bigswoosh.Size = Vector3.new(1,1,1)
            bigswoosh.Material = "Neon"
            bigswoosh.Anchored = true
            bigswoosh.Transparency = 1
            bigswoosh.BrickColor = BrickColor.new("Really red")
            bigswoosh.CanCollide = false
            SOUND(bigswoosh,842332424,10,false,6)
            SOUND(bigswoosh,2017948224,10,false,6)
            SOUND(bigswoosh,138677306,10,false,4)
            coroutine.wrap(function()
                local loc1 = Instance.new("Part",bigswoosh)
                loc1.CFrame = bigswoosh.CFrame * CFrame.new(-3,0,0)
                loc1.Size = Vector3.new(2,2,2)
                loc1.Anchored = true
                loc1.Transparency = 1
                loc1.CanCollide = false
                local loc2 = Instance.new("Part",bigswoosh)
                loc2.CFrame = bigswoosh.CFrame * CFrame.new(3,0,0)
                loc2.Size = Vector3.new(2,2,2)
                loc2.Anchored = true
                loc2.Transparency = 1
                loc2.CanCollide = false
                n = 0
                nb = 0
                for i = 1, 125 do
                    n = n + x
                    nb = nb - x
                    Hit = damagealll(n,bigswoosh.Position)
                    for _,v in pairs(Hit) do
                        if x > 4.5 then     
                            v:FindFirstChildOfClass("Humanoid").Parent:BreakJoints()
                        else    
                            DamageFling(v)
                        end
                        vel = Instance.new("BodyVelocity",v:FindFirstChild("Torso") or v:FindFirstChild("UpperTorso")) 
                        vel.maxForce = Vector3.new(9999999999999,9999999999999,9999999999999)
                        torso = v:FindFirstChild("Torso") or v:FindFirstChild("UpperTorso")
                        vel.velocity = CFrame.new(bigswoosh.Position,torso.Position).lookVector*150
                        removeuseless:AddItem(vel,.1)
                    end
                    local bigtrail = Instance.new("Part",LeftArm)
                    bigtrail.Size = bigswoosh.Size
                    bigtrail.BrickColor = BrickColor.new(colors)
                    bigtrail.Anchored = true
                    bigtrail.Material = "Neon"
                    bigtrail.CFrame = bigswoosh.CFrame * CFrame.Angles(math.rad(math.random(-180,180)),math.rad(math.random(-180,180)),math.rad(math.random(-180,180)))
                    bigtrail.CanCollide = false
                    removeuseless:AddItem(bigtrail,2)
                    local irritatedground = Instance.new("Part",Torso)
                    irritatedground.Size = Vector3.new(n*1.5,1,3*x)
                    irritatedground.BrickColor = BrickColor.new(colors)
                    irritatedground.Material = "Neon"
                    irritatedground.CFrame = bigswoosh.CFrame * CFrame.new(0,-6,0)
                    irritatedground.CanCollide = false
                    irritatedground.Anchored = true
                    removeuseless:AddItem(irritatedground,10)
                    local grassblocks = Instance.new("Part",Torso)
                    grassblocks.Size = Vector3.new(n/2,n/2,n/2)
                    grassblocks.Material = "Grass"
                    grassblocks.Anchored = true
                    grassblocks.Name = "grassblocks"
                    grassblocks.BrickColor = BrickColor.new("Bright green")
                    grassblocks.CFrame = loc1.CFrame * CFrame.new(0,-1,0) * CFrame.Angles(math.rad(math.random(-180,180)),math.rad(math.random(-180,180)),math.rad(math.random(-180,180)))
                    removeuseless:AddItem(grassblocks,10)
                    local grassblocks2 = Instance.new("Part",Torso)
                    grassblocks2.Size = Vector3.new(n/2,n/2,n/2)
                    grassblocks2.Material = "Grass"
                    grassblocks2.Anchored = true
                    grassblocks2.Name = "grassblocks2"
                    grassblocks2.BrickColor = BrickColor.new("Bright green")
                    grassblocks2.CFrame = loc2.CFrame * CFrame.new(0,-1,0) * CFrame.Angles(math.rad(math.random(-180,180)),math.rad(math.random(-180,180)),math.rad(math.random(-180,180)))
                    removeuseless:AddItem(grassblocks2,10)
                    bigswoosh.Size = bigswoosh.Size + Vector3.new(x,x,x)
                    loc1.CFrame = bigswoosh.CFrame * CFrame.new(n,-3,0)
                    loc2.CFrame = bigswoosh.CFrame * CFrame.new(nb,-3,0)
                    bigswoosh.CFrame = bigswoosh.CFrame * CFrame.new(0,0,-3 - x)
                    swait()
                end
                for i = 1, 20 do
                    bigswoosh.CFrame = bigswoosh.CFrame * CFrame.new(0,0,-3)
                    bigswoosh.Transparency = bigswoosh.Transparency + 0.05
                    swait()
                end
                bigswoosh:Remove()
            end)()
            for i = 1, 50 do
                ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(10),math.rad(15),math.rad(0)),.5)
                RIGHTARMLERP.C1 = CFrame.new(0,0,0)
                RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.2,1,.5) * CFrame.Angles(math.rad(-90),math.rad(-25),math.rad(0)), 0.5)
                swait()
            end
            ws = 50
            attacking = false
            debounce = false
            appi = false
            g1:Remove()
        end
    end)

    mouse.KeyDown:connect(function(Press)
        Press=Press:lower()
        if Press=='k' then
            if not levitate then return end
            if debounce then return end
            debounce = true
            attacking = true
            charging = true
            appi = true
            coroutine.wrap(function()
                while appi do
                    if IsDead then break end
                    swait()
                    if Root.Velocity.Magnitude < 2 and attacking == true then
                        position = "Idle3"
                    end
                end
            end)()
            coroutine.wrap(function()
                while appi do
                    if IsDead then break end
                    swait()
                    settime = 0.05
                    sine = sine + change
                    if position == "Idle3" and attacking == true and appi == true then
                        change = .4
                        RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),0,0),.1)
                        LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(-.2,.2,0) * CFrame.Angles(0,0,0),.1)
                        LEFTARMLERP.C1 = CFrame.new(0,0,0) * CFrame.Angles(0,0,0)
                        LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.6, 0.8 - .1 * math.sin(sine/9), 0) * CFrame.Angles(math.rad(0), math.rad(0 + 3 * math.sin(sine/9)), math.rad(35 - 5 * math.sin(sine/9))), 0.4)
                        RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.54, 1.4 + .1 * math.sin(sine/9), .4) * CFrame.Angles(math.rad(9 + 2 * math.cos(sine/9)), math.rad(0), math.rad(0)), 0.4)
                        LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.5, 2.0,0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-10 + 2 * math.sin(sine/9))), 0.4)
                    end
                end
            end)()
            ws = 0
            g1 = Instance.new("BodyGyro", Root)
            g1.D = 175
            g1.P = 20000
            g1.MaxTorque = Vector3.new(0,9000,0)
            g1.CFrame = CFrame.new(Root.Position,mouse.Hit.p)
            for i = 1, 15 do
                g1.CFrame = g1.CFrame:lerp(CFrame.new(Root.Position,mouse.Hit.p),.3)
                ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),math.rad(90),math.rad(0)),.3)
                RIGHTARMLERP.C1 = CFrame.new(0,0,0) * CFrame.Angles(0,0,0)
                RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-.5, 2, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-90)), 0.3)
                swait()
            end
            r = 0
            for i = 1, 10 do
                r = r + .1
                g1.CFrame = g1.CFrame:lerp(CFrame.new(Root.Position,mouse.Hit.p),.3)
                blass = Instance.new("Part",RightArm)
                blass.Size = Vector3.new(r,r,r)
                blass.Material = "Neon"
                blass.CFrame = rightlocation.CFrame * CFrame.new(0,-r/1.5,0) * CFrame.Angles(math.rad(math.random(-180,180)),math.rad(math.random(-180,180)),math.rad(math.random(-180,180)))
                blass.Anchored = true
                blass.CanCollide = false
                blass.BrickColor = BrickColor.new(colors)
                removeuseless:AddItem(blass,2)
                swait()
            end
            while r < 16 and charging == true do
                if IsDead then break end
                r = r + .1
                g1.CFrame = g1.CFrame:lerp(CFrame.new(Root.Position,mouse.Hit.p),.3)
                blass = Instance.new("Part",RightArm)
                blass.Size = Vector3.new(r,r,r)
                blass.Material = "Neon"
                blass.CFrame = rightlocation.CFrame * CFrame.new(0,-r/1.5,0) * CFrame.Angles(math.rad(math.random(-180,180)),math.rad(math.random(-180,180)),math.rad(math.random(-180,180)))
                blass.Anchored = true
                blass.CanCollide = false
                blass.BrickColor = BrickColor.new(colors)
                removeuseless:AddItem(blass,2)
                swait()
            end
            local TheBeam = Instance.new("Part",RightArm)
            TheBeam.Name = "zebeam"
            TheBeam.Size = Vector3.new(1,1,1)
            TheBeam.Material = "Neon"
            TheBeam.Shape = "Cylinder"
            TheBeam.BrickColor = BrickColor.new("Really red")
            TheBeam.Anchored = true
            TheBeam.CanCollide = false
            ws = 12
            bemmo = Instance.new("Sound",RightArm)
            bemmo.SoundId = "rbxassetid://1910988873"
            bemmo.Volume = 8
            bemmo.Looped = false
            bemmo:Play()
            bemmo.TimePosition = 2
            for i = 1, 100 * r/3 do
                if r > 15 then
                    hum.CameraOffset = Vector3.new(math.random(-1,1),math.random(-1,1),math.random(-0,0))
                end
                g1.CFrame = g1.CFrame:lerp(CFrame.new(Root.Position,mouse.Hit.p),.3)
                local blass = Instance.new("Part",RightArm)
                blass.Size = Vector3.new(r,r,r)
                blass.Material = "Neon"
                blass.CFrame = rightlocation.CFrame * CFrame.new(0,-r/1.5,0) * CFrame.Angles(math.rad(math.random(-180,180)),math.rad(math.random(-180,180)),math.rad(math.random(-180,180)))
                blass.Anchored = true
                blass.CanCollide = false
                blass.BrickColor = BrickColor.new(colors)
                removeuseless:AddItem(blass,2)
                local STARTPOS = blass.CFrame*CFrame.new(0,0,0).p
                local ENDHIT,ENDPOS = ray2(STARTPOS,mouse.Hit.p,650,Character)
                local DISTANCE = (STARTPOS - ENDPOS).magnitude
                TheBeam.CFrame = CFrame.new(STARTPOS,ENDPOS)*CFrame.new(0,0,-DISTANCE/2) * CFrame.Angles(math.rad(0),math.rad(90),math.rad(0))
                TheBeam.Size = Vector3.new(DISTANCE,r/math.random(1,2),r/math.random(1,2))
                boom = Instance.new("Part",RightArm)
                boom.Size = Vector3.new(r,r,r)
                boom.BrickColor = BrickColor.new(colors)
                boom.Anchored = true
                boom.CanCollide = false
                boom.Material = "Neon"
                boom.CFrame = CFrame.new(ENDPOS) * CFrame.Angles(math.rad(math.random(-180,180)),math.rad(math.random(-180,180)),math.rad(math.random(-180,180)))
                removeuseless:AddItem(boom,3)
                boom.Touched:connect(function(getbase)
                    if hitdebounce then return end
                    hitdebounce = true
                    if getbase:IsA("Part") then
                        damagedground = Instance.new("Part",RightArm)
                        damagedground.Size = Vector3.new(.1,5+r,.1)
                        damagedground.Material = "Neon"
                        damagedground.CanCollide = false
                        damagedground.BrickColor = BrickColor.new(colors)
                        damagedground.Anchored = true
                        damagedground.CFrame = boom.CFrame * CFrame.Angles(math.rad(math.random(-180,180)),math.rad(math.random(-180,180)),math.rad(math.random(-180,180)))
                        removeuseless:AddItem(damagedground,2)
                        wait(.1)
                        hitdebounce = false
                    end
                end)
                Hit = damagealll(r+3,boom.Position)
                for _,v in pairs(Hit) do    
                    DamageFling(v)
                    vel = Instance.new("BodyVelocity",v:FindFirstChild("Torso") or v:FindFirstChild("UpperTorso")) 
                    vel.maxForce = Vector3.new(9999999999999,9999999999999,9999999999999)
                    torso = v:FindFirstChild("Torso") or v:FindFirstChild("UpperTorso")
                    vel.velocity = CFrame.new(boom.Position,torso.Position).lookVector*r
                    removeuseless:AddItem(vel,.1)
                end
                swait()
            end
            removeuseless:AddItem(g1,.001)
            coroutine.wrap(function()
                for i = 1, 20 do
                    bemmo.Volume = bemmo.Volume - 0.5
                    blass.Transparency = blass.Transparency + 0.05
                    TheBeam.Transparency = TheBeam.Transparency + 0.05
                    swait()
                end
                bemmo:Remove()
                if r > 15 then
                    hum.CameraOffset = Vector3.new(0,0,0)
                end
                blass:Remove()
                TheBeam:Remove()
            end)()
            ws = 50
            appi = false
            attacking = false
            debounce = false
        end
    end)

    mouse.KeyUp:connect(function(Press)
        Press=Press:lower()
        if Press=='j' then
            charging = false
        end
    end)

    mouse.KeyUp:connect(function(Press)
        Press=Press:lower()
        if Press=='k' then
            charging = false
        end
    end)

    doit = coroutine.wrap(function()
        while true do
            if IsDead then break end
            for _,v in pairs(Repeater) do
                v.Scale =  v.Scale + Vector3.new(1, 1, 1)
            end

            for _,v in pairs(openshocktable) do
                v.Scale =  v.Scale + Vector3.new(3, 3, 3)
            end

            for _,v in pairs(nonmeshRepeater) do
                v.Size =  v.Size + Vector3.new(2, 2, 2)
            end

            for _,v in pairs(Extreme) do
                v.Size =  v.Size + Vector3.new(6, 6, 6)
            end

            for _,v in pairs(LessSize) do
                v.Size = v.Size - Vector3.new(1, 1, 1)
            end

            for _,v in pairs(nonmeshRepeater2) do
                v.Transparency = v.Transparency + 0.05
            end

            for _,v in pairs(Repeater2) do
                v.Transparency = v.Transparency - 0.05
            end

            for _,v in pairs(th1) do
                v.CFrame = v.CFrame * CFrame.new(0,0+.3,0) * CFrame.Angles(0,math.rad(0+8),0)
            end

            for _,v in pairs(th2) do
                v.CFrame = v.CFrame * CFrame.new(0,0,0) * CFrame.Angles(0,math.rad(0+15),0)
            end

            for _,v in pairs(th3) do
                v.Scale = v.Scale + Vector3.new(2, 2, 2)
            end

            for _,v in pairs(th5) do
                v.Scale = v.Scale + Vector3.new(1, .1, 1)
            end

            for _,v in pairs(ExtremeM) do
                v.Size = v.Size + Vector3.new(8, 8, 8)
            end

            for _,v in pairs(m3) do
                v.Scale = v.Scale + Vector3.new(.2,.2,.2)
            end

            for _,v in pairs(ExtremeM2) do
                v.Size = v.Size - Vector3.new(2,2,2)
            end

            for _,v in pairs(keyYsize) do
                v.Scale = v.Scale + Vector3.new(8, 8, 1)
            end

            for _,v in pairs(th4) do
                v.Transparency = v.Transparency + 0.009
                v.Rotation = v.Rotation + Vector3.new(3,0,0)
            end

            for _,v in pairs(SlowlyFade) do
                v.Transparency = v.Transparency + 0.05
            end

            for _,v in pairs(keyYtransparency) do
                v.Transparency = v.Transparency + 0.05
            end

            for _,v in pairs(UpMover) do
                v.Position = v.Position + Vector3.new(0, 3, 0)
            end

            for _,v in pairs(ForwardMover) do
                v.CFrame = v.CFrame * CFrame.new(0, 0, 2.4 +(i/.1)) * CFrame.Angles(0, 0, math.rad(0))
            end

            for _,v in pairs(FadeIn) do
                v.Transparency = v.Transparency - .05
            end

            for _,v in pairs(signtransparency) do
                v.TextTransparency = v.TextTransparency + 0.025
            end

            for _,v in pairs(signmover) do
                v.StudsOffset = v.StudsOffset + Vector3.new(math.random(-2,2),.3,math.random(-2,2))
            end

            for _,v in pairs(signrotator) do
                v.Rotation = v.Rotation + 2
            end
            swait()
        end
    end)
    doit()
    t = 0

    mouse.KeyDown:connect(function(Press)
        Press=Press:lower()
        if Press=='0' then
            if levitate then return end
            shoov = true
            if debounce then return end
            ws = 50
        end
    end)

    mouse.KeyUp:connect(function(Press)
        Press=Press:lower()
        if Press=='0' then
            if levitate then return end
            shoov = false
            if debounce then return end
            ws = 10
        end
    end)


    local anims = coroutine.wrap(function()
        while true do
            if IsDead then break end
            settime = 0.05
            sine = sine + change
            if position == "Jump" and attacking == false then
                change = 1
                LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.1)
                RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),0,0),.1)
                LEFTARMLERP.C1 = LEFTARMLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.4)
                RIGHTARMLERP.C1 = RIGHTARMLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.4)
                ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.4)
                LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.4,.1,-.2) * CFrame.Angles(math.rad(20),math.rad(-3),math.rad(-4)), 0.4)
                RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.4,.1,-.2) * CFrame.Angles(math.rad(20),math.rad(3),math.rad(4)), 0.4)
                RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.5, 2, 0) * CFrame.Angles(math.rad(10), math.rad(0), math.rad(0)), 0.4)
                LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.5, 1.0, .9) * CFrame.Angles(math.rad(20), math.rad(0), math.rad(0)), 0.4)
            elseif position == "Jump2" and attacking == false and levitate then
                change = 1
                ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-20 - 1 * math.sin(sine/9)), math.rad(0 + 0 * math.cos(sine/8)), math.rad(0) + Root.RotVelocity.Y / 30, math.cos(10 * math.cos(sine/10))), 0.3)
                LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.3)
                RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),0,0),.3)
                RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.5,.6,-.5) * CFrame.Angles(math.rad(32),math.rad(5 - .1 * math.sin(sine/12)),math.rad(40 - .5 * math.sin(sine/12))), 0.3)
                RIGHTARMLERP.C1 = RIGHTARMLERP.C1:lerp(CFrame.new(-.2,1.2,-.3),.3)
                LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.5,.6,-.5) * CFrame.Angles(math.rad(30),math.rad(-5 + .1 * math.sin(sine/12)),math.rad(-40 + .5 * math.sin(sine/12))), 0.3)
                LEFTARMLERP.C1 = LEFTARMLERP.C1:lerp(CFrame.new(.2,1.2,-.3),.3)
                RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.54, 1.4 + .1 * math.sin(sine/9), .4) * CFrame.Angles(math.rad(9 + 2 * math.cos(sine/9)), math.rad(0), math.rad(0)), 0.3)
                LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.54, 2.0 + .02 * math.sin(sine/9), 0.2 + .1 * math.sin(sine/9)) * CFrame.Angles(math.rad(25 + 5 * math.sin(sine/9)), math.rad(20), math.rad(0)), 0.3)
            elseif position == "Falling" and attacking == false and levitate == false then
                change = 1
                LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.1)
                RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),0,0),.1)
                LEFTARMLERP.C1 = LEFTARMLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.4)
                RIGHTARMLERP.C1 = RIGHTARMLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.4)
                RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.5, 2, 0) * CFrame.Angles(math.rad(8), math.rad(4), math.rad(0)), 0.2)
                LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.5, 1.0, .9) * CFrame.Angles(math.rad(14), math.rad(-4), math.rad(0)), 0.2)
                LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.6, 0.5, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(20)), 0.2)
                RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.6, 0.5, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-20)), 0.2)
            elseif position == "Falling2" and attacking == false and levitate then
                change = 1
                ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-20 - 1 * math.sin(sine/9)), math.rad(0 + 0 * math.cos(sine/8)), math.rad(0) + Root.RotVelocity.Y / 30, math.cos(10 * math.cos(sine/10))), 0.3)
                LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.3)
                RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),0,0),.3)
                RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.5,.6,-.5) * CFrame.Angles(math.rad(32),math.rad(5 - .1 * math.sin(sine/12)),math.rad(40 - .5 * math.sin(sine/12))), 0.3)
                RIGHTARMLERP.C1 = RIGHTARMLERP.C1:lerp(CFrame.new(-.2,1.2,-.3),.3)
                LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.5,.6,-.5) * CFrame.Angles(math.rad(30),math.rad(-5 + .1 * math.sin(sine/12)),math.rad(-40 + .5 * math.sin(sine/12))), 0.3)
                LEFTARMLERP.C1 = LEFTARMLERP.C1:lerp(CFrame.new(.2,1.2,-.3),.3)
                RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.54, 1.4 + .1 * math.sin(sine/9), .4) * CFrame.Angles(math.rad(9 + 2 * math.cos(sine/9)), math.rad(0), math.rad(0)), 0.3)
                LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.54, 2.0 + .02 * math.sin(sine/9), 0.2 + .1 * math.sin(sine/9)) * CFrame.Angles(math.rad(25 + 5 * math.sin(sine/9)), math.rad(20), math.rad(0)), 0.3)
            elseif position == "Walking" and attacking == false and running == false then
                change = 1
                walking = true
                LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.1)
                RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),0,0),.1)
                RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.5,.6,-.5) * CFrame.Angles(math.rad(32),math.rad(5 - .1 * math.sin(sine/12)),math.rad(40 - .5 * math.sin(sine/12))), 0.3)
                RIGHTARMLERP.C1 = RIGHTARMLERP.C1:lerp(CFrame.new(-.2,1.2,-.3),.3)
                LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.5,.6,-.5) * CFrame.Angles(math.rad(30),math.rad(-5 + .1 * math.sin(sine/12)),math.rad(-40 + .5 * math.sin(sine/12))), 0.3)
                LEFTARMLERP.C1 = LEFTARMLERP.C1:lerp(CFrame.new(.2,1.2,-.3),.3)
                ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-10), math.rad(5 * math.cos(sine/7)), math.rad(0) + Root.RotVelocity.Y / 30, math.cos(25 * math.cos(sine/10))), 0.3)
                RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.5, 1.92 - 0.35 * math.cos(sine/8)/2.8, 0.2 - math.sin(sine/8)/3.4) * CFrame.Angles(math.rad(10) + -math.sin(sine/8)/2.3, math.rad(0)*math.cos(sine/1), math.rad(0)  + RightLeg.RotVelocity.Y / 30, math.cos(25 * math.cos(sine/8))), 0.3)
                LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.5, 1.92 + 0.35 * math.cos(sine/8)/2.8, 0.2 + math.sin(sine/8)/3.4) * CFrame.Angles(math.rad(10) - -math.sin(sine/8)/2.3, math.rad(0)*math.cos(sine/1), math.rad(0)  + LeftLeg.RotVelocity.Y / 30, math.cos(25 * math.cos(sine/8))), 0.3)
            elseif position == "Idle" and attacking == false and running == false and not levitate then
                change = .5
                ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, -.2 + -.1 * math.sin(sine/12), 0) * CFrame.Angles(math.rad(0),math.rad(25),math.rad(0)),.1)
                RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.5,.6,-.5) * CFrame.Angles(math.rad(32),math.rad(5 - 1 * math.sin(sine/12)),math.rad(40 - 2 * math.sin(sine/12))), 0.1)
                RIGHTARMLERP.C1 = RIGHTARMLERP.C1:lerp(CFrame.new(-.2,1.2,-.3),.1)
                LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.5,.6,-.5) * CFrame.Angles(math.rad(30),math.rad(-5 + 1 * math.sin(sine/12)),math.rad(-40 + 2 * math.sin(sine/12))), 0.1)
                LEFTARMLERP.C1 = LEFTARMLERP.C1:lerp(CFrame.new(.2,1.2,-.3),.1)
                RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),0,0),.1)
                RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.3, 2 - .1 * math.sin(sine/12), 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-10)), 0.1)
                LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.1)
                LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.3, 2.0 - .1 * math.sin(sine/12), 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(10)), 0.1)
            elseif position == "Idle2" and attacking == false and running == false then
                change = .75
                ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0 - 3 * math.sin(sine/9)),0,0),.1)
                RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),0,0),.1)
                LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(-.2,.2,0) * CFrame.Angles(0,0,0),.1)
                LEFTARMLERP.C1 = CFrame.new(0,0,0) * CFrame.Angles(0,0,0)
                RIGHTARMLERP.C1 = CFrame.new(0,0,0) * CFrame.Angles(0,0,0)
                LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.6, 0.8 - .1 * math.sin(sine/9), 0) * CFrame.Angles(math.rad(0), math.rad(0 + 3 * math.sin(sine/9)), math.rad(35 - 5 * math.sin(sine/9))), 0.4)
                RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.6, 0.8 - .1 * math.sin(sine/9), 0) * CFrame.Angles(math.rad(0), math.rad(0 - 3 * math.sin(sine/9)), math.rad(-35 + 5 * math.sin(sine/9))), 0.4)
                RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.54, 1.4 + .1 * math.sin(sine/9), .4) * CFrame.Angles(math.rad(9 + 2 * math.cos(sine/9)), math.rad(0), math.rad(0)), 0.4)
                LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.5, 2.0,0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-10 + 2 * math.sin(sine/9))), 0.4)
            elseif position == "Walking2" and attacking == false and running == false then
                ws = 50
                ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-20 - 1 * math.sin(sine/9)), math.rad(0 + 0 * math.cos(sine/8)), math.rad(0) + Root.RotVelocity.Y / 30, math.cos(10 * math.cos(sine/10))), 0.3)
                LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.3)
                RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),0,0),.3)
                RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.5,.6,-.5) * CFrame.Angles(math.rad(32),math.rad(5 - .1 * math.sin(sine/12)),math.rad(40 - .5 * math.sin(sine/12))), 0.3)
                RIGHTARMLERP.C1 = RIGHTARMLERP.C1:lerp(CFrame.new(-.2,1.2,-.3),.3)
                LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.5,.6,-.5) * CFrame.Angles(math.rad(30),math.rad(-5 + .1 * math.sin(sine/12)),math.rad(-40 + .5 * math.sin(sine/12))), 0.3)
                LEFTARMLERP.C1 = LEFTARMLERP.C1:lerp(CFrame.new(.2,1.2,-.3),.3)
                RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.54, 1.4 + .1 * math.sin(sine/9), .4) * CFrame.Angles(math.rad(9 + 2 * math.cos(sine/9)), math.rad(0), math.rad(0)), 0.3)
                LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.54, 2.0 + .02 * math.sin(sine/9), 0.2 + .1 * math.sin(sine/9)) * CFrame.Angles(math.rad(25 + 5 * math.sin(sine/9)), math.rad(20), math.rad(0)), 0.3)
            elseif position == "Running" and attacking == false then
                change = 1
                RIGHTARMLERP.C1 = RIGHTARMLERP.C1:lerp(CFrame.new(1.24+.6*math.sin(sine/4)/1.4, 0.54, 0+0.8*math.sin(sine/4)) * CFrame.Angles(math.rad(6-140*math.sin(sine/4)/1.2), math.rad(0), math.rad(-20+70*math.sin(sine/4))), 0.3)
                RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(0, .5, 0)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)), 0.3)
                LEFTARMLERP.C1 = LEFTARMLERP.C1:lerp(CFrame.new(-1.24+.6*math.sin(sine/4)/1.4, 0.54, 0-0.8*math.sin(sine/4))*CFrame.Angles(math.rad(6+140*math.sin(sine/4)/1.2), math.rad(0), math.rad(20+70*math.sin(sine/4))), 0.3)
                LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(0,.5,0)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.3)
                ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, -.2, 0) * CFrame.Angles(math.rad(-20 - 0 * math.sin(sine/4)), math.rad(0 + 6 * math.sin(sine/4)), math.rad(0) + Root.RotVelocity.Y / 30, math.sin(10 * math.sin(sine/4))), 0.3)
                RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,-.2 + .5*-math.sin(sine/4)),.3)
                RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.5, 1.6+0.1*math.sin(sine/4),.7*-math.sin(sine/4)) * CFrame.Angles(math.rad(15+ -50 * math.sin(sine/4)),0,0),.3)
                LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(0,0,-.2 + .5*math.sin(sine/4)),.3)
                LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.5, 1.6-0.1*math.sin(sine/4),.7*math.sin(sine/4)) * CFrame.Angles(math.rad(15 + 50 * math.sin(sine/4)),0,0),.3)
            end
            swait()
        end
    end)
    anims()
    warn("Prepare for a magic trick full of pain and regret. Made by Supr14")
end)

sans.Name = "sans"
sans.Parent = main
sans.BackgroundColor3 = Color3.fromRGB(79, 79, 79)
sans.Position = UDim2.new(0.380645156, 0, 0.467680633, 0)
sans.Size = UDim2.new(0, 74, 0, 45)
sans.Style = Enum.ButtonStyle.RobloxRoundDropdownButton
sans.Font = Enum.Font.SciFi
sans.Text = "SANS"
sans.TextColor3 = Color3.fromRGB(0, 0, 0)
sans.TextSize = 18.000
sans.MouseButton1Down:connect(function()
    HumanDied = false
    local CountSCIFIMOVIELOL = 1
    function SCIFIMOVIELOL(Part0,Part1,Position,Angle)
        local AlignPos = Instance.new('AlignPosition', Part1); AlignPos.Name = "AliP_"..CountSCIFIMOVIELOL
        AlignPos.ApplyAtCenterOfMass = true;
        AlignPos.MaxForce = 5772000--67752;
        AlignPos.MaxVelocity = math.huge/9e110;
        AlignPos.ReactionForceEnabled = false;
        AlignPos.Responsiveness = 200;
        AlignPos.RigidityEnabled = false;
        local AlignOri = Instance.new('AlignOrientation', Part1); AlignOri.Name = "AliO_"..CountSCIFIMOVIELOL
        AlignOri.MaxAngularVelocity = math.huge/9e110;
        AlignOri.MaxTorque = 5772000
        AlignOri.PrimaryAxisOnly = false;
        AlignOri.ReactionTorqueEnabled = false;
        AlignOri.Responsiveness = 200;
        AlignOri.RigidityEnabled = false;
        local AttachmentA=Instance.new('Attachment',Part1); AttachmentA.Name = "Ath_"..CountSCIFIMOVIELOL
        local AttachmentB=Instance.new('Attachment',Part0); AttachmentB.Name = "Ath_"..CountSCIFIMOVIELOL
        AttachmentA.Orientation = Angle or Vector3.new(0,0,0)
        AttachmentA.Position = Position or Vector3.new(0,0,0)
        AlignPos.Attachment1 = AttachmentA;
        AlignPos.Attachment0 = AttachmentB;
        AlignOri.Attachment1 = AttachmentA;
        AlignOri.Attachment0 = AttachmentB;
        CountSCIFIMOVIELOL = CountSCIFIMOVIELOL + 1
        return {AlignPos,AlignOri,AttachmentA,AttachmentB}
    end

    game:FindFirstChildOfClass("Players").LocalPlayer["Character"].Archivable = true
    local hatnameclone = {}
    for _,v in next, game:FindFirstChildOfClass("Players").LocalPlayer["Character"]:GetChildren() do
        if v:IsA("Accessory") then
            if hatnameclone[v.Name] then
                if hatnameclone[v.Name] == "s" then
                    hatnameclone[v.Name] = {}
                end
                table.insert(hatnameclone[v.Name],v)
            else
                hatnameclone[v.Name] = "s"
            end
        end
    end
    for _,v in pairs(hatnameclone) do
        if type(v) == "table" then
            local num = 1
            for _,w in pairs(v) do
                w.Name = w.Name..num
                num = num + 1
            end
        end
    end
    hatnameclone = nil

    local DeadChar = game:FindFirstChildOfClass("Players").LocalPlayer.Character

    local fldr = Instance.new("Folder",game:FindFirstChildOfClass("Players").LocalPlayer["Character"])
    fldr.Name = "DMYF"
    local CloneChar = DeadChar:Clone()
    local ANIMATIONHERE
    if CloneChar:FindFirstChild("Animate") then
        ANIMATIONHERE = CloneChar:FindFirstChild("Animate"):Clone()
        CloneChar:FindFirstChild("Animate"):Destroy()
    end
    if CloneChar:FindFirstChildOfClass("Folder") then CloneChar:FindFirstChildOfClass("Folder"):Destroy() end
    if CloneChar.Torso:FindFirstChild("Neck") then
        local Clonessss = CloneChar.Torso:FindFirstChild("Neck"):Clone()
        Clonessss.Part0 = nil
        Clonessss.Part1 = DeadChar.Head
        Clonessss.Parent = DeadChar.Torso
    end
    CloneChar.Parent = fldr
    CloneChar.HumanoidRootPart.CFrame = DeadChar.HumanoidRootPart.CFrame
    CloneChar.Humanoid.BreakJointsOnDeath = false
    CloneChar.Name = "non"
    CloneChar.Humanoid.DisplayDistanceType = "None"

    for _,v in next, DeadChar:GetChildren() do
        if v:IsA("Accessory") then
            local topacc = false
            if v.Handle:FindFirstChildOfClass("Weld") then v.Handle:FindFirstChildOfClass("Weld"):Destroy() end
            v.Handle.Massless = true
            v.Handle.CanCollide = false
            if v.Handle:FindFirstChildOfClass("Attachment") then
                local ath__ = v.Handle:FindFirstChildOfClass("Attachment")
                if ath__.Name == "HatAttachment" or ath__.Name == "HairAttachment" or ath__.Name == "FaceFrontAttachment" or ath__.Name == "FaceCenterAttachment" then
                    topacc = ath__.Name
                end
            end
            local bv = Instance.new("BodyVelocity",v.Handle)
            bv.Velocity = Vector3.new(0,0,0)
            coroutine.wrap(function()
                if topacc then
                    local allthings = SCIFIMOVIELOL(v.Handle,DeadChar.Torso,Vector3.new(0,1.5,0)+ (DeadChar.Head[topacc].Position + (v.Handle[topacc].Position*-1)),Vector3.new(0,0,0))
                    local normaltop = allthings[1].Attachment1
                    local alipos = allthings[1]
                    local alirot = allthings[2]
                    local p0 = v.Handle
                    local p1 = DeadChar.Head
                    alipos.Parent = CloneChar:FindFirstChild(v.Name).Handle
                    alirot.Parent = CloneChar:FindFirstChild(v.Name).Handle
                    while true do
                        game:GetService("RunService").RenderStepped:wait()
                        if HumanDied then break end
                        coroutine.wrap(function()
                            if alipos.Attachment1 == normaltop then
                                p0.CFrame = p0.CFrame:lerp((((DeadChar.Torso.CFrame * CFrame.new(0,1.5,0)) * p1[topacc].CFrame) * p0[topacc].CFrame:inverse()),1)
                            else
                                v.Handle.CFrame = v.Handle.CFrame:lerp(alipos.Attachment1.Parent.CFrame * CFrame.new(alipos.Attachment1.Position) * CFrame.Angles(math.rad(alipos.Attachment1.Rotation.X),math.rad(alipos.Attachment1.Rotation.Y),math.rad(alipos.Attachment1.Rotation.Z)),1)
                            end
                        end)()
                    end
                else
                    SCIFIMOVIELOL(v.Handle,CloneChar[v.Name].Handle,Vector3.new(0,0,0),Vector3.new(0,0,0))
                end
            end)()
        end
    end

    local a = DeadChar.Torso
    local b = DeadChar.HumanoidRootPart
    local c = DeadChar.Humanoid
    a.Parent = game:FindFirstChildOfClass("Workspace")
    c.Parent = game:FindFirstChildOfClass("Workspace")
    local told = a:Clone()
    local told1 = c:Clone()
    b["RootJoint"].Part0 = told
    b["RootJoint"].Part1 = DeadChar.Head
    a.Name = "torso"
    a.Neck:Destroy()
    c.Name = "Mizt Hub Best"
    told.Parent = DeadChar
    told1.Parent = DeadChar
    DeadChar.PrimaryPart = told
    told1.Health = 0
    b:Destroy()
    a.Parent = DeadChar
    c.Parent = DeadChar
    told:Destroy()
    told1:Destroy()
    a.Name = "Torso"

    if CloneChar.Head:FindFirstChildOfClass("Decal") then CloneChar.Head:FindFirstChildOfClass("Decal").Transparency = 1 end
    if DeadChar:FindFirstChild("Animate") then DeadChar:FindFirstChild("Animate"):Destroy() end

    local Collider
    function UnCollide()
        if HumanDied then Collider:Disconnect(); return end
        for _,Parts in next, CloneChar:GetChildren() do
            if Parts:IsA("BasePart") then
                Parts.CanCollide = false 
            end 
        end
        for _,Parts in next, DeadChar:GetChildren() do
            if Parts:IsA("BasePart") then
                Parts.CanCollide = false
            end 
        end 
    end
    Collider = game:GetService("RunService").Stepped:Connect(UnCollide)

    local resetBindable = Instance.new("BindableEvent")
    resetBindable.Event:connect(function()
        game:GetService("StarterGui"):SetCore("ResetButtonCallback", true)
        resetBindable:Destroy()
        HumanDied = true
        pcall(function()
            game:FindFirstChildOfClass("Players").LocalPlayer.Character = DeadChar
            DeadChar.Head:Destroy()
            DeadChar:FindFirstChildOfClass("Humanoid"):Destroy()
            game:FindFirstChildOfClass("Players").LocalPlayer.Character = CloneChar
            if DeadChar:FindFirstChildOfClass("Folder") then DeadChar:FindFirstChildOfClass("Folder"):Destroy() end
        end)
    end)
    game:GetService("StarterGui"):SetCore("ResetButtonCallback", resetBindable)

    coroutine.wrap(function()
        while true do
            game:GetService("RunService").RenderStepped:wait()
            if not CloneChar or not CloneChar:FindFirstChild("Head") or not CloneChar:FindFirstChildOfClass("Humanoid") or CloneChar:FindFirstChildOfClass("Humanoid").Health <= 0 and not DeadChar or not DeadChar:FindFirstChild("Head") or not DeadChar:FindFirstChildOfClass("Humanoid") or DeadChar:FindFirstChildOfClass("Humanoid").Health <= 0 then 
                HumanDied = true
                pcall(function()
                    game:FindFirstChildOfClass("Players").LocalPlayer.Character = DeadChar
                    DeadChar.Head:Destroy()
                    DeadChar:FindFirstChildOfClass("Humanoid"):Destroy()
                    game:FindFirstChildOfClass("Players").LocalPlayer.Character = CloneChar
                    if DeadChar:FindFirstChildOfClass("Folder") then DeadChar:FindFirstChildOfClass("Folder"):Destroy() end
                end)
                if resetBindable then
                    game:GetService("StarterGui"):SetCore("ResetButtonCallback", true)
                    resetBindable:Destroy()
                end
                break
            end     
        end
    end)()


    SCIFIMOVIELOL(DeadChar["Head"],CloneChar["Head"])
    SCIFIMOVIELOL(DeadChar["Torso"],CloneChar["Torso"])
    SCIFIMOVIELOL(DeadChar["Left Arm"],CloneChar["Left Arm"])
    SCIFIMOVIELOL(DeadChar["Right Arm"],CloneChar["Right Arm"])
    SCIFIMOVIELOL(DeadChar["Left Leg"],CloneChar["Left Leg"])
    SCIFIMOVIELOL(DeadChar["Right Leg"],CloneChar["Right Leg"])

    for _,v in pairs(DeadChar:GetChildren()) do
        if v:IsA("BasePart") and v.Name ~= "Head" then
        --[[local bv = Instance.new("BodyVelocity",v)
        bv.Velocity = Vector3.new(0,0,0)
        coroutine.wrap(function()
            while true do
                game:GetService("RunService").RenderStepped:wait()
                if HumanDied then break end
                v.CFrame = CloneChar[v.Name].CFrame
            end
        end)()]]
        elseif v:IsA("BasePart") and v.Name == "Head" then
            local bv = Instance.new("BodyVelocity",v)
            bv.Velocity = Vector3.new(0,0,0)
            coroutine.wrap(function()
                while true do
                    game:GetService("RunService").RenderStepped:wait()
                    if HumanDied then break end
                    v.CFrame = DeadChar.Torso.CFrame * CFrame.new(0,1.5,0)
                end
            end)()
        end
    end

    for _,BodyParts in next, CloneChar:GetDescendants() do
        if BodyParts:IsA("BasePart") or BodyParts:IsA("Part") then
            BodyParts.Transparency = 1 end end
    game:GetService("RunService").RenderStepped:wait()
    game:FindFirstChildOfClass("Players").LocalPlayer.Character = CloneChar
    game:FindFirstChildOfClass("Workspace"):FindFirstChildOfClass("Camera").CameraSubject = CloneChar.Humanoid

    for _,v in next, DeadChar:GetChildren() do
        if v:IsA("Accessory") then
            if v.Handle:FindFirstChildOfClass("Weld") then v.Handle:FindFirstChildOfClass("Weld"):Destroy() end
        end
    end
    if ANIMATIONHERE then ANIMATIONHERE.Parent = CloneChar end
    s = Instance.new("Sound",Workspace)
    s.Pitch = 1
    s.Volume = 1
    s.SoundId = "rbxassetid://400786493"
    s.Looped = true
    s:Play()
    pls=game:GetService'Players';
    rs=game:GetService'RunService';
    uinps=game:GetService'UserInputService';
    lp=pls.LocalPlayer;
    mouse=lp:GetMouse();
    c=lp.Character;
    rayModel=Instance.new('Model',c);
    human=c.Humanoid;
    Cone=nil;
    human.MaxHealth=5000;
    wait();
    human.Health=5000;
    c.Health:Destroy();
    Debounces={
        FPS=0;
        isAttacking=false;
        isMoving=false;
        isSprinting=false;
        Debounce=false;
        isTyping=false;
        isJumping=false;
        isFlash=false;
        print("FE By Ice & Fire3021")
    };
    numLerp=function(start,goal,alpha)
        return(((goal-start)*alpha)+start);
    end;
    CFrameZero=function()
        return CFrame.new(Vector3.new());
    end;
    local function a()
        local t=tick();
        local l=t%1*3;
        local t=.5*math.pi*(l%1);
        if l<1 then
            return Color3.new(1,1-math.cos(t),1-math.sin(t));
        elseif l<2 then
            return Color3.new(1-math.sin(t),1,1-math.cos(t));
        else
            return Color3.new(1-math.cos(t),1-math.sin(t),1);
        end;
    end;
    rad=function(value)
        return math.rad(value);
    end;
    CFAngles=function(Vector)
        return CFrame.Angles(rad(Vector.x),rad(Vector.y),rad(Vector.z));
    end;
    AnimStat={
        lerpSpeed=.2;
        lerpSpeed2=.35;
        lerpTween=0;
    };
    Joints={
        c.HumanoidRootPart.RootJoint;
        c.Torso.Neck;
        c.Torso['Left Shoulder'];
        c.Torso['Right Shoulder'];
        c.Torso['Left Hip'];
        c.Torso['Right Hip'];
    };
    JointTargets={
        CFrameZero();
        CFrameZero();
        CFrameZero();
        CFrameZero();
        CFrameZero();
        CFrameZero();
    };
    prepareCharacter=function()
        music=Instance.new('Sound',c.HumanoidRootPart);
        music.SoundId='rbxassetid://394144904';
        music.Looped=true;
        music.Volume=.6;
        music2=Instance.new('Sound',c);
        music2.SoundId='rbxassetid://259613634';
        music2.Looped=true;
        music2.Volume=1;
        music3=Instance.new('Sound',c.HumanoidRootPart);
        music3.SoundId='rbxassetid://266530326';
        music3.Looped=true;
        music3.Volume=1;
        music4=Instance.new('Sound',c.HumanoidRootPart);
        music4.SoundId='rbxassetid://155738252';
        music4.Looped=true;
        music4.Volume=1;
        music5=Instance.new('Sound',c.HumanoidRootPart);
        music5.SoundId='rbxassetid://215391212';
        music5.Looped=true;
        music5.Volume=1;
        human.WalkSpeed=0;
        human.JumpPower=0;
        for i,v in pairs(c:children())do
            if v:isA'Hat'then v:Destroy();end;
            if v:FindFirstChild'roblox'then v.roblox:Destroy();end;
            if v.Name=='Head'then v.Transparency=1 for _,x in pairs(v:children())do if x.ClassName=='Sound'then x:Destroy();end;end;end;
            if v:FindFirstChild'face'then v.face:Destroy();end;
            if v:isA'Part'then v.BrickColor=BrickColor.new'White';end;
        end
        local shirt=c:FindFirstChild'Shirt'or Instance.new('Shirt',c);
        local pants=c:FindFirstChild'Pants'or Instance.new('Pants',c);
        shirt.ShirtTemplate='rbxassetid://334755544';
        pants.PantsTemplate='rbxassetid://315964941';
        local Head=Instance.new('Part',c);
        Head.Size=Vector3.new(2.5,2.5,1);
        Head.Transparency=1;
        Head:BreakJoints();
        local hw=Instance.new('Weld',c.Head);
        hw.Part0=c.Head;
        hw.Part1=Head;
        hw.C0=CFrame.new(0,.3,0);
        faceDecal=Instance.new('Decal',Head);
        faceDecal.Face=Enum.NormalId.Front;
        faceDecal.Texture='rbxassetid://400387868';
        local backDecal=Instance.new('Decal',Head);
        backDecal.Face=Enum.NormalId.Back;
        backDecal.Texture='rbxassetid://400377807';
        local mes=Instance.new('BlockMesh',Head);
        mes.Scale=Vector3.new(1,1,.4);
        local Anim=human:FindFirstChild'Animator'
        if Anim then Anim:Destroy();end;
    end;
    setJointCFrames=function(table)
        for i=1,#table do
            JointTargets[i]=table[i];
        end;
    end;
    triWave=function(x)
        local pi2=math.pi/2;
        return math.abs((x/pi2)%4-2)-1;
    end;
    setLerp=function(speed)
        AnimStat.lerpSpeed=speed;
    end;
    setTween=function(tween)
        AnimStat.lerpTween=tween;
    end;
    playSound=function(id,part,vol,pitch)
        local vol=vol or 1;
        local pitch=pitch or 1;
        local x=Instance.new('Sound',part);
        x.Volume=vol;
        x.Pitch=pitch;
        x.SoundId='rbxassetid://'..id;
        spawn(function()
            wait();
            x:Play();
            wait(x.TimeLength+.2);
            x:Destroy();
        end);
    end;
    lerpBoom=function()
        if Cone then
            Cone.CFrame=CFrame.new(c.HumanoidRootPart.CFrame.p,c.HumanoidRootPart.CFrame.p+c.HumanoidRootPart.Velocity)*CFrame.Angles(-math.pi/2,0,0);
            cMesh.Scale=Vector3.new(20,20+c.HumanoidRootPart.Velocity.magnitude/10,20);
            Cone.Transparency=1-c.HumanoidRootPart.Velocity.magnitude/1000;
        else
            Cone=Instance.new('Part',c);
            Cone.Anchored=true;
            Cone.CanCollide=false;
            Cone.Transparency=math.random(50,70)/100;
            Cone.Size=Vector3.new(1,1,1);
            Cone.CFrame=CFrame.new(c.HumanoidRootPart.CFrame.p,c.HumanoidRootPart.CFrame.p+c.HumanoidRootPart.Velocity)*CFrame.Angles(-math.pi/2,0,0);
            cMesh=Instance.new('SpecialMesh',Cone);
            cMesh.MeshId='rbxassetid://1033714';
            cMesh.Scale=Vector3.new(20,50,20);
        end;
    end;
    noBoom=function()
        if Cone then local x=Cone Cone=nil;
            for i=1,20 do
                wait();
                x.Mesh.Scale=x.Mesh.Scale+Vector3.new(-.5,1,-.5);
                x.Transparency=x.Transparency+1/30;
            end;
        end;
    end;
    gasterBlast=function(tCFrame,aimPos,charge)
        local aimTarget;
        if aimPos then
            aimTarget=CFrame.new(tCFrame,aimPos);
        else
            aimTarget=tCFrame;
        end;
        local gast=Instance.new('Part',c);
        gast.Size=Vector3.new(12,.2,12);
        gast.CanCollide=false;
        gast.Anchored=true;
        gast.Transparency=1;
        if charge then
            playSound(400523331,gast,math.random(90,110)/100);
        end;
        wait();
        for i=1,2 do
            local decal=Instance.new('Decal',gast);
            decal.Texture='rbxassetid://323497117';
            if i==1 then
                decal.Face=Enum.NormalId.Top;
            else
                decal.Face=Enum.NormalId.Bottom;
                function k()
                    print("FE By Ice & Fire#3021")
                end
            end;
        end;
        gast.CFrame=CFrame.new(aimTarget.p-Vector3.new(math.sin(tick()*10)*10,20,math.cos(tick()*10)*10));
        spawn(function()
            local tarCFrame=gast.CFrame;
            local isLooping=true;
            spawn(function()
                while rs.RenderStepped:wait()and isLooping do
                    gast.CFrame=gast.CFrame:lerp(tarCFrame,.6/(Debounces.FPS/60));
                end;
            end);
            for i=1,30 do
                wait();
                tarCFrame=gast.CFrame:lerp(aimTarget,.24);
            end;
            playSound(340722848,gast,math.random(90,110)/100);
            isLooping=false;
            wait(.08);
            local ray=Ray.new(aimTarget.p,aimTarget.lookVector.unit*999);
            local _,pos=workspace:FindPartOnRay(ray,c);
            local dis=(aimTarget.p-pos).magnitude;
            local rayCFrame=CFrame.new(gast.CFrame.p+(pos-gast.CFrame.p).unit*(dis/2+200),gast.CFrame.p+(pos-gast.CFrame.p).unit*dis*2)*CFrame.Angles(0,math.pi/2,0);
            local rayPart=Instance.new('Part',rayModel);
            rayPart.Material='Neon';
            rayPart.FormFactor='Custom';
            rayPart.Color=a();
            rayPart.Anchored=true;
            rayPart.CanCollide=false;
            rayPart.Shape='Cylinder';
            rayPart.Size=Vector3.new(dis+400,8,8);
            rayPart.CFrame=rayCFrame;
            gast:Destroy();
        end);
    end;
    largegasterBlast=function(tCFrame,aimPos)
        local aimTarget;
        if aimPos then
            aimTarget=CFrame.new(tCFrame,aimPos);
        else
            aimTarget=tCFrame;
        end;
        local gast=Instance.new('Part',c);
        gast.Size=Vector3.new(25,.2,25);
        gast.CanCollide=false;
        gast.Anchored=true;
        gast.Transparency=1;
        playSound(400523331,gast,math.random(85,97)/100);
        wait();
        for i=1,2 do
            local decal=Instance.new('Decal',gast);
            decal.Texture='rbxassetid://323497117';
            if i==1 then
                decal.Face=Enum.NormalId.Top;
            else
                decal.Face=Enum.NormalId.Bottom;
            end;
        end;
        gast.CFrame=CFrame.new(aimTarget.p-Vector3.new(math.sin(tick()*10)*10,20,math.cos(tick()*10)*10));
        spawn(function()
            local tarCFrame=gast.CFrame;
            local isLooping=true;
            spawn(function()
                while rs.RenderStepped:wait()and isLooping do
                    gast.CFrame=gast.CFrame:lerp(tarCFrame,.6/(Debounces.FPS/60));
                end;
            end);
            for i=1,40 do
                wait();
                tarCFrame=gast.CFrame:lerp(aimTarget,.18);
            end;
            playSound(340722848,gast,math.random(80,95)/100);
            isLooping=false;
            wait(.08);
            local ray=Ray.new(aimTarget.p,aimTarget.lookVector.unit*999);
            local _,pos=workspace:FindPartOnRay(ray,c);
            local dis=(aimTarget.p-pos).magnitude;
            local rayCFrame=CFrame.new(gast.CFrame.p+(pos-gast.CFrame.p).unit*(dis/2+200),gast.CFrame.p+(pos-gast.CFrame.p).unit*dis*2)*CFrame.Angles(0,math.pi/2,0);
            local rayPart=Instance.new('Part',rayModel);
            rayPart.Material='Neon';
            rayPart.FormFactor='Custom';
            rayPart.Color=a();
            rayPart.Anchored=true;
            rayPart.CanCollide=false;
            rayPart.Shape='Cylinder';
            rayPart.Size=Vector3.new(dis+400,17,17);
            rayPart.CFrame=rayCFrame;
            gast:Destroy();
        end);
    end;
    prepareCharacter();
    spawn(function()
        local sine=0;
        while wait()do
            if Debounces.isFlash then
                if(tick()*8)%2>1 then
                    faceDecal.Texture='rbxassetid://400377503';
                else
                    faceDecal.Texture='rbxassetid://400387868';
                end;
            else
                faceDecal.Texture='rbxassetid://400387868';
            end;
            if Debounces.isAttacking==false and Debounces.isMoving==false and Debounces.Debounce==false and Debounces.isJumping==false then
                setLerp(.8);
                local spasm=math.abs(math.sin(tick()*20))*1.1;
                local spasm2=math.abs(math.sin(tick()*20-2))*1.1;
                local spasm3=math.abs(math.sin(tick()*20-2.3))*1.1;
                setJointCFrames({
                    CFrame.new(Vector3.new(0,0-spasm,0))*CFAngles(Vector3.new(0,0,0));
                    CFrame.new(Vector3.new(0,1.5,0))*CFAngles(Vector3.new(-0.011,-0.502,-1.177));
                    CFrame.new(Vector3.new(-1.5-spasm2^2/3,-0.001,0))*CFAngles(Vector3.new(-2.344,7.899,-2.82+spasm3^2*-60));
                    CFrame.new(Vector3.new(1.569+spasm2^2/3,0,-0.1))*CFAngles(Vector3.new(4.822,1.123,6.383+spasm3^2*60));
                    CFrame.new(Vector3.new(-0.61,-2+spasm/1.01,-.15))*CFAngles(Vector3.new(-2.206,0.767,-0.582));
                    CFrame.new(Vector3.new(0.55,-2+spasm/1.01,-.1))*CFAngles(Vector3.new(-0.026,0.463,3.184));
                });
            elseif Debounces.isAttacking==false and Debounces.isMoving==true and Debounces.Debounce==false and Debounces.isSprinting==false and Debounces.isJumping==false then
                sine=tick()*18;
                human.WalkSpeed=120;
                setLerp(.35);
                setJointCFrames({
                    CFrame.new(Vector3.new(0,math.sin(sine)/50-.3,0))*CFAngles(Vector3.new(-30-math.sin(sine*2)*3,math.sin(sine*2)*15,0));
                    CFrame.new(Vector3.new(0,1.48,0.099))*CFAngles(Vector3.new(14.999,-0.001,0));
                    CFrame.new(Vector3.new(-1.5,-0.001,0.2+math.sin(sine*2+math.pi)*1.2))*CFAngles(Vector3.new(-25.001+math.sin(sine*2+math.pi)*-90,0,-15));
                    CFrame.new(Vector3.new(1.5,-0.001,0.2+math.sin(sine*2)*1.2))*CFAngles(Vector3.new(-25+math.sin(sine*2)*-90,-0.001,14.999));
                    CFrame.new(Vector3.new(-0.501,-2+math.cos(sine*2+math.pi)/3,.3+math.sin(sine*2)))*CFAngles(Vector3.new(-25+math.sin(sine*2)*-70,0,-0.001));
                    CFrame.new(Vector3.new(0.499,-2+math.cos(sine*2)/3,.3+math.sin(sine*2+math.pi)))*CFAngles(Vector3.new(-25+math.sin(sine*2)*70,0,0));
                });
            elseif Debounces.isAttacking==false and Debounces.isMoving==true and Debounces.Debounce==false and Debounces.isSprinting==true and Debounces.isJumping==false then
                sine=tick()*28;
                human.WalkSpeed=400;
                lerpBoom();
                setLerp(.65);
                setJointCFrames({
                    CFrame.new(Vector3.new(0,math.sin(sine)/50-.3,0))*CFAngles(Vector3.new(-30-math.sin(sine*2)*3,math.sin(sine*2)*15,0));
                    CFrame.new(Vector3.new(0,1.48,0.099))*CFAngles(Vector3.new(14.999,-0.001,0));
                    CFrame.new(Vector3.new(-1.5,-0.001,0.2+math.sin(sine*2+math.pi)*1.2))*CFAngles(Vector3.new(-25.001+math.sin(sine*2+math.pi)*-90,0,-15));
                    CFrame.new(Vector3.new(1.5,-0.001,0.2+math.sin(sine*2)*1.2))*CFAngles(Vector3.new(-25+math.sin(sine*2)*-90,-0.001,14.999));
                    CFrame.new(Vector3.new(-0.501,-2+math.cos(sine*2+math.pi)/3,.3+math.sin(sine*2)))*CFAngles(Vector3.new(-25+math.sin(sine*2)*-70,0,-0.001));
                    CFrame.new(Vector3.new(0.499,-2+math.cos(sine*2)/3,.3+math.sin(sine*2+math.pi)))*CFAngles(Vector3.new(-25+math.sin(sine*2)*70,0,0));
                });
            elseif Debounces.isJumping==true and Debounces.Debounce==false then
                setLerp(.14);
                human.WalkSpeed=45;
                setJointCFrames({
                    CFrame.new(Vector3.new(0,0,0))*CFAngles(Vector3.new(-8,0,0));
                    CFrame.new(Vector3.new(0,1.5,-0.15))*CFAngles(Vector3.new(-10.138,3.687,0.306));
                    CFrame.new(Vector3.new(-1.23,0.069,-0.56))*CFAngles(Vector3.new(50.809,0.672,18.704));
                    CFrame.new(Vector3.new(0.929,-0.031,-1.0912))*CFAngles(Vector3.new(63.00,13.85,-36.416));
                    CFrame.new(Vector3.new(-0.63,-1.82,-0.74))*CFAngles(Vector3.new(31.324,3.424,-1.249));
                    CFrame.new(Vector3.new(0.619,-1.331,0.82))*CFAngles(Vector3.new(-59.644,0.998,9.776));
                });
            end;
        end;
    end);
    human.Changed:connect(function(prop)
        if prop=='MoveDirection'then
            if human.MoveDirection.magnitude>.02 then
                Debounces.isMoving=true;
            else
                Debounces.isMoving=false;
            end;
        end;
    end);
    uinps.InputBegan:connect(function(InputObj)
        if InputObj.KeyCode==Enum.KeyCode.Slash then
            local finishEvent=nil;
            Debounces.isTyping=true
            finishEvent=uinps.InputBegan:connect(function(InputObj)
                if InputObj.KeyCode==Enum.KeyCode.Return or InputObj.UserInputType==Enum.UserInputType.MouseButton1 then
                    Debounces.isTyping=false;
                    finishEvent:disconnect();
                end;
            end);
        end;
    end);
    mouse.KeyDown:connect(function(key)
        if key=='0'then
            Debounces.isSprinting=true;
            playSound(160248522,c.Torso);
            for i=1,3 do
                spawn(function()
                    local e=Instance.new('Part',c);
                    e.Size=Vector3.new(1,1,1);
                    e.Material='Neon';
                    e.Color=a();
                    e.Anchored=true;
                    e.CFrame=c.HumanoidRootPart.CFrame*CFrame.Angles(0,0,-math.pi/2);
                    e.CanCollide=false;
                    local rm=Instance.new('SpecialMesh',e);
                    rm.MeshType='FileMesh';
                    rm.MeshId='rbxassetid://3270017';
                    rm.Scale=Vector3.new(3.2,3.2,10);
                    for x=1,30 do
                        wait();
                        rm.Scale=rm.Scale:lerp(Vector3.new(i*30,i*30,(4-i)*450),.1);
                        e.Transparency=x/30+.5;
                    end;
                end);
            end;
            c.HumanoidRootPart.Velocity=c.HumanoidRootPart.CFrame.lookVector*200;
        end;
    end);
    mouse.KeyUp:connect(function(key)
        if key==''then
            Debounces.isSprinting=false;
        end;
    end);
    mouse.KeyDown:connect(function(key)
        if key==''then
            playSound(201858087,c.Torso,math.random(90,120)/100);
            local oldPos=c.HumanoidRootPart.CFrame.p;
            local mHit=mouse.Hit.p;
            for i=1,2 do
                spawn(function()
                    local pos
                    if i==1 then pos=oldPos else pos=mHit end
                    local p=Instance.new('Part',workspace);
                    p.Anchored=true;
                    p.CanCollide=false;
                    p.Color=a();
                    p.FormFactor='Custom';
                    p.CFrame=CFrame.new(pos+Vector3.new(0,500,0));
                    p.Transparency=.4;
                    p.Size=Vector3.new(20,1000,20);
                    for i=1,20 do
                        wait();
                        p.Transparency=.4+(i/10)*.6;
                        p.Size=Vector3.new(20-i*1.5,1000,20-i*1.5);
                        p.CFrame=CFrame.new(pos+Vector3.new(0,500,0));
                    end;
                    p:Destroy();
                end);
            end;
            if Debounces.isMoving then
                c.HumanoidRootPart.CFrame=CFrame.new(mouse.Hit.p+Vector3.new(0,4,0),Vector3.new(c.HumanoidRootPart.Velocity.x,mouse.Hit.p.y+4,c.HumanoidRootPart.Velocity.z));
            else
                c.HumanoidRootPart.CFrame=CFrame.new(mouse.Hit.p+Vector3.new(0,4,0),Vector3.new(oldPos.x,mouse.Hit.p.y+4,oldPos.z));
            end;
        end;
    end);
    mouse.KeyDown:connect(function(key)
        if key==''then
            local pointTarget=mouse.Hit.p;
            for i=1,20 do
                wait();
                gasterBlast(CFrame.new(pointTarget+Vector3.new(math.sin(tick()*10)*20,5+math.abs(math.sin(tick()*5)*10),math.cos(tick()*10)*20),pointTarget));
            end;
            wait();
            largegasterBlast(CFrame.new(pointTarget+Vector3.new(0,35,0),pointTarget));
        end;
    end);
    mouse.KeyDown:connect(function(key)
        if key==''then
            local pointTarget=mouse.Hit.p;
            for i=1,20 do
                wait();
                gasterBlast(CFrame.new(c.HumanoidRootPart.CFrame.p+Vector3.new(0,50,0),pointTarget):toWorldSpace(CFrame.new(math.sin(i/2)*(20-i),math.cos(i/2)*(20-i),-i)));
            end;
            largegasterBlast(CFrame.new(c.HumanoidRootPart.CFrame.p+Vector3.new(0,50,0),pointTarget):toWorldSpace(CFrame.new(0,0,-25)));
        end;
    end);
    mouse.Button1Down:connect(function()
        Debounces.isFlash=true;
    end);
    mouse.Button1Up:connect(function()
        Debounces.isFlash=false;
    end);
    mouse.KeyDown:connect(function(key)
        if key==''then
            if music.isPlaying then music:Stop();else music:Play();end;
        end;
    end);
    mouse.KeyDown:connect(function(key)
        if key==''then
            if music2.isPlaying then music2:Stop();else music2:Play();end;
        end;
    end);
    mouse.KeyDown:connect(function(key)
        if key==''then
            if music3.isPlaying then music3:Stop();else music3:Play();end;
        end;
    end);
    mouse.KeyDown:connect(function(key)
        if key==''then
            if music4.isPlaying then music4:Stop();else music4:Play();end;
        end;
    end);
    mouse.KeyDown:connect(function(key)
        if key==''then
            if music5.isPlaying then music4:Stop();else music5:Play();end;
        end;
    end);
    mouse.KeyDown:connect(function(key)
        if key==''then
            gasterBlast(c.Torso.CFrame.p+Vector3.new(math.sin(tick()*10)*10,12,math.cos(tick()*10)*10),mouse.Hit.p,true);
        end;
    end);
    mouse.KeyDown:connect(function(key)
        if key==''then
            largegasterBlast(c.Torso.CFrame.p+Vector3.new(math.sin(tick()*10)*10,12,math.cos(tick()*10)*10),mouse.Hit.p);
        end;
    end);
    mouse.KeyDown:connect(function(key)
        if key==''then
            for i=1,5 do
                wait();
                gasterBlast(c.Torso.CFrame.p+Vector3.new(math.sin(tick()*10)*10,12,math.cos(tick()*10)*10),mouse.Hit.p);
            end;
            largegasterBlast(c.Torso.CFrame.p+Vector3.new(0,25,0),mouse.Hit.p);
        end;
    end);
    mouse.KeyDown:connect(function(key)
        if key==''then
            local pointTarget=mouse.Hit.p;
            for i=1,20 do
                gasterBlast(pointTarget+Vector3.new(math.sin(math.deg((360/40)*i))*(20-i),5+i,math.cos(math.deg((360/40)*i))*(20-i)),pointTarget);
            end;
            wait(.2);
            for i=1,10 do
                largegasterBlast(pointTarget+Vector3.new(math.sin(math.deg((360/20)*i))*25,20,math.cos(math.deg((360/20)*i))*25),pointTarget);
            end;
        end;
    end);
    human.StateChanged:connect(function(os,ns)
        if c.HumanoidRootPart.Velocity.Y<.1 and Debounces.isJumping==true and ns==Enum.HumanoidStateType.Landed then
            Debounces.isJumping=false;
        end;
    end);
    for i=1,#Joints do
        Joints[i].C1=CFrameZero();
    end;
    rs.RenderStepped:connect(function()
        Debounces.FPS=1/rs.RenderStepped:wait();
        if Debounces.FPS<30 then
            Debounces.FPS=30;
        end;
        if Debounces.isSprinting then
            lerpBoom();
        else
            noBoom();
        end;
        for _,v in pairs(rayModel:children())do
            v.Transparency=v.Transparency+.06/(Debounces.FPS/60);
            if v.Transparency>.99 then v:Destroy();return;end;
            v.CanCollide=true;
            local tParts=v:GetTouchingParts();
            v.CanCollide=false;
            local vCFrame=v.CFrame;
            v.Size=v.Size+Vector3.new(0,1,1)/(Debounces.FPS/60);
            v.CFrame=vCFrame;
            for _,x in pairs(tParts)do
                if x and x.Parent and x.Parent:FindFirstChild'Humanoid'and x.Parent.Humanoid:isA'Humanoid'and x.Parent~=c then
                    x.Parent.Humanoid:TakeDamage(1,2);
                end;
            end;
        end;
        local FPSLerp=AnimStat.lerpSpeed/(Debounces.FPS/60);
        for i=1,#Joints do
            Joints[i].C0=Joints[i].C0:lerp(JointTargets[i],FPSLerp);
        end;
    end)
    k()
end)

joy.Name = "joy"
joy.Parent = main
joy.BackgroundColor3 = Color3.fromRGB(79, 79, 79)
joy.Position = UDim2.new(0.680645168, 0, 0.467680633, 0)
joy.Size = UDim2.new(0, 74, 0, 45)
joy.Style = Enum.ButtonStyle.RobloxRoundDropdownButton
joy.Font = Enum.Font.SciFi
joy.Text = "JOY"
joy.TextColor3 = Color3.fromRGB(0, 0, 0)
joy.TextSize = 18.000
joy.MouseButton1Down:connect(function()
    --[[ Please note that some damage functions may cause inconsistant damage between players and must be fixed manually using the DamageRemote I've turned into a comment.
    Don't worry about this if you don't know how as it normally doesn't matter.                                                                                     --]]
    Bypass = "death"
    loadstring(game:GetObjects("rbxassetid://5325226148")[1].Source)()
    local FavIDs = {
        340106355, --Nefl Crystals
        927529620, --Dimension
        876981900, --Fantasy
        398987889, --Ordinary Days
        1117396305, --Oh wait, it's you.
        885996042, --Action Winter Journey
        919231299, --Sprawling Idiot Effigy
        743466274, --Good Day Sunshine
        727411183, --Knife Fight
        1402748531, --The Earth Is Counting On You!
        595230126 --Robot Language
    }



    --The reality of my life isn't real but a Universe -makhail07
    wait(0.2)
    local Player = game:GetService("Players").LocalPlayer
    local lplr = game:GetService("Players").LocalPlayer
    local mouse = Player:GetMouse()
    local char = workspace.non
    local PlayerGui = Player.PlayerGui
    local Cam = workspace.CurrentCamera
    local Backpack = Player.Backpack
    local hum = char.Humanoid
    local hed = char.Head
    local root = char.HumanoidRootPart
    local rootj = root.RootJoint
    local tors = char.Torso
    local ra = char["Right Arm"]
    local la = char["Left Arm"]
    local rl = char["Right Leg"]
    local ll = char["Left Leg"]
    local neck = tors["Neck"]
    local RootCF = CFrame.fromEulerAnglesXYZ(-1.57, 0, 3.14)
    local RHCF = CFrame.fromEulerAnglesXYZ(0, 1.6, 0)
    local LHCF = CFrame.fromEulerAnglesXYZ(0, -1.6, 0)
    local maincolor = BrickColor.new("Really black")

    -------------------------------------------------------
    --Start Good Stuff--
    -------------------------------------------------------
    local cam = game.Workspace.CurrentCamera
    local CF = CFrame.new
    local angles = CFrame.Angles
    local attack = false
    local Euler = CFrame.fromEulerAnglesXYZ
    local Rad = math.rad
    local IT = Instance.new
    local BrickC = BrickColor.new
    local Cos = math.cos
    local Acos = math.acos
    local Sin = math.sin
    local Asin = math.asin
    local Abs = math.abs
    local Mrandom = math.random
    local Floor = math.floor
    local Vt = Vector3.new
    -------------------------------------------------------
    --End Good Stuff--
    -------------------------------------------------------
    local necko = CF(0, 1, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)
    local RW = Instance.new("Weld") 
    local LW = Instance.new("Weld")
    local RH = tors["Right Hip"]
    local LH = tors["Left Hip"]
    RW.Name = "RW"
    RW.Part0 = tors 
    RW.C0 = CF(1.5, 0.5, 0)
    RW.C1 = CF(0, 0.5, 0) 
    RW.Part1 = ra
    RW.Parent = tors 
    LW.Name = "LW"
    LW.Part0 = tors 
    LW.C0 = CF(-1.5, 0.5, 0)
    LW.C1 = CF(0, 0.5, 0) 
    LW.Part1 = la
    LW.Parent = tors
    local Effects = {}
    local joyemoji = Instance.new('ParticleEmitter', tors)
    joyemoji.VelocitySpread = 2000
    joyemoji.Lifetime = NumberRange.new(1)
    joyemoji.Speed = NumberRange.new(40)
    joy= {}
    for i=0, 19 do
        joy[#joy+ 1] = NumberSequenceKeypoint.new(i/19, math.random(1, 1))
    end
    joyemoji.Size = NumberSequence.new(joy)
    joyemoji.Rate = 0
    joyemoji.LockedToPart = false
    joyemoji.LightEmission = 0
    joyemoji.Texture = "rbxassetid://73623723"
    joyemoji.Color = ColorSequence.new(BrickColor.new("Institutional white").Color)

    -------------------------------------------------------
    --Start Important Functions--
    -------------------------------------------------------


    function swait(num)
        if num == 0 or num == nil then
            game:service("RunService").Stepped:wait(0)
        else
            for i = 0, num do
                game:service("RunService").Stepped:wait(0)
            end
        end
    end
    function thread(f)
        coroutine.resume(coroutine.create(f))
    end
    function clerp(a, b, t)
        local qa = {
            QuaternionFromCFrame(a)
        }
        local qb = {
            QuaternionFromCFrame(b)
        }
        local ax, ay, az = a.x, a.y, a.z
        local bx, by, bz = b.x, b.y, b.z
        local _t = 1 - t
        return QuaternionToCFrame(_t * ax + t * bx, _t * ay + t * by, _t * az + t * bz, QuaternionSlerp(qa, qb, t))
    end
    function QuaternionFromCFrame(cf)
        local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components()
        local trace = m00 + m11 + m22
        if trace > 0 then
            local s = math.sqrt(1 + trace)
            local recip = 0.5 / s
            return (m21 - m12) * recip, (m02 - m20) * recip, (m10 - m01) * recip, s * 0.5
        else
            local i = 0
            if m00 < m11 then
                i = 1
            end
            if m22 > (i == 0 and m00 or m11) then
                i = 2
            end
            if i == 0 then
                local s = math.sqrt(m00 - m11 - m22 + 1)
                local recip = 0.5 / s
                return 0.5 * s, (m10 + m01) * recip, (m20 + m02) * recip, (m21 - m12) * recip
            elseif i == 1 then
                local s = math.sqrt(m11 - m22 - m00 + 1)
                local recip = 0.5 / s
                return (m01 + m10) * recip, 0.5 * s, (m21 + m12) * recip, (m02 - m20) * recip
            elseif i == 2 then
                local s = math.sqrt(m22 - m00 - m11 + 1)
                local recip = 0.5 / s
                return (m02 + m20) * recip, (m12 + m21) * recip, 0.5 * s, (m10 - m01) * recip
            end
        end
    end
    function QuaternionToCFrame(px, py, pz, x, y, z, w)
        local xs, ys, zs = x + x, y + y, z + z
        local wx, wy, wz = w * xs, w * ys, w * zs
        local xx = x * xs
        local xy = x * ys
        local xz = x * zs
        local yy = y * ys
        local yz = y * zs
        local zz = z * zs
        return CFrame.new(px, py, pz, 1 - (yy + zz), xy - wz, xz + wy, xy + wz, 1 - (xx + zz), yz - wx, xz - wy, yz + wx, 1 - (xx + yy))
    end
    function QuaternionSlerp(a, b, t)
        local cosTheta = a[1] * b[1] + a[2] * b[2] + a[3] * b[3] + a[4] * b[4]
        local startInterp, finishInterp
        if cosTheta >= 1.0E-4 then
            if 1 - cosTheta > 1.0E-4 then
                local theta = math.acos(cosTheta)
                local invSinTheta = 1 / Sin(theta)
                startInterp = Sin((1 - t) * theta) * invSinTheta
                finishInterp = Sin(t * theta) * invSinTheta
            else
                startInterp = 1 - t
                finishInterp = t
            end
        elseif 1 + cosTheta > 1.0E-4 then
            local theta = math.acos(-cosTheta)
            local invSinTheta = 1 / Sin(theta)
            startInterp = Sin((t - 1) * theta) * invSinTheta
            finishInterp = Sin(t * theta) * invSinTheta
        else
            startInterp = t - 1
            finishInterp = t
        end
        return a[1] * startInterp + b[1] * finishInterp, a[2] * startInterp + b[2] * finishInterp, a[3] * startInterp + b[3] * finishInterp, a[4] * startInterp + b[4] * finishInterp
    end
    function rayCast(Position, Direction, Range, Ignore)
        return game:service("Workspace"):FindPartOnRay(Ray.new(Position, Direction.unit * (Range or 999.999)), Ignore)
    end
    FELOADLIBRARY = {}
    loadstring(game:GetObjects("rbxassetid://5209815302")[1].Source)()
    local Create = FELOADLIBRARY.Create

    function getRegion(point,range,ignore)
        return workspace:FindPartsInRegion3WithIgnoreList(Region3.new(point-Vector3.new(1,1,1)*range/2,point+Vector3.new(1,1,1)*range/2),ignore,100)
    end

    function GetTorso(char)
        return char:FindFirstChild'Torso' or char:FindFirstChild'UpperTorso' or char:FindFirstChild'LowerTorso' or char:FindFirstChild'HumanoidRootPart'
    end

    local M = {C=math.cos,R=math.rad,S=math.sin,P=math.pi,RNG=math.random,MRS=math.randomseed,H=math.huge,RRNG = function(min,max,div) return math.rad(math.random(min,max)/(div or 1)) end}
    -------------------------------------------------------
    --Start Damage Function--
    -------------------------------------------------------
    function Damage(Part, hit, minim, maxim, knockback, Type, Property, Delay, HitSound, HitPitch)
        if hit.Parent == nil then
            return
        end
        local h = hit.Parent:FindFirstChildOfClass("Humanoid")
        for _, v in pairs(hit.Parent:children()) do
            if v:IsA("Humanoid") then
                h = v
            end
        end
        if h ~= nil and hit.Parent.Name ~= char.Name and hit.Parent:FindFirstChild("UpperTorso") ~= nil then

            --hit.Parent:FindFirstChild("Head"):BreakJoints()
        end

        if h ~= nil and hit.Parent.Name ~= char.Name and hit.Parent:FindFirstChild("Torso") ~= nil then
            if hit.Parent:findFirstChild("DebounceHit") ~= nil then
                if hit.Parent.DebounceHit.Value == true then
                    return
                end
            end
            if insta == true then
                --hit.Parent:FindFirstChild("Head"):BreakJoints()
            end
            local c = Create("ObjectValue"){
                Name = "creator",
                Value = Player,
                Parent = h,
            }
            game:GetService("Debris"):AddItem(c, .5)
            if HitSound ~= nil and HitPitch ~= nil then
                CFuncs.Sound.Create(HitSound, hit, 1, HitPitch) 
            end
            local Damage = math.random(minim, maxim)
            local blocked = false
            local block = hit.Parent:findFirstChild("Block")
            if block ~= nil then
                if block.className == "IntValue" then
                    if block.Value > 0 then
                        blocked = true
                        block.Value = block.Value - 1
                        print(block.Value)
                    end
                end
            end
            if blocked == false then
                h.Health = h.Health - Damage
                ShowDamage((Part.CFrame * CFrame.new(0, 0, (Part.Size.Z / 2)).p + Vector3.new(0, 1.5, 0)), -Damage, 1.5, tors.BrickColor.Color)
            else
                h.Health = h.Health - (Damage / 2)
                ShowDamage((Part.CFrame * CFrame.new(0, 0, (Part.Size.Z / 2)).p + Vector3.new(0, 1.5, 0)), -Damage, 1.5, tors.BrickColor.Color)
            end
            if Type == "Knockdown" then
                local hum = hit.Parent.Humanoid
                hum.PlatformStand = true
                coroutine.resume(coroutine.create(function(HHumanoid)
                    swait(1)
                    HHumanoid.PlatformStand = false
                end), hum)
                local angle = (hit.Position - (Property.Position + Vector3.new(0, 0, 0))).unit
                local bodvol = Create("BodyVelocity"){
                    velocity = angle * knockback,
                    P = 5000,
                    maxForce = Vector3.new(8e+003, 8e+003, 8e+003),
                    Parent = hit,
                }
                local rl = Create("BodyAngularVelocity"){
                    P = 3000,
                    maxTorque = Vector3.new(500000, 500000, 500000) * 50000000000000,
                    angularvelocity = Vector3.new(math.random(-10, 10), math.random(-10, 10), math.random(-10, 10)),
                    Parent = hit,
                }
                game:GetService("Debris"):AddItem(bodvol, .5)
                game:GetService("Debris"):AddItem(rl, .5)
            elseif Type == "Normal" then
                local vp = Create("BodyVelocity"){
                    P = 500,
                    maxForce = Vector3.new(math.huge, 0, math.huge),
                    velocity = Property.CFrame.lookVector * knockback + Property.Velocity / 1.05,
                }
                if knockback > 0 then
                    vp.Parent = hit.Parent.Torso
                end
                game:GetService("Debris"):AddItem(vp, .5)
            elseif Type == "Up" then
                local bodyVelocity = Create("BodyVelocity"){
                    velocity = Vector3.new(0, 20, 0),
                    P = 5000,
                    maxForce = Vector3.new(8e+003, 8e+003, 8e+003),
                    Parent = hit,
                }
                game:GetService("Debris"):AddItem(bodyVelocity, .5)
            elseif Type == "DarkUp" then
                coroutine.resume(coroutine.create(function()
                    for i = 0, 1, 0.1 do
                        swait()
                        Effects.Block.Create(BrickColor.new("Black"), hit.Parent.Torso.CFrame, 5, 5, 5, 1, 1, 1, .08, 1)
                    end
                end))
                local bodyVelocity = Create("BodyVelocity"){
                    velocity = Vector3.new(0, 20, 0),
                    P = 5000,
                    maxForce = Vector3.new(8e+003, 8e+003, 8e+003),
                    Parent = hit,
                }
                game:GetService("Debris"):AddItem(bodyVelocity, 1)
            elseif Type == "Snare" then
                local bp = Create("BodyPosition"){
                    P = 2000,
                    D = 100,
                    maxForce = Vector3.new(math.huge, math.huge, math.huge),
                    position = hit.Parent.Torso.Position,
                    Parent = hit.Parent.Torso,
                }
                game:GetService("Debris"):AddItem(bp, 1)
            elseif Type == "Freeze" then
                local BodPos = Create("BodyPosition"){
                    P = 50000,
                    D = 1000,
                    maxForce = Vector3.new(math.huge, math.huge, math.huge),
                    position = hit.Parent.Torso.Position,
                    Parent = hit.Parent.Torso,
                }
                local BodGy = Create("BodyGyro") {
                    maxTorque = Vector3.new(4e+005, 4e+005, 4e+005) * math.huge ,
                    P = 20e+003,
                    Parent = hit.Parent.Torso,
                    cframe = hit.Parent.Torso.CFrame,
                }
                hit.Parent.Torso.Anchored = true
                coroutine.resume(coroutine.create(function(Part) 
                    swait(1.5)
                    Part.Anchored = false
                end), hit.Parent.Torso)
                game:GetService("Debris"):AddItem(BodPos, 3)
                game:GetService("Debris"):AddItem(BodGy, 3)
            end
            local debounce = Create("BoolValue"){
                Name = "DebounceHit",
                Parent = hit.Parent,
                Value = true,
            }
            game:GetService("Debris"):AddItem(debounce, Delay)
            c = Create("ObjectValue"){
                Name = "creator",
                Value = Player,
                Parent = h,
            }
            game:GetService("Debris"):AddItem(c, .5)
        end
    end
    -------------------------------------------------------
    --End Damage Function--
    -------------------------------------------------------

    -------------------------------------------------------
    --Start Damage Function Customization--
    -------------------------------------------------------
    function ShowDamage(Pos, Text, Time, Color)
        local Rate = (1 / 30)
        local Pos = (Pos or Vector3.new(0, 0, 0))
        local Text = (Text or "")
        local Time = (Time or 2)
        local Color = (Color or Color3.new(255, 255, 1))
        local EffectPart = CFuncs.Part.Create(workspace, "SmoothPlastic", 0, 1, BrickColor.new(Color), "Effect", Vector3.new(0, 0, 0))
        EffectPart.Anchored = true
        local BillboardGui = Create("BillboardGui"){
            Size = UDim2.new(3, 0, 3, 0),
            Adornee = EffectPart,
            Parent = EffectPart,
        }
        local TextLabel = Create("TextLabel"){
            BackgroundTransparency = 1,
            Size = UDim2.new(1, 0, 1, 0),
            Text = Text,
            Font = "Bodoni",
            TextColor3 = Color,
            TextScaled = true,
            TextStrokeColor3 = Color3.fromRGB(0,0,0),
            Parent = BillboardGui,
        }
        game.Debris:AddItem(EffectPart, (Time))
        EffectPart.Parent = game:GetService("Workspace")
        delay(0, function()
            local Frames = (Time / Rate)
            for Frame = 1, Frames do
                wait(Rate)
                local Percent = (Frame / Frames)
                EffectPart.CFrame = CFrame.new(Pos) + Vector3.new(0, Percent, 0)
                TextLabel.TextTransparency = Percent
            end
            if EffectPart and EffectPart.Parent then
                EffectPart:Destroy()
            end
        end)
    end
    -------------------------------------------------------
    --End Damage Function Customization--
    -------------------------------------------------------

    function MagniDamage(Part, magni, mindam, maxdam, knock, Type)
        for _, c in pairs(workspace:children()) do
            local hum = c:findFirstChild("Humanoid")
            if hum ~= nil then
                local head = c:findFirstChild("Head")
                if head ~= nil then
                    local targ = head.Position - Part.Position
                    local mag = targ.magnitude
                    if magni >= mag and c.Name ~= plr.Name then
                        Damage(head, head, mindam, maxdam, knock, Type, root, 0.1, "http://www.roblox.com/asset/?id=0", 1.2)
                    end
                end
            end
        end
    end


    CFuncs = {
        Part = {
            Create = function(Parent, Material, Reflectance, Transparency, BColor, Name, Size)
                local Part = Create("Part")({
                    Parent = Parent,
                    Reflectance = Reflectance,
                    Transparency = Transparency,
                    CanCollide = false,
                    Locked = true,
                    BrickColor = BrickColor.new(tostring(BColor)),
                    Name = Name,
                    Size = Size,
                    Material = Material
                })
                RemoveOutlines(Part)
                return Part
            end
        },
        Mesh = {
            Create = function(Mesh, Part, MeshType, MeshId, OffSet, Scale)
                local Msh = Create(Mesh)({
                    Parent = Part,
                    Offset = OffSet,
                    Scale = Scale
                })
                if Mesh == "SpecialMesh" then
                    Msh.MeshType = MeshType
                    Msh.MeshId = MeshId
                end
                return Msh
            end
        },
        Mesh = {
            Create = function(Mesh, Part, MeshType, MeshId, OffSet, Scale)
                local Msh = Create(Mesh)({
                    Parent = Part,
                    Offset = OffSet,
                    Scale = Scale
                })
                if Mesh == "SpecialMesh" then
                    Msh.MeshType = MeshType
                    Msh.MeshId = MeshId
                end
                return Msh
            end
        },
        Weld = {
            Create = function(Parent, Part0, Part1, C0, C1)
                local Weld = Create("Weld")({
                    Parent = Parent,
                    Part0 = Part0,
                    Part1 = Part1,
                    C0 = C0,
                    C1 = C1
                })
                return Weld
            end
        },
        Sound = {
            Create = function(id, par, vol, pit)
                coroutine.resume(coroutine.create(function()
                    local S = Create("Sound")({
                        Volume = vol,
                        Pitch = pit or 1,
                        SoundId = id,
                        Parent = par or workspace
                    })
                    wait()
                    S:play()
                    game:GetService("Debris"):AddItem(S, 6)
                end))
            end
        },
        ParticleEmitter = {
            Create = function(Parent, Color1, Color2, LightEmission, Size, Texture, Transparency, ZOffset, Accel, Drag, LockedToPart, VelocityInheritance, EmissionDirection, Enabled, LifeTime, Rate, Rotation, RotSpeed, Speed, VelocitySpread)
                local fp = Create("ParticleEmitter")({
                    Parent = Parent,
                    Color = ColorSequence.new(Color1, Color2),
                    LightEmission = LightEmission,
                    Size = Size,
                    Texture = Texture,
                    Transparency = Transparency,
                    ZOffset = ZOffset,
                    Acceleration = Accel,
                    Drag = Drag,
                    LockedToPart = LockedToPart,
                    VelocityInheritance = VelocityInheritance,
                    EmissionDirection = EmissionDirection,
                    Enabled = Enabled,
                    Lifetime = LifeTime,
                    Rate = Rate,
                    Rotation = Rotation,
                    RotSpeed = RotSpeed,
                    Speed = Speed,
                    VelocitySpread = VelocitySpread
                })
                return fp
            end
        }
    }
    function RemoveOutlines(part)
        part.TopSurface, part.BottomSurface, part.LeftSurface, part.RightSurface, part.FrontSurface, part.BackSurface = 10, 10, 10, 10, 10, 10
    end
    function CreatePart(FormFactor, Parent, Material, Reflectance, Transparency, BColor, Name, Size)
        local Part = Create("Part")({
            formFactor = FormFactor,
            Parent = Parent,
            Reflectance = Reflectance,
            Transparency = Transparency,
            CanCollide = false,
            Locked = true,
            BrickColor = BrickColor.new(tostring(BColor)),
            Name = Name,
            Size = Size,
            Material = Material
        })
        RemoveOutlines(Part)
        return Part
    end
    function CreateMesh(Mesh, Part, MeshType, MeshId, OffSet, Scale)
        local Msh = Create(Mesh)({
            Parent = Part,
            Offset = OffSet,
            Scale = Scale
        })
        if Mesh == "SpecialMesh" then
            Msh.MeshType = MeshType
            Msh.MeshId = MeshId
        end
        return Msh
    end
    function CreateWeld(Parent, Part0, Part1, C0, C1)
        local Weld = Create("Weld")({
            Parent = Parent,
            Part0 = Part0,
            Part1 = Part1,
            C0 = C0,
            C1 = C1
        })
        return Weld
    end


    -------------------------------------------------------
    --Start Effect Function--
    -------------------------------------------------------
    EffectModel = Instance.new("Model", char)
    Effects = {
        Block = {
            Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay, Type)
                local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
                prt.Anchored = true
                prt.CFrame = cframe
                local msh = CFuncs.Mesh.Create("BlockMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
                game:GetService("Debris"):AddItem(prt, 10)
                if Type == 1 or Type == nil then
                    table.insert(Effects, {
                        prt,
                        "Block1",
                        delay,
                        x3,
                        y3,
                        z3,
                        msh
                    })
                elseif Type == 2 then
                    table.insert(Effects, {
                        prt,
                        "Block2",
                        delay,
                        x3,
                        y3,
                        z3,
                        msh
                    })
                else
                    table.insert(Effects, {
                        prt,
                        "Block3",
                        delay,
                        x3,
                        y3,
                        z3,
                        msh
                    })
                end
            end
        },
        Sphere = {
            Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
                local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
                prt.Anchored = true
                prt.CFrame = cframe
                local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "Sphere", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
                game:GetService("Debris"):AddItem(prt, 10)
                table.insert(Effects, {
                    prt,
                    "Cylinder",
                    delay,
                    x3,
                    y3,
                    z3,
                    msh
                })
            end
        },
        Cylinder = {
            Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
                local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
                prt.Anchored = true
                prt.CFrame = cframe
                local msh = CFuncs.Mesh.Create("CylinderMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
                game:GetService("Debris"):AddItem(prt, 10)
                table.insert(Effects, {
                    prt,
                    "Cylinder",
                    delay,
                    x3,
                    y3,
                    z3,
                    msh
                })
            end
        },
        Wave = {
            Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
                local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
                prt.Anchored = true
                prt.CFrame = cframe
                local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://20329976", Vector3.new(0, 0, 0), Vector3.new(x1 / 60, y1 / 60, z1 / 60))
                game:GetService("Debris"):AddItem(prt, 10)
                table.insert(Effects, {
                    prt,
                    "Cylinder",
                    delay,
                    x3 / 60,
                    y3 / 60,
                    z3 / 60,
                    msh
                })
            end
        },
        Ring = {
            Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
                local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
                prt.Anchored = true
                prt.CFrame = cframe
                local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://3270017", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
                game:GetService("Debris"):AddItem(prt, 10)
                table.insert(Effects, {
                    prt,
                    "Cylinder",
                    delay,
                    x3,
                    y3,
                    z3,
                    msh
                })
            end
        },
        Break = {
            Create = function(brickcolor, cframe, x1, y1, z1)
                local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new(0.5, 0.5, 0.5))
                prt.Anchored = true
                prt.CFrame = cframe * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
                local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "Sphere", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
                local num = math.random(10, 50) / 1000
                game:GetService("Debris"):AddItem(prt, 10)
                table.insert(Effects, {
                    prt,
                    "Shatter",
                    num,
                    prt.CFrame,
                    math.random() - math.random(),
                    0,
                    math.random(50, 100) / 100
                })
            end
        },
        Spiral = {
            Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
                local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
                prt.Anchored = true
                prt.CFrame = cframe
                local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://1051557", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
                game:GetService("Debris"):AddItem(prt, 10)
                table.insert(Effects, {
                    prt,
                    "Cylinder",
                    delay,
                    x3,
                    y3,
                    z3,
                    msh
                })
            end
        },
        Push = {
            Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
                local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
                prt.Anchored = true
                prt.CFrame = cframe
                local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://437347603", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
                game:GetService("Debris"):AddItem(prt, 10)
                table.insert(Effects, {
                    prt,
                    "Cylinder",
                    delay,
                    x3,
                    y3,
                    z3,
                    msh
                })
            end
        }
    }
    function part(formfactor ,parent, reflectance, transparency, brickcolor, name, size)
        local fp = IT("Part")
        fp.formFactor = formfactor 
        fp.Parent = parent
        fp.Reflectance = reflectance
        fp.Transparency = transparency
        fp.CanCollide = false 
        fp.Locked = true
        fp.BrickColor = brickcolor
        fp.Name = name
        fp.Size = size
        fp.Position = tors.Position 
        RemoveOutlines(fp)
        fp.Material = "SmoothPlastic"
        fp:BreakJoints()
        return fp 
    end 

    function mesh(Mesh,part,meshtype,meshid,offset,scale)
        local mesh = IT(Mesh) 
        mesh.Parent = part
        if Mesh == "SpecialMesh" then
            mesh.MeshType = meshtype
            if meshid ~= "nil" then
                mesh.MeshId = "http://www.roblox.com/asset/?id="..meshid
            end
        end
        mesh.Offset = offset
        mesh.Scale = scale
        return mesh
    end

    function Magic(bonuspeed, type, pos, scale, value, color, MType)
        local type = type
        local rng = Instance.new("Part", char)
        rng.Anchored = true
        rng.BrickColor = color
        rng.CanCollide = false
        rng.FormFactor = 3
        rng.Name = "Ring"
        rng.Material = "Neon"
        rng.Size = Vector3.new(1, 1, 1)
        rng.Transparency = 0
        rng.TopSurface = 0
        rng.BottomSurface = 0
        rng.CFrame = pos
        local rngm = Instance.new("SpecialMesh", rng)
        rngm.MeshType = MType
        rngm.Scale = scale
        local scaler2 = 1
        if type == "Add" then
            scaler2 = 1 * value
        elseif type == "Divide" then
            scaler2 = 1 / value
        end
        coroutine.resume(coroutine.create(function()
            for i = 0, 10 / bonuspeed, 0.1 do
                swait()
                if type == "Add" then
                    scaler2 = scaler2 - 0.01 * value / bonuspeed
                elseif type == "Divide" then
                    scaler2 = scaler2 - 0.01 / value * bonuspeed
                end
                rng.Transparency = rng.Transparency + 0.01 * bonuspeed
                rngm.Scale = rngm.Scale + Vector3.new(scaler2 * bonuspeed, scaler2 * bonuspeed, scaler2 * bonuspeed)
            end
            rng:Destroy()
        end))
    end

    function Eviscerate(dude)
        if dude.Name ~= char then
            local val = IT("BoolValue", dude)
            val.Name = "IsHit"
            local ds = coroutine.wrap(function()
                --dude:WaitForChild("Head"):BreakJoints()
                wait(0.5)
                target = nil
                coroutine.resume(coroutine.create(function()
                    for i, v in pairs(dude:GetChildren()) do
                        if v:IsA("Part") or v:IsA("MeshPart") then
                            coroutine.resume(coroutine.create(function()
                                v.CanCollide = false
                                local PartEmmit1 = IT("ParticleEmitter", reye)
                                PartEmmit1.LightEmission = 1
                                PartEmmit1.Texture = "rbxassetid://284205403"
                                PartEmmit1.Color = ColorSequence.new(maincolor.Color)
                                PartEmmit1.Rate = 150
                                PartEmmit1.Lifetime = NumberRange.new(1)
                                PartEmmit1.Size = NumberSequence.new({
                                    NumberSequenceKeypoint.new(0, 0.75, 0),
                                    NumberSequenceKeypoint.new(1, 0, 0)
                                })
                                PartEmmit1.Transparency = NumberSequence.new({
                                    NumberSequenceKeypoint.new(0, 0, 0),
                                    NumberSequenceKeypoint.new(1, 1, 0)
                                })
                                PartEmmit1.Speed = NumberRange.new(0, 0)
                                PartEmmit1.VelocitySpread = 30000
                                PartEmmit1.Rotation = NumberRange.new(-500, 500)
                                PartEmmit1.RotSpeed = NumberRange.new(-500, 500)
                                coroutine.resume(coroutine.create(function()
                                    wait(0.5)
                                    PartEmmit1.Enabled = false
                                    wait(3)
                                end))
                            end))
                        end
                    end
                end))
            end)
            ds()
        end
    end

    function FindNearestHead(Position, Distance, SinglePlayer)
        if SinglePlayer then
            return Distance > (SinglePlayer.Torso.CFrame.p - Position).magnitude
        end
        local List = {}
        for i, v in pairs(workspace:GetChildren()) do
            if v:IsA("Model") and v:findFirstChild("Head") and v ~= char and Distance >= (v.Head.Position - Position).magnitude then
                table.insert(List, v)
            end
        end
        return List
    end

    function Aura(bonuspeed, FastSpeed, type, pos, x1, y1, z1, value, color, outerpos, MType)
        local type = type
        local rng = Instance.new("Part", char)
        rng.Anchored = true
        rng.BrickColor = color
        rng.CanCollide = false
        rng.FormFactor = 3
        rng.Name = "Ring"
        rng.Material = "Neon"
        rng.Size = Vector3.new(1, 1, 1)
        rng.Transparency = 0
        rng.TopSurface = 0
        rng.BottomSurface = 0
        rng.CFrame = pos
        rng.CFrame = rng.CFrame + rng.CFrame.lookVector * outerpos
        local rngm = Instance.new("SpecialMesh", rng)
        rngm.MeshType = MType
        rngm.Scale = Vector3.new(x1, y1, z1)
        local scaler2 = 1
        local speeder = FastSpeed
        if type == "Add" then
            scaler2 = 1 * value
        elseif type == "Divide" then
            scaler2 = 1 / value
        end
        coroutine.resume(coroutine.create(function()
            for i = 0, 10 / bonuspeed, 0.1 do
                swait()
                if type == "Add" then
                    scaler2 = scaler2 - 0.01 * value / bonuspeed
                elseif type == "Divide" then
                    scaler2 = scaler2 - 0.01 / value * bonuspeed
                end
                speeder = speeder - 0.01 * FastSpeed * bonuspeed
                rng.CFrame = rng.CFrame + rng.CFrame.lookVector * speeder * bonuspeed
                rng.Transparency = rng.Transparency + 0.01 * bonuspeed
                rngm.Scale = rngm.Scale + Vector3.new(scaler2 * bonuspeed, scaler2 * bonuspeed, 0)
            end
            rng:Destroy()
        end))
    end

    function SoulSteal(dude)
        if dude.Name ~= char then
            local val = IT("BoolValue", dude)
            val.Name = "IsHit"
            local torso = (dude:FindFirstChild'Head' or dude:FindFirstChild'Torso' or dude:FindFirstChild'UpperTorso' or dude:FindFirstChild'LowerTorso' or dude:FindFirstChild'HumanoidRootPart')
            local soulst = coroutine.wrap(function()
                local soul = Instance.new("Part",dude)
                soul.Size = Vector3.new(1,1,1)
                soul.CanCollide = false
                soul.Anchored = false
                soul.Position = torso.Position
                soul.Transparency = 1
                local PartEmmit1 = IT("ParticleEmitter", soul)
                PartEmmit1.LightEmission = 1
                PartEmmit1.Texture = "rbxassetid://569507414"
                PartEmmit1.Color = ColorSequence.new(maincolor.Color)
                PartEmmit1.Rate = 250
                PartEmmit1.Lifetime = NumberRange.new(1.6)
                PartEmmit1.Size = NumberSequence.new({
                    NumberSequenceKeypoint.new(0, 1, 0),
                    NumberSequenceKeypoint.new(1, 0, 0)
                })
                PartEmmit1.Transparency = NumberSequence.new({
                    NumberSequenceKeypoint.new(0, 0, 0),
                    NumberSequenceKeypoint.new(1, 1, 0)
                })
                PartEmmit1.Speed = NumberRange.new(0, 0)
                PartEmmit1.VelocitySpread = 30000
                PartEmmit1.Rotation = NumberRange.new(-360, 360)
                PartEmmit1.RotSpeed = NumberRange.new(-360, 360)
                local BodPoss = IT("BodyPosition", soul)
                BodPoss.P = 3000
                BodPoss.D = 1000
                BodPoss.maxForce = Vector3.new(50000000000, 50000000000, 50000000000)
                BodPoss.position = torso.Position + Vector3.new(Mrandom(-15, 15), Mrandom(-15, 15), Mrandom(-15, 15))
                wait(1.6)
                soul.Touched:connect(function(hit)
                    if hit.Parent == char then
                        soul:Destroy()
                    end
                end)
                wait(1.2)
                while soul do
                    swait()
                    PartEmmit1.Color = ColorSequence.new(maincolor.Color)
                    BodPoss.Position = tors.Position
                end
            end)
            soulst()
        end
    end
    function FaceMouse()
        local   Cam = workspace.CurrentCamera
        return {
            CFrame.new(char.Torso.Position, Vector3.new(mouse.Hit.p.x, char.Torso.Position.y, mouse.Hit.p.z)),
            Vector3.new(mouse.Hit.p.x, mouse.Hit.p.y, mouse.Hit.p.z)
        }
    end

    BTAUNT = Instance.new("Sound", hed)
    BTAUNT.SoundId = "http://www.roblox.com/asset/?id=1278102150"
    BTAUNT.Volume = 19
    BTAUNT.Pitch = 1
    BTAUNT.Looped = true

    BTAUNT2 = Instance.new("Sound", hed)
    BTAUNT2.Parent = hed
    BTAUNT2.SoundId = "http://www.roblox.com/asset/?id=957602352"
    BTAUNT2.Volume = 20
    BTAUNT2.Pitch = 1
    BTAUNT2.Looped = true

    BTAUNT3 = Instance.new("Sound", char)
    BTAUNT3.SoundId = "http://www.roblox.com/asset/?id=1090127517"
    BTAUNT3.Volume = 2
    BTAUNT3.Pitch = 1
    BTAUNT3.Looped = true

    BTAUNT4 = Instance.new("Sound", tors)
    BTAUNT4.SoundId = "http://www.roblox.com/asset/?id=2658538628"
    BTAUNT4.Volume = 10
    BTAUNT4.Pitch = 3
    BTAUNT4.Looped = true

    BTAUNT5 = Instance.new("Sound", tors)
    BTAUNT5.SoundId = "http://www.roblox.com/asset/?id=1470848774"
    BTAUNT5.Volume = 5
    BTAUNT5.Pitch = 1
    BTAUNT5.Looped = true

    TEST = Instance.new("Sound", tors)
    TEST.SoundId = "http://www.roblox.com/asset/?id=636494529"
    TEST.Volume = 25
    TEST.Pitch = 1
    TEST.Looped = false
    -------------------------------------------------------
    --End Effect Function--
    -------------------------------------------------------

    function CreateMesh(MESH, PARENT, MESHTYPE, MESHID, TEXTUREID, SCALE, OFFSET)
        local NEWMESH = IT(MESH)
        if MESH == "SpecialMesh" then
            NEWMESH.MeshType = MESHTYPE
            if MESHID ~= "nil" and MESHID ~= "" then
                NEWMESH.MeshId = "http://www.roblox.com/asset/?id="..MESHID
            end
            if TEXTUREID ~= "nil" and TEXTUREID ~= "" then
                NEWMESH.TextureId = "http://www.roblox.com/asset/?id="..TEXTUREID
            end
        end
        NEWMESH.Offset = OFFSET or Vt(0, 0, 0)
        NEWMESH.Scale = SCALE
        NEWMESH.Parent = PARENT
        return NEWMESH
    end

    function CreatePart(FORMFACTOR, PARENT, MATERIAL, REFLECTANCE, TRANSPARENCY, BRICKCOLOR, NAME, SIZE)
        local NEWPART = IT("Part")
        NEWPART.formFactor = FORMFACTOR
        NEWPART.Reflectance = REFLECTANCE
        NEWPART.Transparency = TRANSPARENCY
        NEWPART.CanCollide = false
        NEWPART.Locked = true
        NEWPART.BrickColor = BrickC(tostring(BRICKCOLOR))
        NEWPART.Name = NAME
        NEWPART.Size = SIZE
        NEWPART.Position = tors.Position
        NEWPART.Material = MATERIAL
        NEWPART:BreakJoints()
        NEWPART.Parent = PARENT
        return NEWPART
    end

    function MakeForm(PART,TYPE)
        local MSH = nil
        if TYPE == "Cyl" then
            MSH = IT("CylinderMesh",PART)
        elseif TYPE == "Ball" then
            MSH = IT("SpecialMesh",PART)
            MSH.MeshType = "Sphere"
        elseif TYPE == "Wedge" then
            MSH = IT("SpecialMesh",PART)
            MSH.MeshType = "Wedge"
        elseif TYPE == "Block" then
            MSH = IT("SpecialMesh",PART)
            MSH.MeshType = "Brick"
        end
        return MSH
    end

    function Cso(ID, PARENT, VOLUME, PITCH)
        local NSound = nil
        coroutine.resume(coroutine.create(function()
            NSound = IT("Sound", PARENT)
            NSound.Volume = VOLUME
            NSound.Pitch = PITCH
            NSound.SoundId = "http://www.roblox.com/asset/?id="..ID
            swait()
            NSound:play()
            game:GetService("Debris"):AddItem(NSound, 50)
        end))
        return NSound
    end
    function CameraEnshaking(Length, Intensity)
        coroutine.resume(coroutine.create(function()
            local intensity = 1 * Intensity
            local rotM = 0.01 * Intensity
            for i = 0, Length, 0.1 do
                swait()
                intensity = intensity - 0.05 * Intensity / Length
                rotM = rotM - 5.0E-4 * Intensity / Length
                hum.CameraOffset = Vector3.new(Rad(Mrandom(-intensity, intensity)), Rad(Mrandom(-intensity, intensity)), Rad(Mrandom(-intensity, intensity)))
                cam.CFrame = cam.CFrame * CF(Rad(Mrandom(-intensity, intensity)), Rad(Mrandom(-intensity, intensity)), Rad(Mrandom(-intensity, intensity))) * Euler(Rad(Mrandom(-intensity, intensity)) * rotM, Rad(Mrandom(-intensity, intensity)) * rotM, Rad(Mrandom(-intensity, intensity)) * rotM)
            end
            hum.CameraOffset = Vector3.new(0, 0, 0)
        end))
    end


    function Sink(position,radius)
        for i,v in ipairs(workspace:GetChildren()) do
            if v:FindFirstChild("Hit2By"..plr.Name) == nil then
                local body = v:GetChildren()
                for part = 1, #body do
                    if(v:FindFirstChild("Hit2By"..plr.Name) == nil and (body[part].ClassName == "Part" or body[part].ClassName == "MeshPart") and v ~= char) then
                        if(body[part].Position - position).Magnitude < radius then
                            if v.ClassName == "Model" then
                                v:FindFirstChildOfClass("Humanoid").Name = "Humanoid"
                                if v:FindFirstChild("Humanoid") then
                                    local defence = Instance.new("BoolValue",v)
                                    defence.Name = ("Hit2By"..plr.Name)
                                    if v.Humanoid.Health ~= 0 then
                                        local TORS = v:FindFirstChild("HumanoidRootPart") or v:FindFirstChild("Torso") or v:FindFirstChild("UpperTorso")
                                        if TORS ~= nil then
                                            local HITFLOOR2, HITPOS2 = Raycast(TORS.Position, (CF(TORS.Position, TORS.Position + Vector3.new(0, -1, 0))).lookVector, 25 * TORS.Size.Y/2, v)
                                            coroutine.resume(coroutine.create(function()
                                                if HITFLOOR2 ~= nil then
                                                    TORS.Anchored = true
                                                    local Hole2 = CreatePart(3, EffectModel, "Neon", 0, 0, "Really black", "Hole", Vector3.new(TORS.Size.X*4,0,TORS.Size.X*4))
                                                    Hole2.Color = Color3.new(0,0,0)
                                                    local MESH = MakeForm(Hole2,"Cyl")
                                                    MESH.Scale = Vector3.new(0,1,0)
                                                    Hole2.CFrame = CF(HITPOS2)
                                                    for i = 1, 10 do
                                                        swait()
                                                        MESH.Scale = MESH.Scale + Vector3.new(0.1,0,0.1)
                                                    end
                                                    --Cso("160440683", v:FindFirstChild("Head"), 10, .8)
                                                    Cso("154955269", v:FindFirstChild("Head"), 10, 1)
                                                    repeat
                                                        swait()
                                                        TORS.CFrame = TORS.CFrame * CF(0,-0.1,0)
                                                        --MESH.Scale = MESH.Scale + Vector3.new(0,1.6,0)
                                                    until TORS.Position.Y<position.Y-4
                                                    v:remove()
                                                    for i = 1, 10 do
                                                        swait()
                                                        MESH.Scale = MESH.Scale - Vector3.new(0.1,0,0.1)
                                                    end
                                                    Hole2:remove()
                                                end
                                            end))
                                        end
                                    end
                                end
                            end
                            --body[part].Velocity = CFrame.new(position,body[part].Position).lookVector*5*maxstrength
                        end
                    end
                end
            end 
        end
    end
    function Trail(Part)
        local TRAIL = Part:Clone()
        TRAIL.CanCollide = false
        TRAIL.Anchored = true
        TRAIL.Parent = EffectModel
        TRAIL.Name = "Trail"
        local TRANS = Part.Transparency
        coroutine.resume(coroutine.create(function()
            for i = 1, 20 do
                swait()
                TRAIL.Transparency = TRAIL.Transparency + ((1-TRANS)/20)
            end
            TRAIL:remove()
        end))
    end
    function getRegion(point,range,ignore)
        return workspace:FindPartsInRegion3WithIgnoreList(Region3.new(point-Vector3.new(1,1,1)*range/2,point+Vector3.new(1,1,1)*range/2),ignore,100)
    end

    function GetTorso(char)
        return char:FindFirstChild'Torso' or char:FindFirstChild'UpperTorso' or char:FindFirstChild'LowerTorso' or char:FindFirstChild'HumanoidRootPart'
    end

    local M = {C=math.cos,R=math.rad,S=math.sin,P=math.pi,RNG=math.random,MRS=math.randomseed,H=math.huge,RRNG = function(min,max,div) return math.rad(math.random(min,max)/(div or 1)) end}


    function CreateSound(ID, PARENT, VOLUME, PITCH)
        local NSound = nil
        coroutine.resume(coroutine.create(function()
            NSound = Instance.new("Sound", PARENT)
            NSound.Volume = VOLUME
            NSound.Pitch = PITCH
            NSound.SoundId = "http://www.roblox.com/asset/?id="..ID
            swait()
            NSound:play()
            game:GetService("Debris"):AddItem(NSound, 10)
        end))
        return NSound
    end

    -------------------------------------------------------
    --End Important Functions--
    -------------------------------------------------------





    -------------------------------------------------------
    --Start Customization--
    -------------------------------------------------------
    local Player_Size = 1
    if Player_Size ~= 1 then
        root.Size = root.Size * Player_Size
        tors.Size = tors.Size * Player_Size
        hed.Size = hed.Size * Player_Size
        ra.Size = ra.Size * Player_Size
        la.Size = la.Size * Player_Size
        rl.Size = rl.Size * Player_Size
        ll.Size = ll.Size * Player_Size
        ----------------------------------------------------------------------------------
        rootj.Parent = root
        neck.Parent = tors
        RW.Parent = tors
        LW.Parent = tors
        RH.Parent = tors
        LH.Parent = tors
        ----------------------------------------------------------------------------------
        rootj.C0 = RootCF * CF(0 * Player_Size, 0 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(0), Rad(0))
        rootj.C1 = RootCF * CF(0 * Player_Size, 0 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(0), Rad(0))
        neck.C0 = necko * CF(0 * Player_Size, 0 * Player_Size, 0 + ((1 * Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0))
        neck.C1 = CF(0 * Player_Size, -0.5 * Player_Size, 0 * Player_Size) * angles(Rad(-90), Rad(0), Rad(180))
        RW.C0 = CF(1.5 * Player_Size, 0.5 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(0), Rad(0)) --* RIGHTSHOULDERC0
        LW.C0 = CF(-1.5 * Player_Size, 0.5 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(0), Rad(0)) --* LEFTSHOULDERC0
        ----------------------------------------------------------------------------------
        RH.C0 = CF(1 * Player_Size, -1 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(90), Rad(0)) * angles(Rad(0), Rad(0), Rad(0))
        LH.C0 = CF(-1 * Player_Size, -1 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(0)) * angles(Rad(0), Rad(0), Rad(0))
        RH.C1 = CF(0.5 * Player_Size, 1 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(90), Rad(0)) * angles(Rad(0), Rad(0), Rad(0))
        LH.C1 = CF(-0.5 * Player_Size, 1 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(0)) * angles(Rad(0), Rad(0), Rad(0))
        --hat.Parent = Character
    end
    ----------------------------------------------------------------------------------
    ----------------------------------------------------------------------------------
    local equipped = false
    local idle = 0
    local change = 1
    local val = 0
    local toim = 0
    local idleanim = 0.4
    local sine = 0
    local Sit = 1
    ----------------------------------------------------------------------------------
    hum.WalkSpeed = 20
    hum.JumpPower = 57
    ----------------------------------------------------------------------------------
    local Hole = CreatePart(3, EffectModel, "Neon", 0, 0, "Really black", "Hole", Vector3.new(5,0,5))
    local MESH = MakeForm(Hole,"Cyl")


    local BODY = {}
    for _, c in pairs(char:GetDescendants()) do
        if c:IsA("BasePart") and c.Name ~= "Handle" then
            if c ~= root and c ~= tors and c ~= hed and c ~= ra and c ~= la and c ~= rl and c ~= ll then
                c.CustomPhysicalProperties = PhysicalProperties.new(0, 0, 0, 0, 0)
            end
            table.insert(BODY,{c,c.Parent,c.Material,c.Color,c.Transparency,c.Size,c.Name})
        elseif c:IsA("JointInstance") then
            table.insert(BODY,{c,c.Parent,nil,nil,nil,nil,nil})
        end
    end
    for e = 1, #BODY do
        if BODY[e] ~= nil then
            do
                local STUFF = BODY[e]
                local PART = STUFF[1]
                local PARENT = STUFF[2]
                local MATERIAL = STUFF[3]
                local COLOR = STUFF[4]
                local TRANSPARENCY = STUFF[5]
                if PART.ClassName == "Part" and PART ~= root then
                    PART.Material = MATERIAL
                    PART.Transparency = TRANSPARENCY
                end
            --[[PART.AncestryChanged:Connect(function()
                PART.Parent = PARENT
            end)--]]
            end
        end
    end
    function refit()
        coroutine.resume(coroutine.create(function()
            wait()
            hum.Died:connect(refit)
        end))
        char.Parent = workspace
        for e = 1, #BODY do
            if BODY[e] ~= nil then
                local STUFF = BODY[e]
                local PART = STUFF[1]
                local PARENT = STUFF[2]
                local MATERIAL = STUFF[3]
                local COLOR = STUFF[4]
                local TRANSPARENCY = STUFF[5]
                local SIZE = STUFF[6]
                local NAME = STUFF[7]
                if PART.ClassName == "Part" and PART:IsA("BasePart") and PART ~= root then
                    PART.Material = MATERIAL
                    PART.Transparency = TRANSPARENCY
                    PART.Name = NAME
                end
                if PART.Parent ~= PARENT then
                    if PART.Name == "Head" or PART.Name == "Neck" or PART.Name == "Torso" then
                        hum:remove()
                    end
                    PART.Parent = PARENT
                    if PART.Name == "Head" or PART.Name == "Neck" or PART.Name == "Torso" then
                        hum = Instance.new("Humanoid",char)
                    end
                end
            end
        end
    end
    local Regen = {}
    for e = 1, #Regen do
        if Regen[e] ~= nil then
            local STUFF = Regen[e]
            local PART = STUFF[1]
            local PARENT = STUFF[2]
            local MATERIAL = STUFF[3]
            local COLOR = STUFF[4]
            local TRANSPARENCY = STUFF[5]
            if PART.ClassName == "Part" and PART ~= BODY.root then
                PART.Material = MATERIAL
                PART.Color = COLOR
                PART.Transparency = TRANSPARENCY
            end
        --[[PART.AncestryChanged:Connect(function()
            PART.Parent = PARENT
        end)--]]
        end
    end
    function Refit()
        coroutine.resume(coroutine.create(function()
            wait()
            hum.Died:connect(Refit) 
        end))
        for i = 1,#Regen do
            local E = Regen[i]
            local PART = E[1]
            local PARENT = E[2]
            local COLOR = E[3]
            local SIZE = E[4]
            local MATERIAL = E[5]
            if PART:IsA("BasePart") and PART.Parent ~= PARENT then
                PART.Color = COLOR
                PART.Size = SIZE
                PART.Material = MATERIAL
            end
            if PART.Parent ~= PARENT then
                hum.Parent = nil
                PART.Parent = PARENT
                hum.Parent = char
            end
        end
        hum.Parent = char
    end
    function Parents()
        rootj.Parent = root
        neck.Parent = tors
        RW.Parent = tors
        LW.Parent = tors
        RH.Parent = tors
        LH.Parent = tors
        root.Parent = char
        la.Parent = char
        ra.Parent = char
        rl.Parent = char
        ll.Parent = char
        tors.Parent = char
        hed.Parent = char
    end
    local States = {
        "FallingDown";
        "PlatformStanding";
        "Physics";
        "Swimming";
        "Dead";
        "Ragdoll";
        "Seated";
    }
    for i,v in pairs(States) do
        hum:SetStateEnabled(v,false)
    end

    hum.Died:connect(function()
        refit()
        Refit()
        Parents()
    end)
    -------------------------------------------------------
    --End Customization--
    -------------------------------------------------------
    local Blobby = Instance.new("Part", char)
    Blobby.Name = "Blob"
    Blobby.CanCollide = false
    Blobby.BrickColor = BrickColor.new("Deep orange")
    Blobby.Transparency = 0
    Blobby.Material = "Neon"
    Blobby.Size = Vector3.new(1, 1, 2)
    Blobby.TopSurface = Enum.SurfaceType.Smooth
    Blobby.BottomSurface = Enum.SurfaceType.Smooth

    local Weld = Instance.new("Weld", Blobby)
    Weld.Part0 = ra
    Weld.Part1 = Blobby
    Weld.C1 = CFrame.new(0, 1, 0.4)
    Weld.C0 = CFrame.Angles(Rad(0),0,0)

    local M2 = Instance.new("SpecialMesh")
    M2.Parent = Blobby
    M2.MeshId = "rbxassetid://0"
    M2.TextureId = "rbxassetid://749019427"
    M2.Scale = Vector3.new(0.08, 0.08, 0.08)

--[[local naeeym2 = Instance.new("BillboardGui",char)
naeeym2.AlwaysOnTop = true
naeeym2.Size = UDim2.new(5,35,2,15)
naeeym2.StudsOffset = Vector3.new(0, 3.5, 0)
naeeym2.Adornee = hed
naeeym2.Name = "Name"
--naeeym2.PlayerToHideFrom = Player
local tecks2 = Instance.new("TextLabel",naeeym2)
tecks2.BackgroundTransparency = 1
tecks2.TextScaled = true
tecks2.BorderSizePixel = 0
tecks2.Text = "Fight Me"
tecks2.Font = Enum.Font.Bodoni
tecks2.TextSize = 30
tecks2.TextStrokeTransparency = 0
tecks2.TextColor3 = Color3.new(0, 0, 0)
tecks2.TextStrokeColor3 = Color3.new(1, 1, 1)
tecks2.Size = UDim2.new(1,0,0.5,0)
tecks2.Parent = naeeym2]]
    ----------------------------------------------------------------------------------
    local AddInstance = function(Object, ...)
        local Obj = Instance.new(Object)
        for i,v in next,(...) do
            Obj[i] = v
        end
        return Obj
    end
    ----------------------------------------------------


    -------------------------------------------------------

    -------------------------------------------------------
    --Start Attacks N Stuff--
    -------------------------------------------------------


    local naeeym2 = Instance.new("BillboardGui",char)
    naeeym2.AlwaysOnTop = true
    naeeym2.Size = UDim2.new(5,35,2,35)
    naeeym2.StudsOffset = Vector3.new(0,2,0)
    naeeym2.Adornee = hed
    naeeym2.Name = "Name"

    local tecks2 = Instance.new("TextLabel",naeeym2)
    tecks2.BackgroundTransparency = 1
    tecks2.TextScaled = true
    tecks2.BorderSizePixel = 0
    tecks2.Font = "Cartoon"
    tecks2.TextSize = 30
    tecks2.TextStrokeTransparency = 0
    tecks2.TextColor3 = BrickColor.new('Institutional white').Color
    tecks2.TextStrokeColor3 = BrickColor.new('Really black').Color
    tecks2.Size = UDim2.new(1,0,0.5,0)
    tecks2.Parent = naeeym2
    textfag = tecks2
    tecks2.Text = ":joy:"
    BTAUNT2:Play()
    coroutine.resume(coroutine.create(function()
        while textfag ~= nil do
            swait()
            textfag.Position = UDim2.new(math.random(-0.2,0.2),math.random(-3,9),.05,math.random(-10,10))  
            textfag.Rotation = math.random(-1.8,1.8)
        end
    end))

    BTAUNT4 = Instance.new("Sound", char)
    BTAUNT4.SoundId = "http://www.roblox.com/asset/?id=2658538628"
    BTAUNT4.Volume = 10
    BTAUNT4.Pitch = 1
    BTAUNT4.Parent = hed
    BTAUNT4.Looped = false

    BTAUNT7 = Instance.new("Sound", char)
    BTAUNT7.SoundId = "http://www.roblox.com/asset/?id=2770017501"
    BTAUNT7.Volume = 1.5
    BTAUNT7.Pitch = 1
    BTAUNT7.Parent = char
    BTAUNT7.Looped = false

    BTAUNT6 = Instance.new("Sound", char)
    BTAUNT6.SoundId = "http://www.roblox.com/asset/?id=2675983782"
    BTAUNT6.Volume = 10
    BTAUNT6.Pitch = 1
    BTAUNT6.Parent = hed
    BTAUNT6.Looped = false

    BTAUNT5 = Instance.new("Sound", char)
    BTAUNT5.SoundId = "http://www.roblox.com/asset/?id=468944969"
    BTAUNT5.Volume = 3.5
    BTAUNT5.Pitch = 1
    BTAUNT5.Parent = hed
    BTAUNT5.Looped = false

    BTAUNT3 = Instance.new("Sound", char)
    BTAUNT3.SoundId = "http://www.roblox.com/asset/?id=4565988898"
    BTAUNT3.Volume = 2
    BTAUNT3.Pitch = 1
    BTAUNT3.Parent = hed
    BTAUNT3.Looped = false

    function muda()
        for i = 0,0.1,0.1 do
            swait()
            change = 1
            neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(20)), 1)
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-60)), 0.6)
            RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
            LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
        end
        for i = 0,0.1,0.1 do
            swait()
            change = 1
            neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(60)), 0.6)
            RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
            LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
        end
        for i = 0,0.1,0.1 do
            swait()
            change = 1
            neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(20)), 1)
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-60)), 0.6)
            RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
            LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
        end
        for i = 0,0.1,0.1 do
            swait()
            change = 1
            neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(60)), 0.6)
            RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
            LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
        end
        for i = 0,0.1,0.1 do
            swait()
            change = 1
            neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(20)), 1)
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-60)), 0.6)
            RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
            LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
        end
        for i = 0,0.1,0.1 do
            swait()
            change = 1
            neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(60)), 0.6)
            RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
            LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
        end
    end
    function roadroller()
        attack = true
        BTAUNT2:Stop()
        BTAUNT7:Play()
        local Container = Instance.new("Part", char)
        Container.Name = "Blob"
        Container.CanCollide = false
        Container.BrickColor = BrickColor.new("Deep orange")
        Container.Transparency = 0
        Container.Material = "Neon"
        Container.Size = Vector3.new(1, 1, 2)
        Container.TopSurface = Enum.SurfaceType.Smooth
        Container.BottomSurface = Enum.SurfaceType.Smooth

        local aWeld = Instance.new("Weld", Container)
        aWeld.Part0 = tors
        aWeld.Part1 = Container
        aWeld.C1 = CFrame.new(0, 10, 0)
        aWeld.C0 = CFrame.Angles(Rad(0),0,0)

        local M2 = Instance.new("SpecialMesh")
        M2.Parent = Container
        M2.MeshId = "rbxassetid://489989415"
        M2.TextureId = "rbxassetid://489989506"
        M2.Scale = Vector3.new(1, 1, 1)
        for i = 0,67,0.1 do
            swait()
            change = 1
            neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(0)), 1)
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 220* Player_Size) * angles(Rad(0 - 0 * Sin(sine / 1.5)), Rad(0 + 0 * Cos(sine / 1.5)), Rad(0)), 0.6)
            RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(0)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(0)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(0* Cos(sine / 12)), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
            LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(0* Cos(sine / 12)), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
        end
        for i = 0,40,0.1 do
            swait()
            change = 1
            aWeld.C1 = clerp(aWeld.C1, CF(0, -6, 0 + ((1* Player_Size) - 1)) * angles(Rad(90), Rad(0), Rad(0)), 1)
            neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(0)), 1)
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(90 - 0 * Sin(sine / 1.5)), Rad(0 + 0 * Cos(sine / 1.5)), Rad(0)), 0.15)
            RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(0)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(0)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
            LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
        end
        for i = 0,46,0.1 do
            swait()
            change = 1
            root.Anchored = true
            aWeld.Part0 = root
            aWeld.C1 = clerp(aWeld.C1, CF(0, 0.6, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
            Container.Size = Vector3.new(15, 5, 5)
            neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(20), Rad(0)), 0.05)
            RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -0.5* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
            LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -0.5* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
        end
        Container.CanCollide = true
        for i = 0,0.1,0.1 do
            swait()
            change = 1
            root.Anchored = false
            aWeld.C1 = clerp(aWeld.C1, CF(0, 0.5, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
            aWeld.Part0 = root
            neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(20)), 1)
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-60)), 0.6)
            RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
            LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
        end
        for i = 0,0.1,0.1 do
            swait()
            change = 1
            aWeld.C1 = clerp(aWeld.C1, CF(.3, 0, 0.5 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
            aWeld.Part0 = root
            neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(60)), 0.6)
            RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
            LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
        end
        for i = 0,0.1,0.1 do
            swait()
            change = 1
            aWeld.C1 = clerp(aWeld.C1, CF(0.8, 0.4, 0.3 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
            aWeld.Part0 = root
            neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(20)), 1)
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-60)), 0.6)
            RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
            LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
        end
        for i = 0,0.1,0.1 do
            swait()
            change = 1
            aWeld.C1 = clerp(aWeld.C1, CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
            aWeld.Part0 = root
            neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(60)), 0.6)
            RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
            LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
        end
        for i = 0,0.1,0.1 do
            swait()
            change = 1
            aWeld.C1 = clerp(aWeld.C1, CF(0, 0.5, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
            aWeld.Part0 = root
            neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(20)), 1)
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-60)), 0.6)
            RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
            LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
        end
        for i = 0,0.1,0.1 do
            swait()
            change = 1
            aWeld.C1 = clerp(aWeld.C1, CF(.3, 0, 0.5 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
            aWeld.Part0 = root
            neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(60)), 0.6)
            RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
            LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
        end
        for i = 0,0.1,0.1 do
            swait()
            change = 1
            aWeld.C1 = clerp(aWeld.C1, CF(0.8, 0.4, 0.3 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
            aWeld.Part0 = root
            neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(20)), 1)
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-60)), 0.6)
            RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
            LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
        end
        for i = 0,0.1,0.1 do
            swait()
            change = 1
            aWeld.C1 = clerp(aWeld.C1, CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
            aWeld.Part0 = root
            neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(60)), 0.6)
            RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
            LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
        end
        for i = 0,0.1,0.1 do
            swait()
            change = 1
            aWeld.C1 = clerp(aWeld.C1, CF(0, 0.5, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
            aWeld.Part0 = root
            neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(20)), 1)
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-60)), 0.6)
            RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
            LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
        end
        for i = 0,0.1,0.1 do
            swait()
            change = 1
            aWeld.C1 = clerp(aWeld.C1, CF(.3, 0, 0.5 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
            aWeld.Part0 = root
            neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(60)), 0.6)
            RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
            LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
        end
        for i = 0,0.1,0.1 do
            swait()
            change = 1
            aWeld.C1 = clerp(aWeld.C1, CF(0.8, 0.4, 0.3 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
            aWeld.Part0 = root
            neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(20)), 1)
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-60)), 0.6)
            RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
            LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
        end
        for i = 0,0.1,0.1 do
            swait()
            change = 1
            aWeld.C1 = clerp(aWeld.C1, CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
            aWeld.Part0 = root
            neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(60)), 0.6)
            RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
            LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
        end
        for i = 0,0.1,0.1 do
            swait()
            change = 1
            aWeld.C1 = clerp(aWeld.C1, CF(0, 0.5, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
            aWeld.Part0 = root
            neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(20)), 1)
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-60)), 0.6)
            RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
            LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
        end
        for i = 0,0.1,0.1 do
            swait()
            change = 1
            aWeld.C1 = clerp(aWeld.C1, CF(.3, 0, 0.5 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
            aWeld.Part0 = root
            neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(60)), 0.6)
            RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
            LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
        end
        for i = 0,0.1,0.1 do
            swait()
            change = 1
            aWeld.C1 = clerp(aWeld.C1, CF(0.8, 0.4, 0.3 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
            aWeld.Part0 = root
            neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(20)), 1)
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-60)), 0.6)
            RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
            LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
        end
        for i = 0,0.1,0.1 do
            swait()
            change = 1
            aWeld.C1 = clerp(aWeld.C1, CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
            aWeld.Part0 = root
            neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(60)), 0.6)
            RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
            LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
        end
        for i = 0,0.1,0.1 do
            swait()
            change = 1
            aWeld.C1 = clerp(aWeld.C1, CF(0, 0.5, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
            aWeld.Part0 = root
            neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(20)), 1)
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-60)), 0.6)
            RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
            LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
        end
        for i = 0,0.1,0.1 do
            swait()
            change = 1
            aWeld.C1 = clerp(aWeld.C1, CF(.3, 0, 0.5 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
            aWeld.Part0 = root
            neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(60)), 0.6)
            RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
            LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
        end
        for i = 0,0.1,0.1 do
            swait()
            change = 1
            aWeld.C1 = clerp(aWeld.C1, CF(0.8, 0.4, 0.3 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
            aWeld.Part0 = root
            neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(20)), 1)
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-60)), 0.6)
            RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
            LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
        end
        for i = 0,0.1,0.1 do
            swait()
            change = 1
            aWeld.C1 = clerp(aWeld.C1, CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
            aWeld.Part0 = root
            neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(60)), 0.6)
            RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
            LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
        end
        for i = 0,0.1,0.1 do
            swait()
            change = 1
            aWeld.C1 = clerp(aWeld.C1, CF(0, 0.5, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
            aWeld.Part0 = root
            neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(20)), 1)
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-60)), 0.6)
            RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
            LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
        end
        for i = 0,0.1,0.1 do
            swait()
            change = 1
            aWeld.C1 = clerp(aWeld.C1, CF(.3, 0, 0.5 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
            aWeld.Part0 = root
            neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(60)), 0.6)
            RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
            LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
        end
        for i = 0,0.1,0.1 do
            swait()
            change = 1
            aWeld.C1 = clerp(aWeld.C1, CF(0.8, 0.4, 0.3 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
            aWeld.Part0 = root
            neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(20)), 1)
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-60)), 0.6)
            RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
            LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
        end
        for i = 0,0.1,0.1 do
            swait()
            change = 1
            aWeld.C1 = clerp(aWeld.C1, CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
            aWeld.Part0 = root
            neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(60)), 0.6)
            RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
            LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
        end
        for i = 0,0.1,0.1 do
            swait()
            change = 1
            aWeld.C1 = clerp(aWeld.C1, CF(0, 0.5, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
            aWeld.Part0 = root
            neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(20)), 1)
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-60)), 0.6)
            RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
            LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
        end
        for i = 0,0.1,0.1 do
            swait()
            change = 1
            aWeld.C1 = clerp(aWeld.C1, CF(.3, 0, 0.5 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
            aWeld.Part0 = root
            neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(60)), 0.6)
            RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
            LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
        end
        for i = 0,0.1,0.1 do
            swait()
            change = 1
            aWeld.C1 = clerp(aWeld.C1, CF(0.8, 0.4, 0.3 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
            aWeld.Part0 = root
            neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(20)), 1)
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-60)), 0.6)
            RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
            LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
        end
        for i = 0,0.1,0.1 do
            swait()
            change = 1
            aWeld.C1 = clerp(aWeld.C1, CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
            aWeld.Part0 = root
            neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(60)), 0.6)
            RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
            LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
        end
        for i = 0,0.1,0.1 do
            swait()
            change = 1
            aWeld.C1 = clerp(aWeld.C1, CF(0, 0.5, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
            aWeld.Part0 = root
            neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(20)), 1)
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-60)), 0.6)
            RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
            LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
        end
        for i = 0,0.1,0.1 do
            swait()
            change = 1
            aWeld.C1 = clerp(aWeld.C1, CF(.3, 0, 0.5 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
            aWeld.Part0 = root
            neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(60)), 0.6)
            RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
            LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
        end
        for i = 0,0.1,0.1 do
            swait()
            change = 1
            aWeld.C1 = clerp(aWeld.C1, CF(0.8, 0.4, 0.3 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
            aWeld.Part0 = root
            neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(20)), 1)
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-60)), 0.6)
            RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
            LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
        end
        for i = 0,0.1,0.1 do
            swait()
            change = 1
            aWeld.C1 = clerp(aWeld.C1, CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
            aWeld.Part0 = root
            neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(60)), 0.6)
            RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
            LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
        end
        for i = 0,0.1,0.1 do
            swait()
            change = 1
            aWeld.C1 = clerp(aWeld.C1, CF(0, 0.5, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
            aWeld.Part0 = root
            neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(20)), 1)
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-60)), 0.6)
            RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
            LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
        end
        for i = 0,0.1,0.1 do
            swait()
            change = 1
            aWeld.C1 = clerp(aWeld.C1, CF(.3, 0, 0.5 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
            aWeld.Part0 = root
            neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(60)), 0.6)
            RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
            LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
        end
        for i = 0,0.1,0.1 do
            swait()
            change = 1
            aWeld.C1 = clerp(aWeld.C1, CF(0.8, 0.4, 0.3 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
            aWeld.Part0 = root
            neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(20)), 1)
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-60)), 0.6)
            RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
            LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
        end
        for i = 0,0.1,0.1 do
            swait()
            change = 1
            aWeld.C1 = clerp(aWeld.C1, CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
            aWeld.Part0 = root
            neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(60)), 0.6)
            RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
            LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
        end
        for i = 0,0.1,0.1 do
            swait()
            change = 1
            aWeld.C1 = clerp(aWeld.C1, CF(0, 0.5, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
            aWeld.Part0 = root
            neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(20)), 1)
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-60)), 0.6)
            RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
            LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
        end
        for i = 0,0.1,0.1 do
            swait()
            change = 1
            aWeld.C1 = clerp(aWeld.C1, CF(.3, 0, 0.5 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
            aWeld.Part0 = root
            neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(60)), 0.6)
            RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
            LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
        end
        for i = 0,0.1,0.1 do
            swait()
            change = 1
            aWeld.C1 = clerp(aWeld.C1, CF(0.8, 0.4, 0.3 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
            aWeld.Part0 = root
            neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(20)), 1)
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-60)), 0.6)
            RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
            LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
        end
        for i = 0,0.1,0.1 do
            swait()
            change = 1
            aWeld.C1 = clerp(aWeld.C1, CF(0, 0, 0.6 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
            aWeld.Part0 = root
            neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(60)), 0.6)
            RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
            LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
        end
        for i = 0,0.1,0.1 do
            swait()
            change = 1
            aWeld.C1 = clerp(aWeld.C1, CF(0, 0.5, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
            aWeld.Part0 = root
            neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(20)), 1)
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-60)), 0.6)
            RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
            LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
        end
        for i = 0,0.1,0.1 do
            swait()
            change = 1
            aWeld.C1 = clerp(aWeld.C1, CF(0.6, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
            aWeld.Part0 = root
            neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(60)), 0.6)
            RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
            LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
        end
        for i = 0,0.1,0.1 do
            swait()
            change = 1
            aWeld.C1 = clerp(aWeld.C1, CF(0, 0.5, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
            aWeld.Part0 = root
            neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(20)), 1)
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-60)), 0.6)
            RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
            LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
        end
        for i = 0,0.1,0.1 do
            swait()
            change = 1
            aWeld.C1 = clerp(aWeld.C1, CF(0, 0, 0.5 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
            aWeld.Part0 = root
            neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(60)), 0.6)
            RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
            LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
        end
        for i = 0,0.1,0.1 do
            swait()
            change = 1
            aWeld.C1 = clerp(aWeld.C1, CF(0, -1, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
            aWeld.Part0 = root
            neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(20)), 1)
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-60)), 0.6)
            RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
            LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
        end
        for i = 0,0.1,0.1 do
            swait()
            change = 1
            aWeld.C1 = clerp(aWeld.C1, CF(0, 0, 0.5 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
            aWeld.Part0 = root
            neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(60)), 0.6)
            RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
            LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
        end
        for i = 0,0.1,0.1 do
            swait()
            change = 1
            aWeld.C1 = clerp(aWeld.C1, CF(1, 0, 0.1 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
            aWeld.Part0 = root
            neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(20)), 1)
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-60)), 0.6)
            RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
            LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
        end
        for i = 0,0.1,0.1 do
            swait()
            change = 1
            aWeld.C1 = clerp(aWeld.C1, CF(0.5, 0.1, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
            aWeld.Part0 = root
            neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(60)), 0.6)
            RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
            LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
        end
        for i = 0,0.1,0.1 do
            swait()
            change = 1
            aWeld.C1 = clerp(aWeld.C1, CF(0, 0.5, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
            aWeld.Part0 = root
            neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(20)), 1)
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-60)), 0.6)
            RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
            LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
        end
        for i = 0,0.1,0.1 do
            swait()
            change = 1
            aWeld.C1 = clerp(aWeld.C1, CF(0.4, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
            aWeld.Part0 = root
            neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(60)), 0.6)
            RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
            LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
        end
        for i = 0,0.1,0.1 do
            swait()
            change = 1
            aWeld.C1 = clerp(aWeld.C1, CF(0, 0.6, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
            aWeld.Part0 = root
            neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(20)), 1)
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-60)), 0.6)
            RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
            LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
        end
        for i = 0,0.1,0.1 do
            swait()
            change = 1
            aWeld.C1 = clerp(aWeld.C1, CF(0.4, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
            aWeld.Part0 = root
            neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(60)), 0.6)
            RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
            LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
        end
        for i = 0,0.1,0.1 do
            swait()
            change = 1
            aWeld.C1 = clerp(aWeld.C1, CF(0, -0.5, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
            aWeld.Part0 = root
            neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(20)), 1)
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-60)), 0.6)
            RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
            LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
        end
        for i = 0,0.1,0.1 do
            swait()
            change = 1
            aWeld.C1 = clerp(aWeld.C1, CF(0, 1, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
            aWeld.Part0 = root
            neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(60)), 0.6)
            RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
            LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
        end
        for i = 0,0.1,0.1 do
            swait()
            change = 1
            aWeld.C1 = clerp(aWeld.C1, CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
            aWeld.Part0 = root
            neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(20)), 1)
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-60)), 0.6)
            RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
            LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
        end
        for i = 0,0.1,0.1 do
            swait()
            change = 1
            aWeld.C1 = clerp(aWeld.C1, CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
            aWeld.Part0 = root
            neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(60)), 0.6)
            RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
            LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
        end
        for i = 0,0.1,0.1 do
            swait()
            change = 1
            aWeld.C1 = clerp(aWeld.C1, CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
            aWeld.Part0 = root
            neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(20)), 1)
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-60)), 0.6)
            RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
            LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
        end
        for i = 0,0.1,0.1 do
            swait()
            change = 1
            aWeld.C1 = clerp(aWeld.C1, CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
            aWeld.Part0 = root
            neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(60)), 0.6)
            RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
            LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
        end
        for i = 0,0.1,0.1 do
            swait()
            change = 1
            aWeld.C1 = clerp(aWeld.C1, CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
            aWeld.Part0 = root
            neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(20)), 1)
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-60)), 0.6)
            RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
            LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
        end
        for i = 0,0.1,0.1 do
            swait()
            change = 1
            aWeld.C1 = clerp(aWeld.C1, CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
            aWeld.Part0 = root
            neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(60)), 0.6)
            RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
            LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
        end
        for i = 0,0.1,0.1 do
            swait()
            change = 1
            aWeld.C1 = clerp(aWeld.C1, CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
            aWeld.Part0 = root
            neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(20)), 1)
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-60)), 0.6)
            RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
            LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
        end
        for i = 0,0.1,0.1 do
            swait()
            change = 1
            aWeld.C1 = clerp(aWeld.C1, CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
            aWeld.Part0 = root
            neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(60)), 0.6)
            RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
            LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
        end
        for i = 0,0.1,0.1 do
            swait()
            change = 1
            aWeld.C1 = clerp(aWeld.C1, CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
            aWeld.Part0 = root
            neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(20)), 1)
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-60)), 0.6)
            RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
            LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
        end
        for i = 0,0.1,0.1 do
            swait()
            change = 1
            aWeld.C1 = clerp(aWeld.C1, CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
            aWeld.Part0 = root
            neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(60)), 0.6)
            RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
            LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
        end
        for i = 0,0.1,0.1 do
            swait()
            change = 1
            aWeld.C1 = clerp(aWeld.C1, CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
            aWeld.Part0 = root
            neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(20)), 1)
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-60)), 0.6)
            RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
            LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
        end
        for i = 0,0.1,0.1 do
            swait()
            change = 1
            aWeld.C1 = clerp(aWeld.C1, CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
            aWeld.Part0 = root
            neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(60)), 0.6)
            RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
            LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
        end
        for i = 0,0.1,0.1 do
            swait()
            change = 1
            aWeld.C1 = clerp(aWeld.C1, CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
            aWeld.Part0 = root
            neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(20)), 1)
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-60)), 0.6)
            RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
            LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
        end
        for i = 0,0.1,0.1 do
            swait()
            change = 1
            aWeld.C1 = clerp(aWeld.C1, CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
            aWeld.Part0 = root
            neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(60)), 0.6)
            RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
            LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
        end
        for i = 0,0.1,0.1 do
            swait()
            change = 1
            aWeld.C1 = clerp(aWeld.C1, CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
            aWeld.Part0 = root
            neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(20)), 1)
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-60)), 0.6)
            RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
            LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
        end
        for i = 0,0.1,0.1 do
            swait()
            change = 1
            aWeld.C1 = clerp(aWeld.C1, CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
            aWeld.Part0 = root
            neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(60)), 0.6)
            RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
            LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
        end
        for i = 0,0.1,0.1 do
            swait()
            change = 1
            aWeld.C1 = clerp(aWeld.C1, CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
            aWeld.Part0 = root
            neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(20)), 1)
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-60)), 0.6)
            RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
            LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
        end
        for i = 0,0.1,0.1 do
            swait()
            change = 1
            aWeld.C1 = clerp(aWeld.C1, CF(0, 0.8        , 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
            aWeld.Part0 = root
            neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(60)), 0.6)
            RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
            LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
        end
        for i = 0,0.1,0.1 do
            swait()
            change = 1
            aWeld.C1 = clerp(aWeld.C1, CF(0, 0.8, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
            aWeld.Part0 = root
            neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(20)), 1)
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-60)), 0.6)
            RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
            LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
        end
        for i = 0,0.1,0.1 do
            swait()
            change = 1
            aWeld.C1 = clerp(aWeld.C1, CF(0, 0.5, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
            aWeld.Part0 = root
            neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(60)), 0.6)
            RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
            LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
        end
        for i = 0,0.1,0.1 do
            swait()
            change = 1
            aWeld.C1 = clerp(aWeld.C1, CF(0, 0.7, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
            aWeld.Part0 = root
            neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(20)), 1)
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-60)), 0.6)
            RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
            LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
        end
        for i = 0,0.1,0.1 do
            swait()
            change = 1
            aWeld.C1 = clerp(aWeld.C1, CF(0, 0.5, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
            aWeld.Part0 = root
            neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(60)), 0.6)
            RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
            LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
        end
        for i = 0,0.1,0.1 do
            swait()
            change = 1
            aWeld.C1 = clerp(aWeld.C1, CF(0, 0, 0.9 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
            aWeld.Part0 = root
            neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(20)), 1)
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-60)), 0.6)
            RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
            LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
        end
        for i = 0,0.1,0.1 do
            swait()
            change = 1
            aWeld.C1 = clerp(aWeld.C1, CF(0, 1, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
            aWeld.Part0 = root
            neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(60)), 0.6)
            RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
            LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
        end
        for i = 0,0.1,0.1 do
            swait()
            change = 1
            aWeld.C1 = clerp(aWeld.C1, CF(0.8, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
            aWeld.Part0 = root
            neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(20)), 1)
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-60)), 0.6)
            RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
            LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
        end
        for i = 0,0.1,0.1 do
            swait()
            change = 1
            aWeld.C1 = clerp(aWeld.C1, CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
            aWeld.Part0 = root
            neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(60)), 0.6)
            RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
            LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
        end
        for i = 0,0.1,0.1 do
            swait()
            change = 1
            aWeld.C1 = clerp(aWeld.C1, CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
            aWeld.Part0 = root
            neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(20)), 1)
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-60)), 0.6)
            RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
            LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
        end
        for i = 0,0.1,0.1 do
            swait()
            change = 1
            aWeld.C1 = clerp(aWeld.C1, CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
            aWeld.Part0 = root
            neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(60)), 0.6)
            RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
            LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
        end
        for i = 0,0.1,0.1 do
            swait()
            change = 1
            aWeld.C1 = clerp(aWeld.C1, CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
            aWeld.Part0 = root
            neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(20)), 1)
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-60)), 0.6)
            RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
            LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
        end
        for i = 0,0.1,0.1 do
            swait()
            change = 1
            aWeld.C1 = clerp(aWeld.C1, CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
            aWeld.Part0 = root
            neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(60)), 0.6)
            RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
            LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
        end
        for i = 0,0.1,0.1 do
            swait()
            change = 1
            aWeld.C1 = clerp(aWeld.C1, CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
            aWeld.Part0 = root
            neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(20)), 1)
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-60)), 0.6)
            RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
            LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
        end
        for i = 0,0.1,0.1 do
            swait()
            change = 1
            aWeld.C1 = clerp(aWeld.C1, CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
            aWeld.Part0 = root
            neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-20)), 1)
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(60)), 0.6)
            RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, -3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
            LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 3* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
        end
        muda()
        aWeld.C1 = clerp(aWeld.C1, CF(.3, 0, 0.5 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
        muda()
        aWeld.C1 = clerp(aWeld.C1, CF(.1, .6, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
        muda()
        aWeld.C1 = clerp(aWeld.C1, CF(.6, -0.4, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
        muda()
        aWeld.C1 = clerp(aWeld.C1, CF(.3, 0, 0.5 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
        muda()
        aWeld.C1 = clerp(aWeld.C1, CF(.1, .6, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
        muda()
        aWeld.C1 = clerp(aWeld.C1, CF(.6, -0.4, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
        muda()
        aWeld.C1 = clerp(aWeld.C1, CF(.3, 0, 0.5 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
        muda()
        aWeld.C1 = clerp(aWeld.C1, CF(.1, .6, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
        muda()
        aWeld.C1 = clerp(aWeld.C1, CF(.6, -0.4, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
        muda()
        aWeld.C1 = clerp(aWeld.C1, CF(.3, 0, 0.5 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
        muda()
        aWeld.C1 = clerp(aWeld.C1, CF(.1, .6, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
        muda()
        aWeld.C1 = clerp(aWeld.C1, CF(.6, -0.4, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
        muda()
        aWeld.C1 = clerp(aWeld.C1, CF(.3, 0, 0.5 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
        muda()
        aWeld.C1 = clerp(aWeld.C1, CF(.1, .6, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
        muda()
        aWeld.C1 = clerp(aWeld.C1, CF(.6, -0.4, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
        muda()
        aWeld.C1 = clerp(aWeld.C1, CF(.3, 0, 0.5 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
        muda()
        aWeld.C1 = clerp(aWeld.C1, CF(.1, .6, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
        muda()
        aWeld.C1 = clerp(aWeld.C1, CF(.6, -0.4, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
        muda()
        aWeld.C1 = clerp(aWeld.C1, CF(.3, 0, 0.5 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
        muda()
        aWeld.C1 = clerp(aWeld.C1, CF(.1, .6, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
        muda()
        aWeld.C1 = clerp(aWeld.C1, CF(.6, -0.4, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
        muda()
        aWeld.C1 = clerp(aWeld.C1, CF(.3, 0, 0.5 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
        muda()
        aWeld.C1 = clerp(aWeld.C1, CF(.1, .6, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
        muda()
        aWeld.C1 = clerp(aWeld.C1, CF(.6, -0.4, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
        muda()
        aWeld.C1 = clerp(aWeld.C1, CF(.3, 0, 0.5 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
        muda()
        aWeld.C1 = clerp(aWeld.C1, CF(.1, .6, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
        muda()
        aWeld.C1 = clerp(aWeld.C1, CF(.6, -0.4, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
        muda()
        aWeld.C1 = clerp(aWeld.C1, CF(.3, 0, 0.5 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
        muda()
        aWeld.C1 = clerp(aWeld.C1, CF(.1, .6, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
        muda()
        aWeld.C1 = clerp(aWeld.C1, CF(.6, -0.4, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
        muda()
        aWeld.C1 = clerp(aWeld.C1, CF(.3, 0, 0.5 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
        muda()
        aWeld.C1 = clerp(aWeld.C1, CF(.1, .6, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
        muda()
        aWeld.C1 = clerp(aWeld.C1, CF(.6, -0.4, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
        muda()
        aWeld.C1 = clerp(aWeld.C1, CF(.3, 0, 0.5 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
        muda()
        aWeld.C1 = clerp(aWeld.C1, CF(.1, .6, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
        muda()
        aWeld.C1 = clerp(aWeld.C1, CF(.6, -0.4, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
        for i = 0,20.1,0.1 do
            swait()
            change = 1
            aWeld.C1 = clerp(aWeld.C1, CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
            aWeld.Part0 = root
            neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-30)), 1)
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(-30)), 0.6)
            RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0.5* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
            LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(-90 + 0* Cos(sine / 12))), 0.6)
        end
        for i, v in pairs(FindNearestHead(Container.CFrame.p, 19.5)) do
            if v:FindFirstChild("Head") then
                Eviscerate(v)
                Cso("1744093986", v, 10, 1)
            end
        end
        for i = 0, 9 do
            Magic(0.5, "Add", Container.CFrame, Vector3.new(60,80,50), 2, BrickC("Deep orange"), "Sphere")
            Magic(2, "Add", Container.CFrame, Vector3.new(60,80,50), 2, BrickC("Dark orange"), "Sphere")
            Aura(3, 5.5, "Add", Container.CFrame * CFrame.Angles(math.rad(math.random(-360, 360)), math.rad(math.random(-360, 360)), math.rad(math.random(-360, 360))), 5, 5, 50, -0.05, BrickC("Deep orange"), 0, "Sphere")
            change = 1
        end
        for i = 0,20.1,0.1 do
            swait()
            aWeld.C1 = clerp(aWeld.C1, CF(0 + 0.5* Player_Size * Sin(sine / 1.2), 0 + 0.5* Player_Size * Sin(sine / 1.2), 0 + 0.5* Player_Size * Sin(sine / 1.2) + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 1)
            aWeld.Part0 = root
            neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(-30)), 1)
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0* Player_Size * Sin(sine / 1.2)* Player_Size, 7* Player_Size) * angles(Rad(70 - 0 * Sin(sine / 1.5)), Rad(0), Rad(30)), 0.6)
            RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(70)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
            LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0.5* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
        end
        BTAUNT7:Stop()
        BTAUNT2:Play()
        Container:Remove()
        tecks2.Text = ":joy:"
        change = 1.7
        attack = false
    end

    function bruhmoment()
        attack = true
        BTAUNT3:Play()
        while BTAUNT3.Playing == true do
            tecks2.Text = "He spittin facts"
            for i = 0,7,0.1 do
                swait()
                change = 1
                neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 90 * Sin(sine / 5)), Rad(0), Rad(0)), 1)
                rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0.5* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0.3* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0.3* Player_Size * Sin(sine / 1.2)) * angles(Rad(0), Rad(0), Rad(0)), 1)
                RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(0)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
                LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(0)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
                RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(0* Cos(sine / 12)), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
                LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
            end
        end
        if BTAUNT3.Playing == false then
            tecks2.Text = ":joy:"
            change = 1.7
            attack = false
        end
    end

    function when()
        attack = true
        BTAUNT5:Play()
        while BTAUNT5.Playing == true do
            for i = 0,0.5,0.1 do
                swait()
                change = 2
                BTAUNT5.Pitch = 1
                neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(40 + 0 * Sin(sine / 12)), Rad(0), Rad(0)), 1)
                rootj.C0 = clerp(rootj.C0, RootCF * CF(0,0 + 0.2 * Player_Size * Sin(sine / 3.5),0) * angles(Rad(30), Rad(0 * Cos(sine / 1.5)), Rad(0)), 1)
                RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(30)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
                LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0.2 * Player_Size * Sin(sine / 3.5), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(-30)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
                RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(10), Rad(0+ 0* Sin(sine / 20)), Rad(-20 + 0* Cos(sine / 12))), 1)
                LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(120), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
            end
            for i = 0,0.5,0.1 do
                swait()
                change = 2
                neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-40 + 0 * Sin(sine / 12)), Rad(0), Rad(0)), 1)
                rootj.C0 = clerp(rootj.C0, RootCF * CF(0,0 + 0.2 * Player_Size * Sin(sine / 3.5),0) * angles(Rad(-30), Rad(0 * Cos(sine / 1.5)), Rad(0)), 1)
                RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-30)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
                LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0.2 * Player_Size * Sin(sine / 3.5), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(30)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
                RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(10), Rad(0+ 0* Sin(sine / 20)), Rad(-20 + 0* Cos(sine / 12))), 1)
                LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(120), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
            end
            for i = 0,0.5,0.1 do
                swait()
                change = 2
                neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(40 + 0 * Sin(sine / 12)), Rad(0), Rad(0)), 1)
                rootj.C0 = clerp(rootj.C0, RootCF * CF(0,0 + 0.2 * Player_Size * Sin(sine / 3.5),0) * angles(Rad(30), Rad(0 * Cos(sine / 1.5)), Rad(0)), 1)
                RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(30)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
                LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0.2 * Player_Size * Sin(sine / 3.5), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(-30)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
                RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(10), Rad(0+ 0* Sin(sine / 20)), Rad(-20 + 0* Cos(sine / 12))), 1)
                LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(120), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
            end
            for i = 0,0.5,0.1 do
                swait()
                change = 2
                neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-40 + 0 * Sin(sine / 12)), Rad(0), Rad(0)), 1)
                rootj.C0 = clerp(rootj.C0, RootCF * CF(0,0 + 0.2 * Player_Size * Sin(sine / 3.5),0) * angles(Rad(-30), Rad(0 * Cos(sine / 1.5)), Rad(0)), 1)
                RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-30)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
                LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0.2 * Player_Size * Sin(sine / 3.5), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(30)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
                RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(10), Rad(0+ 0* Sin(sine / 20)), Rad(-20 + 0* Cos(sine / 12))), 1)
                LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(120), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
            end
            for i = 0,0.5,0.1 do
                swait()
                change = 2
                neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(40 + 0 * Sin(sine / 12)), Rad(0), Rad(0)), 1)
                rootj.C0 = clerp(rootj.C0, RootCF * CF(0,0 + 0.2 * Player_Size * Sin(sine / 3.5),0) * angles(Rad(30), Rad(0 * Cos(sine / 1.5)), Rad(0)), 1)
                RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(30)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
                LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0.2 * Player_Size * Sin(sine / 3.5), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(-30)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
                RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(10), Rad(0+ 0* Sin(sine / 20)), Rad(-20 + 0* Cos(sine / 12))), 1)
                LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(120), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
            end
            for i = 0,0.5,0.1 do
                swait()
                change = 2
                neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-40 + 0 * Sin(sine / 12)), Rad(0), Rad(0)), 1)
                rootj.C0 = clerp(rootj.C0, RootCF * CF(0,0 + 0.2 * Player_Size * Sin(sine / 3.5),0) * angles(Rad(-30), Rad(0 * Cos(sine / 1.5)), Rad(0)), 1)
                RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-30)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
                LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0.2 * Player_Size * Sin(sine / 3.5), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(30)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
                RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(10), Rad(0+ 0* Sin(sine / 20)), Rad(-20 + 0* Cos(sine / 12))), 1)
                LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(120), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
            end
            for i = 0,0.5,0.1 do
                swait()
                change = 2
                neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(40 + 0 * Sin(sine / 12)), Rad(0), Rad(0)), 1)
                rootj.C0 = clerp(rootj.C0, RootCF * CF(0,0 + 0.2 * Player_Size * Sin(sine / 3.5),0) * angles(Rad(30), Rad(0 * Cos(sine / 1.5)), Rad(0)), 1)
                RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(30)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
                LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0.2 * Player_Size * Sin(sine / 3.5), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(-30)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
                RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(10), Rad(0+ 0* Sin(sine / 20)), Rad(-20 + 0* Cos(sine / 12))), 1)
                LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(120), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
            end
            for i = 0,0.5,0.1 do
                swait()
                change = 2
                neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-40 + 0 * Sin(sine / 12)), Rad(0), Rad(0)), 1)
                rootj.C0 = clerp(rootj.C0, RootCF * CF(0,0 + 0.2 * Player_Size * Sin(sine / 3.5),0) * angles(Rad(-30), Rad(0 * Cos(sine / 1.5)), Rad(0)), 1)
                RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-30)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
                LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0.2 * Player_Size * Sin(sine / 3.5), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(30)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
                RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(10), Rad(0+ 0* Sin(sine / 20)), Rad(-20 + 0* Cos(sine / 12))), 1)
                LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(120), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
            end
            for i = 0,0.5,0.1 do
                swait()
                change = 2
                neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(40 + 0 * Sin(sine / 12)), Rad(0), Rad(0)), 1)
                rootj.C0 = clerp(rootj.C0, RootCF * CF(0,0 + 0.2 * Player_Size * Sin(sine / 3.5),0) * angles(Rad(30), Rad(0 * Cos(sine / 1.5)), Rad(0)), 1)
                RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(30)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
                LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0.2 * Player_Size * Sin(sine / 3.5), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(-30)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
                RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(10), Rad(0+ 0* Sin(sine / 20)), Rad(-20 + 0* Cos(sine / 12))), 1)
                LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(120), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
            end
            for i = 0,0.5,0.1 do
                swait()
                change = 2
                neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-40 + 0 * Sin(sine / 12)), Rad(0), Rad(0)), 1)
                rootj.C0 = clerp(rootj.C0, RootCF * CF(0,0 + 0.2 * Player_Size * Sin(sine / 3.5),0) * angles(Rad(-30), Rad(0 * Cos(sine / 1.5)), Rad(0)), 1)
                RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-30)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
                LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0.2 * Player_Size * Sin(sine / 3.5), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(30)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
                RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(10), Rad(0+ 0* Sin(sine / 20)), Rad(-20 + 0* Cos(sine / 12))), 1)
                LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(120), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
            end
            for i = 0,0.5,0.1 do
                swait()
                change = 2
                neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(40 + 0 * Sin(sine / 12)), Rad(0), Rad(0)), 1)
                rootj.C0 = clerp(rootj.C0, RootCF * CF(0,0 + 0.2 * Player_Size * Sin(sine / 3.5),0) * angles(Rad(30), Rad(0 * Cos(sine / 1.5)), Rad(0)), 1)
                RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(30)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
                LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0.2 * Player_Size * Sin(sine / 3.5), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(-30)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
                RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(10), Rad(0+ 0* Sin(sine / 20)), Rad(-20 + 0* Cos(sine / 12))), 1)
                LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(120), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
            end
            for i = 0,0.5,0.1 do
                swait()
                change = 2
                neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-40 + 0 * Sin(sine / 12)), Rad(0), Rad(0)), 1)
                rootj.C0 = clerp(rootj.C0, RootCF * CF(0,0 + 0.2 * Player_Size * Sin(sine / 3.5),0) * angles(Rad(-30), Rad(0 * Cos(sine / 1.5)), Rad(0)), 1)
                RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-30)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
                LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0.2 * Player_Size * Sin(sine / 3.5), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(30)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
                RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(10), Rad(0+ 0* Sin(sine / 20)), Rad(-20 + 0* Cos(sine / 12))), 1)
                LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(120), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
            end
            for i = 0,0.5,0.1 do
                swait()
                change = 2
                neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(40 + 0 * Sin(sine / 12)), Rad(0), Rad(0)), 1)
                rootj.C0 = clerp(rootj.C0, RootCF * CF(0,0 + 0.2 * Player_Size * Sin(sine / 3.5),0) * angles(Rad(30), Rad(0 * Cos(sine / 1.5)), Rad(0)), 1)
                RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(30)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
                LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0.2 * Player_Size * Sin(sine / 3.5), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(-30)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
                RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(10), Rad(0+ 0* Sin(sine / 20)), Rad(-20 + 0* Cos(sine / 12))), 1)
                LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(120), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
            end
            for i = 0,0.5,0.1 do
                swait()
                change = 2
                neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-40 + 0 * Sin(sine / 12)), Rad(0), Rad(0)), 1)
                rootj.C0 = clerp(rootj.C0, RootCF * CF(0,0 + 0.2 * Player_Size * Sin(sine / 3.5),0) * angles(Rad(-30), Rad(0 * Cos(sine / 1.5)), Rad(0)), 1)
                RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-30)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
                LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0.2 * Player_Size * Sin(sine / 3.5), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(30)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
                RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(10), Rad(0+ 0* Sin(sine / 20)), Rad(-20 + 0* Cos(sine / 12))), 1)
                LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(120), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
            end
            for i = 0,0.5,0.1 do
                swait()
                change = 2
                neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(40 + 0 * Sin(sine / 12)), Rad(0), Rad(0)), 1)
                rootj.C0 = clerp(rootj.C0, RootCF * CF(0,0 + 0.2 * Player_Size * Sin(sine / 3.5),0) * angles(Rad(30), Rad(0 * Cos(sine / 1.5)), Rad(0)), 1)
                RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(30)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
                LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0.2 * Player_Size * Sin(sine / 3.5), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(-30)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
                RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(10), Rad(0+ 0* Sin(sine / 20)), Rad(-20 + 0* Cos(sine / 12))), 1)
                LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(120), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
            end
            for i = 0,0.5,0.1 do
                swait()
                change = 2
                neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-40 + 0 * Sin(sine / 12)), Rad(0), Rad(0)), 1)
                rootj.C0 = clerp(rootj.C0, RootCF * CF(0,0 + 0.2 * Player_Size * Sin(sine / 3.5),0) * angles(Rad(-30), Rad(0 * Cos(sine / 1.5)), Rad(0)), 1)
                RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-30)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
                LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0.2 * Player_Size * Sin(sine / 3.5), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(30)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
                RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(10), Rad(0+ 0* Sin(sine / 20)), Rad(-20 + 0* Cos(sine / 12))), 1)
                LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(120), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
            end
            for i = 0,0.5,0.1 do
                swait()
                change = 2
                neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(40 + 0 * Sin(sine / 12)), Rad(0), Rad(0)), 1)
                rootj.C0 = clerp(rootj.C0, RootCF * CF(0,0 + 0.2 * Player_Size * Sin(sine / 3.5),0) * angles(Rad(30), Rad(0 * Cos(sine / 1.5)), Rad(0)), 1)
                RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(30)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
                LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0.2 * Player_Size * Sin(sine / 3.5), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(-30)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
                RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(10), Rad(0+ 0* Sin(sine / 20)), Rad(-20 + 0* Cos(sine / 12))), 1)
                LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(120), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
            end
            for i = 0,0.5,0.1 do
                swait()
                change = 2
                neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-40 + 0 * Sin(sine / 12)), Rad(0), Rad(0)), 1)
                rootj.C0 = clerp(rootj.C0, RootCF * CF(0,0 + 0.2 * Player_Size * Sin(sine / 3.5),0) * angles(Rad(-30), Rad(0 * Cos(sine / 1.5)), Rad(0)), 1)
                RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-30)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
                LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0.2 * Player_Size * Sin(sine / 3.5), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(30)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
                RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(10), Rad(0+ 0* Sin(sine / 20)), Rad(-20 + 0* Cos(sine / 12))), 1)
                LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(120), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
            end
            for i = 0,0.5,0.1 do
                swait()
                change = 2
                neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(40 + 0 * Sin(sine / 12)), Rad(0), Rad(0)), 1)
                rootj.C0 = clerp(rootj.C0, RootCF * CF(0,0 + 0.2 * Player_Size * Sin(sine / 3.5),0) * angles(Rad(30), Rad(0 * Cos(sine / 1.5)), Rad(0)), 1)
                RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(30)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
                LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0.2 * Player_Size * Sin(sine / 3.5), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(-30)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
                RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(10), Rad(0+ 0* Sin(sine / 20)), Rad(-20 + 0* Cos(sine / 12))), 1)
                LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(120), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
            end
            BTAUNT5:Stop()
            for i = 0,0.5,0.1 do
                swait()
                change = 2
                neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-40 + 0 * Sin(sine / 12)), Rad(0), Rad(0)), 1)
                rootj.C0 = clerp(rootj.C0, RootCF * CF(0,0 + 0.2 * Player_Size * Sin(sine / 3.5),0) * angles(Rad(-30), Rad(0 * Cos(sine / 1.5)), Rad(0)), 1)
                RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-30)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
                LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0.2 * Player_Size * Sin(sine / 3.5), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(30)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
                RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(10), Rad(0+ 0* Sin(sine / 20)), Rad(-20 + 0* Cos(sine / 12))), 1)
                LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(120), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
            end
        end
        if BTAUNT5.Playing == false then
            tecks2.Text = "Touture Dance"
            change = 1.7
            attack = false
        end
    end
    function isthatajojoreference()
        attack = true
        BTAUNT2:Stop()
        BTAUNT6:Play()
        for i = 0,7.5,0.1 do
            swait()
            neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(30)), 0.5)
            rootj.C0 = clerp(rootj.C0, RootCF * CF(-0,0.4,-0.5) * angles(Rad(0), Rad(0 * Cos(sine / 1.5)), Rad(0)), 0.6)
            RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.75  * Player_Size) * angles(Rad(0), Rad(85), Rad(0)) * angles(Rad(-3 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.5)
            LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.75 * Player_Size) * angles(Rad(0), Rad(-85), Rad(0)) * angles(Rad(-3 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.5)
            RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.45 - 0 * Cos(sine / 12)* Player_Size, -0.5* Player_Size) * angles(Rad(120), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
            LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.45 - 0 * Cos(sine / 12)* Player_Size, -0.5* Player_Size) * angles(Rad(120), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
        end
        for i = 0,5.5,0.1 do
            swait()
            neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(30)), 0.5)
            rootj.C0 = clerp(rootj.C0, RootCF * CF(-0,0.4,-0.5) * angles(Rad(0), Rad(0 * Cos(sine / 1.5)), Rad(0)), 0.6)
            RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.75  * Player_Size) * angles(Rad(0), Rad(85), Rad(0)) * angles(Rad(-3 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.5)
            LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.75 * Player_Size) * angles(Rad(0), Rad(-85), Rad(0)) * angles(Rad(-3 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.5)
            RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.45 - 0 * Cos(sine / 12)* Player_Size, -0.5* Player_Size) * angles(Rad(170), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
            LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.45 - 0 * Cos(sine / 12)* Player_Size, -0.5* Player_Size) * angles(Rad(127), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
        end
        print("1!")
        for i = 0,7.5,0.1 do
            swait()
            neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(30)), 0.5)
            rootj.C0 = clerp(rootj.C0, RootCF * CF(-0,0.4,-0.5) * angles(Rad(0), Rad(0 * Cos(sine / 1.5)), Rad(0)), 0.6)
            RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.75  * Player_Size) * angles(Rad(0), Rad(85), Rad(0)) * angles(Rad(-3 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.5)
            LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.75 * Player_Size) * angles(Rad(0), Rad(-85), Rad(0)) * angles(Rad(-3 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.5)
            RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.45 - 0 * Cos(sine / 12)* Player_Size, -0.5* Player_Size) * angles(Rad(120), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
            LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.45 - 0 * Cos(sine / 12)* Player_Size, -0.5* Player_Size) * angles(Rad(120), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
        end
        for i = 0,5.5,0.1 do
            swait()
            neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(30)), 0.5)
            rootj.C0 = clerp(rootj.C0, RootCF * CF(-0,0.4,-0.5) * angles(Rad(0), Rad(0 * Cos(sine / 1.5)), Rad(0)), 0.6)
            RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.75  * Player_Size) * angles(Rad(0), Rad(85), Rad(0)) * angles(Rad(-3 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.5)
            LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.75 * Player_Size) * angles(Rad(0), Rad(-85), Rad(0)) * angles(Rad(-3 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.5)
            RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.45 - 0 * Cos(sine / 12)* Player_Size, -0.5* Player_Size) * angles(Rad(170), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
            LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.45 - 0 * Cos(sine / 12)* Player_Size, -0.5* Player_Size) * angles(Rad(127), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
        end
        print("2!")
        for i = 0,4.5,0.1 do
            swait()
            neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(30)), 0.5)
            rootj.C0 = clerp(rootj.C0, RootCF * CF(-0,0.4,-0.5) * angles(Rad(0), Rad(0 * Cos(sine / 1.5)), Rad(0)), 0.6)
            RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.75  * Player_Size) * angles(Rad(0), Rad(85), Rad(0)) * angles(Rad(-3 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.5)
            LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.75 * Player_Size) * angles(Rad(0), Rad(-85), Rad(0)) * angles(Rad(-3 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.5)
            RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.45 - 0 * Cos(sine / 12)* Player_Size, -0.5* Player_Size) * angles(Rad(120), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
            LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.45 - 0 * Cos(sine / 12)* Player_Size, -0.5* Player_Size) * angles(Rad(120), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
        end
        for i = 0,5.5,0.1 do
            swait()
            neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(30)), 0.5)
            rootj.C0 = clerp(rootj.C0, RootCF * CF(-0,0.4,-0.5) * angles(Rad(0), Rad(0 * Cos(sine / 1.5)), Rad(0)), 0.6)
            RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.75  * Player_Size) * angles(Rad(0), Rad(85), Rad(0)) * angles(Rad(-3 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.5)
            LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.75 * Player_Size) * angles(Rad(0), Rad(-85), Rad(0)) * angles(Rad(-3 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.5)
            RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.45 - 0 * Cos(sine / 12)* Player_Size, -0.5* Player_Size) * angles(Rad(170), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
            LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.45 - 0 * Cos(sine / 12)* Player_Size, -0.5* Player_Size) * angles(Rad(127), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
        end
        print("3!")
        for i = 0,5.5,0.1 do
            swait()
            neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(30)), 0.5)
            rootj.C0 = clerp(rootj.C0, RootCF * CF(-0,0.4,-0.5) * angles(Rad(0), Rad(0 * Cos(sine / 1.5)), Rad(0)), 0.6)
            RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.75  * Player_Size) * angles(Rad(0), Rad(85), Rad(0)) * angles(Rad(-3 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.5)
            LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.75 * Player_Size) * angles(Rad(0), Rad(-85), Rad(0)) * angles(Rad(-3 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.5)
            RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.45 - 0 * Cos(sine / 12)* Player_Size, -0.5* Player_Size) * angles(Rad(120), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
            LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.45 - 0 * Cos(sine / 12)* Player_Size, -0.5* Player_Size) * angles(Rad(120), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
        end
        for i = 0,5.5,0.1 do
            swait()
            neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(30)), 0.5)
            rootj.C0 = clerp(rootj.C0, RootCF * CF(-0,0.4,-0.5) * angles(Rad(0), Rad(0 * Cos(sine / 1.5)), Rad(0)), 0.6)
            RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.75  * Player_Size) * angles(Rad(0), Rad(85), Rad(0)) * angles(Rad(-3 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.5)
            LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.75 * Player_Size) * angles(Rad(0), Rad(-85), Rad(0)) * angles(Rad(-3 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.5)
            RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.45 - 0 * Cos(sine / 12)* Player_Size, -0.5* Player_Size) * angles(Rad(170), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
            LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.45 - 0 * Cos(sine / 12)* Player_Size, -0.5* Player_Size) * angles(Rad(127), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
        end
        print("4!")
        while BTAUNT6.Playing == true do
            for i = 0,2.5,0.1 do
                swait()
                change = 1
                neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(30)), 0.5)
                rootj.C0 = clerp(rootj.C0, RootCF * CF(0,0,0) * angles(Rad(0), Rad(0 * Cos(sine / 1.5)), Rad(0)), 0.1)
                RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), 0  * Player_Size) * angles(Rad(0), Rad(75), Rad(-0)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.5)
                LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), 0 * Player_Size) * angles(Rad(0), Rad(-75), Rad(0)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.5)
                RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, -0.1 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(10), Rad(0+ 0* Sin(sine / 20)), Rad(130 + 0* Cos(sine / 12))), 0.5)
                LW.C0 = clerp(LW.C0, CF(-1.4* Player_Size, 0.25 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(10), Rad(0+ 0* Sin(sine / 20)), Rad(40 + 0* Cos(sine / 12))), 0.5)
            end
            for i = 0,0.5,0.1 do
                swait()
                change = 1
                neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(30)), 0.5)
                rootj.C0 = clerp(rootj.C0, RootCF * CF(0.5,0,0) * angles(Rad(0), Rad(0 * Cos(sine / 1.5)), Rad(0)), 0.6)
                RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), 0  * Player_Size) * angles(Rad(0), Rad(75), Rad(-0)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.5)
                LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), 0 * Player_Size) * angles(Rad(0), Rad(-75), Rad(0)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.5)
                RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, -0.15 - 0 * Cos(sine / 12)* Player_Size, -0.3* Player_Size) * angles(Rad(10), Rad(0+ 0* Sin(sine / 20)), Rad(120 + 0* Cos(sine / 12))), 0.5)
                LW.C0 = clerp(LW.C0, CF(-1.8* Player_Size, 0.25 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(10), Rad(0+ 0* Sin(sine / 20)), Rad(40 + 0* Cos(sine / 12))), 0.5)
            end
            for i = 0,2.7,0.1 do
                swait()
                change = 1
                neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(10 + 0 * Sin(sine / 12)), Rad(0), Rad(60)), 0.5)
                rootj.C0 = clerp(rootj.C0, RootCF * CF(-1,-1,-0.2) * angles(Rad(10), Rad(0 * Cos(sine / 1.5)), Rad(0)), 0.1)
                RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.5  * Player_Size) * angles(Rad(0), Rad(97), Rad(10)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.5)
                LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.5 * Player_Size) * angles(Rad(0), Rad(-97), Rad(-10)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.5)
                RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0 - 0 * Cos(sine / 12)* Player_Size, -0* Player_Size) * angles(Rad(10), Rad(0+ 0* Sin(sine / 20)), Rad(170 + 0* Cos(sine / 12))), 0.5)
                LW.C0 = clerp(LW.C0, CF(-1.8* Player_Size, 0.25 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(10), Rad(0+ 0* Sin(sine / 20)), Rad(40 + 0* Cos(sine / 12))), 0.5)
            end
            for i = 0,0.5,0.1 do
                swait()
                change = 1
                neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(10 + 0 * Sin(sine / 12)), Rad(0), Rad(60)), 0.5)
                rootj.C0 = clerp(rootj.C0, RootCF * CF(-0.5,-1,-0.2) * angles(Rad(10), Rad(0 * Cos(sine / 1.5)), Rad(0)), 0.6)
                RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.5  * Player_Size) * angles(Rad(0), Rad(97), Rad(10)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.5)
                LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.5 * Player_Size) * angles(Rad(0), Rad(-97), Rad(-10)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.5)
                RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, -0.15 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(10), Rad(0+ 0* Sin(sine / 20)), Rad(120 + 0* Cos(sine / 12))), 0.5)
                LW.C0 = clerp(LW.C0, CF(-1.8* Player_Size, 0.25 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(10), Rad(0+ 0* Sin(sine / 20)), Rad(40 + 0* Cos(sine / 12))), 0.5)
            end
            for i = 0,2.5,0.1 do
                swait()
                change = 1
                neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(30)), 0.5)
                rootj.C0 = clerp(rootj.C0, RootCF * CF(-1,0,0) * angles(Rad(0), Rad(0 * Cos(sine / 1.5)), Rad(0)), 0.1)
                RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), 0  * Player_Size) * angles(Rad(0), Rad(75), Rad(-0)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.5)
                LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), 0 * Player_Size) * angles(Rad(0), Rad(-75), Rad(0)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.5)
                RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, -0.25 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(10), Rad(0+ 0* Sin(sine / 20)), Rad(130 + 0* Cos(sine / 12))), 0.5)
                LW.C0 = clerp(LW.C0, CF(-1.8* Player_Size, 0.25 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(10), Rad(0+ 0* Sin(sine / 20)), Rad(40 + 0* Cos(sine / 12))), 0.5)
            end
            for i = 0,2.7,0.1 do
                swait()
                change = 1
                neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(10 + 0 * Sin(sine / 12)), Rad(0), Rad(60)), 0.5)
                rootj.C0 = clerp(rootj.C0, RootCF * CF(-2,-1,-0.2) * angles(Rad(10), Rad(0 * Cos(sine / 1.5)), Rad(0)), 0.1)
                RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.5  * Player_Size) * angles(Rad(0), Rad(97), Rad(10)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.5)
                LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.5 * Player_Size) * angles(Rad(0), Rad(-97), Rad(-10)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.5)
                RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.25 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(10), Rad(0+ 0* Sin(sine / 20)), Rad(170 + 0* Cos(sine / 12))), 0.5)
                LW.C0 = clerp(LW.C0, CF(-1.8* Player_Size, 0.25 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(10), Rad(0+ 0* Sin(sine / 20)), Rad(40 + 0* Cos(sine / 12))), 0.5)
            end
            for i = 0,1.7,0.1 do
                swait()
                change = 1
                neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(30 + 0 * Sin(sine / 12)), Rad(0), Rad(0)), 0.5)
                rootj.C0 = clerp(rootj.C0, RootCF * CF(-2,0.4,-0.5) * angles(Rad(30), Rad(0 * Cos(sine / 1.5)), Rad(0)), 0.1)
                RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -0.6 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.75  * Player_Size) * angles(Rad(0), Rad(85), Rad(30)) * angles(Rad(-3 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.5)
                LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -0.6 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.75 * Player_Size) * angles(Rad(0), Rad(-85), Rad(-30)) * angles(Rad(-3 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.5)
                RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.45 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(150), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.5)
                LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.45 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(150), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.5)
            end
            for i = 0,2,0.1 do
                swait()
                change = 1
                neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-30 + 0 * Sin(sine / 12)), Rad(0), Rad(0)), 0.5)
                rootj.C0 = clerp(rootj.C0, RootCF * CF(-2,0.4,-0.5) * angles(Rad(-30), Rad(0 * Cos(sine / 1.5)), Rad(0)), 0.6)
                RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.75  * Player_Size) * angles(Rad(0), Rad(85), Rad(-30)) * angles(Rad(-3 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.5)
                LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.75 * Player_Size) * angles(Rad(0), Rad(-85), Rad(30)) * angles(Rad(-3 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.5)
                RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.45 - 0 * Cos(sine / 12)* Player_Size, -0.5* Player_Size) * angles(Rad(60), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
                LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.45 - 0 * Cos(sine / 12)* Player_Size, -0.5* Player_Size) * angles(Rad(60), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 0.6)
            end
            for i = 0,3.4,0.1 do
                swait()
                change = 1
                neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-30 + 0 * Sin(sine / 12)), Rad(0), Rad(-40)), 0.1)
                rootj.C0 = clerp(rootj.C0, RootCF * CF(-2,0.4,-0.1) * angles(Rad(30), Rad(0 * Cos(sine / 1.5)), Rad(0)), 0.1)
                RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1.5 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.75  * Player_Size) * angles(Rad(-40), Rad(85), Rad(30)) * angles(Rad(30 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.1)
                LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.75 * Player_Size) * angles(Rad(0), Rad(-85), Rad(-30)) * angles(Rad(20 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.1)
                RW.C0 = clerp(RW.C0, CF(0.8* Player_Size, -0.5 - 0 * Cos(sine / 12)* Player_Size, -0.8* Player_Size) * angles(Rad(60), Rad(0+ 0* Sin(sine / 20)), Rad(-50 + 0* Cos(sine / 12))), 0.1)
                LW.C0 = clerp(LW.C0, CF(0.2* Player_Size, 0.65 - 0 * Cos(sine / 12)* Player_Size, -0.5* Player_Size) * angles(Rad(60), Rad(0+ 0* Sin(sine / 20)), Rad(120 + 0* Cos(sine / 12))), 0.1)
            end
            for i = 0,0.5,0.1 do
                swait()
                change = 1
                neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(40)), 1)
                rootj.C0 = clerp(rootj.C0, RootCF * CF(-2,0.4,0.8) * angles(Rad(0), Rad(0 * Cos(sine / 1.5)), Rad(-50)), 1)
                RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0  * Player_Size) * angles(Rad(0), Rad(85), Rad(0)) * angles(Rad(-3 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
                LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0 * Player_Size) * angles(Rad(0), Rad(-85), Rad(0)) * angles(Rad(-3 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
                RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.45 - 0 * Cos(sine / 12)* Player_Size, -0.5* Player_Size) * angles(Rad(0), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
                LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.45 - 0 * Cos(sine / 12)* Player_Size, -0.5* Player_Size) * angles(Rad(0), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
            end
            for i = 0,0.2,0.1 do
                swait()
                change = 1
                neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(40)), 1)
                rootj.C0 = clerp(rootj.C0, RootCF * CF(-1,0.4,0.8) * angles(Rad(0), Rad(0 * Cos(sine / 1.5)), Rad(-100)), 0.6)
                RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0  * Player_Size) * angles(Rad(0), Rad(85), Rad(0)) * angles(Rad(-3 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
                LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0 * Player_Size) * angles(Rad(0), Rad(-85), Rad(0)) * angles(Rad(-3 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
                RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.45 - 0 * Cos(sine / 12)* Player_Size, -0* Player_Size) * angles(Rad(0), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
                LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.45 - 0 * Cos(sine / 12)* Player_Size, -0* Player_Size) * angles(Rad(0), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
            end
            for i = 0,0.4,0.1 do
                swait()
                change = 1
                neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(40)), 1)
                rootj.C0 = clerp(rootj.C0, RootCF * CF(0,0.4,0.2) * angles(Rad(0), Rad(0 * Cos(sine / 1.5)), Rad(-150)), 0.6)
                RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0  * Player_Size) * angles(Rad(0), Rad(85), Rad(0)) * angles(Rad(-3 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
                LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0 * Player_Size) * angles(Rad(0), Rad(-85), Rad(0)) * angles(Rad(-3 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
                RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.45 - 0 * Cos(sine / 12)* Player_Size, -0* Player_Size) * angles(Rad(0), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
                LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.45 - 0 * Cos(sine / 12)* Player_Size, -0* Player_Size) * angles(Rad(0), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
            end
            for i = 0,0.4,0.1 do
                swait()
                change = 1
                neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(40)), 1)
                rootj.C0 = clerp(rootj.C0, RootCF * CF(0,0.4,0) * angles(Rad(-30), Rad(0 * Cos(sine / 1.5)), Rad(0)), 0.6)
                RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0  * Player_Size) * angles(Rad(0), Rad(85), Rad(0)) * angles(Rad(-3 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
                LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0 * Player_Size) * angles(Rad(0), Rad(-85), Rad(0)) * angles(Rad(-3 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
                RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.45 - 0 * Cos(sine / 12)* Player_Size, -0* Player_Size) * angles(Rad(0), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
                LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.45 - 0 * Cos(sine / 12)* Player_Size, -0* Player_Size) * angles(Rad(0), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
            end
            for i = 0,1.7,0.1 do
                swait()
                change = 1
                neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(30 + 0 * Sin(sine / 12)), Rad(0), Rad(10)), 0.5)
                rootj.C0 = clerp(rootj.C0, RootCF * CF(.8,0.4,-0) * angles(Rad(0), Rad(0 * Cos(sine / 1.5)), Rad(0)), 0.1)
                RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1* Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.15  * Player_Size) * angles(Rad(0), Rad(85), Rad(0)) * angles(Rad(-3 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.5)
                LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.15 * Player_Size) * angles(Rad(0), Rad(-85), Rad(0)) * angles(Rad(-3 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.5)
                RW.C0 = clerp(RW.C0, CF(1.2* Player_Size, 0.45 - 0 * Cos(sine / 12)* Player_Size, -0.5* Player_Size) * angles(Rad(0), Rad(0+ 0* Sin(sine / 20)), Rad(-30 + 0* Cos(sine / 12))), 0.5)
                LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.15 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(0+ 0* Sin(sine / 20)), Rad(-130 + 0* Cos(sine / 12))), 0.5)
            end
            for i = 0,1.7,0.1 do
                swait()
                change = 1
                neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(30 + 0 * Sin(sine / 12)), Rad(0), Rad(30)), 0.5)
                rootj.C0 = clerp(rootj.C0, RootCF * CF(1,0.4,-0) * angles(Rad(0), Rad(0 * Cos(sine / 1.5)), Rad(0)), 0.1)
                RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1* Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.15  * Player_Size) * angles(Rad(0), Rad(95), Rad(0)) * angles(Rad(-23 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.5)
                LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1* Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.15 * Player_Size) * angles(Rad(0), Rad(-95), Rad(0)) * angles(Rad(-23 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.5)
                RW.C0 = clerp(RW.C0, CF(1.2* Player_Size, 0.45 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(0+ 0* Sin(sine / 20)), Rad(-30 + 0* Cos(sine / 12))), 0.5)
                LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.15 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(0+ 0* Sin(sine / 20)), Rad(-60 + 0* Cos(sine / 12))), 0.5)
            end
            for i = 0,1.7,0.1 do
                swait()
                change = 1
                neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(30 + 0 * Sin(sine / 12)), Rad(0), Rad(10)), 0.5)
                rootj.C0 = clerp(rootj.C0, RootCF * CF(1.5,0.4,-0) * angles(Rad(0), Rad(0 * Cos(sine / 1.5)), Rad(0)), 0.1)
                RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1* Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.15  * Player_Size) * angles(Rad(0), Rad(85), Rad(0)) * angles(Rad(-3 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.5)
                LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1* Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.15 * Player_Size) * angles(Rad(0), Rad(-85), Rad(0)) * angles(Rad(-3 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.5)
                RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.45 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(0+ 0* Sin(sine / 20)), Rad(-30 + 0* Cos(sine / 12))), 0.5)
                LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.15 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(0+ 0* Sin(sine / 20)), Rad(-130 + 0* Cos(sine / 12))), 0.5)
            end
            for i = 0,1.7,0.1 do
                swait()
                change = 1
                neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-40 + 0 * Sin(sine / 12)), Rad(0), Rad(0)), 0.5)
                rootj.C0 = clerp(rootj.C0, RootCF * CF(1.5,0.4,-0) * angles(Rad(20), Rad(0 * Cos(sine / 1.5)), Rad(0)), 0.7)
                RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1* Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.55  * Player_Size) * angles(Rad(0), Rad(85), Rad(20)) * angles(Rad(-13 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.5)
                LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1* Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.55 * Player_Size) * angles(Rad(0), Rad(-85), Rad(-20)) * angles(Rad(-13 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.5)
                RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.85 - 0 * Cos(sine / 12)* Player_Size, -0.2* Player_Size) * angles(Rad(0), Rad(0+ 0* Sin(sine / 20)), Rad(-40 + 0* Cos(sine / 12))), 0.5)
                LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.85 - 0 * Cos(sine / 12)* Player_Size, -0.2* Player_Size) * angles(Rad(0), Rad(0+ 0* Sin(sine / 20)), Rad(40 + 0* Cos(sine / 12))), 0.5)
            end
            for i = 0,0.7,0.1 do
                swait()
                change = 1
                neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(30 + 0 * Sin(sine / 12)), Rad(0), Rad(0)), 0.5)
                rootj.C0 = clerp(rootj.C0, RootCF * CF(1.5,0.4,-0) * angles(Rad(30), Rad(0 * Cos(sine / 1.5)), Rad(0)), 0.1)
                RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1* Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.55  * Player_Size) * angles(Rad(0), Rad(85), Rad(30)) * angles(Rad(-13 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.1)
                LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1* Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.55 * Player_Size) * angles(Rad(0), Rad(-85), Rad(-30)) * angles(Rad(-13 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.1)
                RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.35 - 0 * Cos(sine / 12)* Player_Size, -0.2* Player_Size) * angles(Rad(0), Rad(0+ 0* Sin(sine / 20)), Rad(-40 + 0* Cos(sine / 12))), 0.5)
                LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.35 - 0 * Cos(sine / 12)* Player_Size, -0.2* Player_Size) * angles(Rad(0), Rad(0+ 0* Sin(sine / 20)), Rad(40 + 0* Cos(sine / 12))), 0.5)
            end
            for i = 0,1.7,0.1 do
                swait()
                change = 1
                neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(0)), 0.5)
                rootj.C0 = clerp(rootj.C0, RootCF * CF(1.5,0.4,-0) * angles(Rad(0), Rad(0 * Cos(sine / 1.5)), Rad(0)), 0.1)
                RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1* Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.55  * Player_Size) * angles(Rad(0), Rad(85), Rad(-0)) * angles(Rad(-13 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.1)
                LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1* Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.55 * Player_Size) * angles(Rad(0), Rad(-85), Rad(0)) * angles(Rad(-13 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.1)
                RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.85 - 0 * Cos(sine / 12)* Player_Size, -0.2* Player_Size) * angles(Rad(0), Rad(0+ 0* Sin(sine / 20)), Rad(-40 + 0* Cos(sine / 12))), 0.5)
                LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.85 - 0 * Cos(sine / 12)* Player_Size, -0.2* Player_Size) * angles(Rad(0), Rad(0+ 0* Sin(sine / 20)), Rad(40 + 0* Cos(sine / 12))), 0.5)
            end
            for i = 0,1,0.1 do
                swait()
                change = 1
                neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(30 + 0 * Sin(sine / 12)), Rad(0), Rad(0)), 0.5)
                rootj.C0 = clerp(rootj.C0, RootCF * CF(1.5,0.4,-0) * angles(Rad(30), Rad(0 * Cos(sine / 1.5)), Rad(0)), 0.1)
                RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1* Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.55  * Player_Size) * angles(Rad(0), Rad(85), Rad(30)) * angles(Rad(-13 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.1)
                LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1* Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.55 * Player_Size) * angles(Rad(0), Rad(-85), Rad(-30)) * angles(Rad(-13 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.1)
                RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.15 - 0 * Cos(sine / 12)* Player_Size, -0.2* Player_Size) * angles(Rad(0), Rad(0+ 0* Sin(sine / 20)), Rad(-30 + 0* Cos(sine / 12))), 0.5)
                LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.15 - 0 * Cos(sine / 12)* Player_Size, -0.2* Player_Size) * angles(Rad(0), Rad(0+ 0* Sin(sine / 20)), Rad(30 + 0* Cos(sine / 12))), 0.5)
            end
            for i = 0,0.7,0.1 do
                swait()
                change = 1
                neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(30 + 0 * Sin(sine / 12)), Rad(0), Rad(0)), 0.5)
                rootj.C0 = clerp(rootj.C0, RootCF * CF(1.2,0.4,-0) * angles(Rad(30), Rad(0 * Cos(sine / 1.5)), Rad(0)), 0.1)
                RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1* Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.55  * Player_Size) * angles(Rad(0), Rad(85), Rad(30)) * angles(Rad(-13 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.1)
                LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1* Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.55 * Player_Size) * angles(Rad(0), Rad(-85), Rad(-30)) * angles(Rad(-13 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.1)
                RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.35 - 0 * Cos(sine / 12)* Player_Size, -0.2* Player_Size) * angles(Rad(0), Rad(0+ 0* Sin(sine / 20)), Rad(-40 + 0* Cos(sine / 12))), 0.5)
                LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.35 - 0 * Cos(sine / 12)* Player_Size, -0.2* Player_Size) * angles(Rad(0), Rad(0+ 0* Sin(sine / 20)), Rad(40 + 0* Cos(sine / 12))), 0.5)
            end
            for i = 0,2.7,0.1 do
                swait()
                change = 1
                neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(0)), 0.5)
                rootj.C0 = clerp(rootj.C0, RootCF * CF(1.8,0.4,-0) * angles(Rad(0), Rad(0 * Cos(sine / 1.5)), Rad(0)), 0.1)
                RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1* Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.55  * Player_Size) * angles(Rad(0), Rad(85), Rad(-0)) * angles(Rad(-13 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.1)
                LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1* Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.55 * Player_Size) * angles(Rad(0), Rad(-85), Rad(0)) * angles(Rad(-13 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.1)
                RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.85 - 0 * Cos(sine / 12)* Player_Size, -0.2* Player_Size) * angles(Rad(0), Rad(0+ 0* Sin(sine / 20)), Rad(-40 + 0* Cos(sine / 12))), 0.5)
                LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.85 - 0 * Cos(sine / 12)* Player_Size, -0.2* Player_Size) * angles(Rad(0), Rad(0+ 0* Sin(sine / 20)), Rad(40 + 0* Cos(sine / 12))), 0.5)
            end
            for i = 0,2,0.1 do
                swait()
                change = 1
                neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(30 + 0 * Sin(sine / 12)), Rad(0), Rad(0)), 0.5)
                rootj.C0 = clerp(rootj.C0, RootCF * CF(1.2,0.4,-0) * angles(Rad(30), Rad(0 * Cos(sine / 1.5)), Rad(0)), 0.1)
                RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1* Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.55  * Player_Size) * angles(Rad(0), Rad(85), Rad(30)) * angles(Rad(-13 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.1)
                LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1* Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.55 * Player_Size) * angles(Rad(0), Rad(-85), Rad(-30)) * angles(Rad(-13 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.1)
                RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.15 - 0 * Cos(sine / 12)* Player_Size, -0.2* Player_Size) * angles(Rad(0), Rad(0+ 0* Sin(sine / 20)), Rad(-30 + 0* Cos(sine / 12))), 0.5)
                LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.15 - 0 * Cos(sine / 12)* Player_Size, -0.2* Player_Size) * angles(Rad(0), Rad(0+ 0* Sin(sine / 20)), Rad(30 + 0* Cos(sine / 12))), 0.5)
            end
            for i = 0,3.4,0.1 do
                swait()
                change = 1
                neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-30 + 0 * Sin(sine / 12)), Rad(0), Rad(40)), 0.1)
                rootj.C0 = clerp(rootj.C0, RootCF * CF(1.5,0.4,-0) * angles(Rad(30), Rad(0 * Cos(sine / 1.5)), Rad(0)), 0.1)
                RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1.5 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.75  * Player_Size) * angles(Rad(-40), Rad(85), Rad(30)) * angles(Rad(30 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.1)
                LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0.75 * Player_Size) * angles(Rad(0), Rad(-85), Rad(-30)) * angles(Rad(20 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 0.1)
                RW.C0 = clerp(RW.C0, CF(0.8* Player_Size, -0.5 - 0 * Cos(sine / 12)* Player_Size, -0.8* Player_Size) * angles(Rad(60), Rad(0+ 0* Sin(sine / 20)), Rad(-50 + 0* Cos(sine / 12))), 0.1)
                LW.C0 = clerp(LW.C0, CF(0.2* Player_Size, 0.65 - 0 * Cos(sine / 12)* Player_Size, -0.5* Player_Size) * angles(Rad(60), Rad(0+ 0* Sin(sine / 20)), Rad(120 + 0* Cos(sine / 12))), 0.1)
            end
            for i = 0,0.5,0.1 do
                swait()
                change = 1
                neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(40)), 1)
                rootj.C0 = clerp(rootj.C0, RootCF * CF(1,0.4,0.8) * angles(Rad(0), Rad(0 * Cos(sine / 1.5)), Rad(-50)), 1)
                RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0  * Player_Size) * angles(Rad(0), Rad(85), Rad(0)) * angles(Rad(-3 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
                LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0 * Player_Size) * angles(Rad(0), Rad(-85), Rad(0)) * angles(Rad(-3 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
                RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.45 - 0 * Cos(sine / 12)* Player_Size, -0.5* Player_Size) * angles(Rad(0), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
                LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.45 - 0 * Cos(sine / 12)* Player_Size, -0.5* Player_Size) * angles(Rad(0), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
            end
            for i = 0,0.2,0.1 do
                swait()
                change = 1
                neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(40)), 1)
                rootj.C0 = clerp(rootj.C0, RootCF * CF(0.5,0.4,0.8) * angles(Rad(0), Rad(0 * Cos(sine / 1.5)), Rad(-100)), 0.6)
                RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0  * Player_Size) * angles(Rad(0), Rad(85), Rad(0)) * angles(Rad(-3 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
                LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0 * Player_Size) * angles(Rad(0), Rad(-85), Rad(0)) * angles(Rad(-3 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
                RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.45 - 0 * Cos(sine / 12)* Player_Size, -0* Player_Size) * angles(Rad(0), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
                LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.45 - 0 * Cos(sine / 12)* Player_Size, -0* Player_Size) * angles(Rad(0), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
            end
            for i = 0,0.4,0.1 do
                swait()
                change = 1
                neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(40)), 1)
                rootj.C0 = clerp(rootj.C0, RootCF * CF(0,0.4,0.2) * angles(Rad(0), Rad(0 * Cos(sine / 1.5)), Rad(-150)), 0.6)
                RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0  * Player_Size) * angles(Rad(0), Rad(85), Rad(0)) * angles(Rad(-3 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
                LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0 * Player_Size) * angles(Rad(0), Rad(-85), Rad(0)) * angles(Rad(-3 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
                RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.45 - 0 * Cos(sine / 12)* Player_Size, -0* Player_Size) * angles(Rad(0), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
                LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.45 - 0 * Cos(sine / 12)* Player_Size, -0* Player_Size) * angles(Rad(0), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
            end
            for i = 0,0.4,0.1 do
                swait()
                change = 1
                neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(40)), 1)
                rootj.C0 = clerp(rootj.C0, RootCF * CF(0,0.4,0) * angles(Rad(-30), Rad(0 * Cos(sine / 1.5)), Rad(0)), 0.6)
                RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0  * Player_Size) * angles(Rad(0), Rad(85), Rad(0)) * angles(Rad(-3 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
                LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 3.5), -0 * Player_Size) * angles(Rad(0), Rad(-85), Rad(0)) * angles(Rad(-3 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
                RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.45 - 0 * Cos(sine / 12)* Player_Size, -0* Player_Size) * angles(Rad(0), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
                LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.45 - 0 * Cos(sine / 12)* Player_Size, -0* Player_Size) * angles(Rad(0), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
            end
        end
        BTAUNT2:Play()
        attack = false
    end


    function discord()
        attack = true
        BTAUNT2:Stop()
        tecks2.Text = "car noises"
        hum.WalkSpeed = 100
        BTAUNT4:Play()
        la.Transparency = 1
        ra.Transparency = 1
        for i = 0,17,0.1 do
            swait()
            change = 1
            neck.C0 = clerp(neck.C0, necko* CF(0, -0.6, -1.5 + ((1* Player_Size) - 1)) * angles(Rad(90 + 0 * Sin(sine / 12)), Rad(0), Rad(0)), 1)
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0,-2.6,-2) * angles(Rad(-90), Rad(0 + 10 * Cos(sine / 1.5)), Rad(0)), 1)
            RH.C0 = clerp(RH.C0, CF(1.8 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0.7  * Player_Size) * angles(Rad(0), Rad(90), Rad(-180)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            LH.C0 = clerp(LH.C0, CF(-1.8 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0.7 * Player_Size) * angles(Rad(0), Rad(-90), Rad(180)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            RW.C0 = clerp(RW.C0, CF(0* Player_Size, -1.55 - 0 * Cos(sine / 12)* Player_Size, -0.7* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
            LW.C0 = clerp(LW.C0, CF(-0* Player_Size, -2.55 - 0 * Cos(sine / 12)* Player_Size, -0.7* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
        end
        for i = 0,97,0.05 do
            swait()
            change = 1
            neck.C0 = clerp(neck.C0, necko* CF(0, -0.6, -1.5 + ((1* Player_Size) - 1)) * angles(Rad(90 + 0 * Sin(sine / 12)), Rad(0), Rad(0)), 1)
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0,-2.6,-2) * angles(Rad(-90), Rad(0 + 10 * Cos(sine / 1.5)), Rad(0)), 1)
            RH.C0 = clerp(RH.C0, CF(1.8 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0.7  * Player_Size) * angles(Rad(0), Rad(90), Rad(-180)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            LH.C0 = clerp(LH.C0, CF(-1.8 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0.7 * Player_Size) * angles(Rad(0), Rad(-90), Rad(180)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            RW.C0 = clerp(RW.C0, CF(0* Player_Size, -1.55 - 0 * Cos(sine / 12)* Player_Size, -0.7* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
            LW.C0 = clerp(LW.C0, CF(-0* Player_Size, -2.55 - 0 * Cos(sine / 12)* Player_Size, -0.7* Player_Size) * angles(Rad(90), Rad(0+ 0* Sin(sine / 20)), Rad(0 + 0* Cos(sine / 12))), 1)
        end
        BTAUNT4:Stop()
        hum.WalkSpeed = 20
        la.Transparency = 0
        ra.Transparency = 0
        tecks2.Text = ":joy:"
        BTAUNT2:Play()
        change = 1.7
        attack = false
    end

    function E()
        attack = true
        Cso("1937272483", hed, 10, 1)
        tecks2.Text = "E"
        for i = 0,7,0.1 do
            swait()
            change = 1
            neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(0)), 1)
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0.5* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0.3* Player_Size * Sin(sine / 1.2)* Player_Size, 0.8 + 0.3* Player_Size * Sin(sine / 1.2)) * angles(Rad(0 - 10 * Sin(sine / 1.5)), Rad(0 + 10 * Cos(sine / 1.5)), Rad(0)), 1)
            RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(0)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(0)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(0* Cos(sine / 12)), Rad(0+ 0* Sin(sine / 20)), Rad(90 + 0* Cos(sine / 12))), 1)
            LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(0* Cos(sine / 12)), Rad(0+ 0* Sin(sine / 20)), Rad(-90 + 0* Cos(sine / 12))), 1)
        end
        tecks2.Text = ":joy:"
        change = 1.7
        attack = false
    end




    function bruh()
        attack = true
        Cso("4615152991", hed, 10, 1)
        tecks2.Text = "me going to the poop dimension"
        for i = 0,7,0.1 do
            swait()
            change = 1
            neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(0)), 1)
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0.5* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0.3* Player_Size * Sin(sine / 1.2)* Player_Size, 0.8 + 0.3* Player_Size * Sin(sine / 1.2)) * angles(Rad(-70 - 10 * Sin(sine / 1.5)), Rad(0 + 10 * Cos(sine / 1.5)), Rad(0)), 0.11)
            RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-50)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(50)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(-70), Rad(0+ 0* Sin(sine / 20)), Rad(20 + 0* Cos(sine / 12))), 1)
            LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(-70), Rad(0+ 0* Sin(sine / 20)), Rad(-20 + 0* Cos(sine / 12))), 1)
        end
        for i = 0,7,0.1 do
            swait()
            change = 1
            neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 + 0 * Sin(sine / 12)), Rad(0), Rad(0)), 1)
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0 + 0.5* Player_Size * Sin(sine / 1.2)* Player_Size, 0 + 0.3* Player_Size * Sin(sine / 1.2)* Player_Size, 45.8 + 0* Player_Size * Sin(sine / 1.2)) * angles(Rad(-70 - 10 * Sin(sine / 1.5)), Rad(0 + 10 * Cos(sine / 1.5)), Rad(0)), 0.03)
            RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0  * Player_Size) * angles(Rad(0), Rad(90), Rad(-50)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0 * Player_Size * Sin(sine / 12), 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(50)) * angles(Rad(0 - 0 * Cos(sine / 12)), Rad(0), Rad(0)), 1)
            RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(-70), Rad(0+ 0* Sin(sine / 20)), Rad(20 + 0* Cos(sine / 12))), 1)
            LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(-70), Rad(0+ 0* Sin(sine / 20)), Rad(-20 + 0* Cos(sine / 12))), 1)
        end
        tecks2.Text = ":joy:"
        change = 1.7
        attack = false
    end
    local Head1 = Instance.new("Part", char)
    Head1.Name = "Blob"
    Head1.CanCollide = false
    Head1.BrickColor = BrickColor.new("Really black")
    Head1.Transparency = 1
    Head1.Material = "Plastic"
    Head1.Size = Vector3.new(1, 1, 1)
    Head1.TopSurface = Enum.SurfaceType.Smooth
    Head1.BottomSurface = Enum.SurfaceType.Smooth

    local Weld = Instance.new("Weld", Head1)
    Weld.Part0 = tors
    Weld.Part1 = Head1
    Weld.C1 = CFrame.new(0, 0, 0)
    Weld.C0 = CFrame.Angles(Rad(0),0,0)

    local M3 = Instance.new("SpecialMesh")
    M3.Parent = Head1
    M3.MeshType = "Brick"
    M3.Scale = Vector3.new(5, 5, 5)
    face1 = Instance.new("Decal", Head1)
    face1.Face = "Front"
    face1.Transparency = 1
    face1.Texture = "rbxassetid://153159982"


    -------------------------------------------------------
    --End Attacks N Stuff--
    -------------------------------------------------------
    mouse.KeyDown:connect(function(key)
        if attack == false then
            if key == "e" then
                E()
            elseif key == "z" then
                bruh()
            elseif key == "t" then
                face1.Transparency = 0
                Head1.Transparency = 0
                Cso("1747834381", hed, 10, 1)
                BTAUNT2:Stop()
                wait(19) 
                Cso("3173571164", hed, 10, 1)
                Head1.Transparency = 1
                face1.Transparency = 1
                wait(19)
                BTAUNT2:Play()
            elseif key == "r" then
                roadroller()
            elseif key == "x" then
                bruhmoment()
            elseif key == "c" then
                discord()
            elseif key == "v" then
                when()
            elseif key == "f" then
                isthatajojoreference()
            end
        end
    end)

    local FakeVel = Vector3.new(0,0,0)
    if lplr == Player then
        spawn(function()
            while true do
                local Positions = {}
                local Speeds = {}
                for i = 1,10 do
                    table.insert(Positions, root.CFrame)
                    table.insert(Speeds, root.Velocity)
                    swait()
                end
            end
        end)
    end

    if lplr ~= Player then
        local Last = root.Position
        Mover.OnClientEvent:Connect(function(v, Speed)
            for i,v2 in pairs(v) do
                FakeVel = Speed[i]
                if v[i].p ~= Last then
                    if MoverSpeed.Value == "Remote" then
                        root.CFrame = v[i]
                    end
                    Last = v[i].p
                    swait()
                end
            end
        end)
        spawn(function()
            while true do
                game:GetService("RunService").RenderStepped:wait()
                FakeRoot = workspace.Terrain:WaitForChild(Player.Name.." char tracker")
                if MoverSpeed.Value == "Smooth" then
                    root.CFrame = FakeRoot.CFrame
                end
            end
        end)
    end

    -------------------------------------------------------
    --Start Damage Function--
    -------------------------------------------------------
    function PixelBlock(bonuspeed,FastSpeed,type,pos,x1,y1,z1,value,color,outerpos) --Thanks, Star Glitcher!
        local type = type
        local rng = Instance.new("Part", char)
        rng.Anchored = true
        rng.BrickColor = color
        rng.CanCollide = false
        rng.FormFactor = 3
        rng.Name = "Ring"
        rng.Material = "Neon"
        rng.Size = Vector3.new(1, 1, 1)
        rng.Transparency = 0
        rng.TopSurface = 0
        rng.BottomSurface = 0
        rng.CFrame = pos
        rng.CFrame = rng.CFrame + rng.CFrame.lookVector*outerpos
        local rngm = Instance.new("SpecialMesh", rng)
        rngm.MeshType = "Brick"
        if rainbowmode == true then
            rng.Color = Color3.new(r/255,g/255,b/255)
        end
        local scaler2 = 1
        local speeder = FastSpeed/10
        if type == "Add" then
            scaler2 = 1*value
        elseif type == "Divide" then
            scaler2 = 1/value
        end
        coroutine.resume(coroutine.create(function()
            for i = 0,10/bonuspeed,0.1 do
                swait()
                if type == "Add" then
                    scaler2 = scaler2 - 0.01*value/bonuspeed
                elseif type == "Divide" then
                    scaler2 = scaler2 - 0.01/value*bonuspeed
                end
                speeder = speeder - 0.01*FastSpeed*bonuspeed/10
                rng.CFrame = rng.CFrame + rng.CFrame.lookVector*speeder*bonuspeed
                rng.Transparency = rng.Transparency + 0.01*bonuspeed
            end
            rng:Destroy()
        end))
    end

    function Damage(Part, hit, minim, maxim, knockback, Type, Property, Delay, HitSound, HitPitch)
        if hit.Parent == nil then
            return
        end
        local h = hit.Parent:FindFirstChildOfClass("Humanoid")
        for _, v in pairs(hit.Parent:children()) do
            if v:IsA("Humanoid") then
                h = v
            end
        end
        if h ~= nil and hit.Parent.Name ~= char.Name and hit.Parent:FindFirstChild("UpperTorso") ~= nil then

            hit.Parent:FindFirstChild("Head"):BreakJoints()
        end

        if h ~= nil and hit.Parent.Name ~= char.Name and hit.Parent:FindFirstChild("Torso") ~= nil then
            if hit.Parent:findFirstChild("DebounceHit") ~= nil then
                if hit.Parent.DebounceHit.Value == true then
                    return
                end
            end
            if insta == true then
                hit.Parent:FindFirstChild("Head"):BreakJoints()
            end
            local c = Create("ObjectValue"){
                Name = "creator",
                Value = Player,
                Parent = h,
            }
            game:GetService("Debris"):AddItem(c, .5)
            if HitSound ~= nil and HitPitch ~= nil then
                CFuncs.Sound.Create(HitSound, hit, 1, HitPitch) 
            end
            local Damage = math.random(minim, maxim)
            local blocked = false
            local block = hit.Parent:findFirstChild("Block")
            if block ~= nil then
                if block.className == "IntValue" then
                    if block.Value > 0 then
                        blocked = true
                        block.Value = block.Value - 1
                        print(block.Value)
                    end
                end
            end
            if blocked == false then
                --h.Health = h.Health - Damage
                ShowDamage((Part.CFrame * CFrame.new(0, 0, (Part.Size.Z / 2)).p + Vector3.new(0, 1.5, 0)), -Damage, 1.5, tors.BrickColor.Color)
            else
                --h.Health = h.Health - (Damage / 2)
                ShowDamage((Part.CFrame * CFrame.new(0, 0, (Part.Size.Z / 2)).p + Vector3.new(0, 1.5, 0)), -Damage, 1.5, tors.BrickColor.Color)
            end
            if Type == "Knockdown" then
                local hum = hit.Parent.Humanoid
                hum.PlatformStand = true
                coroutine.resume(coroutine.create(function(HHumanoid)
                    swait(1)
                    HHumanoid.PlatformStand = false
                end), hum)
                local angle = (hit.Position - (Property.Position + Vector3.new(0, 0, 0))).unit
                local bodvol = Create("BodyVelocity"){
                    velocity = angle * knockback,
                    P = 5000,
                    maxForce = Vector3.new(8e+003, 8e+003, 8e+003),
                    Parent = hit,
                }
                local rl = Create("BodyAngularVelocity"){
                    P = 3000,
                    maxTorque = Vector3.new(500000, 500000, 500000) * 50000000000000,
                    angularvelocity = Vector3.new(math.random(-10, 10), math.random(-10, 10), math.random(-10, 10)),
                    Parent = hit,
                }
                game:GetService("Debris"):AddItem(bodvol, .5)
                game:GetService("Debris"):AddItem(rl, .5)
            elseif Type == "Normal" then
                local vp = Create("BodyVelocity"){
                    P = 500,
                    maxForce = Vector3.new(math.huge, 0, math.huge),
                    velocity = Property.CFrame.lookVector * knockback + Property.Velocity / 1.05,
                }
                if knockback > 0 then
                    vp.Parent = hit.Parent.Torso
                end
                game:GetService("Debris"):AddItem(vp, .5)
            elseif Type == "Up" then
                local bodyVelocity = Create("BodyVelocity"){
                    velocity = Vector3.new(0, 20, 0),
                    P = 5000,
                    maxForce = Vector3.new(8e+003, 8e+003, 8e+003),
                    Parent = hit,
                }
                game:GetService("Debris"):AddItem(bodyVelocity, .5)
            elseif Type == "DarkUp" then
                coroutine.resume(coroutine.create(function()
                    for i = 0, 1, 0.1 do
                        swait()
                        Effects.Block.Create(BrickColor.new("Royal purple"), hit.Parent.Torso.CFrame, 5, 5, 5, 1, 1, 1, .08, 1)
                    end
                end))
                local bodyVelocity = Create("BodyVelocity"){
                    velocity = Vector3.new(0, 20, 0),
                    P = 5000,
                    maxForce = Vector3.new(8e+003, 8e+003, 8e+003),
                    Parent = hit,
                }
                game:GetService("Debris"):AddItem(bodyVelocity, 1)
            elseif Type == "Snare" then
                local bp = Create("BodyPosition"){
                    P = 2000,
                    D = 100,
                    maxForce = Vector3.new(math.huge, math.huge, math.huge),
                    position = hit.Parent.Torso.Position,
                    Parent = hit.Parent.Torso,
                }
                game:GetService("Debris"):AddItem(bp, 1)
            elseif Type == "Freeze" then
                local BodPos = Create("BodyPosition"){
                    P = 50000,
                    D = 1000,
                    maxForce = Vector3.new(math.huge, math.huge, math.huge),
                    position = hit.Parent.Torso.Position,
                    Parent = hit.Parent.Torso,
                }
                local BodGy = Create("BodyGyro") {
                    maxTorque = Vector3.new(4e+005, 4e+005, 4e+005) * math.huge ,
                    P = 20e+003,
                    Parent = hit.Parent.Torso,
                    cframe = hit.Parent.Torso.CFrame,
                }
                hit.Parent.Torso.Anchored = true
                coroutine.resume(coroutine.create(function(Part) 
                    swait(1.5)
                    Part.Anchored = false
                end), hit.Parent.Torso)
                game:GetService("Debris"):AddItem(BodPos, 3)
                game:GetService("Debris"):AddItem(BodGy, 3)
            end
            local debounce = Create("BoolValue"){
                Name = "DebounceHit",
                Parent = hit.Parent,
                Value = true,
            }
            game:GetService("Debris"):AddItem(debounce, Delay)
            c = Create("ObjectValue"){
                Name = "creator",
                Value = Player,
                Parent = h,
            }
            game:GetService("Debris"):AddItem(c, .5)
        end
    end

    function damage(range,mindam,maxdam,pos)
        if true then return end
    end
    -------------------------------------------------------
    --End Damage Function--
    -------------------------------------------------------

    -------------------------------------------------------
    --Start Animations--
    -------------------------------------------------------
    print("By XandersAltAccount1")
    while true do
        swait()
        sine = sine + change
        local torvel = (FakeVel * Vector3.new(1, 0, 1)).magnitude
        local velderp = FakeVel.y
        if lplr == plr then
            torvel = (root.Velocity * Vt(1, 0, 1)).magnitude
            velderp = root.Velocity.y
        end
        hitfloor, posfloor = rayCast(root.Position, CFrame.new(root.Position, root.Position - Vector3.new(0, 1, 0)).lookVector, 4* Player_Size, char)
        if equipped == true or equipped == false then
            if attack == false then
                idle = idle + 1
            else
                idle = 0
            end
            if 1 < root.Velocity.y and hitfloor == nil then
                Anim = "Jump"
                if attack == false then
                    rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, 0.9 + 0.5* Player_Size * Cos(sine / -15)) * angles(Rad(0), Rad(0), Rad(0)), 0.17)
                    neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(10 - 2.5 * Sin(sine / 30)), Rad(0), Rad(0)), 0.3)
                    RH.C0 = clerp(RH.C0, CF(1* Player_Size, -.2 - 0.1 * Cos(sine / 20)* Player_Size, -.3* Player_Size) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
                    LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -.9 - 0.1 * Cos(sine / 20), -.5* Player_Size) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
                    RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(25), Rad(-.6), Rad(13 + 4.5 * Sin(sine / 20))), 0.1)
                    LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(25), Rad(-.6), Rad(-13 - 4.5 * Sin(sine / 20))), 0.1)
                end
            elseif -1 > root.Velocity.y and hitfloor == nil then
                Anim = "Fall"
                if attack == false then
                    rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1 * Cos(sine / 20)* Player_Size) * angles(Rad(24), Rad(0), Rad(0)), 0.15)
                    neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(10 - 2.5 * Sin(sine / 30)), Rad(0), Rad(0)), 0.3)
                    RH.C0 = clerp(RH.C0, CF(1* Player_Size, -1 - 0.1 * Cos(sine / 20)* Player_Size, -.3* Player_Size) * RHCF * angles(Rad(-3.5), Rad(0), Rad(0)), 0.15)
                    LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -.8 - 0.1 * Cos(sine / 20)* Player_Size, -.3* Player_Size) * LHCF * angles(Rad(-3.5), Rad(0), Rad(0)), 0.15)
                    RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(65), Rad(-.6), Rad(45 + 4.5 * Sin(sine / 20))), 0.1)
                    LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(55), Rad(-.6), Rad(-45 - 4.5 * Sin(sine / 20))), 0.1)
                end
            elseif torvel < 1 and hitfloor ~= nil then
                Anim = "Idle"
                change = 1.75
                if attack == false then
                    neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-10 + 12.5 * Sin(sine / 12)), Rad(0), Rad(0)), 0.3)
                    rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.3* Player_Size * Sin(sine / 12)) * angles(Rad(0 - 0 * Sin(sine / 20)), Rad(0 + 0 * Cos(sine / 20)), Rad(0)), 0.35)
                    RH.C0 = clerp(RH.C0, CF(1 * Player_Size, -1 * Player_Size - 0.3 * Player_Size * Sin(sine / 12), -0.5  * Player_Size) * angles(Rad(0), Rad(76), Rad(-10)) * angles(Rad(-13 - -7 * Cos(sine / 12)), Rad(0), Rad(0)), 0.35)
                    LH.C0 = clerp(LH.C0, CF(-1 * Player_Size, -1 * Player_Size - 0.3 * Player_Size * Sin(sine / 12), -0.5 * Player_Size) * angles(Rad(0), Rad(-76), Rad(10)) * angles(Rad(-13 - -7 * Cos(sine / 12)), Rad(0), Rad(0)), 0.35)
                    RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.55 - 0.15 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(10* Cos(sine / 12)), Rad(0+ 0* Sin(sine / 20)), Rad(10 + -12.5 * Cos(sine / 12))), 0.12)
                    LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.55 - 0.15 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(10* Cos(sine / 12)), Rad(0+ 0* Sin(sine / 20)), Rad(-10 + 12.5 * Cos(sine / 12))), 0.12)
                end
            elseif torvel > 2 and torvel < 25 and hitfloor ~= nil then
                Anim = "Walk"
                change = 1.3
                if attack == false then
                    rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, 0.375 + -0.73 * Sin(sine / 3.5) + -Sin(sine / 3.5) / 1* Player_Size) * angles(Rad(-3 - 32.5 * Cos(sine / 3.5)), Rad(0) - root.RotVelocity.Y / 75, Rad(1 * Cos(sine / 7))), 0.15)
                    neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(30 * Sin(sine / 3.5)), Rad(0), Rad(0 * Cos(sine / 7)) - hed.RotVelocity.Y / 15), 0.3)
                    RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.8 - 1 * Cos(sine / 7) / 2* Player_Size, 0.8 * Cos(sine / 7) / 0.7* Player_Size)  * angles(Rad(-10 - 25 * Cos(sine / 7)) - rl.RotVelocity.Y / 75 + -Sin(sine / 7) / 2, Rad(90 - 15 * Cos(sine / 7)), Rad(0)) * angles(Rad(0 + 2 * Cos(sine / 7)), Rad(0), Rad(-0)), 0.3)
                    LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.8 + 1 * Cos(sine / 7) / 2* Player_Size, -0.8 * Cos(sine / 7) / 0.7* Player_Size) * angles(Rad(-10 + 25 * Cos(sine / 7)) + ll.RotVelocity.Y / 75 + Sin(sine / 7) / 2, Rad(-90 - 15 * Cos(sine / 7)), Rad(0)) * angles(Rad(0 - 2 * Cos(sine / 7)), Rad(0), Rad(0)), 0.3)
                    RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.05 * Sin(sine / 7)* Player_Size, 0* Player_Size) * angles(Rad(137)  * Cos(sine / 7) , Rad(10 * Cos(sine / 7)), Rad(0) - ra.RotVelocity.Y / 75), 0.1)
                    LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.05 * Sin(sine / 7)* Player_Size, 0* Player_Size) * angles(Rad(-137)  * Cos(sine / 7) , Rad(10 * Cos(sine / 7)) , Rad(0) + la.RotVelocity.Y / 75), 0.1)
                end
            elseif torvel >= 25 and hitfloor ~= nil then
                Anim = "Sprint"
                change = 1.35
                if attack == false then
                    rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.175 + 0.13 * Cos(sine / 3.5) + -Sin(sine / 3.5) / 7* Player_Size) * angles(Rad(23 - 2.5 * Cos(sine / 3.5)), Rad(0) - root.RotVelocity.Y / 75, Rad(15 * Cos(sine / 7))), 0.15)
                    neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-10), Rad(0), Rad(0) - hed.RotVelocity.Y / 15), 0.3)
                    RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.8 - 0.5 * Cos(sine / 7) / 2* Player_Size, 0.6 * Cos(sine / 7) / 2* Player_Size)  * angles(Rad(-10 - 25 * Cos(sine / 7)) - rl.RotVelocity.Y / 75 + -Sin(sine / 7) / 2.5, Rad(90 - 15 * Cos(sine / 7)), Rad(0)) * angles(Rad(0 + 2 * Cos(sine / 7)), Rad(0), Rad(20)), 0.3)
                    LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.8 + 0.5 * Cos(sine / 7) / 2* Player_Size, -0.6 * Cos(sine / 7) / 2* Player_Size) * angles(Rad(-10 + 25 * Cos(sine / 7)) + ll.RotVelocity.Y / 75 + Sin(sine / 7) / 2.5, Rad(-90 - 15 * Cos(sine / 7)), Rad(0)) * angles(Rad(0 - 2 * Cos(sine / 7)), Rad(0), Rad(-20)), 0.3)
                    RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.05 * Sin(sine / 7)* Player_Size, 0* Player_Size) * angles(Rad(57)  * Cos(sine / 7) , Rad(10 * Cos(sine / 7)), Rad(0) - ra.RotVelocity.Y / 75), 0.1)
                    LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.05 * Sin(sine / 7)* Player_Size, 0* Player_Size) * angles(Rad(-57)  * Cos(sine / 7) , Rad(10 * Cos(sine / 7)) ,  Rad(0) + la.RotVelocity.Y / 75), 0.1)
                end
            end
        end
        refit()
        Refit()
        Parents()
        if 0 < #Effects then
            for e = 1, #Effects do
                if Effects[e] ~= nil then
                    local Thing = Effects[e]
                    if Thing ~= nil then
                        local Part = Thing[1]
                        local Mode = Thing[2]
                        local Delay = Thing[3]
                        local IncX = Thing[4]
                        local IncY = Thing[5]
                        local IncZ = Thing[6]
                        if 1 >= Thing[1].Transparency then
                            if Thing[2] == "Block1" then
                                Thing[1].CFrame = Thing[1].CFrame * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
                                local Mesh = Thing[1].Mesh
                                Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
                                Thing[1].Transparency = Thing[1].Transparency + Thing[3]
                            elseif Thing[2] == "Block2" then
                                Thing[1].CFrame = Thing[1].CFrame + Vector3.new(0, 0, 0)
                                local Mesh = Thing[7]
                                Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
                                Thing[1].Transparency = Thing[1].Transparency + Thing[3]
                            elseif Thing[2] == "Block3" then
                                Thing[1].CFrame = Thing[1].CFrame * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50)) + Vector3.new(0, 0.15, 0)
                                local Mesh = Thing[7]
                                Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
                                Thing[1].Transparency = Thing[1].Transparency + Thing[3]
                            elseif Thing[2] == "Cylinder" then
                                local Mesh = Thing[1].Mesh
                                Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
                                Thing[1].Transparency = Thing[1].Transparency + Thing[3]
                            elseif Thing[2] == "Blood" then
                                local Mesh = Thing[7]
                                Thing[1].CFrame = Thing[1].CFrame * Vector3.new(0, 0.5, 0)
                                Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
                                Thing[1].Transparency = Thing[1].Transparency + Thing[3]
                            elseif Thing[2] == "Elec" then
                                local Mesh = Thing[1].Mesh
                                Mesh.Scale = Mesh.Scale + Vector3.new(Thing[7], Thing[8], Thing[9])
                                Thing[1].Transparency = Thing[1].Transparency + Thing[3]
                            elseif Thing[2] == "Disappear" then
                                Thing[1].Transparency = Thing[1].Transparency + Thing[3]
                            elseif Thing[2] == "Shatter" then
                                Thing[1].Transparency = Thing[1].Transparency + Thing[3]
                                Thing[4] = Thing[4] * CFrame.new(0, Thing[7], 0)
                                Thing[1].CFrame = Thing[4] * CFrame.fromEulerAnglesXYZ(Thing[6], 0, 0)
                                Thing[6] = Thing[6] + Thing[5]
                            end
                        else
                            Part.Parent = nil
                            table.remove(Effects, e)
                        end
                    end
                end
            end
        end
    end
    -----------------------------------------------------
end)

memeus.Name = "memeus"
memeus.Parent = main
memeus.BackgroundColor3 = Color3.fromRGB(79, 79, 79)
memeus.Position = UDim2.new(0.0741935521, 0, 0.718631208, 0)
memeus.Size = UDim2.new(0, 74, 0, 45)
memeus.Style = Enum.ButtonStyle.RobloxRoundDropdownButton
memeus.Font = Enum.Font.SciFi
memeus.Text = "MEMEUS"
memeus.TextColor3 = Color3.fromRGB(0, 0, 0)
memeus.TextSize = 18.000
memeus.MouseButton1Down:connect(function()
    local FavIDs = {
        340106355, --Nefl Crystals
        927529620, --Dimension
        876981900, --Fantasy
        398987889, --Ordinary Days
        1117396305, --Oh wait, it's you.
        885996042, --Action Winter Journey
        919231299, --Sprawling Idiot Effigy
        743466274, --Good Day Sunshine
        727411183, --Knife Fight
        1402748531, --The Earth Is Counting On You!
        595230126 --Robot Language
    }

    FELOADLIBRARY = {}
    loadstring(game:GetObjects("rbxassetid://5209815302")[1].Source)()
    Bypass = "death"
    loadstring(game:GetObjects("rbxassetid://5325226148")[1].Source)()

    --The reality of my life isn't real but a Universe -makhail07
    wait()
    local Player = game.Players.localPlayer
    local Character = workspace.non
    local plr = game:service'Players'.LocalPlayer
    local Humanoid = Character.Humanoid
    local char = Character
    local hum = char.Humanoid
    local ra = char["Right Arm"]
    local la= char["Left Arm"]
    local rl= char["Right Leg"]
    local ll = char["Left Leg"]
    local hed = char.Head
    local root = char.HumanoidRootPart
    local rootj = root.RootJoint
    local tors = char.Torso
    local mouse = plr:GetMouse()
    local RootCF = CFrame.fromEulerAnglesXYZ(-1.57, 0, 3.14)
    local RHCF = CFrame.fromEulerAnglesXYZ(0, 1.6, 0)
    local LHCF = CFrame.fromEulerAnglesXYZ(0, -1.6, 0)
    local cam = game.Workspace.CurrentCamera
    trazx = Instance.new("ParticleEmitter")
    c = game.Players.LocalPlayer.Character

    --where i put all the warn things

    warn ("Well Look at that, I finished it.")
    --Looks Like you decided to look though the script. Well, Hello.
    warn ("I had a fun time making this edit.")
    --I Really DID have fun editing this.
    warn ("I hope you Enjoy this. Go have Fun!")
    --Just don't abuse.
    warn ("Also, the original MemeusV2 was made by makhail07.")
    --Support makhail07 for making the original!
    warn ("This edit was made by me, 2003boobear.")
    --This is one of my best edits BY FAR, though.
    Character.Head.face.Texture = "rbxassetid://620619801"

    -------------------------------------------------------
    --Start Good Stuff--
    -------------------------------------------------------
    CF = CFrame.new
    angles = CFrame.Angles
    attack = false
    timetofly = true
    Euler = CFrame.fromEulerAnglesXYZ
    Rad = math.rad
    IT = Instance.new
    BrickC = BrickColor.new
    Cos = math.cos
    Acos = math.acos
    Sin = math.sin
    Asin = math.asin
    Abs = math.abs
    Mrandom = math.random
    Floor = math.floor
    random = math.random
    radian = math.rad
    Vec3 = Vector3.new
    cFrame = CFrame.new
    Euler = CFrame.fromEulerAnglesXYZ
    -------------------------------------------------------
    --End Good Stuff--
    -------------------------------------------------------
    necko = CF(0, 1, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)
    RSH, LSH = nil, nil 
    RW = Instance.new("Weld") 
    LW = Instance.new("Weld")
    RH = tors["Right Hip"]
    LH = tors["Left Hip"]
    RSH = tors["Right Shoulder"] 
    LSH = tors["Left Shoulder"] 
    RSH.Parent = nil 
    LSH.Parent = nil 
    RW.Name = "RW"
    RW.Part0 = tors 
    RW.C0 = CF(1.5, 0.5, 0)
    RW.C1 = CF(0, 0.5, 0) 
    RW.Part1 = ra
    RW.Parent = tors 
    LW.Name = "LW"
    LW.Part0 = tors 
    LW.C0 = CF(-1.5, 0.5, 0)
    LW.C1 = CF(0, 0.5, 0) 
    LW.Part1 = la
    LW.Parent = tors
    Effects = {}

    -------------------------------------------------------
    --Start HeartBeat--
    -------------------------------------------------------
    ArtificialHB = Instance.new("BindableEvent", script)
    ArtificialHB.Name = "Heartbeat"
    script:WaitForChild("Heartbeat")

    frame = 1 / 60
    tf = 0
    allowframeloss = false
    tossremainder = false


    lastframe = tick()
    script.Heartbeat:Fire()


    game:GetService("RunService").Heartbeat:connect(function(s, p)
        tf = tf + s
        if tf >= frame then
            if allowframeloss then
                script.Heartbeat:Fire()
                lastframe = tick()
            else
                for i = 1, math.floor(tf / frame) do
                    script.Heartbeat:Fire()
                end
                lastframe = tick()
            end
            if tossremainder then
                tf = 0
            else
                tf = tf - frame * math.floor(tf / frame)
            end
        end
    end)
    -------------------------------------------------------
    --End HeartBeat--
    -------------------------------------------------------

    function CameraEnshaking(Length, Intensity) --Took Straight from StarGlitcher!
        coroutine.resume(coroutine.create(function()
            local intensity = 1 * Intensity
            local rotM = 0.01 * Intensity
            for i = 0, Length, 0.1 do
                swait()
                intensity = intensity - 0.05 * Intensity / Length
                rotM = rotM - 5.0E-4 * Intensity / Length
                hum.CameraOffset = Vec3(radian(random(-intensity, intensity)), radian(random(-intensity, intensity)), radian(random(-intensity, intensity)))
                cam.CFrame = cam.CFrame * cFrame(radian(random(-intensity, intensity)), radian(random(-intensity, intensity)), radian(random(-intensity, intensity))) * Euler(radian(random(-intensity, intensity)) * rotM, radian(random(-intensity, intensity)) * rotM, radian(random(-intensity, intensity)) * rotM)
            end
            Humanoid.CameraOffset = Vec3(0, 0, 0)
        end))
    end

    local joyemoji = Instance.new('ParticleEmitter', tors)
    joyemoji.VelocitySpread = 2000
    joyemoji.Lifetime = NumberRange.new(1)
    joyemoji.Speed = NumberRange.new(40)
    joy= {}
    for i=0, 19 do
        joy[#joy+ 1] = NumberSequenceKeypoint.new(i/19, math.random(1, 1))
    end
    joyemoji.Size = NumberSequence.new(joy)
    joyemoji.Rate = 0
    joyemoji.LockedToPart = false
    joyemoji.LightEmission = 0
    joyemoji.Texture = "rbxassetid://1176402123"
    joyemoji.Color = ColorSequence.new(BrickColor.new("Institutional white").Color)


    local LIT = Instance.new('ParticleEmitter', tors)
    LIT.VelocitySpread = 2000
    LIT.Lifetime = NumberRange.new(1)
    LIT.Speed = NumberRange.new(45)
    nani= {}
    for i=0, 19 do
        nani[#nani+ 1] = NumberSequenceKeypoint.new(i/19, math.random(1, 1))
    end
    LIT.Size = NumberSequence.new(nani)
    LIT.Rate = 0
    LIT.LockedToPart = false
    LIT.LightEmission = 0
    LIT.Texture = "rbxassetid://1492670151"
    LIT.Color = ColorSequence.new(BrickColor.new("Institutional white").Color)

    local toast = Instance.new('ParticleEmitter', tors)
    toast.VelocitySpread = 2000
    toast.Lifetime = NumberRange.new(1)
    toast.Speed = NumberRange.new(60)
    toasterstoasttoast= {}
    for i=0, 19 do
        toasterstoasttoast[#toasterstoasttoast+ 1] = NumberSequenceKeypoint.new(i/19, math.random(1, 1))
    end
    toast.Size = NumberSequence.new(toasterstoasttoast)
    toast.Rate = 0
    toast.LockedToPart = false
    toast.LightEmission = 0
    toast.Texture = "rbxassetid://436096230"
    toast.Color = ColorSequence.new(BrickColor.new("Institutional white").Color)

    local ok = Instance.new('ParticleEmitter', tors)
    ok.VelocitySpread = 2000
    ok.Lifetime = NumberRange.new(1)
    ok.Speed = NumberRange.new(50)
    cool= {}
    for i=0, 19 do
        cool[#cool+ 1] = NumberSequenceKeypoint.new(i/19, math.random(1, 1))
    end
    ok.Size = NumberSequence.new(cool)
    ok.Rate = 0
    ok.LockedToPart = false
    ok.LightEmission = 0
    ok.Texture = "rbxassetid://636768448"
    ok.Color = ColorSequence.new(BrickColor.new("Institutional white").Color)

    -------------------------------------------------------
    --Start Kyu's shitty stuff--
    -------------------------------------------------------

    function ragdoll(model)
        local char = model
        torso = char.HumanoidRootPart
        torso2 = char.Torso
        LW.Parent = nil
        RW.Parent = nil
        LH.Parent = nil
        RH.Parent = nil
        if hum ~= nil then
            hum.PlatformStand = true
        end

        local Head = char:FindFirstChild("Head")
        if Head then
            local Neck = Instance.new("Weld")
            Neck.Name = "Neck"
            Neck.Part0 = torso
            Neck.Part1 = Head
            Neck.C0 = CFrame.new(0, 1.5, 0)
            Neck.C1 = CFrame.new()
            Neck.Parent = torso
        end
        local Limb = char:FindFirstChild("Right Arm")
        if Limb then

            Limb.CFrame = torso.CFrame * CFrame.new(1.5, 0, 0)
            local Joint = Instance.new("Glue")
            Joint.Name = "RightShoulder"
            Joint.Part0 = torso
            Joint.Part1 = Limb
            Joint.C0 = CFrame.new(1.5, 0.5, 0, 0, 0, 1, 0, 1, 0, -1, -0, -0)
            Joint.C1 = CFrame.new(-0, 0.5, 0, 0, 0, 1, 0, 1, 0, -1, -0, -0)
            Joint.Parent = torso

            local B = Instance.new("Part")
            B.TopSurface = 0
            B.BottomSurface = 0
            B.formFactor = "Symmetric"
            B.Size = Vector3.new(1, 1, 1)
            B.Transparency = 1
            B.CFrame = Limb.CFrame * CFrame.new(0, -0.5, 0)
            B.Parent = char
            local W = Instance.new("Weld")
            W.Part0 = Limb
            W.Part1 = B
            W.C0 = CFrame.new(0, -0.5, 0)
            W.Parent = Limb

        end
        local Limb = char:FindFirstChild("Left Arm")
        if Limb then

            Limb.CFrame = torso.CFrame * CFrame.new(-1.5, 0, 0)
            local Joint = Instance.new("Glue")
            Joint.Name = "LeftShoulder"
            Joint.Part0 = torso
            Joint.Part1 = Limb
            Joint.C0 = CFrame.new(-1.5, 0.5, 0, -0, -0, -1, 0, 1, 0, 1, 0, 0)
            Joint.C1 = CFrame.new(0, 0.5, 0, -0, -0, -1, 0, 1, 0, 1, 0, 0)
            Joint.Parent = torso

            local B = Instance.new("Part")
            B.TopSurface = 0
            B.BottomSurface = 0
            B.formFactor = "Symmetric"
            B.Size = Vector3.new(1, 1, 1)
            B.Transparency = 1
            B.CFrame = Limb.CFrame * CFrame.new(0, -0.5, 0)
            B.Parent = char
            local W = Instance.new("Weld")
            W.Part0 = Limb
            W.Part1 = B
            W.C0 = CFrame.new(0, -0.5, 0)
            W.Parent = Limb

        end
        local Limb = char:FindFirstChild("Right Leg")
        if Limb then

            Limb.CFrame = torso.CFrame * CFrame.new(0.5, -2, 0)
            local Joint = Instance.new("Glue")
            Joint.Name = "RightHip"
            Joint.Part0 = torso
            Joint.Part1 = Limb
            Joint.C0 = CFrame.new(0.5, -1, 0, 0, 0, 1, 0, 1, 0, -1, -0, -0)
            Joint.C1 = CFrame.new(0, 1, 0, 0, 0, 1, 0, 1, 0, -1, -0, -0)
            Joint.Parent = torso

            local B = Instance.new("Part")
            B.TopSurface = 0
            B.BottomSurface = 0
            B.formFactor = "Symmetric"
            B.Size = Vector3.new(1, 1, 1)
            B.Transparency = 1
            B.CFrame = Limb.CFrame * CFrame.new(0, -0.5, 0)
            B.Parent = char
            local W = Instance.new("Weld")
            W.Part0 = Limb
            W.Part1 = B
            W.C0 = CFrame.new(0, -0.5, 0)
            W.Parent = Limb

        end
        local Limb = char:FindFirstChild("Left Leg")
        if Limb then

            Limb.CFrame = torso.CFrame * CFrame.new(-0.5, -2, 0)
            local Joint = Instance.new("Glue")
            Joint.Name = "LeftHip"
            Joint.Part0 = torso
            Joint.Part1 = Limb
            Joint.C0 = CFrame.new(-0.5, -1, 0, -0, -0, -1, 0, 1, 0, 1, 0, 0)
            Joint.C1 = CFrame.new(-0, 1, 0, -0, -0, -1, 0, 1, 0, 1, 0, 0)
            Joint.Parent = torso

            local B = Instance.new("Part")
            B.TopSurface = 0
            B.BottomSurface = 0
            B.formFactor = "Symmetric"
            B.Size = Vector3.new(1, 1, 1)
            B.Transparency = 1
            B.CFrame = Limb.CFrame * CFrame.new(0, -0.5, 0)
            B.Parent = char
            local W = Instance.new("Weld")
            W.Part0 = Limb
            W.Part1 = B
            W.C0 = CFrame.new(0, -0.5, 0)
            W.Parent = Limb

        end
        --[
        local Bar = Instance.new("Part")
        Bar.TopSurface = 0
        Bar.BottomSurface = 0
        Bar.formFactor = "Symmetric"
        Bar.Size = Vector3.new(1, 1, 1)
        Bar.Transparency = 1
        Bar.CFrame = torso.CFrame * CFrame.new(0, 0.5, 0)
        Bar.Parent = char
        local Weld = Instance.new("Weld")
        Weld.Part0 = torso
        Weld.Part1 = Bar
        Weld.C0 = CFrame.new(0, 0.5, 0)
        Weld.Parent = torso
        --]]

        torso.CFrame = CFrame.new(torso.Position)*CFrame.Angles(math.rad(20),math.rad(torso.Orientation.Y),math.rad(torso.Orientation.Z))

    end

    -------------------------------------------------------
    --End Kyu's shitty stuff--
    -------------------------------------------------------

    -------------------------------------------------------
    --Start Important Functions--
    -------------------------------------------------------
    function swait(num)
        if num == 0 or num == nil then
            game:service("RunService").Stepped:wait(0)
        else
            for i = 0, num do
                game:service("RunService").Stepped:wait(0)
            end
        end
    end
    function thread(f)
        coroutine.resume(coroutine.create(f))
    end
    function clerp(a, b, t)
        local qa = {
            QuaternionFromCFrame(a)
        }
        local qb = {
            QuaternionFromCFrame(b)
        }
        local ax, ay, az = a.x, a.y, a.z
        local bx, by, bz = b.x, b.y, b.z
        local _t = 1 - t
        return QuaternionToCFrame(_t * ax + t * bx, _t * ay + t * by, _t * az + t * bz, QuaternionSlerp(qa, qb, t))
    end
    function QuaternionFromCFrame(cf)
        local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components()
        local trace = m00 + m11 + m22
        if trace > 0 then
            local s = math.sqrt(1 + trace)
            local recip = 0.5 / s
            return (m21 - m12) * recip, (m02 - m20) * recip, (m10 - m01) * recip, s * 0.5
        else
            local i = 0
            if m00 < m11 then
                i = 1
            end
            if m22 > (i == 0 and m00 or m11) then
                i = 2
            end
            if i == 0 then
                local s = math.sqrt(m00 - m11 - m22 + 1)
                local recip = 0.5 / s
                return 0.5 * s, (m10 + m01) * recip, (m20 + m02) * recip, (m21 - m12) * recip
            elseif i == 1 then
                local s = math.sqrt(m11 - m22 - m00 + 1)
                local recip = 0.5 / s
                return (m01 + m10) * recip, 0.5 * s, (m21 + m12) * recip, (m02 - m20) * recip
            elseif i == 2 then
                local s = math.sqrt(m22 - m00 - m11 + 1)
                local recip = 0.5 / s
                return (m02 + m20) * recip, (m12 + m21) * recip, 0.5 * s, (m10 - m01) * recip
            end
        end
    end
    function QuaternionToCFrame(px, py, pz, x, y, z, w)
        local xs, ys, zs = x + x, y + y, z + z
        local wx, wy, wz = w * xs, w * ys, w * zs
        local xx = x * xs
        local xy = x * ys
        local xz = x * zs
        local yy = y * ys
        local yz = y * zs
        local zz = z * zs
        return CFrame.new(px, py, pz, 1 - (yy + zz), xy - wz, xz + wy, xy + wz, 1 - (xx + zz), yz - wx, xz - wy, yz + wx, 1 - (xx + yy))
    end
    function QuaternionSlerp(a, b, t)
        local cosTheta = a[1] * b[1] + a[2] * b[2] + a[3] * b[3] + a[4] * b[4]
        local startInterp, finishInterp
        if cosTheta >= 1.0E-4 then
            if 1 - cosTheta > 1.0E-4 then
                local theta = math.acos(cosTheta)
                local invSinTheta = 1 / Sin(theta)
                startInterp = Sin((1 - t) * theta) * invSinTheta
                finishInterp = Sin(t * theta) * invSinTheta
            else
                startInterp = 1 - t
                finishInterp = t
            end
        elseif 1 + cosTheta > 1.0E-4 then
            local theta = math.acos(-cosTheta)
            local invSinTheta = 1 / Sin(theta)
            startInterp = Sin((t - 1) * theta) * invSinTheta
            finishInterp = Sin(t * theta) * invSinTheta
        else
            startInterp = t - 1
            finishInterp = t
        end
        return a[1] * startInterp + b[1] * finishInterp, a[2] * startInterp + b[2] * finishInterp, a[3] * startInterp + b[3] * finishInterp, a[4] * startInterp + b[4] * finishInterp
    end
    function rayCast(Position, Direction, Range, Ignore)
        return game:service("Workspace"):FindPartOnRay(Ray.new(Position, Direction.unit * (Range or 999.999)), Ignore)
    end

    local Create = FELOADLIBRARY.Create

    -------------------------------------------------------
    --Start Damage Function--
    -------------------------------------------------------
    function Damage(Part, hit, minim, maxim, knockback, Type, Property, Delay, HitSound, HitPitch)
        if hit.Parent == nil then
            return
        end
        local h = hit.Parent:FindFirstChildOfClass("Humanoid")
        for _, v in pairs(hit.Parent:children()) do
            if v:IsA("Humanoid") then
                h = v
            end
        end

        if h ~= nil and hit.Parent.Name ~= char.Name and hit.Parent:FindFirstChild("Torso") ~= nil then
            if hit.Parent:findFirstChild("DebounceHit") ~= nil then
                if hit.Parent.DebounceHit.Value == true then
                    return
                end
            end
            local c = Create("ObjectValue"){
                Name = "creator",
                Value = game:service("Players").LocalPlayer,
                Parent = h,
            }
            game:GetService("Debris"):AddItem(c, .5)
            if HitSound ~= nil and HitPitch ~= nil then
                CFuncs.Sound.Create(HitSound, hit, 1, HitPitch) 
            end
            local Damage = math.random(minim, maxim)
            local blocked = false
            local block = hit.Parent:findFirstChild("Block")
            if block ~= nil then
                if block.className == "IntValue" then
                    if block.Value > 0 then
                        blocked = true
                        block.Value = block.Value - 1
                    end
                end
            end
            if blocked == false then
                ShowDamage((Part.CFrame * CFrame.new(0, 0, (Part.Size.Z / 2)).p + Vector3.new(0, 1.5, 0)), -Damage, 1.5, tors.BrickColor.Color)
            else
                ShowDamage((Part.CFrame * CFrame.new(0, 0, (Part.Size.Z / 2)).p + Vector3.new(0, 1.5, 0)), -Damage, 1.5, tors.BrickColor.Color)
            end
            if Type == "Knockdown" then
                local hum = hit.Parent.Humanoid
                hum.PlatformStand = true
                coroutine.resume(coroutine.create(function(HHumanoid)
                    swait(1)
                    HHumanoid.PlatformStand = false
                end), hum)
                local angle = (hit.Position - (Property.Position + Vector3.new(0, 0, 0))).unit
                local bodvol = Create("BodyVelocity"){
                    velocity = angle * knockback,
                    P = 5000,
                    maxForce = Vector3.new(8e+003, 8e+003, 8e+003),
                    Parent = hit,
                }
                local rl = Create("BodyAngularVelocity"){
                    P = 3000,
                    maxTorque = Vector3.new(500000, 500000, 500000) * 50000000000000,
                    angularvelocity = Vector3.new(math.random(-10, 10), math.random(-10, 10), math.random(-10, 10)),
                    Parent = hit,
                }
                game:GetService("Debris"):AddItem(bodvol, .5)
                game:GetService("Debris"):AddItem(rl, .5)
            elseif Type == "Normal" then
                local vp = Create("BodyVelocity"){
                    P = 500,
                    maxForce = Vector3.new(math.huge, 0, math.huge),
                    velocity = Property.CFrame.lookVector * knockback + Property.Velocity / 1.05,
                }
                if knockback > 0 then
                    vp.Parent = hit.Parent.Torso
                end
                game:GetService("Debris"):AddItem(vp, .5)
            elseif Type == "Up" then
                local bodyVelocity = Create("BodyVelocity"){
                    velocity = Vector3.new(0, 20, 0),
                    P = 5000,
                    maxForce = Vector3.new(8e+003, 8e+003, 8e+003),
                    Parent = hit,
                }
                game:GetService("Debris"):AddItem(bodyVelocity, .5)
            elseif Type == "DarkUp" then
                coroutine.resume(coroutine.create(function()
                    for i = 0, 1, 0.1 do
                        swait()
                        Effects.Block.Create(BrickColor.new("Black"), hit.Parent.Torso.CFrame, 5, 5, 5, 1, 1, 1, .08, 1)
                    end
                end))
                local bodyVelocity = Create("BodyVelocity"){
                    velocity = Vector3.new(0, 20, 0),
                    P = 5000,
                    maxForce = Vector3.new(8e+003, 8e+003, 8e+003),
                    Parent = hit,
                }
                game:GetService("Debris"):AddItem(bodyVelocity, 1)
            elseif Type == "Snare" then
                local bp = Create("BodyPosition"){
                    P = 2000,
                    D = 100,
                    maxForce = Vector3.new(math.huge, math.huge, math.huge),
                    position = hit.Parent.Torso.Position,
                    Parent = hit.Parent.Torso,
                }
                game:GetService("Debris"):AddItem(bp, 1)
            elseif Type == "Freeze" then
                local BodPos = Create("BodyPosition"){
                    P = 50000,
                    D = 1000,
                    maxForce = Vector3.new(math.huge, math.huge, math.huge),
                    position = hit.Parent.Torso.Position,
                    Parent = hit.Parent.Torso,
                }
                local BodGy = Create("BodyGyro") {
                    maxTorque = Vector3.new(4e+005, 4e+005, 4e+005) * math.huge ,
                    P = 20e+003,
                    Parent = hit.Parent.Torso,
                    cframe = hit.Parent.Torso.CFrame,
                }
                hit.Parent.Torso.Anchored = true
                coroutine.resume(coroutine.create(function(Part) 
                    swait(1.5)
                    Part.Anchored = false
                end), hit.Parent.Torso)
                game:GetService("Debris"):AddItem(BodPos, 3)
                game:GetService("Debris"):AddItem(BodGy, 3)
            end
            local debounce = Create("BoolValue"){
                Name = "DebounceHit",
                Parent = hit.Parent,
                Value = true,
            }
            game:GetService("Debris"):AddItem(debounce, Delay)
            c = Create("ObjectValue"){
                Name = "creator",
                Value = Player,
                Parent = h,
            }
            game:GetService("Debris"):AddItem(c, .5)
        end
    end
    -------------------------------------------------------
    --End Damage Function--
    -------------------------------------------------------

    -------------------------------------------------------
    --Start Damage Function Customization--
    -------------------------------------------------------
    function ShowDamage(Pos, Text, Time, Color)
        local Rate = (1 / 30)
        local Pos = (Pos or Vector3.new(0, 0, 0))
        local Text = (Text or "")
        local Time = (Time or 2)
        local Color = (Color or Color3.new(1, 0, 1))
        local EffectPart = CFuncs.Part.Create(workspace, "SmoothPlastic", 0, 1, BrickColor.new(Color), "Effect", Vector3.new(0, 0, 0))
        EffectPart.Anchored = true
        local BillboardGui = Create("BillboardGui"){
            Size = UDim2.new(3, 0, 3, 0),
            Adornee = EffectPart,
            Parent = EffectPart,
        }
        local TextLabel = Create("TextLabel"){
            BackgroundTransparency = 1,
            Size = UDim2.new(1, 0, 1, 0),
            Text = Text,
            Font = "Highway",
            TextColor3 = Color,
            TextScaled = true,
            Parent = BillboardGui,
        }
        game.Debris:AddItem(EffectPart, (Time))
        EffectPart.Parent = game:GetService("Workspace")
        delay(0, function()
            local Frames = (Time / Rate)
            for Frame = 1, Frames do
                wait(Rate)
                local Percent = (Frame / Frames)
                EffectPart.CFrame = CFrame.new(Pos) + Vector3.new(0, Percent, 0)
                TextLabel.TextTransparency = Percent
            end
            if EffectPart and EffectPart.Parent then
                EffectPart:Destroy()
            end
        end)
    end
    -------------------------------------------------------
    --End Damage Function Customization--
    -------------------------------------------------------

    function MagniDamage(Part, magni, mindam, maxdam, knock, Type)
        for _, c in pairs(workspace:children()) do
            local hum = c:findFirstChild("Humanoid")
            if hum ~= nil then
                local head = c:findFirstChild("Head")
                if head ~= nil then
                    local targ = head.Position - Part.Position
                    local mag = targ.magnitude
                    if magni >= mag and c.Name ~= plr.Name then
                        Damage(head, head, mindam, maxdam, knock, Type, root, 0.1, "http://www.roblox.com/asset/?id=231917784", 1.2)
                    end
                end
            end
        end
    end


    CFuncs = {
        Part = {
            Create = function(Parent, Material, Reflectance, Transparency, BColor, Name, Size)
                local Part = Create("Part")({
                    Parent = Parent,
                    Reflectance = Reflectance,
                    Transparency = Transparency,
                    CanCollide = false,
                    Locked = true,
                    BrickColor = BrickColor.new(tostring(BColor)),
                    Name = Name,
                    Size = Size,
                    Material = Material
                })
                RemoveOutlines(Part)
                return Part
            end
        },
        Mesh = {
            Create = function(Mesh, Part, MeshType, MeshId, OffSet, Scale)
                local Msh = Create(Mesh)({
                    Parent = Part,
                    Offset = OffSet,
                    Scale = Scale
                })
                if Mesh == "SpecialMesh" then
                    Msh.MeshType = MeshType
                    Msh.MeshId = MeshId
                end
                return Msh
            end
        },
        Mesh = {
            Create = function(Mesh, Part, MeshType, MeshId, OffSet, Scale)
                local Msh = Create(Mesh)({
                    Parent = Part,
                    Offset = OffSet,
                    Scale = Scale
                })
                if Mesh == "SpecialMesh" then
                    Msh.MeshType = MeshType
                    Msh.MeshId = MeshId
                end
                return Msh
            end
        },
        Weld = {
            Create = function(Parent, Part0, Part1, C0, C1)
                local Weld = Create("Weld")({
                    Parent = Parent,
                    Part0 = Part0,
                    Part1 = Part1,
                    C0 = C0,
                    C1 = C1
                })
                return Weld
            end
        },
        Sound = {
            Create = function(id, par, vol, pit)
                coroutine.resume(coroutine.create(function()
                    local S = Create("Sound")({
                        Volume = vol,
                        Pitch = pit or 1,
                        SoundId = id,
                        Parent = par or workspace
                    })
                    wait()
                    S:play()
                    game:GetService("Debris"):AddItem(S, 6)
                end))
            end
        },
        ParticleEmitter = {
            Create = function(Parent, Color1, Color2, LightEmission, Size, Texture, Transparency, ZOffset, Accel, Drag, LockedToPart, VelocityInheritance, EmissionDirection, Enabled, LifeTime, Rate, Rotation, RotSpeed, Speed, VelocitySpread)
                local fp = Create("ParticleEmitter")({
                    Parent = Parent,
                    Color = ColorSequence.new(Color1, Color2),
                    LightEmission = LightEmission,
                    Size = Size,
                    Texture = Texture,
                    Transparency = Transparency,
                    ZOffset = ZOffset,
                    Acceleration = Accel,
                    Drag = Drag,
                    LockedToPart = LockedToPart,
                    VelocityInheritance = VelocityInheritance,
                    EmissionDirection = EmissionDirection,
                    Enabled = Enabled,
                    Lifetime = LifeTime,
                    Rate = Rate,
                    Rotation = Rotation,
                    RotSpeed = RotSpeed,
                    Speed = Speed,
                    VelocitySpread = VelocitySpread
                })
                return fp
            end
        }
    }
    function RemoveOutlines(part)
        part.TopSurface, part.BottomSurface, part.LeftSurface, part.RightSurface, part.FrontSurface, part.BackSurface = 10, 10, 10, 10, 10, 10
    end
    function CreatePart(FormFactor, Parent, Material, Reflectance, Transparency, BColor, Name, Size)
        local Part = Create("Part")({
            formFactor = FormFactor,
            Parent = Parent,
            Reflectance = Reflectance,
            Transparency = Transparency,
            CanCollide = false,
            Locked = true,
            BrickColor = BrickColor.new(tostring(BColor)),
            Name = Name,
            Size = Size,
            Material = Material
        })
        RemoveOutlines(Part)
        return Part
    end
    function CreateMesh(Mesh, Part, MeshType, MeshId, OffSet, Scale)
        local Msh = Create(Mesh)({
            Parent = Part,
            Offset = OffSet,
            Scale = Scale
        })
        if Mesh == "SpecialMesh" then
            Msh.MeshType = MeshType
            Msh.MeshId = MeshId
        end
        return Msh
    end
    function CreateWeld(Parent, Part0, Part1, C0, C1)
        local Weld = Create("Weld")({
            Parent = Parent,
            Part0 = Part0,
            Part1 = Part1,
            C0 = C0,
            C1 = C1
        })
        return Weld
    end


    -------------------------------------------------------
    --Start Effect Function--
    -------------------------------------------------------
    EffectModel = Instance.new("Model", char)
    Effects = {
        Block = {
            Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay, Type)
                local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
                prt.Anchored = true
                prt.CFrame = cframe
                local msh = CFuncs.Mesh.Create("BlockMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
                game:GetService("Debris"):AddItem(prt, 10)
                if Type == 1 or Type == nil then
                    table.insert(Effects, {
                        prt,
                        "Block1",
                        delay,
                        x3,
                        y3,
                        z3,
                        msh
                    })
                elseif Type == 2 then
                    table.insert(Effects, {
                        prt,
                        "Block2",
                        delay,
                        x3,
                        y3,
                        z3,
                        msh
                    })
                else
                    table.insert(Effects, {
                        prt,
                        "Block3",
                        delay,
                        x3,
                        y3,
                        z3,
                        msh
                    })
                end
            end
        },
        Sphere = {
            Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
                local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
                prt.Anchored = true
                prt.CFrame = cframe
                local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "Sphere", "", Vector3.new(0,0,0), Vector3.new(x1, y1, z1))
                game:GetService("Debris"):AddItem(prt, 10)
                table.insert(Effects, {
                    prt,
                    "Cylinder",
                    delay,
                    x3,
                    y3,
                    z3,
                    msh
                })
            end
        },
        Cylinder = {
            Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
                local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
                prt.Anchored = true
                prt.CFrame = cframe
                local msh = CFuncs.Mesh.Create("CylinderMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
                game:GetService("Debris"):AddItem(prt, 10)
                table.insert(Effects, {
                    prt,
                    "Cylinder",
                    delay,
                    x3,
                    y3,
                    z3,
                    msh
                })
            end
        },
        Wave = {
            Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
                local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
                prt.Anchored = true
                prt.CFrame = cframe
                local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://20329976", Vector3.new(0, 0, 0), Vector3.new(x1 / 60, y1 / 60, z1 / 60))
                game:GetService("Debris"):AddItem(prt, 10)
                table.insert(Effects, {
                    prt,
                    "Cylinder",
                    delay,
                    x3 / 60,
                    y3 / 60,
                    z3 / 60,
                    msh
                })
            end
        },
        Ring = {
            Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
                local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
                prt.Anchored = true
                prt.CFrame = cframe
                local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://3270017", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
                game:GetService("Debris"):AddItem(prt, 10)
                table.insert(Effects, {
                    prt,
                    "Cylinder",
                    delay,
                    x3,
                    y3,
                    z3,
                    msh
                })
            end
        },
        Break = {
            Create = function(brickcolor, cframe, x1, y1, z1)
                local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new(0.5, 0.5, 0.5))
                prt.Anchored = true
                prt.CFrame = cframe * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
                local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "Sphere", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
                local num = math.random(10, 50) / 1000
                game:GetService("Debris"):AddItem(prt, 10)
                table.insert(Effects, {
                    prt,
                    "Shatter",
                    num,
                    prt.CFrame,
                    math.random() - math.random(),
                    0,
                    math.random(50, 100) / 100
                })
            end
        },
        Spiral = {
            Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
                local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
                prt.Anchored = true
                prt.CFrame = cframe
                local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://1051557", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
                game:GetService("Debris"):AddItem(prt, 10)
                table.insert(Effects, {
                    prt,
                    "Cylinder",
                    delay,
                    x3,
                    y3,
                    z3,
                    msh
                })
            end
        },
        Push = {
            Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
                local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
                prt.Anchored = true
                prt.CFrame = cframe
                local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://437347603", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
                game:GetService("Debris"):AddItem(prt, 10)
                table.insert(Effects, {
                    prt,
                    "Cylinder",
                    delay,
                    x3,
                    y3,
                    z3,
                    msh
                })
            end
        }
    }
    -------------------------------------------------------
    --End Effect Function--
    -------------------------------------------------------

    function CreateSound(ID, PARENT, VOLUME, PITCH) --Very important.
        local NSound = nil
        coroutine.resume(coroutine.create(function()
            NSound = Instance.new("Sound", PARENT)
            NSound.Volume = VOLUME
            NSound.Pitch = PITCH
            NSound.SoundId = "http://www.roblox.com/asset/?id="..ID
            swait()
            NSound:play()
            game:GetService("Debris"):AddItem(NSound, 10)
        end))
        return NSound
    end





    -------------------------------------------------------
    --End Important Functions--
    -------------------------------------------------------

    chargeup = Instance.new("Sound", hed)
    chargeup.SoundId = "http://www.roblox.com/asset/?id=527276541"
    chargeup.Volume = 10
    chargeup.Pitch = 1
    chargeup.Looped = true
    chargeup.TimePosition = 1

    meme = Instance.new("Sound", hed)
    meme.SoundId = "http://www.roblox.com/asset/?id=291151190"
    meme.Volume = 10
    meme.Pitch = 1
    meme.Looped = true
    meme.TimePosition = 1

    local ohno = Instance.new("Sound")
    ohno.Parent = hed
    ohno.Volume = 10
    ohno.Pitch = 1
    ohno.Looped = true

    local bass = Instance.new("Sound") --why
    bass.Parent = hed
    bass.Volume = 7
    bass.Pitch = 1
    bass.SoundId = "http://www.roblox.com/asset/?id=1087356234"
    bass.Looped = true

    Cause_Im_having_a_good_time_having_a_good_time = Instance.new("Sound", hed) --DONT STOP ME NOOOOOOOOOWWWWWWWW
    Cause_Im_having_a_good_time_having_a_good_time.SoundId = "http://www.roblox.com/asset/?id=672104253"
    Cause_Im_having_a_good_time_having_a_good_time.Volume = 10
    Cause_Im_having_a_good_time_having_a_good_time.Pitch = 1
    Cause_Im_having_a_good_time_having_a_good_time.Looped = false
    Cause_Im_having_a_good_time_having_a_good_time.TimePosition = 35.3

    STHAP = Instance.new("Sound", hed)
    STHAP.SoundId = "http://www.roblox.com/asset/?id=1591656314"
    STHAP.Volume = 10
    STHAP.Pitch = 1
    STHAP.Looped = false

    forevergone = Instance.new("Sound", tors)
    forevergone.SoundId = "http://www.roblox.com/asset/?id=1286436928"
    forevergone.Volume = 10
    forevergone.Pitch = 1
    forevergone.Looped = true
    forevergone.TimePosition = 24

    -------------------------------------------------------
    --Start Music Option--
    -------------------------------------------------------
    local Music = Instance.new("Sound",tors)
    Music.Volume = 2.5
    Music.SoundId = "rbxassetid://"
    Music.Looped = true
    Music.Pitch = 1 --Pitcher
    Music:Play()
    -------------------------------------------------------
    --End Music Option--
    -------------------------------------------------------
    --hi fat >:)
    -------------------------------------------------------
    --Start Attacks N Stuff--
    -------------------------------------------------------
    local sine=0
    function HitboxFunction(Pose, lifetime, siz1, siz2, siz3, Radie, Min, Max, kb, atype)
        local Hitboxpart = Instance.new("Part", EffectModel)
        RemoveOutlines(Hitboxpart)
        Hitboxpart.Size = Vector3.new(siz1, siz2, siz3)
        Hitboxpart.CanCollide = false
        Hitboxpart.Transparency = 1
        Hitboxpart.Anchored = true
        Hitboxpart.CFrame = Pose
        game:GetService("Debris"):AddItem(Hitboxpart, lifetime)
        MagniDamage(Hitboxpart, Radie, Min, Max, kb, atype)
    end
    function GEtOuT()
        attack = true
        hum.WalkSpeed = 10
        Character.Head.face.Texture = "rbxassetid://494811799"
        CreateSound("814652778", hed, 10, 1)
        CreateSound("537371462", hed, 10, 1)
        local vel3 = Instance.new("BodyVelocity",tors)
        vel3.Velocity = Vector3.new(0,25,0)
        vel3.MaxForce = Vector3.new(10000000,10000000,10000000)
        for i = 0,12,0.1 do
            swait()
            CameraEnshaking(1, 2)
            HitboxFunction(ll.CFrame, 0.01, 1, 1, 1, 7, 20, 99, 53, "Knockdown")
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(0-255.45*i)), 0.3)
            tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-40), Rad(0), Rad(0)), 0.3)
            RW.C0 = clerp(RW.C0, CF(1.5, 0.5, 0) * angles(Rad(30), Rad(0), Rad(20)), 0.3)
            LW.C0 = clerp(LW.C0, CF(-1.5, 0.5, 0) * angles(Rad(-20), Rad(0), Rad(-30)), 0.3)
            LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 * Cos(sine / 20), -0.3) * LHCF * angles(Rad(-5), Rad(0), Rad(20)), 0.15)
            RH.C0 = clerp(RH.C0, CF(1, -1, 0.3) * angles(Rad(0), Rad(90), Rad(-20)), 0.3)
        end
        vel3:Destroy()
        Character.Head.face.Texture = "rbxassetid://620619801"
        attack = false
        Humanoid.JumpPower = 50
        hum.WalkSpeed = 16
    end

    function GEtOuT2()
        attack = true
        hum.WalkSpeed = 10
        Humanoid.JumpPower = 0
        Character.Head.face.Texture = "rbxassetid://494811799"
        CreateSound("814652778", hed, 10, 1)
        CreateSound("537371462", hed, 10, 1)
        root.Velocity = root.CFrame.lookVector * 20
        for i = 0,12,0.1 do
            swait()
            CameraEnshaking(1, 2)
            root.Velocity = root.CFrame.lookVector * 50
            HitboxFunction(ll.CFrame, 0.01, 1, 1, 1, 7, 10, 50, 53, "Knockdown")
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1 * Cos(sine / 20)) * angles(Rad(90), Rad(0), Rad(0-255.45*i)), 0.3)
            tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-40), Rad(0), Rad(0)), 0.3)
            RW.C0 = clerp(RW.C0, CF(1.5, 0.5, 0) * angles(Rad(30), Rad(0), Rad(20)), 0.3)
            LW.C0 = clerp(LW.C0, CF(-1.5, 0.5, 0) * angles(Rad(-20), Rad(0), Rad(-30)), 0.3)
            LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 * Cos(sine / 20), -0.3) * LHCF * angles(Rad(-5), Rad(0), Rad(20)), 0.15)
            RH.C0 = clerp(RH.C0, CF(1, -1, 0.3) * angles(Rad(0), Rad(90), Rad(-20)), 0.3)
        end
        Character.Head.face.Texture = "rbxassetid://620619801"
        attack = false
        Humanoid.JumpPower = 50
        hum.WalkSpeed = 16
    end
    function Flight() --wowthatsdiffrent
        attack = true
        Character.Head.face.Texture = "rbxassetid://269748407"
        local ColorsArray ={ColorSequenceKeypoint.new(0, Color3.new(1,0,0)),
            ColorSequenceKeypoint.new(0.16, Color3.new(1,1,1)),
            ColorSequenceKeypoint.new(0.32, Color3.new(0,0,1)),
            ColorSequenceKeypoint.new(0.48, Color3.new(1,1,1)),
            ColorSequenceKeypoint.new(0.64, Color3.new(1,0,0)),
            ColorSequenceKeypoint.new(0.80, Color3.new(1,1,1)),
            ColorSequenceKeypoint.new(0.96, Color3.new(0,0,1)),
            ColorSequenceKeypoint.new(1, Color3.new(1,1,1))}
        local vel4 = Instance.new("BodyVelocity",ll)
        vel4.Velocity = Vector3.new(0,4,0)
        vel4.MaxForce = Vector3.new(10000000,10000000,10000000)
        local Atch3 = Instance.new("Attachment",ll)Atch3.Position = Vector3.new(0,0.6,0)
        local Atch4 = Instance.new("Attachment",ll)Atch4.Position = Vector3.new(0,-0.6,0)
        local Trail2 = Instance.new("Trail",ll)Trail2.Attachment0 = Atch3 Trail2.Attachment1 = Atch4
        Trail2.Texture = "rbxassetid://22636887" Trail2.Lifetime = 0.2 Trail2.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0,0),NumberSequenceKeypoint.new(1,0,0)})
        Trail2.Color = ColorSequence.new(ColorsArray) Trail2.LightEmission = 1 
        Trail2.Enabled = true
        local Atch5 = Instance.new("Attachment",rl)Atch5.Position = Vector3.new(0,0.6,0)
        local Atch6 = Instance.new("Attachment",rl)Atch6.Position = Vector3.new(0,-0.6,0)
        local Trail3 = Instance.new("Trail",rl)Trail3.Attachment0 = Atch5 Trail3.Attachment1 = Atch6
        Trail3.Texture = "rbxassetid://22636887" Trail3.Lifetime = 0.2 Trail3.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0,0),NumberSequenceKeypoint.new(1,0,0)})
        Trail3.Color = ColorSequence.new(ColorsArray) Trail3.LightEmission = 1 
        Trail3.Enabled = true
        local Atch7 = Instance.new("Attachment",ra)Atch7.Position = Vector3.new(0,0.6,0)
        local Atch8 = Instance.new("Attachment",ra)Atch8.Position = Vector3.new(0,-0.6,0)
        local Trail4 = Instance.new("Trail",ra)Trail4.Attachment0 = Atch7 Trail4.Attachment1 = Atch8
        Trail4.Texture = "rbxassetid://22636887" Trail4.Lifetime = 0.2 Trail4.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0,0),NumberSequenceKeypoint.new(1,0,0)})
        Trail4.Color = ColorSequence.new(ColorsArray) Trail4.LightEmission = 1 
        Trail4.Enabled = true
        local Atch9 = Instance.new("Attachment",la)Atch9.Position = Vector3.new(0,0.6,0)
        local Atch10 = Instance.new("Attachment",la)Atch10.Position = Vector3.new(0,-0.6,0)
        local Trail5 = Instance.new("Trail",la)Trail5.Attachment0 = Atch9 Trail5.Attachment1 = Atch10
        Trail5.Texture = "rbxassetid://22636887" Trail5.Lifetime = 0.2 Trail5.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0,0),NumberSequenceKeypoint.new(1,0,0)})
        Trail5.Color = ColorSequence.new(ColorsArray) Trail5.LightEmission = 1 
        Trail5.Enabled = true
        local Atch1 = Instance.new("Attachment",Torso)Atch1.Position = Vector3.new(0,2,0)
        local Atch2 = Instance.new("Attachment",Torso)Atch2.Position = Vector3.new(0,-2.5,0)
        local Trail = Instance.new("Trail",Torso)Trail.Attachment0 = Atch1 Trail.Attachment1 = Atch2
        Trail.Texture = "rbxassetid://22636887" Trail.Lifetime = 0.2 Trail.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0,0),NumberSequenceKeypoint.new(1,0,0)})
        Trail.Color = ColorSequence.new(ColorsArray) Trail.LightEmission = 1 
        Trail.Enabled = false
        ragdoll(char)
        wait(1)
        Character.Head.face.Texture = "rbxassetid://249062487"
        CreateSound("948494432", hed, 10, 1)
        wait(2)
        Character.Head.face.Texture = "rbxassetid://269748407"
        CreateSound("633394595", hed, 10, 1)
        wait(2)
        Character.Head.face.Texture = "rbxassetid://494811799"
        STHAP:play()
        wait(11)
        forevergone:play()
    end

    function OBJECTION()
        attack = true
        hum.WalkSpeed = 10
        Character.Head.face.Texture = "rbxassetid://55831869"
        CreateSound("330859085", hed, 10, 1)
        for i = 0,8,0.1 do
            swait()
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.2) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
            tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(0), Rad(0), Rad(0)), 0.3)
            RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
            LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
            RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(180), Rad(0), Rad(5)), 0.1)
            LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(-5)), 0.1)
        end
        attack = false
        Character.Head.face.Texture = "rbxassetid://620619801"
        hum.WalkSpeed = 16
    end

    function Hello()
        attack = true
        hum.WalkSpeed = 10
        Character.Head.face.Texture = "rbxassetid://334668738"
        CreateSound("855338765", hed, 10, 0.9)
        for i = 0,3,0.1 do
            swait()
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.2) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
            tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(0), Rad(0), Rad(0)), 0.3)
            RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
            LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
            RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(0)), 0.1)
            LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(180), Rad(20), Rad(-5)), 0.1)
        end
        attack = false
        Character.Head.face.Texture = "rbxassetid://620619801"
        hum.WalkSpeed = 16
    end

    function Victory()
        attack = true
        hum.WalkSpeed = 1.01
        Character.Head.face.Texture = "rbxassetid://616284160"
        Humanoid.Jump = true
        CreateSound("130834939", hed, 10, 1)
        for i = 0,3.7,0.1 do
            swait()
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.2) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
            tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(0), Rad(0), Rad(0)), 0.3)
            RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(-40)), 0.15)
            LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(-40)), 0.15)
            RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(0)), 0.1)
            LW.C0 = clerp(LW.C0, CF(-1.5, 1 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(180), Rad(20), Rad(-5)), 0.1)
        end
        Humanoid.Jump = true
        for i = 0,3.7,0.1 do
            swait()
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.2) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
            tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(0), Rad(0), Rad(0)), 0.3)
            RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(40)), 0.15)
            LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(40)), 0.15)
            RW.C0 = clerp(RW.C0, CF(1.5, 1 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(-180), Rad(-25), Rad(5)), 0.1)
            LW.C0 = clerp(LW.C0, CF(-1.5, 1 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(-0)), 0.1)
        end
        Humanoid.Jump = true
        for i = 0,3.7,0.1 do
            swait()
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.2) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
            tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(0), Rad(0), Rad(0)), 0.3)
            RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(-40)), 0.15)
            LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(-40)), 0.15)
            RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(0)), 0.1)
            LW.C0 = clerp(LW.C0, CF(-1.5, 1 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(180), Rad(20), Rad(-5)), 0.1)
        end
        Humanoid.Jump = true
        for i = 0,3.7,0.1 do
            swait()
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.2) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
            tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(0), Rad(0), Rad(0)), 0.3)
            RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(40)), 0.15)
            LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(40)), 0.15)
            RW.C0 = clerp(RW.C0, CF(1.5, 1 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(-180), Rad(-25), Rad(5)), 0.1)
            LW.C0 = clerp(LW.C0, CF(-1.5, 1 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(-0)), 0.1)
        end
        Humanoid.Jump = true
        for i = 0,3.7,0.1 do
            swait()
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.2) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
            tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(0), Rad(0), Rad(0)), 0.3)
            RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(-40)), 0.15)
            LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(-40)), 0.15)
            RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(0)), 0.1)
            LW.C0 = clerp(LW.C0, CF(-1.5, 1 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(180), Rad(20), Rad(-5)), 0.1)
        end
        attack = false
        Character.Head.face.Texture = "rbxassetid://620619801"
        hum.WalkSpeed = 16
    end

    function ShutTheHellUp()
        attack = true
        hum.WalkSpeed = 2.01
        Character.Head.face.Texture = "rbxassetid://963148419"
        CreateSound("336377340", hed, 10, 1)
        for i = 0,3,0.1 do
            swait()
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
            tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(0), Rad(0), Rad(0)), 0.3)
            RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
            LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
            RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(90), Rad(0), Rad(5)), 0.1)
            LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(-5)), 0.1)
        end
        for i = 0,1.2,0.1 do
            swait()
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
            tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(20), Rad(0), Rad(0)), 0.3)
            RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
            LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
            RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(90), Rad(0), Rad(5)), 0.1)
            LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(-5)), 0.1)
        end
        for i = 0,1.2,0.1 do
            swait()
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
            tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-5), Rad(0), Rad(0)), 0.3)
            RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
            LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
            RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(90), Rad(0), Rad(5)), 0.1)
            LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(-5)), 0.1)
        end
        for i = 0,1.2,0.1 do
            swait()
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.2) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
            tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(20), Rad(0), Rad(0)), 0.3)
            RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
            LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
            RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(90), Rad(0), Rad(5)), 0.1)
            LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(-5)), 0.1)
        end
        for i = 0,1.2,0.1 do
            swait()
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.2) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
            tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-5), Rad(0), Rad(0)), 0.3)
            RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
            LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
            RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(90), Rad(0), Rad(5)), 0.1)
            LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(-5)), 0.1)
        end
        for i = 0,2,0.1 do
            swait()
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
            tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(0), Rad(0), Rad(0)), 0.3)
            RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
            LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
            RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(120), Rad(0), Rad(5)), 0.1)
            LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(-5)), 0.1)
        end
        for i = 0,2,0.1 do
            swait()
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
            tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(0), Rad(0), Rad(0)), 0.3)
            RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
            LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
            RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(90), Rad(0), Rad(5)), 0.1)
            LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(-5)), 0.1)
        end
        hum.WalkSpeed = 16
        Character.Head.face.Texture = "rbxassetid://620619801"
        attack = false
    end

    function SpinMeDad() --YOU SPIN ME RIGHT ROUND BABY RIGHT ROUND
        attack = true
        hum.WalkSpeed = 5
        Humanoid.JumpPower = 175
        Character.Head.face.Texture = "rbxassetid://1223903433"
        CreateSound("145799973", hed, 10, 1)
        local vel2 = Instance.new("BodyVelocity",tors)
        vel2.Velocity = Vector3.new(0,1.2,0)
        vel2.MaxForce = Vector3.new(10000000,10000000,10000000)
        for i = 0,60,0.1 do
            HitboxFunction(ll.CFrame, 0.01, 1, 1, 1, 7, 5, 20, 53, "Knockdown")
            swait()
            CameraEnshaking(1, 1)
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0-255.45*i)), 0.15)
            tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(0), Rad(0), Rad(0)), 0.3)
            RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
            LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
            RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(90)), 0.1)
            LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(-90)), 0.1)
        end
        hum.WalkSpeed = 16
        vel2:Destroy()
        Character.Head.face.Texture = "rbxassetid://620619801"
        Humanoid.JumpPower = 50
        attack = false
    end

    function EndMySufferingV2() --why
        attack = true
        hum.WalkSpeed = 1.01
        Character.Head.face.Texture = "rbxassetid://202210455"
        local A = math.random(1,5)
        if A == 1 then
            meme.SoundId = "rbxassetid://295810519"
        end
        if A == 2 then
            meme.SoundId = "rbxassetid://1124778077"
        end
        if A == 3 then
            meme.SoundId = "rbxassetid://464157070"
        end
        if A == 4 then
            meme.SoundId = "rbxassetid://146334595"
        end
        if A == 5 then
            meme.SoundId = "rbxassetid://145536915"
        end
        meme:Play()
        bass:Play()
        joyemoji.Rate = 70
        LIT.Rate = 70
        ok.Rate = 70
        toast.Rate = 70

        for i = 0,50,0.1 do
            swait()
            CameraEnshaking(1, 10)
            bass.Parent = hed
            meme.Parent = hed
            rootj.C0=clerp(rootj.C0,RootCF*CF(0,0,-0.1+0.1*math.cos(sine/20))*angles(math.rad(15),math.rad(-10),math.rad(0)),0.15)
            tors.Neck.C0=clerp(tors.Neck.C0,necko*angles(math.rad(35),math.rad(0),math.rad(0)),.3)
            RH.C0=clerp(RH.C0,CF(1,-.9-0.1*math.cos(sine/20),.025*math.cos(sine/20))*RHCF*angles(math.rad(-5),math.rad(0),math.rad(0)),0.15)
            LH.C0=clerp(LH.C0,CF(-1,-.9-0.1*math.cos(sine/20),.025*math.cos(sine/20))*LHCF*angles(math.rad(-5),math.rad(-0),math.rad(-20)),0.15)
            RW.C0 = clerp(RW.C0, CFrame.new(1.1, 0.5+0.1*math.sin(sine/30), -0.6) * angles(math.rad(-0), math.rad(10), math.rad(-110)), 0.1)
            LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5+0.1*math.sin(sine/30), 0.055*math.cos(sine/20)) * angles(math.rad(-0), math.rad(-10), math.rad(-105)), 0.1)
        end
        bass:Stop()
        meme:Stop()
        joyemoji.Rate = 0
        LIT.Rate = 0
        ok.Rate = 0
        toast.Rate = 0
        Character.Head.face.Texture = "rbxassetid://620619801"
        attack = false
        hum.WalkSpeed = 16
    end

    function HELP()
        attack = true
        hum.WalkSpeed = 1.01
        Character.Head.face.Texture = "rbxassetid://307972876"
        CreateSound("1123321019", hed, 10, 1)
        for i = 0,15,0.1 do
            swait()
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
            tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(0), Rad(0), Rad(0)), 0.3)
            RH.C0 = clerp(RH.C0, CF(0.7, -0.01 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
            LH.C0 = clerp(LH.C0, CF(-0.7, -0.01 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
            RW.C0 = clerp(RW.C0, CF(0.9, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(0)), 0.1)
            LW.C0 = clerp(LW.C0, CF(-0.9, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(0)), 0.1)
        end
        CreateSound("198462271", hed, 10, 1)
        for i = 0,8,0.1 do
            Character.Head.face.Texture = "rbxassetid://341497730"
            swait()
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
            tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(0), Rad(0), Rad(0)), 0.3)
            RH.C0 = clerp(RH.C0, CF(0.7, -0.01 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
            LH.C0 = clerp(LH.C0, CF(-0.7, -0.01 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
            RW.C0 = clerp(RW.C0, CF(0.9, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(0)), 0.1)
            LW.C0 = clerp(LW.C0, CF(-0.9, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(0)), 0.1)
        end
        for i = 0,8,0.1 do
            Character.Head.face.Texture = "rbxassetid://341497730"
            swait()
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
            tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(60), Rad(0), Rad(0)), 0.3)
            RH.C0 = clerp(RH.C0, CF(0.7, -0.01 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
            LH.C0 = clerp(LH.C0, CF(-0.7, -0.01 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
            RW.C0 = clerp(RW.C0, CF(0.9, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(0)), 0.1)
            LW.C0 = clerp(LW.C0, CF(-0.9, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(0)), 0.1)
        end
        CreateSound("948494432", hed, 10, 1)
        for i = 0,7.5,0.1 do
            Character.Head.face.Texture = "rbxassetid://249062487"
            swait()
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
            tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(60), Rad(0), Rad(0)), 0.3)
            RH.C0 = clerp(RH.C0, CF(0.7, -0.01 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
            LH.C0 = clerp(LH.C0, CF(-0.7, -0.01 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
            RW.C0 = clerp(RW.C0, CF(0.9, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(0)), 0.1)
            LW.C0 = clerp(LW.C0, CF(-0.9, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(0)), 0.1)
        end
        CreateSound("1542642349", hed, 10, 1)
        for i = 0,10,0.1 do
            Character.Head.face.Texture = "rbxassetid://270636807"
            swait()
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
            tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(0), Rad(0), Rad(0)), 0.3)
            RH.C0 = clerp(RH.C0, CF(0.7, -0.01 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
            LH.C0 = clerp(LH.C0, CF(-0.7, -0.01 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
            RW.C0 = clerp(RW.C0, CF(0.9, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(0)), 0.1)
            LW.C0 = clerp(LW.C0, CF(-0.9, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(0)), 0.1)
        end
        CreateSound("269597232", hed, 10, 1)
        for i = 0,6,0.1 do
            Character.Head.face.Texture = "rbxassetid://265057155"
            swait()
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
            tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(0), Rad(0), Rad(0)), 0.3)
            RH.C0 = clerp(RH.C0, CF(0.7, -0.01 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
            LH.C0 = clerp(LH.C0, CF(-0.7, -0.01 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
            RW.C0 = clerp(RW.C0, CF(0.9, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(0)), 0.1)
            LW.C0 = clerp(LW.C0, CF(-0.9, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(0)), 0.1)
        end
        attack = false
        Character.Head.face.Texture = "rbxassetid://620619801"
        hum.WalkSpeed = 16
    end

    function Choose()
        attack = true
        hum.WalkSpeed = 1.01
        Character.Head.face.Texture = "rbxassetid://374187112"
        CreateSound("130784263", hed, 10, 1)
        for i = 0,4,0.1 do
            swait()
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
            tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(0), Rad(0), Rad(0)), 0.3)
            RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
            LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
            RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(110), Rad(0), Rad(0)), 0.1)
            LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(110), Rad(0), Rad(0)), 0.1)
        end
        for i = 0,5,0.1 do
            swait()
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
            tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(0), Rad(0), Rad(0)), 0.3)
            RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
            LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
            RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(35), Rad(0), Rad(-10)), 0.1)
            LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(35), Rad(0), Rad(10)), 0.1)
        end
        attack = false
        Character.Head.face.Texture = "rbxassetid://620619801"
        hum.WalkSpeed = 16
    end

    function slap()
        attack = true
        hum.WalkSpeed = 10
        CreateSound("146163534", hed, 10, 1)
        Character.Head.face.Texture = "rbxassetid://293603561"
        CameraEnshaking(1, 2)
        for i = 0,4,0.1 do
            swait()
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
            tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(20), Rad(0), Rad(0)), 0.3)
            RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
            LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
            RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(20), Rad(0), Rad(5)), 0.1)
            LW.C0 = clerp(LW.C0, CF(-1, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(115 + 4), Rad(45), Rad(50)), 0.1)
        end
        Character.Head.face.Texture = "rbxassetid://620619801"
        attack = false
        hum.WalkSpeed = 16
    end

    function MYSPAGHETTTTTTT() --ow
        attack = true
        hum.WalkSpeed = 1.01
        CreateSound("1282149571", hed, 10, 1)
        Character.Head.face.Texture = "rbxassetid://1329282756"
        CameraEnshaking(1, 2.2)
        for i = 0,4,0.1 do
            swait()
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
            tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(20), Rad(0), Rad(0)), 0.3)
            RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
            LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
            RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(20), Rad(0), Rad(5)), 0.1)
            LW.C0 = clerp(LW.C0, CF(-1, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(115 + 4), Rad(45), Rad(50)), 0.1)
        end
        for i = 0,5,0.1 do
            swait()
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
            tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(0), Rad(0), Rad(0)), 0.3)
            RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
            LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
            RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(110), Rad(0), Rad(0)), 0.1)
            LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(110), Rad(0), Rad(0)), 0.1)
        end
        for i = 0,6,0.1 do
            swait()
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
            tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(0), Rad(0), Rad(0)), 0.3)
            RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
            LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
            RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(35), Rad(0), Rad(-10)), 0.1)
            LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(35), Rad(0), Rad(10)), 0.1)
        end
        attack = false
        Character.Head.face.Texture = "rbxassetid://620619801"
        hum.WalkSpeed = 16
    end


    function dead()
        attack = true
        hum.WalkSpeed = 0.20
        CreateSound("137225991", hed, 10, 1)
        Character.Head.face.Texture = "rbxassetid://297512410"
        for i = 0,1.1,0.1 do
            swait()
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
            tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-0), Rad(0), Rad(0)), 0.3)
            RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(90)), 0.15)
            LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(-90)), 0.15)
            RW.C0 = clerp(RW.C0, CF(1.5, 1 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(140)), 0.1)
            LW.C0 = clerp(LW.C0, CF(-1.5, 1 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(-140)), 0.1)
        end
        for i = 0,1.1,0.1 do
            swait()
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(90), Rad(0)), 0.15)
            tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-0), Rad(0), Rad(0)), 0.3)
            RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(90)), 0.15)
            LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(-90)), 0.15)
            RW.C0 = clerp(RW.C0, CF(1.5, 1 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(140)), 0.1)
            LW.C0 = clerp(LW.C0, CF(-1.5, 1 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(-140)), 0.1)
        end
        for i = 0,1.1,0.1 do
            swait()
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(180), Rad(0)), 0.15)
            tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-0), Rad(0), Rad(0)), 0.3)
            RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(90)), 0.15)
            LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(-90)), 0.15)
            RW.C0 = clerp(RW.C0, CF(1.5, 1 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(140)), 0.1)
            LW.C0 = clerp(LW.C0, CF(-1.5, 1 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(-140)), 0.1)
        end
        for i = 0,1.1,0.1 do
            swait()
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(270), Rad(0)), 0.15)
            tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-0), Rad(0), Rad(0)), 0.3)
            RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(90)), 0.15)
            LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(-90)), 0.15)
            RW.C0 = clerp(RW.C0, CF(1.5, 1 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(140)), 0.1)
            LW.C0 = clerp(LW.C0, CF(-1.5, 1 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(-140)), 0.1)
        end
        for i = 0,1.1,0.1 do
            swait()
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
            tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-0), Rad(0), Rad(0)), 0.3)
            RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(90)), 0.15)
            LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(-90)), 0.15)
            RW.C0 = clerp(RW.C0, CF(1.5, 1 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(140)), 0.1)
            LW.C0 = clerp(LW.C0, CF(-1.5, 1 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(-140)), 0.1)
        end
        for i = 0,1.1,0.1 do
            swait()
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(90), Rad(0)), 0.15)
            tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-0), Rad(0), Rad(0)), 0.3)
            RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(90)), 0.15)
            LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(-90)), 0.15)
            RW.C0 = clerp(RW.C0, CF(1.5, 1 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(140)), 0.1)
            LW.C0 = clerp(LW.C0, CF(-1.5, 1 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(-140)), 0.1)
        end
        for i = 0,1.1,0.1 do
            swait()
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(180), Rad(0)), 0.15)
            tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-0), Rad(0), Rad(0)), 0.3)
            RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(90)), 0.15)
            LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(-90)), 0.15)
            RW.C0 = clerp(RW.C0, CF(1.5, 1 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(140)), 0.1)
            LW.C0 = clerp(LW.C0, CF(-1.5, 1 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(-140)), 0.1)
        end
        for i = 0,1.1,0.1 do
            swait()
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(270), Rad(0)), 0.15)
            tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-0), Rad(0), Rad(0)), 0.3)
            RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(90)), 0.15)
            LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(-90)), 0.15)
            RW.C0 = clerp(RW.C0, CF(1.5, 1 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(140)), 0.1)
            LW.C0 = clerp(LW.C0, CF(-1.5, 1 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(-140)), 0.1)
        end
        for i = 0,1.1,0.1 do
            swait()
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
            tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-0), Rad(0), Rad(0)), 0.3)
            RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(90)), 0.15)
            LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(-90)), 0.15)
            RW.C0 = clerp(RW.C0, CF(1.5, 1 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(140)), 0.1)
            LW.C0 = clerp(LW.C0, CF(-1.5, 1 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(-140)), 0.1)
        end
        Character.Head.face.Texture = "rbxassetid://273309187"
        for i = 0,9,0.1 do
            swait()
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -2.59 + 0.1) * angles(Rad(-90), Rad(90), Rad(0)), 0.15)
            tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-0), Rad(0), Rad(0)), 0.3)
            RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
            LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(-0)), 0.15)
            RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(30)), 0.1)
            LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(-30)), 0.1)
        end
        attack = false
        Character.Head.face.Texture = "rbxassetid://620619801"
        hum.WalkSpeed = 16
    end

    function hap() --much hap
        attack = true
        hum.WalkSpeed = 0.10
        CreateSound("363808674", hed, 10, 1)
        Character.Head.face.Texture = "rbxassetid://315792941"
        for i = 0,12,0.1 do
            swait()
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
            tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-0), Rad(0), Rad(180)), 0.3)
            RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
            LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
            RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(0)), 0.1)
            LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(-0)), 0.1)
        end
        CreateSound("233168827", hed, 10, 1)
        Character.Head.face.Texture = "rbxassetid://335761015"
        for i = 0,10,0.1 do
            swait()
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
            tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-0), Rad(0), Rad(180)), 0.3)
            RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
            LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
            RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(0)), 0.1)
            LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(-0)), 0.1)
        end
        CreateSound("363808674", hed, 10, 1)
        attack = false
        Character.Head.face.Texture = "rbxassetid://620619801"
        hum.WalkSpeed = 16
    end

    function HAAAAA() --KONO POWA
        attack = true
        hum.WalkSpeed = 1.01
        Character.Head.face.Texture = "rbxassetid://305068389"
        chargeup.Pitch = 1
        for i = 0,7,0.1 do
            swait()
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
            tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(0), Rad(0), Rad(0)), 0.3)
            RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
            LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
            RW.C0 = clerp(RW.C0, CF(1.5, 1 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(150), Rad(0), Rad(0)), 0.1)
            LW.C0 = clerp(LW.C0, CF(-1.5, 1 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(150), Rad(0), Rad(-0)), 0.1)
        end
        Character.Head.face.Texture = "rbxassetid://313921371"
        chargeup:play()
        for i = 0,30,0.1 do
            swait()
            CameraEnshaking(1, 2)
            chargeup.Parent = hed
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
            tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(15), Rad(0), Rad(0)), 0.3)
            RH.C0 = clerp(RH.C0, CF(1.1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-20), Rad(0), Rad(0)), 0.15)
            LH.C0 = clerp(LH.C0, CF(-1.1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-20), Rad(0), Rad(0)), 0.15)
            RW.C0 = clerp(RW.C0, CF(1.4, 0.0000000005 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(150), Rad(0), Rad(0)), 0.1)
            LW.C0 = clerp(LW.C0, CF(-1.4, 0.0000000005 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(150), Rad(0), Rad(-0)), 0.1)
        end
        chargeup:stop()
        chargeup.Pitch = 1.1
        chargeup.TimePosition = 1
        chargeup:play()
        Character.Head.face.Texture = "rbxassetid://304942859"
        for i, v in pairs(c:children()) do
            if v.ClassName == "Part" then
                local tra = trazx:clone()
                tra.Parent = v
                tra.LightEmission = 1
                tra.Color = ColorSequence.new(Color3.new(0, 0.6666666666666666, 1))
                tra.Rate = 15
                tra.Rotation = NumberRange.new(-5, 5)
                tra.Lifetime = NumberRange.new(1.5, 2)
                tra.Size = NumberSequence.new({
                    NumberSequenceKeypoint.new(0, 0.1, 0),
                    NumberSequenceKeypoint.new(1, 0, 0)
                })
                tra.Transparency = NumberSequence.new({
                    NumberSequenceKeypoint.new(0, 1, 0),
                    NumberSequenceKeypoint.new(0.135, 0, 0),
                    NumberSequenceKeypoint.new(0.875, 0, 0),
                    NumberSequenceKeypoint.new(1, 1, 0)
                })
                tra.Speed = NumberRange.new(0.5)
                tra.VelocitySpread = 360
                tra.VelocityInheritance = 0.5
                tra.ZOffset = 2
                tra.Acceleration = Vector3.new(0, 2.5, 0)
            end
        end
        local tra = trazx:clone()
        tra.Parent = c.HumanoidRootPart
        tra.Texture = "rbxassetid://347730682"
        tra.LightEmission = 0.8
        tra.Color = ColorSequence.new(Color3.new(0, 0.6666666666666666, 1))
        tra.Rate = 250
        tra.Rotation = NumberRange.new(-5, 5)
        tra.Lifetime = NumberRange.new(0.75)
        tra.Size = NumberSequence.new({
            NumberSequenceKeypoint.new(0, 4.81, 0.875),
            NumberSequenceKeypoint.new(1, 2.13, 0.875)
        })
        tra.Transparency = NumberSequence.new({
            NumberSequenceKeypoint.new(0, 1, 0),
            NumberSequenceKeypoint.new(0.0399, 0.85, 0),
            NumberSequenceKeypoint.new(0.394, 0.9, 0),
            NumberSequenceKeypoint.new(0.699, 1, 0),
            NumberSequenceKeypoint.new(1, 1, 0)
        })
        tra.Speed = NumberRange.new(15)
        tra.VelocitySpread = 360
        tra.VelocityInheritance = 0.5
        tra.ZOffset = 3.5
        tra.Acceleration = Vector3.new(0, 25, 0)
        for i = 0,35,0.1 do
            swait()
            ohno.Parent = hed
            CameraEnshaking(1, 3)
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
            tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(60), Rad(0), Rad(0)), 0.3)
            RH.C0 = clerp(RH.C0, CF(1.1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-20), Rad(0), Rad(0)), 0.15)
            LH.C0 = clerp(LH.C0, CF(-1.1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-20), Rad(0), Rad(0)), 0.15)
            RW.C0 = clerp(RW.C0, CF(1.4, 0.0000000005 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(150), Rad(0), Rad(0)), 0.1)
            LW.C0 = clerp(LW.C0, CF(-1.4, 0.0000000005 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(150), Rad(0), Rad(-0)), 0.1)
        end
        chargeup:stop()
        chargeup.Pitch = 1.3
        chargeup.TimePosition = 1
        chargeup:play()
        tra:Destroy()
        tra:Destroy()
        Character.Head.face.Texture = "rbxassetid://280233855"
        local tra = trazx:clone()
        tra.Parent = c.HumanoidRootPart
        tra.Texture = "rbxassetid://347730682"
        tra.LightEmission = 0.8
        tra.Color = ColorSequence.new(Color3.new(1, 0, 0))
        tra.Rate = 250
        tra.Rotation = NumberRange.new(-5, 5)
        tra.Lifetime = NumberRange.new(0.3)
        tra.Size = NumberSequence.new({
            NumberSequenceKeypoint.new(0, 8, 0.875),
            NumberSequenceKeypoint.new(1, 10, 0.875)
        })
        tra.Transparency = NumberSequence.new({
            NumberSequenceKeypoint.new(0, 1, 0),
            NumberSequenceKeypoint.new(0.0399, 0.531, 0),
            NumberSequenceKeypoint.new(0.394, 0.906, 0),
            NumberSequenceKeypoint.new(0.699, 1, 0),
            NumberSequenceKeypoint.new(1, 1, 0)
        })
        for i = 0,32,0.1 do
            swait()
            CameraEnshaking(1, 5)
            chargeup.Parent = hed
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
            tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-65), Rad(0), Rad(0)), 0.3)
            RH.C0 = clerp(RH.C0, CF(1.1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-20), Rad(0), Rad(0)), 0.15)
            LH.C0 = clerp(LH.C0, CF(-1.1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-20), Rad(0), Rad(0)), 0.15)
            RW.C0 = clerp(RW.C0, CF(1.4, 0.0000000005 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(150), Rad(0), Rad(0)), 0.1)
            LW.C0 = clerp(LW.C0, CF(-1.4, 0.0000000005 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(150), Rad(0), Rad(-0)), 0.1)
        end
        chargeup:stop()
        CreateSound("681582832", hed, 10, 1)
        game.Players.LocalPlayer.Character:BreakJoints()
        local S = Instance.new("Explosion",workspace)    
        S.Position = tors.Position
        S.BlastPressure = 9
        S.BlastRadius = 30
        S.ExplosionType = 0
        attack = false
        hum.WalkSpeed = 16
        Character.Head.face.Texture = "rbxassetid://295197013"
        tra:Destroy()
        CameraEnshaking(4, 30)
        error("WARNING, TO MUCH ENERGY.")
    end

    function NEN()
        attack = true
        hum.WalkSpeed = 1.01
        CreateSound("230292011", hed, 10, 1)
        Character.Head.face.Texture = "rbxassetid://705269463"
        for i = 0,4,0.1 do
            swait()
            CameraEnshaking(1, 3)
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
            tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-90), Rad(0), Rad(0)), 0.3)
            RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
            LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
            RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(120)), 0.1)
            LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(-120)), 0.1)
        end
        attack = false
        Character.Head.face.Texture = "rbxassetid://620619801"
        hum.WalkSpeed = 16
    end

    function FLYSKYHIGH()
        attack = true
        timetofly = false
        hum.WalkSpeed = 0.05
        Character.Head.face.Texture = "rbxassetid://705269463"
        Cause_Im_having_a_good_time_having_a_good_time:Play()
        Cause_Im_having_a_good_time_having_a_good_time.TimePosition = 35.3
        Humanoid.JumpPower = 0
        for i = 0,300,0.1 do --thatsalongtime
            swait()
            CameraEnshaking(1, 7)
            HitboxFunction(ll.CFrame, 0.01, 1, 1, 1, 7, 75, 500, 100, "Knockdown")
            Cause_Im_having_a_good_time_having_a_good_time.Parent = hed
            root.Velocity = root.CFrame.lookVector * 225
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
            tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-0-255.45*i), Rad(0), Rad(0)), 0.3)
            RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0-255.45*i)), 0.15)
            LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0-255.45*i)), 0.15)
            RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(-75), Rad(0), Rad(0)), 0.1)
            LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(-75), Rad(0), Rad(0)), 0.1)
        end
        Cause_Im_having_a_good_time_having_a_good_time:Stop()
        attack = false
        Humanoid.JumpPower = 50
        Character.Head.face.Texture = "rbxassetid://620619801"
        hum.WalkSpeed = 16
        wait(45)
        timetofly = true
        warn("You can FLY SKY HIGH Now! Go Nuts!") --please dont go nuts
    end


    function highnoon()
        attack = true
        hum.WalkSpeed = 1.01
        CreateSound("495316660", hed, 10, 1)
        Character.Head.face.Texture = "rbxassetid://155195214"
        CameraEnshaking(2, 4)
        local Blobby = Instance.new("Part", char)
        Blobby.Name = "Blob"
        Blobby.CanCollide = false
        Blobby.BrickColor = BrickColor.new("Really black")
        Blobby.Transparency = 0
        Blobby.Material = "Plastic"
        Blobby.Size = Vector3.new(1, 1, 2)
        Blobby.TopSurface = Enum.SurfaceType.Smooth
        Blobby.BottomSurface = Enum.SurfaceType.Smooth

        local Weld = Instance.new("Weld", Blobby)
        Weld.Part0 = ra
        Weld.Part1 = Blobby
        Weld.C1 = CFrame.new(0, -.4, -1.6) *angles(Rad(180), Rad(0), Rad(180))
        Weld.C0 = CFrame.Angles(math.rad(-90),0,0)

        local M2 = Instance.new("SpecialMesh")
        M2.Parent = Blobby
        M2.MeshId = "http://www.roblox.com/asset/?id=432256490"
        M2.TextureId = "http://www.roblox.com/asset/?id=432256526"
        M2.Scale = Vector3.new(.002, .002, .002)
        for i = 0,7.75,0.1 do
            swait()
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(90)), 0.2)
            tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(30), Rad(0), Rad(0)), 0.2)
            RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.2)
            LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.2)
            RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(-.6), Rad(180)), 0.2)
            LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(-45), Rad(-.6), Rad(136 - 4.5 * Sin(sine / 20))), 0.2)
        end
        for i = 0,16.5,0.1 do
            swait()
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(90)), 0.2)
            tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(30), Rad(0), Rad(0)), 0.2)
            RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.2)
            LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.2)
            RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(-.6), Rad(90)), 0.2)
            LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(-45), Rad(-.6), Rad(136 - 4.5 * Sin(sine / 20))), 0.2)
        end
        Blobby.Transparency = 1
        Blobby:Destroy()
        attack = false
        Character.Head.face.Texture = "rbxassetid://620619801"
        hum.WalkSpeed = 16
    end

    function somuchcancerwhy() --o no
        attack = true
        hum.WalkSpeed = 0.10
        Character.Head.face.Texture = "rbxassetid://315074049"
        local A = math.random(1,13)
        if A == 1 then
            ohno.SoundId = "rbxassetid://295810519"
            ohno.TimePosition = 1
        end
        if A == 2 then
            ohno.SoundId = "rbxassetid://488472970"
            ohno.TimePosition = 2
        end
        if A == 3 then
            ohno.SoundId = "rbxassetid://917045199"
            ohno.TimePosition = 3
        end
        if A == 4 then
            ohno.SoundId = "rbxassetid://324205173"
            ohno.TimePosition = 1
        end
        if A == 5 then
            ohno.SoundId = "rbxassetid://376134741"
            ohno.TimePosition = 8
        end
        if A == 6 then
            ohno.SoundId = "rbxassetid://164147183"
            ohno.TimePosition = 0
        end
        if A == 7 then
            ohno.SoundId = "rbxassetid://825526716"
            ohno.TimePosition = 1
        end
        if A == 8 then
            ohno.SoundId = "rbxassetid://185460366"
            ohno.TimePosition = 0
        end
        if A == 9 then
            ohno.SoundId = "rbxassetid://273319633"
            ohno.TimePosition = 1
        end
        if A == 10 then
            ohno.SoundId = "rbxassetid://506212392"
            ohno.TimePosition = 2
        end
        if A == 11 then
            ohno.SoundId = "rbxassetid://708297448"
            ohno.TimePosition = 4
        end
        if A == 12 then
            ohno.SoundId = "rbxassetid://497199103"
            ohno.TimePosition = 9
        end
        if A == 13 then
            ohno.SoundId = "rbxassetid://152833989"
            ohno.TimePosition = 1
        end
        ohno:Play()
        for i = 0,100,0.1 do
            swait()
            CameraEnshaking(2, 3)
            ohno.Parent = hed
            char.Torso.Neck.C0 = char.Torso.Neck.C0 * CFrame.Angles(math.random(-10,10),math.random(-10,10),math.random(-10,10))
        end
        attack = false
        ohno:Stop()
        Character.Head.face.Texture = "rbxassetid://620619801"
        hum.WalkSpeed = 16
    end

    function WRY() --WRYYYYYYY
        attack = true
        hum.WalkSpeed = 0.30
        CreateSound("794081034", hed, 10, 1)
        Character.Head.face.Texture = "rbxassetid://396389196"
        for i = 0,2,0.1 do
            swait()
            CameraEnshaking(1, 2)
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
            tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(30), Rad(0), Rad(0)), 0.3)
            RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
            LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
            RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(140), Rad(60)), 0.1)
            LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(-140), Rad(-60)), 0.1)
        end
        for i = 0,14.7,0.1 do
            swait()
            CameraEnshaking(1, 3)
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 1, -1 + 0.1) * angles(Rad(-75), Rad(0), Rad(0)), 0.15)
            tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(65), Rad(0), Rad(0)), 0.3)
            RH.C0 = clerp(RH.C0, CF(1.1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(-70)), 0.15)
            LH.C0 = clerp(LH.C0, CF(-1.1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(70)), 0.15)
            RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(45), Rad(0), Rad(40)), 0.1)
            LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(45), Rad(-0), Rad(-40)), 0.1)
        end
        attack = false
        Character.Head.face.Texture = "rbxassetid://620619801"
        hum.WalkSpeed = 16
    end

    function BOI()
        attack = true
        hum.WalkSpeed = 1.01
        CreateSound("390901873", hed, 10, 1)
        Character.Head.face.Texture = "rbxassetid://282463320"
        for i = 0,4,0.1 do
            swait()
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
            tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(0), Rad(0), Rad(0)), 0.3)
            RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
            LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
            RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(50), Rad(90)), 0.1)
            LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(-50), Rad(-90)), 0.1)
        end
        for i = 0,4,0.1 do
            swait()
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
            tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(30), Rad(0), Rad(0)), 0.3)
            RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
            LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
            RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(140), Rad(60)), 0.1)
            LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(-140), Rad(-60)), 0.1)
        end
        attack = false
        Character.Head.face.Texture = "rbxassetid://620619801"
        hum.WalkSpeed = 16
    end

    function WhatHuh()
        attack = true
        hum.WalkSpeed = 1.01
        CreateSound("130766865", hed, 10, 1)
        Character.Head.face.Texture = "rbxassetid://276732672"
        for i = 0,4,0.1 do
            swait()
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
            tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(0), Rad(26), Rad(0)), 0.3)
            RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
            LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
            RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(120)), 0.1)
            LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(-120)), 0.1)
        end
        for i = 0,6.7,0.1 do
            swait()
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
            tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(0), Rad(-26), Rad(0)), 0.3)
            RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
            LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
            RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(120)), 0.1)
            LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(-120)), 0.1)
        end
        for i = 0,8.1,0.1 do
            swait()
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
            tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(0), Rad(26), Rad(0)), 0.3)
            RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
            LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
            RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(120)), 0.1)
            LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(-120)), 0.1)
        end
        for i = 0,1,0.1 do
            swait()
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
            tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(40), Rad(-26), Rad(0)), 0.3)
            RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
            LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
            RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(120)), 0.1)
            LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(-120)), 0.1)
        end
        for i = 0,1,0.1 do
            swait()
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
            tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(40), Rad(26), Rad(0)), 0.3)
            RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
            LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
            RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(120)), 0.1)
            LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(-120)), 0.1)
        end
        for i = 0,4,0.1 do
            swait()
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
            tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(0), Rad(-26), Rad(0)), 0.3)
            RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
            LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
            RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(120)), 0.1)
            LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(-120)), 0.1)
        end
        attack = false
        Character.Head.face.Texture = "rbxassetid://620619801"
        hum.WalkSpeed = 16
    end

    function NothingPersonal()
        if mouse.Target.Parent ~= char and mouse.Target.Parent.Parent ~= char and mouse.Target.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
            local HITBODY = mouse.Target.Parent
            local TORS = HITBODY:FindFirstChild("Torso") or HITBODY:FindFirstChild("UpperTorso")
            local HEAD = HITBODY:FindFirstChild("Head")
            local HUMAN = mouse.Target.Parent:FindFirstChildOfClass("Humanoid")
            if TORS ~= nil and HUMAN ~= nil then
                attack = true
                root.CFrame = TORS.CFrame * CFrame.new(-1,0,3)
                TORS.Anchored = true
                hum.WalkSpeed = 0
                Character.Head.face.Texture = "rbxassetid://40770311"
                CreateSound("1255922819", hed, 10, 1)
                CameraEnshaking(2, 4)
            end
            wait(3.5)
            for i = 0,9,0.1 do
                swait()
                for i = 1,2 do
                    HitboxFunction(ll.CFrame, 0.01, 1, 1, 1, 7, 1, 10, 53, "Knockdown")
                    CameraEnshaking(1, 7)
                    Effects.Sphere.Create(BrickColor.new("Persimmon"), TORS.CFrame*CFrame.new(math.random(-200,200)/100,math.random(-300,200)/100,math.random(-100,100)/100), 1, 1, 1, 15, 15, 15, 0.2)
                end
            end
            wait(.5)
            TORS.Anchored = false
            attack = false
            Character.Head.face.Texture = "rbxassetid://620619801"
            hum.WalkSpeed = 16
        end
    end

    function VeryMuchWorrying()
        attack = true
        hum.WalkSpeed = 1.01
        Character.Head.face.Texture = "rbxassetid://111523405"
        CreateSound("1395854043", hed, 10, 1)
        for i = 0,14,0.1 do
            swait()
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
            tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(0), Rad(0), Rad(0)), 0.3)
            RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
            LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
            RW.C0 = clerp(RW.C0, CF(1.3, 0.9 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(-145)), 0.1)
            LW.C0 = clerp(LW.C0, CF(-1.3, 0.9 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(145)), 0.1)
        end
        attack = false
        Character.Head.face.Texture = "rbxassetid://620619801"
        hum.WalkSpeed = 16
    end

    function Ashes() --Straight from... Whatever it was called.
        attack = true
        hum.WalkSpeed = 1.01
        Character.Head.face.Texture = "rbxassetid://360687027"
        CreateSound("290084602", tors, 10, 1)
        for i = 0,6.2,0.1 do
            swait()
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
            tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-30), Rad(0), Rad(0)), 0.3)
            RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-5), Rad(0), Rad(0)), 0.15)
            LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-5), Rad(0), Rad(-0)), 0.15)
            RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(-0), Rad(0), Rad(145)), 0.1)
            LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(-0), Rad(0), Rad(-145)), 0.1)
        end
        for i = 0,6.2,0.1 do
            swait()
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1 * Cos(sine / 20)) * angles(Rad(20), Rad(0), Rad(0)), 0.15)
            tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(0), Rad(0), Rad(0)), 0.3)
            RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-5), Rad(0), Rad(20)), 0.15)
            LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-5), Rad(0), Rad(-20)), 0.15)
            RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(-30), Rad(0), Rad(15)), 0.1)
            LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(-30), Rad(0), Rad(-15)), 0.1)
        end
        attack = false
        Character.Head.face.Texture = "rbxassetid://620619801"
        hum.WalkSpeed = 16
    end

    function AnotherOne() --WhAT ANOTHER ONE
        attack = true
        hum.WalkSpeed = 1.01
        local icri = CreateSound("1205111204", hed, 10, 1)
        swait(165)
        local FRAME = tors.CFrame
        repeat
            swait()
            Character.Head.face.Texture = "rbxassetid://582931093"
            CameraEnshaking(1, 10)
            tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(0), Rad(0), Rad(0)), 0.3)
            RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
            LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
            RW.C0 = clerp(RW.C0, CF(1.3, 0.9 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(90)), 0.1)
            LW.C0 = clerp(LW.C0, CF(-1.3, 0.9 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(-90)), 0.1)
            tors.CFrame = FRAME * CF(0,1,0)
            swait()
            tors.CFrame = FRAME
        until icri.Playing == false
        Character.Head.face.Texture = "rbxassetid://620619801"
        attack = false
        hum.WalkSpeed = 16
    end

    function Dance()
        attack = true
        hum.WalkSpeed = 1.01
        CreateSound("838766490", hed, 10, 1)
        Character.Head.face.Texture = "rbxassetid://258591579"
        for i = 0,2,0.1 do
            swait()
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
            tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-0), Rad(0), Rad(0)), 0.3)
            RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
            LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
            RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(180)), 0.1)
            LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(-180)), 0.1)
        end
        for i = 0,4,0.1 do
            swait()
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
            tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-0), Rad(0), Rad(0)), 0.3)
            RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(-30)), 0.15)
            LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(-30)), 0.15)
            RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(50), Rad(0), Rad(180)), 0.1)
            LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(-50), Rad(-0), Rad(-180)), 0.1)
        end
        for i = 0,4,0.1 do
            swait()
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
            tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-0), Rad(0), Rad(0)), 0.3)
            RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(30)), 0.15)
            LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(30)), 0.15)
            RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(-50), Rad(0), Rad(180)), 0.1)
            LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(50), Rad(-0), Rad(-180)), 0.1)
        end
        for i = 0,4,0.1 do
            swait()
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
            tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-0), Rad(0), Rad(0)), 0.3)
            RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(-30)), 0.15)
            LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(-30)), 0.15)
            RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(50), Rad(0), Rad(180)), 0.1)
            LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(-50), Rad(-0), Rad(-180)), 0.1)
        end
        for i = 0,4,0.1 do
            swait()
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
            tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-0), Rad(0), Rad(0)), 0.3)
            RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(30)), 0.15)
            LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(30)), 0.15)
            RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(-50), Rad(0), Rad(180)), 0.1)
            LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(50), Rad(-0), Rad(-180)), 0.1)
        end
        for i = 0,4,0.1 do
            swait()
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
            tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-0), Rad(0), Rad(0)), 0.3)
            RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(-30)), 0.15)
            LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(-30)), 0.15)
            RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(50), Rad(0), Rad(180)), 0.1)
            LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(-50), Rad(-0), Rad(-180)), 0.1)
        end
        for i = 0,4,0.1 do
            swait()
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
            tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-0), Rad(0), Rad(0)), 0.3)
            RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(30)), 0.15)
            LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(30)), 0.15)
            RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(-50), Rad(0), Rad(180)), 0.1)
            LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(50), Rad(-0), Rad(-180)), 0.1)
        end
        for i = 0,4,0.1 do
            swait()
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
            tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-0), Rad(0), Rad(0)), 0.3)
            RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(-30)), 0.15)
            LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(-30)), 0.15)
            RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(50), Rad(0), Rad(180)), 0.1)
            LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(-50), Rad(-0), Rad(-180)), 0.1)
        end
        for i = 0,4,0.1 do
            swait()
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
            tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-0), Rad(0), Rad(0)), 0.3)
            RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(30)), 0.15)
            LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(30)), 0.15)
            RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(-50), Rad(0), Rad(180)), 0.1)
            LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(50), Rad(-0), Rad(-180)), 0.1)
        end
        for i = 0,4,0.1 do
            swait()
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
            tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-0), Rad(0), Rad(0)), 0.3)
            RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(-30)), 0.15)
            LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(-30)), 0.15)
            RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(50), Rad(0), Rad(180)), 0.1)
            LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(-50), Rad(-0), Rad(-180)), 0.1)
        end
        for i = 0,4,0.1 do
            swait()
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
            tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-0), Rad(0), Rad(0)), 0.3)
            RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(30)), 0.15)
            LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(30)), 0.15)
            RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(-50), Rad(0), Rad(180)), 0.1)
            LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(50), Rad(-0), Rad(-180)), 0.1)
        end
        for i = 0,4,0.1 do
            swait()
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
            tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-0), Rad(0), Rad(0)), 0.3)
            RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(-30)), 0.15)
            LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(-30)), 0.15)
            RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(50), Rad(0), Rad(180)), 0.1)
            LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(-50), Rad(-0), Rad(-180)), 0.1)
        end
        for i = 0,4,0.1 do
            swait()
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
            tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-0), Rad(0), Rad(0)), 0.3)
            RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(30)), 0.15)
            LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(30)), 0.15)
            RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(-50), Rad(0), Rad(180)), 0.1)
            LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(50), Rad(-0), Rad(-180)), 0.1)
        end
        for i = 0,4,0.1 do
            swait()
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
            tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-0), Rad(0), Rad(0)), 0.3)
            RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(-30)), 0.15)
            LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(-30)), 0.15)
            RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(50), Rad(0), Rad(180)), 0.1)
            LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(-50), Rad(-0), Rad(-180)), 0.1)
        end
        for i = 0,4,0.1 do
            swait()
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
            tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-0), Rad(0), Rad(0)), 0.3)
            RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(30)), 0.15)
            LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(30)), 0.15)
            RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(-50), Rad(0), Rad(180)), 0.1)
            LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(50), Rad(-0), Rad(-180)), 0.1)
        end
        for i = 0,3,0.1 do
            swait()
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
            tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-0), Rad(0), Rad(0)), 0.3)
            RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(-30)), 0.15)
            LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(-30)), 0.15)
            RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(50), Rad(0), Rad(180)), 0.1)
            LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(-50), Rad(-0), Rad(-180)), 0.1)
        end
        attack = false
        Character.Head.face.Texture = "rbxassetid://620619801"
        hum.WalkSpeed = 16
    end

    function kyu_will_break_your_neck_asdf_longest_function_name_ever_xd()
        attack = true
        Character.Head.face.Texture = "rbxassetid://266304560"
        for i = 0,6,0.1 do
            swait()
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
            tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(0), Rad(0), Rad(0)), 0.3)
            RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
            LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
            RW.C0 = clerp(RW.C0, CF(1.3, 0.9 + 0.05 * Sin(sine / 30), 0.2 * Cos(sine / 20)) * angles(Rad(170), Rad(0), Rad(-15)), 0.1)
            LW.C0 = clerp(LW.C0, CF(-1.3, 0.8 + 0.05 * Sin(sine / 30), -0.025 * Cos(sine / 20)) * angles(Rad(140), Rad(0), Rad(15)), 0.1)
        end
        CreateSound("1093102664", hed, 10, 1)
        CameraEnshaking(3, 8)
        for i = 0,2,0.1 do
            swait()
            rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(5), Rad(0), Rad(0)), 0.15)
            tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(10), Rad(40), Rad(0)), 0.4)
            RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
            LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
            RW.C0 = clerp(RW.C0, CF(1.3, 0.9 + 0.05 * Sin(sine / 30), 0.2 * Cos(sine / 20)) * angles(Rad(200), Rad(0), Rad(-40)), 0.4)
            LW.C0 = clerp(LW.C0, CF(-1.3, 0.8 + 0.05 * Sin(sine / 30), -0.025 * Cos(sine / 20)) * angles(Rad(40), Rad(0), Rad(40)), 0.4)
        end
        Character.Head.face.Texture = "rbxassetid://30128383"
        hum.MaxHealth = 0
        ragdoll(char)
        CreateSound("534269232", hed, 5, 1)
        error("Seems like you just died.")
    end

    MoreTaunts = false
    mouse.KeyDown:connect(function(key)
        if attack == false then
            if MoreTaunts == false then
                if key == 'q' then
                    GEtOuT()
                elseif key == 'e' then
                    GEtOuT2()
                elseif key == 'x' then
                    OBJECTION()
                elseif key == 'n' then
                    BOI()
                elseif key == 'u' then
                    Victory()
                elseif key == '3' then
                    hap()
                elseif key == '6' then
                    Flight()
                elseif key == '9' and timetofly then
                    FLYSKYHIGH()
                elseif key == '9' then
                    local A = math.random(1,10)
                    if A == 1 then
                        warn ("This has a Cooldown, Please wait. :>")
                    end
                    if A == 2 then
                        warn ("You can't Fly All day, you know.")
                    end
                    if A == 3 then
                        warn ("Calm down there.")
                    end
                    if A == 4 then
                        warn ("Take a Break.")
                    end
                    if A == 5 then
                        warn ("*Elevator Music plays in the backround*")
                    end
                    if A == 6 then
                        warn ("I know, You want to FLY SKY HIGH, but wait a little bit.")
                    end
                    if A == 7 then
                        warn ("Can you wait a LITTLE Longer?")
                    end
                    if A == 8 then
                        warn ("Like a tiger defying the laws of gravity...")
                    end
                    if A == 9 then
                        warn ("DON'T STOP ME NNNNNOOOOOOOOWWWW")
                    end
                    if A == 10 then
                        warn ("Oh, I'm burnin' through the sky, Yeah!")
                    end
                elseif key == 'k' then
                    Hello()
                elseif key == '5' then
                    HAAAAA()
                elseif key == '4' then
                    Dance()
                elseif key == '1' then
                    HELP()
                elseif key == '2' then
                    dead()
                elseif key == 'j' then
                    WhatHuh()
                elseif key == 'l' then
                    ShutTheHellUp()
                elseif key == 'c' then
                    Choose()
                elseif key == 'r' then
                    MYSPAGHETTTTTTT()
                elseif key == 't' then
                    SpinMeDad()
                elseif key == 'y' then
                    EndMySufferingV2()
                elseif key == 'f' then
                    NEN()
                elseif key == 'z' then
                    NothingPersonal()
                elseif key == '7' then
                    somuchcancerwhy()
                elseif key == '8' then
                    highnoon()
                elseif key == 'v' then
                    VeryMuchWorrying()
                elseif key == 'b' then
                    Ashes()
                elseif key == 'p' then
                    kyu_will_break_your_neck_asdf_longest_function_name_ever_xd()
                elseif key == 'g' then
                    AnotherOne()
                elseif key == 'h' then
                    slap()
                elseif key == 'm' then
                    WRY()
                end
            end
        end
    end)

    -------------------------------------------------------
    --End Attacks N Stuff--
    -------------------------------------------------------




    while jumping do
        Humanoid.Jump = true
        wait(0.9)
    end




    -------------------------------------------------------
    --Start Animations--
    -------------------------------------------------------
    local equipped = false
    local idle = 0
    local change = 1
    local val = 0
    local toim = 0
    local idleanim = 0.4
    hum.Animator.Parent = nil
    while true do
        swait()
        sine = sine + change
        local torvel = (root.Velocity * Vector3.new(1, 0, 1)).magnitude
        local velderp = root.Velocity.y
        hitfloor, posfloor = rayCast(root.Position, CFrame.new(root.Position, root.Position - Vector3.new(0, 1, 0)).lookVector, 4, char)
        if equipped == true or equipped == false then
            if attack == false then
                idle = idle + 1
            else
                idle = 0
            end
            if 1 < root.Velocity.y and hitfloor == nil then
                Anim = "Jump"
                if attack == false then
                    rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1 * Cos(sine / 20)) * angles(Rad(10), Rad(0), Rad(0)), 0.3)
                    tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-40), Rad(0), Rad(0)), 0.3)
                    RW.C0 = clerp(RW.C0, CF(1.5, 0.5, 0) * angles(Rad(30), Rad(0), Rad(20)), 0.3)
                    LW.C0 = clerp(LW.C0, CF(-1.5, 0.5, 0) * angles(Rad(-20), Rad(0), Rad(-30)), 0.3)
                    LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 * Cos(sine / 20), -0.3) * LHCF * angles(Rad(-5), Rad(0), Rad(20)), 0.15)
                    RH.C0 = clerp(RH.C0, CF(1, -1, 0.3) * angles(Rad(0), Rad(90), Rad(-20)), 0.3)
                end
            elseif -1 > root.Velocity.y and hitfloor == nil then
                Anim = "Fall"
                if attack == false then
                    rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1 * Cos(sine / 20)) * angles(Rad(-5), Rad(0), Rad(0)), 0.3)
                    tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(40), Rad(0), Rad(0)), 0.3)
                    RW.C0 = clerp(RW.C0, CF(1.5, 0.5, 0) * angles(Rad(30), Rad(0), Rad(20)), 0.3)
                    LW.C0 = clerp(LW.C0, CF(-1.5, 0.5, 0) * angles(Rad(-20), Rad(0), Rad(-30)), 0.3)
                    LH.C0=clerp(LH.C0, CF(-1,-.4-0.1 * Cos(sine / 20), -.6) * LHCF * angles(Rad(-5), Rad(-0), Rad(20)), 0.15)
                    RH.C0=clerp(RH.C0, CF(1,-.3-0.1 * Cos(sine / 20), -.6) * angles(Rad(0), Rad(90), Rad(-20)), .3)
                end
            elseif torvel < 1 and hitfloor ~= nil then
                Anim = "Idle"
                change = 1
                if attack == false then
                    rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
                    tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(0), Rad(0), Rad(0)), 0.3)
                    RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
                    LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
                    RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(30 * Cos(sine / 20)), Rad(0), Rad(5)), 0.1)
                    LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(30 * Cos(sine / 20)), Rad(0), Rad(-5)), 0.1)
                end
            elseif tors.Velocity.magnitude < 50 and hitfloor ~= nil then
                Anim = "Walk"
                change = 1
                if attack == false then
                    rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.175 + 0.025 * Cos(sine / 3.5) + -Sin(sine / 3.5) / 7) * angles(Rad(9-2.5 * Cos(sine / 3.5)), Rad(0), Rad(10 * Cos(sine / 7))), 0.15)
                    tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(0), Rad(0), Rad(0)), 0.3)
                    RH.C0 = clerp(RH.C0, CFrame.new(1, -0.925 - 0.5 * math.cos(sine / 7) / 2, 0.5 * math.cos(sine / 7) / 2) * angles(math.rad(-15 - 35 * math.cos(sine / 7)) + -math.sin(sine / 7) / 2.5, math.rad(90 - 2 * math.cos(sine / 7)), math.rad(0)) * angles(math.rad(0 + 2.5 * math.cos(sine / 7)), math.rad(0), math.rad(0)), 0.3)
                    LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.925 + 0.5 * math.cos(sine / 7) / 2, -0.5 * math.cos(sine / 7) / 2) * angles(math.rad(-15 + 35 * math.cos(sine / 7)) + math.sin(sine / 7) / 2.5, math.rad(-90 - 2 * math.cos(sine / 7)), math.rad(0)) * angles(math.rad(0 - 2.5 * math.cos(sine / 7)), math.rad(0), math.rad(0)), 0.3)
                    RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(70) * Cos(sine / 7) , Rad(0), Rad(5)), 0.1)
                    LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(-70) * Cos(sine / 7) , Rad(0),  Rad(-5)), 0.1)
                end
            end
        end
        if 0 < #Effects then
            for e = 1, #Effects do
                if Effects[e] ~= nil then
                    local Thing = Effects[e]
                    if Thing ~= nil then
                        local Part = Thing[1]
                        local Mode = Thing[2]
                        local Delay = Thing[3]
                        local IncX = Thing[4]
                        local IncY = Thing[5]
                        local IncZ = Thing[6]
                        if 1 >= Thing[1].Transparency then
                            if Thing[2] == "Block1" then
                                Thing[1].CFrame = Thing[1].CFrame * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
                                local Mesh = Thing[1].Mesh
                                Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
                                Thing[1].Transparency = Thing[1].Transparency + Thing[3]
                            elseif Thing[2] == "Block2" then
                                Thing[1].CFrame = Thing[1].CFrame + Vector3.new(0, 0, 0)
                                local Mesh = Thing[7]
                                Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
                                Thing[1].Transparency = Thing[1].Transparency + Thing[3]
                            elseif Thing[2] == "Block3" then
                                Thing[1].CFrame = Thing[1].CFrame * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50)) + Vector3.new(0, 0.15, 0)
                                local Mesh = Thing[7]
                                Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
                                Thing[1].Transparency = Thing[1].Transparency + Thing[3]
                            elseif Thing[2] == "Cylinder" then
                                local Mesh = Thing[1].Mesh
                                Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
                                Thing[1].Transparency = Thing[1].Transparency + Thing[3]
                            elseif Thing[2] == "Blood" then
                                local Mesh = Thing[7]
                                Thing[1].CFrame = Thing[1].CFrame * Vector3.new(0, 0.5, 0)
                                Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
                                Thing[1].Transparency = Thing[1].Transparency + Thing[3]
                            elseif Thing[2] == "Elec" then
                                local Mesh = Thing[1].Mesh
                                Mesh.Scale = Mesh.Scale + Vector3.new(Thing[7], Thing[8], Thing[9])
                                Thing[1].Transparency = Thing[1].Transparency + Thing[3]
                            elseif Thing[2] == "Disappear" then
                                Thing[1].Transparency = Thing[1].Transparency + Thing[3]
                            elseif Thing[2] == "Shatter" then
                                Thing[1].Transparency = Thing[1].Transparency + Thing[3]
                                Thing[4] = Thing[4] * CFrame.new(0, Thing[7], 0)
                                Thing[1].CFrame = Thing[4] * CFrame.fromEulerAnglesXYZ(Thing[6], 0, 0)
                                Thing[6] = Thing[6] + Thing[5]
                            end
                        else
                            Part.Parent = nil
                            table.remove(Effects, e)
                        end
                    end
                end
            end
        end
    end
    -------------------------------------------------------
    --End Animations And Script--
    -------------------------------------------------------

    --cool beans boibiparti
end)

flip.Name = "flip"
flip.Parent = main
flip.BackgroundColor3 = Color3.fromRGB(79, 79, 79)
flip.Position = UDim2.new(0.380645156, 0, 0.718631208, 0)
flip.Size = UDim2.new(0, 74, 0, 45)
flip.Style = Enum.ButtonStyle.RobloxRoundDropdownButton
flip.Font = Enum.Font.SciFi
flip.Text = "FLIP"
flip.TextColor3 = Color3.fromRGB(0, 0, 0)
flip.TextSize = 18.000
flip.MouseButton1Down:connect(function()
    --Press Z To Front Flip
    --Press X To Back Flip
    --Press C To Jump
    wait(5)

    --[[ Info ]]--

    local ver = "2.00"
    local scriptname = "feFlip"


    --[[ Keybinds ]]--

    local FrontflipKey = Enum.KeyCode.Z
    local BackflipKey = Enum.KeyCode.X
    local AirjumpKey = Enum.KeyCode.C


    --[[ Dependencies ]]--

    local ca = game:GetService("ContextActionService")
    local zeezy = game:GetService("Players").LocalPlayer
    local h = 0.0174533
    local antigrav


    --[[ Functions ]]--

    function zeezyFrontflip(act,inp,obj)
        if inp == Enum.UserInputState.Begin then
            zeezy.Character.Humanoid:ChangeState("Jumping")
            wait()
            zeezy.Character.Humanoid.Sit = true
            for i = 1,360 do 
                delay(i/720,function()
                    zeezy.Character.Humanoid.Sit = true
                    zeezy.Character.HumanoidRootPart.CFrame = zeezy.Character.HumanoidRootPart.CFrame * CFrame.Angles(-h,0,0)
                end)
            end
            wait(0.55)
            zeezy.Character.Humanoid.Sit = false
        end
    end

    function zeezyBackflip(act,inp,obj)
        if inp == Enum.UserInputState.Begin then
            zeezy.Character.Humanoid:ChangeState("Jumping")
            wait()
            zeezy.Character.Humanoid.Sit = true
            for i = 1,360 do
                delay(i/720,function()
                    zeezy.Character.Humanoid.Sit = true
                    zeezy.Character.HumanoidRootPart.CFrame = zeezy.Character.HumanoidRootPart.CFrame * CFrame.Angles(h,0,0)
                end)
            end
            wait(0.55)
            zeezy.Character.Humanoid.Sit = false
        end
    end

    function zeezyAirjump(act,inp,obj)
        if inp == Enum.UserInputState.Begin then
            zeezy.Character:FindFirstChildOfClass'Humanoid':ChangeState("Seated")
            wait()
            zeezy.Character:FindFirstChildOfClass'Humanoid':ChangeState("Jumping")  
        end
    end


    --[[ Binds ]]--

    ca:BindAction("zeezyFrontflip",zeezyFrontflip,false,FrontflipKey)
    ca:BindAction("zeezyBackflip",zeezyBackflip,false,BackflipKey)
    ca:BindAction("zeezyAirjump",zeezyAirjump,false,AirjumpKey)

    --[[ Load Message ]]--

    print(scriptname .. " " .. ver .. " loaded successfully")
    print("made by Zeezy#7203")

    local notifSound = Instance.new("Sound",workspace)
    notifSound.PlaybackSpeed = 1.5
    notifSound.Volume = 0.15
    notifSound.SoundId = "rbxassetid://170765130"
    notifSound.PlayOnRemove = true
    notifSound:Destroy()
    game.StarterGui:SetCore("SendNotification", {Title = "feFlip", Text = "feFlip loaded successfully!", Icon = "rbxassetid://505845268", Duration = 5, Button1 = "Okay"})
end)

ball.Name = "ball"
ball.Parent = main
ball.BackgroundColor3 = Color3.fromRGB(79, 79, 79)
ball.Position = UDim2.new(0.680645168, 0, 0.718631208, 0)
ball.Size = UDim2.new(0, 74, 0, 45)
ball.Style = Enum.ButtonStyle.RobloxRoundDropdownButton
ball.Font = Enum.Font.SciFi
ball.Text = "BALL"
ball.TextColor3 = Color3.fromRGB(0, 0, 0)
ball.TextSize = 18.000
ball.MouseButton1Down:connect(function()
    local UserInputService = game:GetService("UserInputService")
    local RunService = game:GetService("RunService")
    local Camera = workspace.CurrentCamera

    local SPEED_MULTIPLIER = 30
    local JUMP_POWER = 60
    local JUMP_GAP = 0.3

    local character = game.Players.LocalPlayer.Character

    for i,v in ipairs(character:GetDescendants()) do
        if v:IsA("BasePart") then
            v.CanCollide = false
        end
    end

    local ball = character.HumanoidRootPart
    ball.Shape = Enum.PartType.Ball
    ball.Size = Vector3.new(5,5,5)
    local humanoid = character:WaitForChild("Humanoid")
    local params = RaycastParams.new()
    params.FilterType = Enum.RaycastFilterType.Blacklist
    params.FilterDescendantsInstances = {character}

    local tc = RunService.RenderStepped:Connect(function(delta)
        ball.CanCollide = true
        humanoid.PlatformStand = true
        if UserInputService:GetFocusedTextBox() then return end
        if UserInputService:IsKeyDown("W") then
            ball.RotVelocity -= Camera.CFrame.RightVector * delta * SPEED_MULTIPLIER
        end
        if UserInputService:IsKeyDown("A") then
            ball.RotVelocity -= Camera.CFrame.LookVector * delta * SPEED_MULTIPLIER
        end
        if UserInputService:IsKeyDown("S") then
            ball.RotVelocity += Camera.CFrame.RightVector * delta * SPEED_MULTIPLIER
        end
        if UserInputService:IsKeyDown("D") then
            ball.RotVelocity += Camera.CFrame.LookVector * delta * SPEED_MULTIPLIER
        end
        --ball.RotVelocity = ball.RotVelocity - Vector3.new(0,ball.RotVelocity.Y/50,0)
    end)

    UserInputService.JumpRequest:Connect(function()
        local result = workspace:Raycast(
            ball.Position,
            Vector3.new(
                0,
                -((ball.Size.Y/2)+JUMP_GAP),
                0
            ),
            params
        )
        if result then
            ball.Velocity = ball.Velocity + Vector3.new(0,JUMP_POWER,0)
        end
    end)

    Camera.CameraSubject = ball
    humanoid.Died:Connect(function() tc:Disconnect() end)
end)
		end
		if cmd == "join" then
			game.StarterGui:SetCore("SendNotification", {
				Title = "Warning";
				Text = "Place the game ID you want to join on ValueBox";
			})

			local TeleportService = game:GetService("TeleportService")
			local placeID = ValueBox_2.Text
			TeleportService:Teleport(placeID, player)
		end
		if cmd == "rj" then
			game.StarterGui:SetCore("SendNotification", {
				Title = "Warning";
				Text = "Place the game ID you want to rejoin on ValueBox";
			})

			local TeleportService = game:GetService("TeleportService")
			local placeID = ValueBox_2.Text
			TeleportService:Teleport(placeID, player)
		end
		if cmd == "telekinesis" then
-- Q & E - bring closer and further
-- R - Roates Block
-- T - Tilts Block
-- Y - Throws Block
local function a(b, c)
    local d = getfenv(c)
    local e =
        setmetatable(
        {},
        {__index = function(self, f)
                if f == "script" then
                    return b
                else
                    return d[f]
                end
            end}
    )
    setfenv(c, e)
    return c
end
local g = {}
local h = Instance.new("Model", game:GetService("Lighting"))
local i = Instance.new("Tool")
local j = Instance.new("Part")
local k = Instance.new("Script")
local l = Instance.new("LocalScript")
local m = sethiddenproperty or set_hidden_property
i.Name = "Telekinesis"
i.Parent = h
i.Grip = CFrame.new(0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0)
i.GripForward = Vector3.new(-0, -1, -0)
i.GripRight = Vector3.new(0, 0, 1)
i.GripUp = Vector3.new(1, 0, 0)
j.Name = "Handle"
j.Parent = i
j.CFrame = CFrame.new(-17.2635937, 15.4915619, 46, 0, 1, 0, 1, 0, 0, 0, 0, -1)
j.Orientation = Vector3.new(0, 180, 90)
j.Position = Vector3.new(-17.2635937, 15.4915619, 46)
j.Rotation = Vector3.new(-180, 0, -90)
j.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
j.Transparency = 1
j.Size = Vector3.new(1, 1.20000005, 1)
j.BottomSurface = Enum.SurfaceType.Weld
j.BrickColor = BrickColor.new("Really black")
j.Material = Enum.Material.Metal
j.TopSurface = Enum.SurfaceType.Smooth
j.brickColor = BrickColor.new("Really black")
k.Name = "LineConnect"
k.Parent = i
table.insert(
    g,
    a(
        k,
        function()
            wait()
            local n = script.Part2
            local o = script.Part1.Value
            local p = script.Part2.Value
            local q = script.Par.Value
            local color = script.Color
            local r = Instance.new("Part")
            r.TopSurface = 0
            r.BottomSurface = 0
            r.Reflectance = .5
            r.Name = "Laser"
            r.Locked = true
            r.CanCollide = false
            r.Anchored = true
            r.formFactor = 0
            r.Size = Vector3.new(1, 1, 1)
            local s = Instance.new("BlockMesh")
            s.Parent = r
            while true do
                if n.Value == nil then
                    break
                end
                if o == nil or p == nil or q == nil then
                    break
                end
                if o.Parent == nil or p.Parent == nil then
                    break
                end
                if q.Parent == nil then
                    break
                end
                local t = CFrame.new(o.Position, p.Position)
                local dist = (o.Position - p.Position).magnitude
                r.Parent = q
                r.BrickColor = color.Value.BrickColor
                r.Reflectance = color.Value.Reflectance
                r.Transparency = color.Value.Transparency
                r.CFrame = CFrame.new(o.Position + t.lookVector * dist / 2)
                r.CFrame = CFrame.new(r.Position, p.Position)
                s.Scale = Vector3.new(.25, .25, dist)
                wait()
            end
            r:remove()
            script:remove()
        end
    )
)
k.Disabled = true
l.Name = "MainScript"
l.Parent = i
table.insert(
    g,
    a(
        l,
        function()
            wait()
            tool = script.Parent
            lineconnect = tool.LineConnect
            object = nil
            mousedown = false
            found = false
            BP = Instance.new("BodyPosition")
            BP.maxForce = Vector3.new(math.huge * math.huge, math.huge * math.huge, math.huge * math.huge)
            BP.P = BP.P * 1.1
            dist = nil
            point = Instance.new("Part")
            point.Locked = true
            point.Anchored = true
            point.formFactor = 0
            point.Shape = 0
            point.BrickColor = BrickColor.Black()
            point.Size = Vector3.new(1, 1, 1)
            point.CanCollide = false
            local s = Instance.new("SpecialMesh")
            s.MeshType = "Sphere"
            s.Scale = Vector3.new(.7, .7, .7)
            s.Parent = point
            handle = tool.Handle
            front = tool.Handle
            color = tool.Handle
            objval = nil
            local u = false
            local v = BP:clone()
            v.maxForce = Vector3.new(30000, 30000, 30000)
            function LineConnect(o, p, q)
                local w = Instance.new("ObjectValue")
                w.Value = o
                w.Name = "Part1"
                local x = Instance.new("ObjectValue")
                x.Value = p
                x.Name = "Part2"
                local y = Instance.new("ObjectValue")
                y.Value = q
                y.Name = "Par"
                local z = Instance.new("ObjectValue")
                z.Value = color
                z.Name = "Color"
                local A = lineconnect:clone()
                A.Disabled = false
                w.Parent = A
                x.Parent = A
                y.Parent = A
                z.Parent = A
                A.Parent = workspace
                if p == object then
                    objval = x
                end
            end
            function onButton1Down(B)
                if mousedown == true then
                    return
                end
                mousedown = true
                coroutine.resume(
                    coroutine.create(
                        function()
                            local C = point:clone()
                            C.Parent = tool
                            LineConnect(front, C, workspace)
                            while mousedown == true do
                                C.Parent = tool
                                if object == nil then
                                    if B.Target == nil then
                                        local t = CFrame.new(front.Position, B.Hit.p)
                                        C.CFrame = CFrame.new(front.Position + t.lookVector * 1000)
                                    else
                                        C.CFrame = CFrame.new(B.Hit.p)
                                    end
                                else
                                    LineConnect(front, object, workspace)
                                    break
                                end
                                wait()
                            end
                            C:remove()
                        end
                    )
                )
                while mousedown == true do
                    if B.Target ~= nil then
                        local D = B.Target
                        if D.Anchored == false then
                            object = D
                            dist = (object.Position - front.Position).magnitude
                            break
                        end
                    end
                    wait()
                end
                while mousedown == true do
                    if object.Parent == nil then
                        break
                    end
                    local t = CFrame.new(front.Position, B.Hit.p)
                    BP.Parent = object
                    BP.position = front.Position + t.lookVector * dist
                    wait()
                end
                BP:remove()
                object = nil
                objval.Value = nil
            end
            function onKeyDown(E, B)
                local E = E:lower()
                local F = false
                if E == "q" then
                    if dist >= 5 then
                        dist = dist - 10
                    end
                end
                if E == "r" then
                    if object == nil then
                        return
                    end
                    for G, H in pairs(object:children()) do
                        if H.className == "BodyGyro" then
                            return nil
                        end
                    end
                    BG = Instance.new("BodyGyro")
                    BG.maxTorque = Vector3.new(math.huge, math.huge, math.huge)
                    BG.cframe = CFrame.new(object.CFrame.p)
                    BG.Parent = object
                    repeat
                        wait()
                    until object.CFrame == CFrame.new(object.CFrame.p)
                    BG.Parent = nil
                    if object == nil then
                        return
                    end
                    for G, H in pairs(object:children()) do
                        if H.className == "BodyGyro" then
                            H.Parent = nil
                        end
                    end
                    object.Velocity = Vector3.new(0, 0, 0)
                    object.RotVelocity = Vector3.new(0, 0, 0)
                    object.Orientation = Vector3.new(0, 0, 0)
                end
                if E == "e" then
                    dist = dist + 10
                end
                if E == "t" then
                    if dist ~= 10 then
                        dist = 10
                    end
                end
                if E == "y" then
                    if dist ~= 200 then
                        dist = 200
                    end
                end
                if E == "=" then
                    BP.P = BP.P * 1.5
                end
                if E == "-" then
                    BP.P = BP.P * 0.5
                end
            end
            function onEquipped(B)
                keymouse = B
                local I = tool.Parent
                human = I.Humanoid
                human.Changed:connect(
                    function()
                        if human.Health == 0 then
                            mousedown = false
                            BP:remove()
                            point:remove()
                            tool:remove()
                        end
                    end
                )
                B.Button1Down:connect(
                    function()
                        onButton1Down(B)
                    end
                )
                B.Button1Up:connect(
                    function()
                        mousedown = false
                    end
                )
                B.KeyDown:connect(
                    function(E)
                        onKeyDown(E, B)
                    end
                )
                B.Icon = "rbxasset://textures\\GunCursor.png"
            end
            tool.Equipped:connect(onEquipped)
        end
    )
)
for J, H in pairs(h:GetChildren()) do
    H.Parent = game:GetService("Players").LocalPlayer.Backpack
    pcall(
        function()
            H:MakeJoints()
        end
    )
end
h:Destroy()
for J, H in pairs(g) do
    spawn(
        function()
            pcall(H)
        end
    )
end
			game.StarterGui:SetCore("SendNotification", {
				Title = "Telekinesis Enable";
				Text = "Q & E to bring close and further, Y to throw the block, R to rotate the block, and T to tilt the block";
			})
		end
	end -- final end
end)

function GetPlayer(String)
	local plr
	local strl = String:lower()
	for i, v in pairs(game:GetService("Players"):GetPlayers()) do
		if v.Name:lower():sub(1, #String) == String:lower() then
			plr = v
		end 
	end
	if String == "me" then
		plr = game.Players.LocalPlayer
	end
	if String == "" or String == " " then
		plr = nil
	end
	return plr
end
